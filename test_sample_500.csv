Context,Completion
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.builder

import com.intellij.psi.tree.IElementType
import org.jetbrains.kotlin.KtFakeSourceElementKind
import org.jetbrains.kotlin.KtRealSourceElementKind
import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.contracts.description.LogicOperationKind
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.descriptors.Visibilities
import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget
import org.jetbrains.kotlin.fakeElement
import org.jetbrains.kotlin.fir.*",import org.jetbrains.kotlin.fir.contracts.FirContractDescription
"package test

class A {
    companion object {
        annotation class Anno1",class B {
")

                // Native:
                assertFileExists(""build/classes/kotlin/linux64/integrationTest/klib/new-mpp-associate-compilations_integrationTest.klib"")
            }
        }
    }

    @Test
    fun testTestRunsApi() = with(Project(""new-mpp-associate-compilations"")) {
        setupWorkingDir()
        gradleBuildScript().modify(::transformBuildScriptWithPluginsDsl)

        // TOOD: add Kotlin/JS tests once they can be tested without much performance overhead
        val targetsToTest = listOf(""jvm"", nativeHostTargetName) + when (HostManager.host) {
            KonanTarget.MACOS_X64 -> listOf(""iosX64"")
            KonanTarget.MACOS_ARM64 -> listOf(""iosSimulatorArm64"")
            else -> emptyList()
        }
        val testTasks = targetsToTest.flatMap { listOf("":${it}Test"", "":${it}IntegrationTest"") }.toTypedArray()

        build(*testTasks) {
            assertSuccessful()

            assertTasksExecuted(
                *testTasks,
                "":compileIntegrationTestKotlinJvm"",
                "":linkIntegrationDebugTest${nativeHostTargetName.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }}""
            )

            fun checkUnitTestOutput(targetName: String) {
                val classReportHtml = projectDir
                    .resolve(""build/reports/tests/${targetName}Test/classes/com.example.HelloTest.html"")
                    .readText()

                assertTrue(""secondTest"" !in classReportHtml, ""Test report should not contain 'secondTest':\n$classReportHtml"")
            }
            targetsToTest.forEach {
                checkUnitTestOutput(it)
            }

            fun checkIntegrationTestOutput(targetName: String) {
                val classReportHtml = projectDir
                    .resolve(""build/reports/tests/${targetName}IntegrationTest/classes/com.example.HelloIntegrationTest.html"")
                    .readText()

                assertTrue(""test[$targetName]"" in classReportHtml, ""Test report should contain 'test[$targetName]':\n$classReportHtml"")
                assertTrue(""secondTest"" !in classReportHtml, ""Test report should not contain 'secondTest':\n$classReportHtml"")
                assertTrue(""thirdTest"" !in classReportHtml, ""Test report should not contain 'thirdTest':\n$classReportHtml"")
            }
            targetsToTest.forEach {
                checkIntegrationTestOutput(it)
            }
        }
    }

    @Test
    fun testKlibsWithTheSameProjectName() = with(transformProjectWithPluginsDsl(""new-mpp-klibs-with-same-name"")) {
        // KT-36721.
        build(""assemble"") {
            assertSuccessful()
            assertTasksExecuted(
                "":foo:foo:compileKotlinJs"",
                "":foo:foo:compileKotlinLinux"",
                "":foo:compileKotlinJs"",",""":foo:compileKotlinLinux"","
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.references.fe10

import com.intellij.util.SmartList
import org.jetbrains.kotlin.references.fe10.base.KtFe10Reference
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.idea.references.SyntheticPropertyAccessorReference",import org.jetbrains.kotlin.psi.KtImportAlias
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.checkers

import org.jetbrains.kotlin.KtFakeSourceElementKind
import org.jetbrains.kotlin.builtins.StandardNames
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.*
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.declaration.FirNameConflictsTracker
import org.jetbrains.kotlin.fir.analysis.checkers.declaration.isEffectivelyFinal
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.declarations.impl.FirResolvedDeclarationStatusImpl.Companion.DEFAULT_STATUS_FOR_STATUSLESS_DECLARATIONS
import org.jetbrains.kotlin.fir.declarations.impl.FirResolvedDeclarationStatusImpl.Companion.DEFAULT_STATUS_FOR_SUSPEND_MAIN_FUNCTION
import org.jetbrains.kotlin.fir.declarations.impl.modifiersRepresentation
import org.jetbrains.kotlin.fir.declarations.utils.nameOrSpecialName
import org.jetbrains.kotlin.fir.expressions.FirBlock
import org.jetbrains.kotlin.fir.expressions.FirComponentCall
import org.jetbrains.kotlin.fir.expressions.FirPropertyAccessExpression
import org.jetbrains.kotlin.fir.references.FirResolvedNamedReference
import org.jetbrains.kotlin.fir.resolve.fullyExpandedType
import org.jetbrains.kotlin.fir.resolve.outerType
import org.jetbrains.kotlin.fir.resolve.providers.firProvider
import org.jetbrains.kotlin.fir.resolve.scope
import org.jetbrains.kotlin.fir.scopes.*
import org.jetbrains.kotlin.fir.scopes.impl.FirPackageMemberScope
import org.jetbrains.kotlin.fir.scopes.impl.TypeAliasConstructorsSubstitutingScope
import org.jetbrains.kotlin.fir.scopes.impl.toConeType
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.fir.symbols.SymbolInternals
import org.jetbrains.kotlin.fir.symbols.impl.*
import org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase
import org.jetbrains.kotlin.fir.types.*
import org.jetbrains.kotlin.fir.util.ListMultimap
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId",import org.jetbrains.kotlin.name.Name
"import org.jetbrains.kotlin.ir.BuiltInOperatorNames
import org.jetbrains.kotlin.ir.IrBuiltIns
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.interpreter.CallInterceptor
import org.jetbrains.kotlin.ir.interpreter.fqName
import org.jetbrains.kotlin.ir.interpreter.isPrimitiveArray
import org.jetbrains.kotlin.ir.interpreter.proxy.CommonProxy.Companion.asProxy
import org.jetbrains.kotlin.ir.interpreter.proxy.reflection.ReflectionProxy.Companion.asProxy
import org.jetbrains.kotlin.ir.interpreter.state.*
import org.jetbrains.kotlin.ir.interpreter.state.reflection.ReflectionState
import org.jetbrains.kotlin.ir.types.isArray
import org.jetbrains.kotlin.ir.types.isFloat
import org.jetbrains.kotlin.name.Name
import java.lang.invoke.MethodType

internal interface Proxy {
    val state: State
    val callInterceptor: CallInterceptor
    val environment
        get() = callInterceptor.environment

    override fun equals(other: Any?): Boolean
    override fun hashCode(): Int
    override fun toString(): String
}

internal fun State.wrap(callInterceptor: CallInterceptor, remainArraysAsIs: Boolean, extendFrom: Class<*>? = null): Any? {
    return when (this) {
        is ExceptionState -> this
        is Wrapper -> this.value
        is Primitive<*> -> when {
            this.isNull() -> null
            this.type.isArray() || this.type.isPrimitiveArray() -> if (remainArraysAsIs) this else this.value
            else -> this.value
        }
        is Common -> this.asProxy(callInterceptor, extendFrom)
        is ReflectionState -> this.asProxy(callInterceptor)
        else -> throw AssertionError(""${this::class} is unsupported as argument for wrap function"")
    }
}

private val eqeqName = IrBuiltIns.KOTLIN_INTERNAL_IR_FQN.child(Name.identifier(BuiltInOperatorNames.EQEQ)).asString()
private val checkNotNullName = IrBuiltIns.KOTLIN_INTERNAL_IR_FQN.child(Name.identifier(BuiltInOperatorNames.CHECK_NOT_NULL)).asString()

/**
 * Prepare state object to be passed in outer world
 */
internal fun List<State>.wrap(callInterceptor: CallInterceptor, irFunction: IrFunction, methodType: MethodType? = null): List<Any?> {
    val name = irFunction.fqName
    if (name == eqeqName && this.any { it is Common }) {
        // in case of custom `equals` it is important not to lose information obout type
        // so all states remain as is, only common will be converted to Proxy
        return mapIndexed { index, state ->
            if (state !is Common) return@mapIndexed state
            state.wrap(callInterceptor, remainArraysAsIs = true, methodType?.parameterType(index))
        }
    }
    return this.mapIndexed { index, state ->
        // don't get arrays from Primitive in case of ""set"" and ""Pair.<init>""; information about type will be lost
        val unwrapArrays = (name == ""kotlin.Array.set"" && index != 0) || name == ""kotlin.Pair.<init>"" || name == checkNotNullName
        state.wrap(callInterceptor, unwrapArrays, methodType?.parameterType(index))
    }
}",internal fun Class<*>.isObject(): Boolean {
fun box(): String {,"return if (call(10, ::calc) == 5) ""OK"" else ""fail"""
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""PackageDirectoryMismatch"") // Old package for compatibility
package org.jetbrains.kotlin.gradle.plugin.mpp

import org.gradle.api.Project
import org.jetbrains.kotlin.gradle.DeprecatedTargetPresetApi
import org.jetbrains.kotlin.gradle.plugin.AbstractKotlinTargetConfigurator
import org.jetbrains.kotlin.gradle.plugin.KotlinPlatformType
import org.jetbrains.kotlin.gradle.targets.jvm.KotlinJvmTarget
import org.jetbrains.kotlin.gradle.targets.jvm.KotlinJvmTargetConfigurator

@DeprecatedTargetPresetApi
class KotlinJvmTargetPreset(
    project: Project",") : KotlinOnlyTargetPreset<KotlinJvmTarget, KotlinJvmCompilation>("
"equals(null)
            propT
            propAny
            propNullableT
            propNullableAny
            funT()
            funAny()
            funNullableT()
            funNullableAny()
            get()
            ip1test1()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.get()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.ip1test1()
        }
        also {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.get()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.ip1test1()
        }
    }
}

// TESTCASE NUMBER: 52
fun <T> T?.case_52() where T : Inv<in T>, T: InterfaceWithTypeParameter1<T>? {
    if (this != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.get()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.ip1test1()

        equals(this)
        get()
        ip1test1()
        apply {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>
            equals(null)
            propT
            propAny
            propNullableT",propNullableAny
"// !RENDER_DIAGNOSTICS_FULL_TEXT
fun <T> flowOf(value: T): Flow<T> = TODO()

interface FlowCollector<in T> {}

interface Flow<out T>

fun <T, R> Flow<T>.transform(transform: FlowCollector<R>.(T) -> Unit): Flow<R> = TODO()

fun f() {
    fun <T> doEmit(collector: FlowCollector<T>) {}",flowOf(1).<!INFERRED_INTO_DECLARED_UPPER_BOUNDS!>transform<!> { doEmit(this) }
"generateCompareTo()

        generateBinaryOperators()
        generateUnaryOperators()
        generateRangeTo()
        generateRangeUntil()

        if (type == UnsignedType.UINT || type == UnsignedType.ULONG) {
            generateBitShiftOperators()
        }

        generateBitwiseOperators()

        generateMemberConversions()
        generateFloatingConversions()

        generateToStringHashCode()

        out.println(""}"")
        out.println()


        generateExtensionConversions()
    }


    private fun generateCompareTo() {
        for (otherType in UnsignedType.entries) {
            out.println(""""""
    /**
     * Compares this value with the specified value for order.
     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,
     * or a positive number if it's greater than other.
     */"""""")
            out.println(""    @kotlin.internal.InlineOnly"")
            if (otherType == type)
                out.println(""""""    @Suppress(""OVERRIDE_BY_INLINE"")"""""")
            out.print(""    public "")
            if (otherType == type) out.print(""override "")
            out.print(""inline operator fun compareTo(other: ${otherType.capitalized}): Int = "")
            if (otherType == type && maxByDomainCapacity(type, UnsignedType.UINT) == type) {
                out.println(""${className.lowercase()}Compare(this.data, other.data)"")
            } else {
                if (maxOf(type, otherType) < UnsignedType.UINT) {
                    out.println(""this.toInt().compareTo(other.toInt())"")
                } else {
                    val ctype = maxByDomainCapacity(type, otherType)
                    out.println(""${convert(""this"", type, ctype)}.compareTo(${convert(""other"", otherType, ctype)})"")
                }
            }
        }
        out.println()
    }

    private fun generateBinaryOperators() {
        for (name in BasePrimitivesGenerator.binaryOperators) {
            generateOperator(name)
        }
        generateFloorDivMod(""floorDiv"")
        generateFloorDivMod(""mod"")
    }

    private fun generateOperator(name: String) {
        for (otherType in UnsignedType.entries) {","val returnType = getOperatorReturnType(type, otherType)"
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.codegen.optimization

import org.jetbrains.kotlin.codegen.TransformationMethodVisitor
import org.jetbrains.kotlin.codegen.coroutines.UninitializedStoresProcessor
import org.jetbrains.kotlin.codegen.inline.InplaceArgumentsMethodTransformer
import org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer
import org.jetbrains.kotlin.codegen.optimization.boxing.RedundantBoxingMethodTransformer
import org.jetbrains.kotlin.codegen.optimization.boxing.StackPeepholeOptimizationsTransformer
import org.jetbrains.kotlin.codegen.optimization.common.prepareForEmitting
import org.jetbrains.kotlin.codegen.optimization.common.nodeType
import org.jetbrains.kotlin.codegen.optimization.nullCheck.RedundantNullCheckMethodTransformer
import org.jetbrains.kotlin.codegen.optimization.temporaryVals.TemporaryVariablesEliminationTransformer
import org.jetbrains.kotlin.codegen.optimization.transformer.CompositeMethodTransformer
import org.jetbrains.kotlin.codegen.state.GenerationState
import org.jetbrains.org.objectweb.asm.MethodVisitor
import org.jetbrains.org.objectweb.asm.Opcodes
import org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode
import org.jetbrains.org.objectweb.asm.tree.MethodNode

class OptimizationMethodVisitor(
    delegate: MethodVisitor,
    private val mandatoryTransformationsOnly: Boolean,
    private val generationState: GenerationState,
    access: Int,
    name: String,
    desc: String,
    signature: String?,
    exceptions: Array<out String>?
) : TransformationMethodVisitor(delegate, access, name, desc, signature, exceptions) {
    val normalizationMethodTransformer = CompositeMethodTransformer(
        InplaceArgumentsMethodTransformer(),
        FixStackWithLabelNormalizationMethodTransformer(),
        MethodVerifier(""AFTER mandatory stack transformations"", generationState)
    )

    val optimizationTransformer = CompositeMethodTransformer(
        CapturedVarsOptimizationMethodTransformer(),
        RedundantNullCheckMethodTransformer(generationState),
        RedundantCheckCastEliminationMethodTransformer(),
        ConstantConditionEliminationMethodTransformer(),
        RedundantBoxingMethodTransformer(generationState),
        TemporaryVariablesEliminationTransformer(generationState),
        StackPeepholeOptimizationsTransformer(),
        PopBackwardPropagationTransformer(),
        DeadCodeEliminationMethodTransformer(),
        RedundantGotoMethodTransformer(),
        RedundantNopsCleanupMethodTransformer(),
        NegatedJumpsMethodTransformer(),
        RedundantCheckcastsBeforeAastoreMethodTransformer,","MethodVerifier(""AFTER optimizations"", generationState)"
"): FirSimpleFunction {
        // TODO: consider using here some light-weight functions instead of pseudo-real FirMemberFunctionImpl
        // As second alternative, we can invent some light-weight kind of FirRegularClass
        return createCopyForFirFunction(
            fakeOverrideSymbol,
            baseFunction,
            derivedClassLookupTag = derivedClassLookupTag,
            session,
            origin,
            isExpect,
            newDispatchReceiverType,
            newParameterTypes,
            newTypeParameters,
            newReceiverType,
            newContextReceiverTypes,
            newReturnType,
            deferredReturnTypeCalculation = callableCopySubstitutionForTypeUpdater
        ).apply {
            originalForSubstitutionOverrideAttr = baseFunction
        }
    }

    fun createCopyForFirFunction(
        newSymbol: FirNamedFunctionSymbol,
        baseFunction: FirSimpleFunction,
        derivedClassLookupTag: ConeClassLikeLookupTag?,
        session: FirSession,
        origin: FirDeclarationOrigin,
        isExpect: Boolean = baseFunction.isExpect,
        newDispatchReceiverType: ConeSimpleKotlinType?,
        newParameterTypes: List<ConeKotlinType?>? = null,
        newTypeParameters: List<FirTypeParameter>? = null,
        newReceiverType: ConeKotlinType? = null,
        newContextReceiverTypes: List<ConeKotlinType?>? = null,
        newReturnType: ConeKotlinType? = null,
        newModality: Modality? = null,
        newVisibility: Visibility? = null,
        deferredReturnTypeCalculation: DeferredCallableCopyReturnType? = null,
        newSource: KtSourceElement? = derivedClassLookupTag?.toSymbol(session)?.source ?: baseFunction.source,
    ): FirSimpleFunction = buildSimpleFunction {
        source = newSource
        moduleData = session.nullableModuleData ?: baseFunction.moduleData
        this.origin = origin
        name = baseFunction.name
        status = baseFunction.status.copy(newVisibility, newModality, isExpect = isExpect, isOverride = true)
        symbol = newSymbol
        resolvePhase = origin.resolvePhaseForCopy

        dispatchReceiverType = newDispatchReceiverType
        attributes = baseFunction.attributes.copy()
        typeParameters += configureAnnotationsTypeParametersAndSignature(
            session, baseFunction, newParameterTypes, newTypeParameters,
            newReceiverType, newContextReceiverTypes, newReturnType, deferredReturnTypeCalculation, newSymbol,
            copyDefaultValues = false,
        ).filterIsInstance<FirTypeParameter>()
        deprecationsProvider = baseFunction.deprecationsProvider
    }.apply {
        containingClassForStaticMemberAttr = derivedClassLookupTag.takeIf { shouldOverrideSetContainingClass(baseFunction) }
    }

    fun createCopyForFirConstructor(
        fakeOverrideSymbol: FirConstructorSymbol,
        session: FirSession,
        baseConstructor: FirConstructor,
        derivedClassLookupTag: ConeClassLikeLookupTag?,","origin: FirDeclarationOrigin,"
"// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion
// !DIAGNOSTICS: -UNUSED_VARIABLE

// FILE: J.java
public class J {
    public static void foo() {}
}

// FILE: test.kt
open class A<T> : J() {
    init {
        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>
        bar()
        val a: Int = <!TYPE_MISMATCH!><!DEBUG_INFO_LEAKING_THIS!>baz<!>()<!>
        val b: T = <!DEBUG_INFO_LEAKING_THIS!>baz<!>()
    }

    fun test1() {
        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>
        bar()
        val a: Int = <!TYPE_MISMATCH!>baz()<!>
        val b: T = baz()
    }

    fun baz(): T = null!!

    object O {
        fun test() {
            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>
            bar()
            val a: Int = baz()
            val b: <!UNRESOLVED_REFERENCE!>T<!> = baz()
        }
    }

    companion object : A<Int>() {
        init {
            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>
            bar()
            val a: Int = baz()
            val b: <!UNRESOLVED_REFERENCE!>T<!> = baz()
        }",fun test() {
"internal companion object {
            private const val serialVersionUID = 0L
        }
    }

    /* Not implemented as data class to ensure more controllable binary compatibility */
    class Key<T> @PublishedApi internal constructor(
        val type: Type<T>,
        val name: String? = null,
    ) : Serializable {

        val stableString: String
            get() {
                return if (name == null) type.signature
                else ""${type.signature};$name""
            }

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other !is Key<*>) return false
            if (name != other.name) return false
            if (type != other.type) return false
            return true
        }

        override fun hashCode(): Int {
            var result = name?.hashCode() ?: 0
            result = 31 * result + type.hashCode()
            return result
        }

        override fun toString(): String = stableString

        companion object {
            fun fromString(stableString: String): Key<*> {
                @OptIn(UnsafeApi::class) return if (stableString.contains(';')) {
                    val split = stableString.split(';', limit = 2)
                    Key<Any?>(Type(split[0]), split[1])
                } else Key<Any?>(Type(stableString))
            }

            private const val serialVersionUID = 0L
        }
    }

    /* Not implemented as data class to ensure more controllable binary compatibility */
    class Entry<T>(val key: Key<T>, val value: T) : Serializable {
        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other !is Entry<*>) return false
            if (other.key != key) return false
            if (other.value != value) return false
            return true
        }

        override fun hashCode(): Int {
            var result = key.hashCode()
            result = 31 * result + value.hashCode()
            return result
        }

        override fun toString(): String = ""$key=$value""

        operator fun component1() = key",operator fun component2() = value
"// TARGET_BACKEND: JVM
// JVM_TARGET: 1.8
// SAM_CONVERSIONS: INDY
// WITH_STDLIB

// CHECK_BYTECODE_TEXT
// JVM_IR_TEMPLATES
// 0 java/lang/invoke/LambdaMetafactory
// 19 final synthetic class BoundAdaptedFunctionReferenceKt\$box\$[0-9]*
// 1 final synthetic class FromOtherFileKt\$target1FromOtherFile\$[0-9]*
// 1 final synthetic class FromOtherFileKt\$adapted1FromOtherFile\$[0-9]*
// 1 final synthetic class FromOtherFileKt\$adapted2FromOtherFile\$[0-9]*

// FILE: boundAdaptedFunctionReference.kt

fun checkEqual(x: Any, y: Any) {
    if (x != y || y != x) throw AssertionError(""$x and $y should be equal"")
    if (x.hashCode() != y.hashCode()) throw AssertionError(""$x and $y should have the same hash code"")
}

fun checkNotEqual(x: Any, y: Any) {
    if (x == y || y == x) throw AssertionError(""$x and $y should NOT be equal"")
}

fun interface FunInterface {
    fun invoke()
}

private fun id(f: FunInterface): Any = f

class C {",fun target1() {}
"public constructor StringBuilder()

    public constructor StringBuilder(content: kotlin.CharSequence)

    public constructor StringBuilder(capacity: kotlin.Int)

    public constructor StringBuilder(content: kotlin.String)

    public open override val length: kotlin.Int { get; }

    public final fun append(value: kotlin.Any?): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.3"")
    public final fun append(value: kotlin.Boolean): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.9"")
    public final fun append(value: kotlin.Byte): kotlin.text.StringBuilder

    public open override fun append(value: kotlin.Char): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.4"")
    public final fun append(value: kotlin.CharArray): kotlin.text.StringBuilder

    public open override fun append(value: kotlin.CharSequence?): kotlin.text.StringBuilder

    public open override fun append(value: kotlin.CharSequence?, startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.9"")
    public final fun append(value: kotlin.Double): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.9"")
    public final fun append(value: kotlin.Float): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.9"")
    public final fun append(value: kotlin.Int): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.9"")
    public final fun append(value: kotlin.Long): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.9"")
    public final fun append(value: kotlin.Short): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.3"")
    public final fun append(value: kotlin.String?): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.4"")
    public final fun appendRange(value: kotlin.CharArray, startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.4"")
    public final fun appendRange(value: kotlin.CharSequence, startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.3"")
    @kotlin.Deprecated(level = DeprecationLevel.WARNING, message = ""Obtaining StringBuilder capacity is not supported in JS and common code."")
    public final fun capacity(): kotlin.Int

    @kotlin.SinceKotlin(version = ""1.3"")
    public final fun clear(): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.4"")
    public final fun deleteAt(index: kotlin.Int): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.4"")
    public final fun deleteRange(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.4"")",public final fun ensureCapacity(minimumCapacity: kotlin.Int): kotlin.Unit
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.lower.coroutines

import org.jetbrains.kotlin.backend.common.BodyLoweringPass
import org.jetbrains.kotlin.ir.backend.js.JsIrBackendContext
import org.jetbrains.kotlin.ir.backend.js.utils.compileSuspendAsJsGenerator
import org.jetbrains.kotlin.ir.declarations.IrDeclaration
import org.jetbrains.kotlin.ir.expressions.IrBody
import org.jetbrains.kotlin.ir.expressions.IrCall
import org.jetbrains.kotlin.ir.expressions.IrCallableReference
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.symbols.IrSimpleFunctionSymbol
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
import org.jetbrains.kotlin.ir.visitors.transformChildrenVoid

class ReplaceSuspendIntrinsicLowering(private val context: JsIrBackendContext) : BodyLoweringPass {
    private val valueParamSizeToItsCreateCoroutineUnintercepted =
        context.intrinsics.createCoroutineUninterceptedGeneratorVersion.groupPerValueParamSize()
    private val valueParamSizeToItsStartCoroutineUninterceptedOrReturn =
        context.intrinsics.startCoroutineUninterceptedOrReturnGeneratorVersion.groupPerValueParamSize()

    private fun Set<IrSimpleFunctionSymbol>.groupPerValueParamSize(): Map<Int, IrSimpleFunctionSymbol> {
        return associateBy { it.owner.valueParameters.size }
    }

    override fun lower(irBody: IrBody, container: IrDeclaration) {
        if (!context.compileSuspendAsJsGenerator) return
        irBody.transformChildrenVoid(object : IrElementTransformerVoid() {
            override fun visitCallableReference(expression: IrCallableReference<*>): IrExpression {
                if (expression.symbol !is IrSimpleFunctionSymbol) return super.visitCallableReference(expression)

                @Suppress(""UNCHECKED_CAST"")
                val reference = expression as IrCallableReference<IrSimpleFunctionSymbol>

                when (val symbol = reference.symbol) {
                    in context.intrinsics.createCoroutineUnintercepted ->
                        reference.symbol = valueParamSizeToItsCreateCoroutineUnintercepted.getValue(symbol.owner.valueParameters.size)
                    in context.intrinsics.startCoroutineUninterceptedOrReturn ->
                        reference.symbol = valueParamSizeToItsStartCoroutineUninterceptedOrReturn.getValue(symbol.owner.valueParameters.size)
                }

                return super.visitCallableReference(reference)
            }

            override fun visitCall(expression: IrCall): IrExpression {
                when (val symbol = expression.symbol) {
                    in context.intrinsics.createCoroutineUnintercepted ->
                        expression.symbol = valueParamSizeToItsCreateCoroutineUnintercepted.getValue(symbol.owner.valueParameters.size)
                    in context.intrinsics.startCoroutineUninterceptedOrReturn ->",expression.symbol = valueParamSizeToItsStartCoroutineUninterceptedOrReturn.getValue(symbol.owner.valueParameters.size)
"internal fun IrClass.hasSerializableOrMetaAnnotationWithoutArgs(): Boolean = checkSerializableOrMetaAnnotationArgs(mustDoNotHaveArgs = true)

fun IrClass.hasSerializableOrMetaAnnotation() = checkSerializableOrMetaAnnotationArgs(mustDoNotHaveArgs = false)

private fun IrClass.hasSerializableAnnotationWithArgs(): Boolean {
    val annot = getAnnotation(SerializationAnnotations.serializableAnnotationFqName)
    return annot?.getValueArgument(0) != null
}

private fun IrClass.checkSerializableOrMetaAnnotationArgs(mustDoNotHaveArgs: Boolean): Boolean {
    val annot = getAnnotation(SerializationAnnotations.serializableAnnotationFqName)
    if (annot != null) { // @Serializable have higher priority
        if (!mustDoNotHaveArgs) return true
        if (annot.getValueArgument(0) != null) return false
        return true
    }
    return annotations
        .map { it.constructedClass.annotations }
        .any { it.hasAnnotation(SerializationAnnotations.metaSerializableAnnotationFqName) }
}

internal val IrClass.isSerialInfoAnnotation: Boolean
    get() = annotations.hasAnnotation(SerializationAnnotations.serialInfoFqName)
            || annotations.hasAnnotation(SerializationAnnotations.inheritableSerialInfoFqName)
            || annotations.hasAnnotation(SerializationAnnotations.metaSerializableAnnotationFqName)

internal val IrClass.isInheritableSerialInfoAnnotation: Boolean
    get() = annotations.hasAnnotation(SerializationAnnotations.inheritableSerialInfoFqName)

internal fun IrClass.shouldHaveGeneratedSerializer(): Boolean =
    (isInternalSerializable && (modality == Modality.FINAL || modality == Modality.OPEN))
            || isEnumWithLegacyGeneratedSerializer()
            // enum factory must be used for enums
            || (shouldHaveGeneratedMethods() && kind != ClassKind.ENUM_CLASS)

internal val IrClass.shouldHaveGeneratedMethodsInCompanion: Boolean
    get() = this.isSerializableObject || this.isSerializableEnum() || (this.kind == ClassKind.CLASS && hasSerializableOrMetaAnnotation()) || this.isSealedSerializableInterface || this.isSerializableInterfaceWithCustom

internal fun IrClass.isSerializableEnum(): Boolean = kind == ClassKind.ENUM_CLASS && hasSerializableOrMetaAnnotation()

internal val IrType.genericIndex: Int?
    get() = (this.classifierOrNull as? IrTypeParameterSymbol)?.owner?.index

fun IrType.serialName(): String = this.classOrUpperBound()!!.owner.serialName()

fun IrClass.serialName(): String {
    return annotations.serialNameValue ?: fqNameWhenAvailable?.asString() ?: error(""${this.render()} does not have fqName"")
}

fun IrClass.findEnumValuesMethod() = this.functions.singleOrNull { f ->
    f.name == Name.identifier(""values"") && f.valueParameters.isEmpty() && f.extensionReceiverParameter == null && f.dispatchReceiverParameter == null
} ?: error(""Enum class does not have single .values() function"")

internal fun IrClass.enumEntries(): List<IrEnumEntry> {
    check(this.kind == ClassKind.ENUM_CLASS)
    return declarations.filterIsInstance<IrEnumEntry>().toList()
}

internal fun IrClass.isEnumWithSerialInfoAnnotation(): Boolean {
    if (kind != ClassKind.ENUM_CLASS) return false
    if (annotations.hasAnySerialAnnotation) return true
    return enumEntries().any { (it.annotations.hasAnySerialAnnotation) }
}

fun IrClass.findWriteSelfMethod(): IrSimpleFunction? =",functions.singleOrNull { it.name == SerialEntityNames.WRITE_SELF_NAME && !it.isFakeOverride }
"// Auto-generated by GenerateSteppedRangesCodegenTestData. Do not edit!
// WITH_STDLIB
import kotlin.test.*

fun box(): String {
    val intList = mutableListOf<Int>()
    for (i in 1 until 8 step 3 step 2) {
        intList += i
    }
    assertEquals(listOf(1, 3, 5, 7), intList)

    val longList = mutableListOf<Long>()
    for (i in 1L until 8L step 3L step 2L) {
        longList += i
    }","assertEquals(listOf(1L, 3L, 5L, 7L), longList)"
"}

    override fun visitBlock(block: FirBlock) {
        if (block !is FirContractCallBlock) {
            super.visitBlock(block)
        }
    }

    override fun visitContractDescription(contractDescription: FirContractDescription) {
        // Skip contract description.
        // Contract blocks are skipped in BE, so we would never need to inline contract DSL calls.
    }

    override fun visitConstructor(constructor: FirConstructor) {
        constructor.lazyResolveToPhase(FirResolvePhase.BODY_RESOLVE)

        super.visitConstructor(constructor)
    }

    override fun visitSimpleFunction(simpleFunction: FirSimpleFunction) {
        simpleFunction.lazyResolveToPhase(FirResolvePhase.BODY_RESOLVE)

        val oldIsInlineFunctionContext = isInlineFunctionContext
        try {
            isInlineFunctionContext = simpleFunction.isInline
            super.visitFunction(simpleFunction)
        } finally {
            isInlineFunctionContext = oldIsInlineFunctionContext
        }
    }

    override fun visitProperty(property: FirProperty) {
        property.lazyResolveToPhase(FirResolvePhase.BODY_RESOLVE)

        super.visitProperty(property)
    }

    override fun visitClass(klass: FirClass) {
        super.visitClass(klass)

        if (isInlineFunctionContext) {
            collectedInlinedClasses.addIfNotNull(klass.psi as? KtClassOrObject)
        }
    }

    @OptIn(SymbolInternals::class)
    private fun processResolvable(element: FirResolvable) {
        fun addToQueue(function: FirFunction?) {
            val original = function?.unwrapSubstitutionOverrides() ?: return
            if (original.isInline && original.hasBody) {
                queue.add(function)
            }
        }

        val reference = element.calleeReference
        if (reference !is FirResolvedNamedReference) {
            return
        }

        val symbol = reference.resolvedSymbol
        if (symbol is FirCallableSymbol<*>) {
            when (val fir = symbol.fir) {
                is FirFunction -> {
                    addToQueue(fir)
                }",is FirProperty -> {
"import kotlin.reflect.KProperty

class Delegate {
    var inner = 1
    operator fun getValue(t: Any?, p: KProperty<*>): Int = inner
    operator fun setValue(t: Any?, p: KProperty<*>, i: Int) { inner = i }
}

fun foo() = Delegate()

class A {
    var prop: Int by foo()
}",fun box(): String {
"import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.declaration.FirAbstractOverrideChecker
import org.jetbrains.kotlin.fir.analysis.checkers.unsubstitutedScope
import org.jetbrains.kotlin.fir.analysis.diagnostics.jvm.FirJvmErrors
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.declarations.utils.isExpect
import org.jetbrains.kotlin.fir.java.enhancement.EnhancedForWarningConeSubstitutor
import org.jetbrains.kotlin.fir.scopes.*
import org.jetbrains.kotlin.fir.scopes.impl.FirFakeOverrideGenerator
import org.jetbrains.kotlin.fir.symbols.SymbolInternals
import org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol
import org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase
import org.jetbrains.kotlin.fir.types.coneType
import org.jetbrains.kotlin.fir.types.typeContext
import org.jetbrains.kotlin.utils.addToStdlib.runIf

sealed class FirOverrideJavaNullabilityWarningChecker(mppKind: MppCheckerKind) : FirAbstractOverrideChecker(mppKind) {
    object Regular : FirOverrideJavaNullabilityWarningChecker(MppCheckerKind.Platform) {
        override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {
            if (declaration.isExpect) return
            super.check(declaration, context, reporter)
        }
    }

    object ForExpectClass : FirOverrideJavaNullabilityWarningChecker(MppCheckerKind.Common) {
        override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {
            if (!declaration.isExpect) return
            super.check(declaration, context, reporter)
        }
    }

    override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {
        val substitutor = EnhancedForWarningConeSubstitutor(context.session.typeContext)
        val scope = declaration.unsubstitutedScope(context)
        val typeCheckerState = context.session.typeContext.newTypeCheckerState(
            errorTypesEqualToAnything = false,
            stubTypesEqualToAnything = false
        )

        for (member in declaration.declarations) {
            var anyBaseEnhanced = false
            var anyReported = false

            if (member is FirSimpleFunction) {
                val enhancedOverrides = scope
                    .getDirectOverriddenFunctions(member.symbol)
                    .map {
                        val substitutedBase = it.substituteOrNull(substitutor, context) ?: return@map it
                        anyBaseEnhanced = true

                        if (!anyReported && !context.session.firOverrideChecker.isOverriddenFunction(member.symbol, substitutedBase)) {
                            anyReported = true
                            reporter.reportOn(
                                member.source,
                                FirJvmErrors.WRONG_NULLABILITY_FOR_JAVA_OVERRIDE,
                                member.symbol,
                                substitutedBase,
                                context
                            )
                        }

                        substitutedBase
                    }",if (anyBaseEnhanced && !anyReported) {
"for (projStep in projectInfo.steps) {
                val testInfo = projStep.order.map { setupTestStep(projStep, it) }

                val mainModuleInfo = testInfo.last()
                testInfo.find { it != mainModuleInfo && it.friends.isNotEmpty() }?.let {
                    error(""module ${it.moduleName} has friends, but only main module may have the friends"")
                }

                val configuration = createConfiguration(projStep.order.last(), projStep.language, projectInfo.moduleKind)

                val dirtyData = when (granularity) {
                    JsGenerationGranularity.PER_FILE -> projStep.dirtyJsFiles
                    else -> projStep.dirtyJsModules
                }

                val cacheUpdater = CacheUpdater(
                    mainModule = mainModuleInfo.modulePath,
                    allModules = testInfo.mapTo(mutableListOf(STDLIB_KLIB, KOTLIN_TEST_KLIB)) { it.modulePath },
                    mainModuleFriends = mainModuleInfo.friends,
                    cacheDir = buildDir.resolve(""incremental-cache"").absolutePath,
                    compilerConfiguration = configuration,
                    irFactory = { IrFactoryImplForJsIC(WholeWorldStageController()) },
                    compilerInterfaceFactory = { mainModule, cfg ->
                        JsIrCompilerWithIC(
                            mainModule,
                            mainArguments,
                            cfg,
                            granularity,
                            getPhaseConfig(projStep.id),
                            setOf(FqName(BOX_FUNCTION_NAME)),
                        )
                    }
                )

                val removedModulesInfo = (projectInfo.modules - projStep.order.toSet()).map { setupTestStep(projStep, it) }

                val icCaches = cacheUpdater.actualizeCaches()
                verifyCacheUpdateStats(projStep.id, cacheUpdater.getDirtyFileLastStats(), testInfo + removedModulesInfo)

                val mainModuleName = icCaches.last().moduleExternalName
                val jsExecutableProducer = JsExecutableProducer(
                    mainModuleName = mainModuleName,
                    moduleKind = configuration[JSConfigurationKeys.MODULE_KIND]!!,
                    sourceMapsInfo = SourceMapsInfo.from(configuration),
                    caches = icCaches,
                    relativeRequirePath = true
                )

                val (jsOutput, rebuiltModules) = jsExecutableProducer.buildExecutable(granularity, outJsProgram = true)
                val writtenFiles = writeJsCode(projStep.id, mainModuleName, jsOutput, dtsStrategy)

                verifyJsExecutableProducerBuildModules(projStep.id, rebuiltModules, dirtyData)
                verifyJsCode(projStep.id, mainModuleName, writtenFiles)
                verifyDTS(projStep.id, testInfo)
            }
        }
    }

    private fun String.isAllowedKtFile() = endsWith("".kt"") && !TEST_FILE_IGNORE_PATTERN.matches(this)

    private fun String.isAllowedJsFile() = (endsWith("".js"") || endsWith("".mjs"")) && !TEST_FILE_IGNORE_PATTERN.matches(this)

    protected fun CompilerConfiguration.addSourcesFromDir(sourceDir: File): List<KtFile> {
        assert(sourceDir.isDirectory && sourceDir.exists()) { ""Cannot find source directory $sourceDir"" }","val sourceFiles = Files.find(sourceDir.toPath(), Integer.MAX_VALUE, { path: Path, fileAttributes: BasicFileAttributes ->"
"/*
 * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the LICENSE file.
 */
@file:OptIn(FreezingIsDeprecated::class)

package test.text

import kotlin.reflect.KClass
import kotlin.test.*
import kotlinx.cinterop.toKString
import test.assertArrayContentEquals

internal actual val surrogateCodePointDecoding: String = ""\uFFFD"".repeat(3)

internal actual val surrogateCharEncoding: ByteArray = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())

// Native-specific part of stdlib/test/text/StringEncodingTest.kt
class StringEncodingTestNative {
    private fun bytes(vararg elements: Int) = ByteArray(elements.size) {
        val v = elements[it]
        require(v in Byte.MIN_VALUE..Byte.MAX_VALUE)
        v.toByte()
    }

    private fun testEncoding(isWellFormed: Boolean, expected: ByteArray, string: String) {","assertArrayContentEquals(expected, string.encodeToByteArray())"
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER
// KT-7440 Cannot complete type inference if two extension functions for interface hierarchy

package inferenceagain",interface Base<T>
"}
        builder.append(""$indent</$name>\n"")
    }

    private fun renderAttributes(): String? {
        val builder = StringBuilder()
        for (a in attributes.keys) {
            builder.append("" $a=\""${attributes[a]}\"""")
        }
        return builder.toString()
    }
}

abstract class TagWithText(name: String) : Tag(name) {
    operator fun String.unaryPlus() {
        children.add(TextElement(this))
    }
}

class HTML() : TagWithText(""html"") {
    inline fun head(init: Head.() -> Unit) = initTag(Head(), init)

    inline fun body(init: Body.() -> Unit) = initTag(Body(), init)

    fun bodyNoInline(init: Body.() -> Unit) = initTag(Body(), init)
}

class Head() : TagWithText(""head"") {
    inline fun title(init: Title.() -> Unit) = initTag(Title(), init)
}

class Title() : TagWithText(""title"")

abstract class BodyTag(name: String) : TagWithText(name) {
    inline fun b(init: B.() -> Unit) = initTag(B(), init)
    inline fun p(init: P.() -> Unit) = initTag(P(), init)
    inline fun pNoInline(init: P.() -> Unit) = initTag(P(), init)
    inline fun h1(init: H1.() -> Unit) = initTag(H1(), init)
    inline fun ul(init: UL.() -> Unit) = initTag(UL(), init)
    inline fun a(href: String, init: A.() -> Unit) {
        val a = initTag(A(), init)
        a.href = href
    }
}

class Body() : BodyTag(""body"")
class UL() : BodyTag(""ul"") {
    inline fun li(init: LI.() -> Unit) = initTag(LI(), init)
}

class B() : BodyTag(""b"")
class LI() : BodyTag(""li"")
class P() : BodyTag(""p"")
class H1() : BodyTag(""h1"")
class A() : BodyTag(""a"") {
    public var href: String
        get() = attributes[""href""]!!
        set(value) {
            attributes[""href""] = value
        }
}

inline fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()",return html
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.tasks.configuration

import org.gradle.api.Project
import org.gradle.api.provider.Property
import org.gradle.api.provider.Provider
import org.gradle.api.tasks.TaskProvider
import org.gradle.api.tasks.compile.AbstractCompile
import org.jetbrains.kotlin.gradle.dsl.KotlinJvmCompilerOptions
import org.jetbrains.kotlin.gradle.dsl.KotlinJvmCompilerOptionsHelper
import org.jetbrains.kotlin.gradle.dsl.KotlinTopLevelExtension
import org.jetbrains.kotlin.gradle.internal.*
import org.jetbrains.kotlin.gradle.internal.Kapt3GradleSubplugin.Companion.KAPT_SUBPLUGIN_ID
import org.jetbrains.kotlin.gradle.internal.Kapt3GradleSubplugin.Companion.isIncludeCompileClasspath
import org.jetbrains.kotlin.gradle.internal.Kapt3GradleSubplugin.Companion.isUseK2
import org.jetbrains.kotlin.gradle.plugin.KaptExtension
import org.jetbrains.kotlin.gradle.plugin.KotlinCompilation
import org.jetbrains.kotlin.gradle.plugin.KotlinCompilationInfo
import org.jetbrains.kotlin.gradle.tasks.CompilerPluginOptions
import org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile
import org.jetbrains.kotlin.gradle.tasks.withType
import org.jetbrains.kotlin.gradle.utils.whenKaptEnabled

internal class KaptGenerateStubsConfig : BaseKotlinCompileConfig<KaptGenerateStubsTask> {

    constructor(
        compilation: KotlinCompilation<*>
    ) : super(KotlinCompilationInfo(compilation)) {
        configureFromExtension(project.extensions.getByType(KaptExtension::class.java))

        configureTask { kaptGenerateStubsTask ->
            // Syncing compiler options from related KotlinJvmCompile task
            @Suppress(""DEPRECATION"") val jvmCompilerOptions = compilation.compilerOptions.options as KotlinJvmCompilerOptions
            KotlinJvmCompilerOptionsHelper.syncOptionsAsConvention(
                from = jvmCompilerOptions,
                into = kaptGenerateStubsTask.compilerOptions
            )

            // This task should not sync any freeCompilerArgs from relevant KotlinCompile task
            // when someone explicitly configures any value for this task as well.
            // Here we reset any configured value and say that use KotlinCompile freeCompilerArgs as convention
            kaptGenerateStubsTask.compilerOptions.freeCompilerArgs.value(null as Iterable<String>?)
            kaptGenerateStubsTask.compilerOptions.freeCompilerArgs.convention(jvmCompilerOptions.freeCompilerArgs)
        }
    }","constructor(project: Project, ext: KotlinTopLevelExtension, kaptExtension: KaptExtension) : super(project, ext) {"
fun main() {,var result: String? = null
"// SKIP_KT_DUMP
// FIR_IDENTICAL
// TARGET_BACKEND: JVM
// FULL_JDK
// WITH_STDLIB

// FILE: Java1.java
public class Java1 {
    public <T> void foo(T a) { }
    public <T> T bar() {
        return null;
    }
}

// FILE: 1.kt

class A : Java1()

class B : Java1() {
    override fun <T : Any> foo(a: T?) { }",override fun <T : Any> bar(): T? {
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin

import org.gradle.api.Project
import org.jetbrains.kotlin.gradle.plugin.PropertiesProvider.Companion.kotlinPropertiesProvider
import org.jetbrains.kotlin.gradle.plugin.diagnostics.KotlinToolingDiagnostics.FailedToGetAgpVersionWarning
import org.jetbrains.kotlin.gradle.plugin.diagnostics.KotlinToolingDiagnostics.IncompatibleAgpVersionTooHighWarning
import org.jetbrains.kotlin.gradle.plugin.diagnostics.KotlinToolingDiagnostics.IncompatibleAgpVersionTooLowWarning
import org.jetbrains.kotlin.gradle.plugin.diagnostics.kotlinToolingDiagnosticsCollector
import org.jetbrains.kotlin.gradle.utils.androidPluginIds
import org.jetbrains.kotlin.gradle.utils.findAppliedAndroidPluginIdOrNull
import org.jetbrains.kotlin.gradle.utils.getOrPutRootProjectProperty
import org.jetbrains.kotlin.gradle.utils.runProjectConfigurationHealthCheck
import java.util.concurrent.atomic.AtomicBoolean

internal object KotlinMultiplatformAndroidGradlePluginCompatibilityHealthCheck {

    val compatibleAndroidGradlePluginVersionRange = AndroidGradlePluginVersionRange(
        minSupportedVersion = AndroidGradlePluginVersionRange.Version(7, 1),
        maxSupportedVersion = AndroidGradlePluginVersionRange.Version(8, 3)
    )

    /**
     * Used to store project paths that executed this health check
     */
    const val PROPERTY_KEY_EXECUTED_PROJECT_PATHS = ""KotlinMultiplatformAndroidGradlePluginCompatibilityHealthCheck.executedProjects""

    data class AndroidGradlePluginVersionRange(
        val minSupportedVersion: Version,
        val maxSupportedVersion: Version
    ) {

        constructor(
            minSupportedVersionMajor: Int, minSupportedVersionMinor: Int = 0,
            maxSupportedVersionMajor: Int, maxSupportedVersionMinor: Int = 0
        ) : this(
            minSupportedVersion = Version(minSupportedVersionMajor, minSupportedVersionMinor),
            maxSupportedVersion = Version(maxSupportedVersionMajor, maxSupportedVersionMinor)
        )

        data class Version(val major: Int, val minor: Int)

        fun isTooHigh(version: AndroidGradlePluginVersion): Boolean {
            if (version.major > this.maxSupportedVersion.major) return true",if (version.major < this.maxSupportedVersion.major) return false
"targetIds.map(incrementalComponents::getIncrementalCache)
        ),
        incrementalCompilationScope
    )
}

private class ProjectEnvironmentWithCoreEnvironmentEmulation(
    project: Project,
    localFileSystem: VirtualFileSystem,
    getPackagePartProviderFn: (GlobalSearchScope) -> PackagePartProvider,
    val initialRoots: List<JavaRoot>,
    val configuration: CompilerConfiguration
) : VfsBasedProjectEnvironment(project, localFileSystem, getPackagePartProviderFn) {

    val packagePartProviders = mutableListOf<JvmPackagePartProvider>()

    override fun getPackagePartProvider(fileSearchScope: AbstractProjectFileSearchScope): PackagePartProvider {
        return super.getPackagePartProvider(fileSearchScope).also {
            (it as? JvmPackagePartProvider)?.run {
                addRoots(initialRoots, configuration.getNotNull(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY))
                packagePartProviders += this
            }
        }
    }
}

fun createProjectEnvironment(
    configuration: CompilerConfiguration,
    parentDisposable: Disposable,
    configFiles: EnvironmentConfigFiles,
    messageCollector: MessageCollector
): VfsBasedProjectEnvironment {
    setupIdeaStandaloneExecution()
    val appEnv = KotlinCoreEnvironment.getOrCreateApplicationEnvironmentForProduction(parentDisposable, configuration)
    // TODO: get rid of projEnv too - seems that all needed components could be easily extracted
    val projectEnvironment = KotlinCoreEnvironment.ProjectEnvironment(parentDisposable, appEnv, configuration)

    projectEnvironment.configureProjectEnvironment(configuration, configFiles)

    val project = projectEnvironment.project
    val localFileSystem = VirtualFileManager.getInstance().getFileSystem(StandardFileSystems.FILE_PROTOCOL)

    val javaFileManager = project.getService(CoreJavaFileManager::class.java) as KotlinCliJavaFileManagerImpl

    val releaseTarget = configuration.get(JVMConfigurationKeys.JDK_RELEASE)

    val javaModuleFinder =
        CliJavaModuleFinder(configuration.get(JVMConfigurationKeys.JDK_HOME), messageCollector, javaFileManager, project, releaseTarget)

    val outputDirectory =
        configuration.get(JVMConfigurationKeys.MODULES)?.singleOrNull()?.getOutputDirectory()
            ?: configuration.get(JVMConfigurationKeys.OUTPUT_DIRECTORY)?.absolutePath

    val classpathRootsResolver = ClasspathRootsResolver(
        PsiManager.getInstance(project),
        messageCollector,
        configuration.getList(JVMConfigurationKeys.ADDITIONAL_JAVA_MODULES),
        { contentRootToVirtualFile(it, localFileSystem, projectEnvironment.jarFileSystem, messageCollector) },
        javaModuleFinder,
        !configuration.getBoolean(CLIConfigurationKeys.ALLOW_KOTLIN_PACKAGE),
        outputDirectory?.let { localFileSystem.findFileByPath(it) },
        javaFileManager,
        releaseTarget
    )","val (initialRoots, javaModules) ="
"}
}

class E1 {
    val property: Any get() = TODO()
    fun function(value: Any): Any = value

    class Nested {
        val property: Any get() = TODO()
        fun function(value: Any): Any = value
    }

    inner class Inner {
        val property: Any get() = TODO()
        fun function(value: Any): Any = value
    }
}

class E2<T : Any?> {
    val property: T get() = TODO()
    fun function(value: T): T = value

    class Nested<T : Any?> {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }
}

class E3<R : Any?> {
    val property: R get() = TODO()
    fun function(value: R): R = value

    class Nested<R : Any?> {
        val property: R get() = TODO()
        fun function(value: R): R = value
    }

    inner class Inner {
        val property: R get() = TODO()
        fun function(value: R): R = value
    }
}

class E4<T : Any> {
    val property: T get() = TODO()
    fun function(value: T): T = value

    class Nested<T : Any> {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }
}

class E5<T : CharSequence> {
    val property: T get() = TODO()",fun function(value: T): T = value
"val deprecationProvider = DeprecationResolver(
        LockBasedStorageManager.NO_LOCKS, languageVersionSettings, JavaDeprecationSettings
    )

    // TODO: remove after cleanin up IDE counterpart
    var files: List<KtFile>? = null
    var codegenFactory: CodegenFactory? = null

    init {
        val icComponents = configuration.get(JVMConfigurationKeys.INCREMENTAL_COMPILATION_COMPONENTS)
        if (icComponents != null) {
            val targetId = targetId
                ?: moduleName?.let {
                    // hack for Gradle IC, Gradle does not use build.xml file, so there is no way to pass target id
                    TargetId(it, ""java-production"")
                } ?: error(""Target ID should be specified for incremental compilation"")
            incrementalCacheForThisTarget = icComponents.getIncrementalCache(targetId)
            packagesWithObsoleteParts = incrementalCacheForThisTarget.getObsoletePackageParts().map {
                JvmClassName.byInternalName(it).packageFqName
            }.toSet()
            obsoleteMultifileClasses = incrementalCacheForThisTarget.getObsoleteMultifileClasses().map {
                JvmClassName.byInternalName(it).fqNameForClassNameWithoutDollars
            }
        } else {
            incrementalCacheForThisTarget = null
            packagesWithObsoleteParts = emptySet()
            obsoleteMultifileClasses = emptyList()
        }
    }

    private val extraJvmDiagnosticsTrace: BindingTrace =
        DelegatingBindingTrace(
            originalFrontendBindingContext, ""For extra diagnostics in ${this::class.java}"", false,
            customSuppressCache = if (isIrBackend) OnDemandSuppressCache(originalFrontendBindingContext) else null,
        )

    private val interceptedBuilderFactory: ClassBuilderFactory
    private var used = false

    val diagnostics: DiagnosticSink get() = extraJvmDiagnosticsTrace
    val collectedExtraJvmDiagnostics: Diagnostics = LazyJvmDiagnostics {
        duplicateSignatureFactory?.reportDiagnostics()
        extraJvmDiagnosticsTrace.bindingContext.diagnostics
    }

    val moduleName: String = moduleName ?: JvmCodegenUtil.getModuleName(module)
    val classBuilderMode: ClassBuilderMode = builderFactory.classBuilderMode
    val bindingTrace: BindingTrace = DelegatingBindingTrace(originalFrontendBindingContext, ""trace in GenerationState"")
    val bindingContext: BindingContext = bindingTrace.bindingContext
    val mainFunctionDetector = MainFunctionDetector(originalFrontendBindingContext, languageVersionSettings)
    val typeMapper: KotlinTypeMapper = KotlinTypeMapper(
        bindingContext,
        classBuilderMode,
        this.moduleName,
        languageVersionSettings,
        config.useOldManglingSchemeForFunctionsWithInlineClassesInSignatures,
        config.target,
        isIrBackend
    )
    val intrinsics: IntrinsicMethods =
        IntrinsicMethods(languageVersionSettings.apiVersion <= ApiVersion.parse(KotlinVersion.CURRENT.toString())!!)

    val samWrapperClasses: SamWrapperClasses = SamWrapperClasses(this)
    val globalInlineContext: GlobalInlineContext = GlobalInlineContext()",val mappingsClassesForWhenByEnum: MappingsClassesForWhenByEnum = MappingsClassesForWhenByEnum(this)
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.util

import org.jetbrains.kotlin.gradle.idea.testFixtures.tcs.binaryCoordinates

/**
 * Legacy -jdk8 and -jdk7 dependencies:
 * Those artifacts will be published as empty jars starting from Kotlin 1.8.0 as
 * the classes will be included in the kotlin-stdlib artifact already.
 *
 * Note: The kotlin-stdlib will add a constraint to always resolve 1.8.0 of those artifacts.
 * This will be necessary in the future, when no more jdk8 or jdk7 artifacts will be published:
 * In this case we need to still resolve to a version that will contain empty artifacts (1.8.0)
 *
 */
fun legacyStdlibJdkDependencies(version: String = ""1.8.0"") = listOf(","binaryCoordinates(""org.jetbrains.kotlin:kotlin-stdlib-jdk8:$version""),"
"import org.gradle.util.GradleVersion
import org.jetbrains.kotlin.gradle.testbase.*
import org.junit.jupiter.api.DisplayName

@MppGradlePluginTests
class WasmConfigurationCacheIT : KGPBaseTest() {
    override val defaultBuildOptions =
        super.defaultBuildOptions.copy(
            configurationCache = true,
        )

    @DisplayName(""configuration cache is working for wasm"")
    @GradleTest
    fun testKotlinWasmCompilation(gradleVersion: GradleVersion) {
        project(""wasm-d8-simple-project"", gradleVersion) {
            assertSimpleConfigurationCacheScenarioWorks(
                ""assemble"",
                buildOptions = defaultBuildOptions,
                executedTaskNames = listOf("":compileKotlinWasmJs"")
            )
        }
    }

    @DisplayName(""D8 run correctly works with configuration cache"")
    @GradleTest
    @GradleTestVersions(minVersion = TestVersions.Gradle.G_7_6)
    fun testD8Run(gradleVersion: GradleVersion) {
        project(
            ""wasm-d8-simple-project"",
            gradleVersion,
            dependencyManagement = DependencyManagement.DisabledDependencyManagement // :d8Download adds custom ivy repository during build
        ) {
            build(""wasmJsD8Run"", buildOptions = buildOptions) {
                assertTasksExecuted("":wasmJsD8Run"")
                if (gradleVersion < GradleVersion.version(TestVersions.Gradle.G_8_5)) {
                    assertOutputContains(
                        ""Calculating task graph as no configuration cache is available for tasks: wasmJsD8Run""
                    )
                } else {
                    assertOutputContains(
                        ""Calculating task graph as no cached configuration is available for tasks: wasmJsD8Run""
                    )
                }

                assertConfigurationCacheStored()
            }

            build(""clean"", buildOptions = buildOptions)

            // Then run a build where tasks states are deserialized to check that they work correctly in this mode
            build(""wasmJsD8Run"", buildOptions = buildOptions) {
                assertTasksExecuted("":wasmJsD8Run"")
                assertConfigurationCacheReused()
            }
        }
    }

    @DisplayName(""Browser case works correctly with configuration cache"")
    @GradleTest
    @GradleTestVersions(minVersion = TestVersions.Gradle.G_7_6)
    fun testBrowser(gradleVersion: GradleVersion) {
        project(""wasm-browser-simple-project"", gradleVersion) {
            assertSimpleConfigurationCacheScenarioWorks(
                ""assemble"",","buildOptions = defaultBuildOptions,"
"assertPrints(result, ""{b=98, o=111, n=110, e=101,  =32, j=106, u=117, r=114, =233}"")
    }

    @Sample
    fun associateWith() {
        val string = ""bonne journe""
        // associate each character with its code
        val result = string.associateWith { char -> char.code }
        // notice each letter occurs only once
        assertPrints(result, ""{b=98, o=111, n=110, e=101,  =32, j=106, u=117, r=114, =233}"")
    }

    @Sample
    fun associateWithTo() {
        val string = ""bonne journe""
        // associate each character with its code
        val result = mutableMapOf<Char, Int>()
        string.associateWithTo(result) { char -> char.code }
        // notice each letter occurs only once
        assertPrints(result, ""{b=98, o=111, n=110, e=101,  =32, j=106, u=117, r=114, =233}"")
    }

    @Sample
    fun partition() {
        fun isVowel(c: Char) = ""aeuio"".contains(c, ignoreCase = true)
        val string = ""Discussion""
        val result = string.partition(::isVowel)
        assertPrints(result, ""(iuio, Dscssn)"")
    }

    @Sample
    fun stringToByteArray() {
        val charset = Charsets.UTF_8
        val byteArray = ""Hello"".toByteArray(charset)
        assertPrints(byteArray.contentToString(), ""[72, 101, 108, 108, 111]"")
        assertPrints(byteArray.toString(charset), ""Hello"")
    }

    @Sample
    fun lowercase() {
        assertPrints(""Iced frapp!"".lowercase(), ""iced frapp!"")
    }

    @Sample
    fun lowercaseLocale() {
        assertPrints(""KOTLIN"".lowercase(), ""kotlin"")
        val turkishLocale = Locale.forLanguageTag(""tr"")
        assertPrints(""KOTLIN"".lowercase(turkishLocale), ""kotln"")
    }

    @Sample
    fun uppercase() {
        assertPrints(""Iced frapp!"".uppercase(), ""ICED FRAPP!"")
    }

    @Sample
    fun uppercaseLocale() {
        assertPrints(""Kotlin"".uppercase(), ""KOTLIN"")
        val turkishLocale = Locale.forLanguageTag(""tr"")
        assertPrints(""Kotlin"".uppercase(turkishLocale), ""KOTLN"")
    }

    @Sample
    fun padStart() {
        val padWithSpace = ""125"".padStart(5)","assertPrints(""'$padWithSpace'"", ""'  125'"")"
"// TARGET_BACKEND: JVM
// WITH_STDLIB
// WITH_COROUTINES

// FILE: defaultParametersInSuspsendWithJvmOverloads.kt
import helpers.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.test.assertEquals",@JvmOverloads
"// EXPECTED_REACHABLE_NODES: 1706
// KJS_WITH_FULL_RUNTIME
// SKIP_DCE_DRIVEN
// RUN_UNIT_TESTS

import common.*
import kotlin.test.Test
import kotlin.test.BeforeTest
import kotlin.test.AfterTest

class Simple {
    @BeforeTest
    fun before() {
        call(""before"")
    }

    @AfterTest
    fun after() {
        call(""after"")
    }

    @Test
    fun foo() {
        call(""foo"")
    }

    @Test
    fun bar() {
        call(""bar"")
    }

    @Test
    fun withException() {
        call(""withException"")
        raise(""some exception"")
        call(""never happens"")
    }
}

fun box() = checkLog {
    suite(""Simple"") {
        test(""foo"") {
            call(""before"")
            call(""foo"")
            call(""after"")
        }
        test(""bar"") {
            call(""before"")
            call(""bar"")
            call(""after"")
        }
        test(""withException"") {
            call(""before"")","call(""withException"")"
"@Suppress(""UNCHECKED_CAST"")
        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()
    }
    return toMutableList().apply { sort() }
}

/**
 * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.
 * 
 * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.
 * 
 * @sample samples.collections.Collections.Sorting.sortedBy
 */
public inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {
    return sortedWith(compareBy(selector))
}

/**
 * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.
 * 
 * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.
 */
public inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {
    return sortedWith(compareByDescending(selector))
}

/**
 * Returns a list of all elements sorted descending according to their natural sort order.
 * 
 * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.
 */
public fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {
    return sortedWith(reverseOrder())
}

/**
 * Returns a list of all elements sorted according to the specified [comparator].
 * 
 * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.
 */
public fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {
    if (this is Collection) {
       if (size <= 1) return this.toList()
       @Suppress(""UNCHECKED_CAST"")
       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()
    }
    return toMutableList().apply { sortWith(comparator) }
}

/**
 * Returns an array of Boolean containing all of the elements of this collection.
 */
public fun Collection<Boolean>.toBooleanArray(): BooleanArray {
    val result = BooleanArray(size)
    var index = 0
    for (element in this)
        result[index++] = element
    return result
}

/**
 * Returns an array of Byte containing all of the elements of this collection.
 */
public fun Collection<Byte>.toByteArray(): ByteArray {
    val result = ByteArray(size)",var index = 0
"fun DescriptorRendererOptions.defaultDecompilerRendererOptions() {
    withDefinedIn = false
    classWithPrimaryConstructor = true
    secondaryConstructorsAsPrimary = false
    modifiers = DescriptorRendererModifier.ALL
    excludedTypeAnnotationClasses = emptySet()
    alwaysRenderModifiers = true
    parameterNamesInFunctionalTypes = false // to support parameters names in decompiled text we need to load annotation arguments
    defaultParameterValueRenderer = { _ -> COMPILED_DEFAULT_PARAMETER_VALUE }
    includePropertyConstant = true
    propertyConstantRenderer = { _ -> COMPILED_DEFAULT_INITIALIZER }
}

/**
 * @see org.jetbrains.kotlin.analysis.decompiler.stub.mustNotBeWrittenToStubs
 */
internal fun CallableMemberDescriptor.mustNotBeWrittenToDecompiledText(): Boolean {
    return when (kind) {
        CallableMemberDescriptor.Kind.DECLARATION, CallableMemberDescriptor.Kind.DELEGATION -> false
        CallableMemberDescriptor.Kind.FAKE_OVERRIDE -> true
        CallableMemberDescriptor.Kind.SYNTHESIZED -> syntheticMemberMustNotBeWrittenToDecompiledText()
    }
}

private fun CallableMemberDescriptor.syntheticMemberMustNotBeWrittenToDecompiledText(): Boolean {
    val containingClass = containingDeclaration as? ClassDescriptor ?: return false

    return when {
        containingClass.kind == ClassKind.ENUM_CLASS -> {
            name in arrayOf(
                StandardNames.ENUM_VALUES,
                StandardNames.ENUM_ENTRIES,
                StandardNames.ENUM_VALUE_OF,
            )
        }

        else -> false
    }
}

fun buildDecompiledText(
    packageFqName: FqName,
    descriptors: List<DeclarationDescriptor>,
    descriptorRenderer: DescriptorRenderer,
): DecompiledText {
    val builder = StringBuilder()

    fun appendDecompiledTextAndPackageName() {
        builder.append(""// IntelliJ API Decompiler stub source generated from a class file\n"" + ""// Implementation of methods is not available"")
        builder.append(""\n\n"")
        if (!packageFqName.isRoot) {
            builder.append(""package "").append(packageFqName.render()).append(""\n\n"")
        }
    }

    fun appendDescriptor(descriptor: DeclarationDescriptor, indent: String, lastEnumEntry: Boolean? = null) {
        if (isEnumEntry(descriptor)) {
            for (annotation in descriptor.annotations) {
                builder.append(descriptorRenderer.renderAnnotation(annotation))
                builder.append("" "")
            }
            builder.append(descriptor.name.asString().quoteIfNeeded())
            builder.append(if (lastEnumEntry!!) "";"" else "","")
        } else {","builder.append(descriptorRenderer.render(descriptor).replace(""= ..."", DECOMPILED_COMMENT_FOR_PARAMETER))"
"configuration,
            diagnosticReporter,
            metadataSerializer,
            tmpKlibDir,
            emptyList(),
            moduleFragment,
            emptyList(),
            true,
            perFile,
            abiVersion = KotlinAbiVersion.CURRENT,
            jsOutputName = null,
        )

        return tmpKlibDir
    }

    private fun doDeserializeModuleMetadata(moduleRef: KotlinLibrary): ModuleDescriptorImpl {
        return getModuleDescriptorByLibrary(moduleRef, emptyMap())
    }

    private data class DeserializedModuleInfo(
        val module: IrModuleFragment,
        val symbolTable: SymbolTable,
        val irBuiltIns: IrBuiltIns,
        val linker: JsIrLinker
    )


    private fun doSerializeIrModule(module: IrModuleFragment): SerializedIrModule {
        return JsIrModuleSerializer(
            KtDiagnosticReporterWithImplicitIrBasedContext(
                DiagnosticReporterFactory.createPendingReporter(),
                configuration.languageVersionSettings,
            ),
            module.irBuiltins,
            CompatibilityMode.CURRENT,
            normalizeAbsolutePaths = false,
            emptyList(),
            configuration.languageVersionSettings,
        ).serializedIrModule(module)
    }

    private fun doWriteIrModuleToStorage(serializedIrModule: SerializedIrModule, writer: KotlinLibraryOnlyIrWriter) {
        writer.writeIr(serializedIrModule)
    }

    @OptIn(ObsoleteDescriptorBasedAPI::class)
    private fun doDeserializeIrModule(moduleDescriptor: ModuleDescriptorImpl): DeserializedModuleInfo {
        val mangler = JsManglerDesc
        val signaturer = IdSignatureDescriptor(mangler)
        val symbolTable = SymbolTable(signaturer, IrFactoryImpl)
        val typeTranslator = TypeTranslatorImpl(symbolTable, languageVersionSettings, moduleDescriptor)
        val irBuiltIns = IrBuiltInsOverDescriptors(moduleDescriptor.builtIns, typeTranslator, symbolTable)

        val jsLinker = JsIrLinker(moduleDescriptor, IrMessageLogger.None, irBuiltIns, symbolTable, PartialLinkageSupportForLinker.DISABLED, null)

        val moduleFragment = jsLinker.deserializeFullModule(moduleDescriptor, moduleDescriptor.kotlinLibrary)
        jsLinker.init(null, emptyList())
        // Create stubs
        ExternalDependenciesGenerator(symbolTable, listOf(jsLinker))
            .generateUnboundSymbolsAsDependencies()

        jsLinker.postProcess(inOrAfterLinkageStep = true)
        jsLinker.clear()",moduleFragment.patchDeclarationParents()
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.resolve.calls.smartcasts

import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.calls.context.ResolutionContext
import org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValue
import org.jetbrains.kotlin.types.KotlinType

/**
 * This class is intended to create data flow values for different kind of expressions.
 * Then data flow values serve as keys to obtain data flow information for these expressions.
 */
interface DataFlowValueFactory {
    fun createDataFlowValue(
        expression: KtExpression,
        type: KotlinType,
        resolutionContext: ResolutionContext<*>
    ): DataFlowValue

    fun createDataFlowValue(
        expression: KtExpression,
        type: KotlinType,
        bindingContext: BindingContext,
        containingDeclarationOrModule: DeclarationDescriptor
    ): DataFlowValue

    fun createDataFlowValueForStableReceiver(receiver: ReceiverValue): DataFlowValue

    fun createDataFlowValue(
        receiverValue: ReceiverValue,
        resolutionContext: ResolutionContext<*>
    ): DataFlowValue

    fun createDataFlowValue(","receiverValue: ReceiverValue,"
"/*
 * TESTCASE NUMBER: 15
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28785
 */
fun <T: InterfaceWithFiveTypeParameters1<*, *, *, *, *>?> T.case_15() {
    if (this != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.itest1()

        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>equals<!>(this)
        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>itest1<!>()
        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>apply<!> {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>
            equals(null)
            propT
            propAny
            propNullableT
            propNullableAny
            funT()
            funAny()
            funNullableT()
            funNullableAny()
            itest1()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.itest1()
        }
        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>also<!> {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.itest1()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.funNullableAny()
        }
    }
}

/*
 * TESTCASE NUMBER: 16
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28785
 */",fun <T: InterfaceWithTypeParameter1<out T>?> T.case_16() {
"override val element: IrElement,
) : InferenceNode() {
    override val kind: NodeKind get() = NodeKind.Expression
    override val function: InferenceFunction? get() = null
    override val referenceContainer: InferenceNode? get() = null
}

/**
 * An [InferenceResolvedParameter] is a node that references a parameter of a container of this
 * node. For example, if the parameter is captured by a nested lambda this is resolved to the
 * captured parameter.
 */
class InferenceResolvedParameter(
    override val element: IrGetValue,
    override val function: InferenceFunction,
    val container: InferenceNode,
    val index: Int
) : InferenceNode() {
    override val kind: NodeKind get() = NodeKind.ParameterReference
    override fun parameterIndex(node: InferenceNode): Int =
        if (node.function == function) index else -1

    override val referenceContainer: InferenceNode get() = container

    override fun equals(other: Any?): Boolean =
        other is InferenceResolvedParameter && other.element == element

    override fun hashCode(): Int = element.hashCode() * 31 + 103
}

private inline fun <reified T> IrConstructorCall.firstParameterOrNull() =
    if (valueArgumentsCount >= 1) {
        (getValueArgument(0) as? IrConst<*>)?.value as? T
    } else null

private val IrConstructorCall.isComposableTarget get() =
    annotationClass?.isClassWithFqName(
        ComposeFqNames.ComposableTarget.toUnsafe()
    ) == true

private val IrConstructorCall.isComposableTargetMarked: Boolean get() =
    annotationClass?.owner?.annotations?.hasAnnotation(
        ComposeFqNames.ComposableTargetMarker
    ) == true

private val IrConstructorCall.isComposableInferredTarget get() =
    annotationClass?.isClassWithFqName(
        ComposeFqNames.ComposableInferredTarget.toUnsafe()
    ) == true

private val IrConstructorCall.isComposableOpenTarget get() =
    annotationClass?.isClassWithFqName(
        ComposeFqNames.ComposableOpenTarget.toUnsafe()
    ) == true

private fun IrType.samOwnerOrNull() =
    classOrNull?.let { cls ->
        if (cls.owner.kind == ClassKind.INTERFACE) {
            cls.functions.singleOrNull {
                it.owner.modality == Modality.ABSTRACT
            }?.owner
        } else null
    }

private val IrCall.arguments get() = Array(valueArgumentsCount) {",getValueArgument(it)
"// DONT_TARGET_EXACT_BACKEND: JS
fun <T> T.id() = this

const val minusOneVal = <!EVALUATED(""-1.0"")!>-1.0<!>
const val oneVal = <!EVALUATED(""1.0"")!>1.0<!>
const val twoVal = <!EVALUATED(""2.0"")!>2.0<!>
const val threeVal = <!EVALUATED(""3.0"")!>3.0<!>
const val fourVal = <!EVALUATED(""4.0"")!>4.0<!>
const val oneAndAHalf = <!EVALUATED(""1.5"")!>1.5<!>

const val byteVal = 2.<!EVALUATED(""2"")!>toByte()<!>
const val shortVal = 2.<!EVALUATED(""2"")!>toShort()<!>
const val intVal = <!EVALUATED(""2"")!>2<!>
const val longVal = <!EVALUATED(""2"")!>2L<!>
const val floatVal = <!EVALUATED(""2.0"")!>2.0f<!>
const val doubleVal = <!EVALUATED(""2.0"")!>2.0<!>

const val funCompareTo1 = oneVal.<!EVALUATED(""-1"")!>compareTo(twoVal)<!>
const val funCompareTo2 = twoVal.<!EVALUATED(""0"")!>compareTo(twoVal)<!>
const val funCompareTo3 = threeVal.<!EVALUATED(""1"")!>compareTo(twoVal)<!>
const val funCompareTo4 = twoVal.<!EVALUATED(""0"")!>compareTo(byteVal)<!>
const val funCompareTo5 = twoVal.<!EVALUATED(""0"")!>compareTo(shortVal)<!>
const val funCompareTo6 = twoVal.<!EVALUATED(""0"")!>compareTo(intVal)<!>
const val funCompareTo7 = twoVal.<!EVALUATED(""0"")!>compareTo(longVal)<!>
const val funCompareTo8 = twoVal.<!EVALUATED(""0"")!>compareTo(floatVal)<!>

const val singCompareTo1 = <!EVALUATED(""false"")!>oneVal >= twoVal<!>
const val singCompareTo2 = <!EVALUATED(""false"")!>twoVal > twoVal<!>
const val singCompareTo3 = <!EVALUATED(""false"")!>threeVal <= twoVal<!>
const val singCompareTo4 = <!EVALUATED(""false"")!>twoVal < byteVal<!>

const val plus1 = oneVal.<!EVALUATED(""3.0"")!>plus(twoVal)<!>
const val plus2 = twoVal.<!EVALUATED(""4.0"")!>plus(twoVal)<!>
const val plus3 = threeVal.<!EVALUATED(""5.0"")!>plus(twoVal)<!>
const val plus4 = twoVal.<!EVALUATED(""4.0"")!>plus(byteVal)<!>
const val plus5 = twoVal.<!EVALUATED(""4.0"")!>plus(shortVal)<!>
const val plus6 = twoVal.<!EVALUATED(""4.0"")!>plus(intVal)<!>
const val plus7 = twoVal.<!EVALUATED(""4.0"")!>plus(longVal)<!>
const val plus8 = twoVal.<!EVALUATED(""4.0"")!>plus(floatVal)<!>

const val minus1 = oneVal.<!EVALUATED(""-1.0"")!>minus(twoVal)<!>
const val minus2 = twoVal.<!EVALUATED(""0.0"")!>minus(twoVal)<!>
const val minus3 = threeVal.<!EVALUATED(""1.0"")!>minus(twoVal)<!>
const val minus4 = twoVal.<!EVALUATED(""0.0"")!>minus(byteVal)<!>
const val minus5 = twoVal.<!EVALUATED(""0.0"")!>minus(shortVal)<!>
const val minus6 = twoVal.<!EVALUATED(""0.0"")!>minus(intVal)<!>
const val minus7 = twoVal.<!EVALUATED(""0.0"")!>minus(longVal)<!>
const val minus8 = twoVal.<!EVALUATED(""0.0"")!>minus(floatVal)<!>

const val times1 = oneVal.<!EVALUATED(""2.0"")!>times(twoVal)<!>
const val times2 = twoVal.<!EVALUATED(""4.0"")!>times(twoVal)<!>
const val times3 = threeVal.<!EVALUATED(""6.0"")!>times(twoVal)<!>
const val times4 = twoVal.<!EVALUATED(""4.0"")!>times(byteVal)<!>
const val times5 = twoVal.<!EVALUATED(""4.0"")!>times(shortVal)<!>
const val times6 = twoVal.<!EVALUATED(""4.0"")!>times(intVal)<!>
const val times7 = twoVal.<!EVALUATED(""4.0"")!>times(longVal)<!>
const val times8 = twoVal.<!EVALUATED(""4.0"")!>times(floatVal)<!>

const val div1 = oneVal.<!EVALUATED(""0.5"")!>div(twoVal)<!>
const val div2 = twoVal.<!EVALUATED(""1.0"")!>div(twoVal)<!>
const val div3 = threeVal.<!EVALUATED(""1.5"")!>div(twoVal)<!>
const val div4 = twoVal.<!EVALUATED(""1.0"")!>div(byteVal)<!>
const val div5 = twoVal.<!EVALUATED(""1.0"")!>div(shortVal)<!>
const val div6 = twoVal.<!EVALUATED(""1.0"")!>div(intVal)<!>
const val div7 = twoVal.<!EVALUATED(""1.0"")!>div(longVal)<!>","const val div8 = twoVal.<!EVALUATED(""1.0"")!>div(floatVal)<!>"
"}
    }
    declaration.extensionReceiverParameter?.let {
        val superTypes = it.type.superTypes().joinTypes(context)
        nameBuilder.append(""_r$${it.type.asString(context)}$superTypes"")
    }
    declaration.valueParameters.ifNotEmpty {
        joinTo(nameBuilder, """") {
            val defaultValueSign = if (it.origin == JsLoweredDeclarationOrigin.JS_SHADOWED_DEFAULT_PARAMETER) ""?"" else """"
            val superTypes = it.type.superTypes().joinTypes(context)
            ""_${it.type.asString(context)}$superTypes$defaultValueSign""
        }
    }
    declaration.returnType.let {
        // Return type is only used in signature for inline class and Unit types because
        // they are binary incompatible with supertypes.
        if (context.inlineClassesUtils.isTypeInlined(it) || it.isUnit()) {
            nameBuilder.append(""_ret$${it.asString(context)}"")
        }
    }

    val signature = abs(nameBuilder.toString().hashCode()).toString(Character.MAX_RADIX)

    // TODO: Use better hashCode
    val sanitizedName = sanitizeName(declarationName, withHash = false)
    return context.globalIrInterner.string(""${sanitizedName}_$signature$RESERVED_MEMBER_NAME_SUFFIX"")
}

fun jsFunctionSignature(declaration: IrFunction, context: JsIrBackendContext): String {
    require(!declaration.isStaticMethodOfClass)
    require(declaration.dispatchReceiverParameter != null)

    if (declaration.hasStableJsName(context)) {
        val declarationName = declaration.getJsNameOrKotlinName().asString()
        // TODO: Handle reserved suffix in FE
        require(!declarationName.endsWith(RESERVED_MEMBER_NAME_SUFFIX)) {
            ""Function ${declaration.fqNameWhenAvailable} uses reserved name suffix \""$RESERVED_MEMBER_NAME_SUFFIX\""""
        }
        return declarationName
    }

    val declarationSignature = (declaration as? IrSimpleFunction)?.resolveFakeOverride() ?: declaration
    return calculateJsFunctionSignature(declarationSignature, context)
}

class LocalNameGenerator(val variableNames: NameTable<IrDeclaration>) : IrElementVisitorVoid {
    val localLoopNames = NameTable<IrLoop>()
    val localReturnableBlockNames = NameTable<IrReturnableBlock>()

    private val jumpableDeque: Deque<IrExpression> = LinkedList()

    override fun visitElement(element: IrElement) {
        element.acceptChildrenVoid(this)
    }

    override fun visitDeclaration(declaration: IrDeclarationBase) {
        super.visitDeclaration(declaration)
        if (declaration is IrDeclarationWithName) {
            variableNames.declareFreshName(declaration, declaration.name.asString())
        }
    }

    override fun visitBreak(jump: IrBreak) {
        val loop = jump.loop
        if (loop.label == null && loop != jumpableDeque.firstOrNull()) {","persistLoopName(SYNTHETIC_LOOP_LABEL, loop)"
"// EXPECTED_REACHABLE_NODES: 1292
package foo

// CHECK_CONTAINS_NO_CALLS: maxBySquare except=imul;Unit_getInstance

internal data class Result(var value: Int = 0, var invocationCount: Int = 0)

internal inline fun maxBy(a: Array<Int>, keyFun: (Int) -> Int): Int {
    var maxVal = a[0]
    var maxKey = keyFun(maxVal)

    for (element in a) {
        val key = keyFun(element)

        if (key > maxKey) {
            maxVal = element
            maxKey = key
        }
    }

    return maxVal
}

// CHECK_BREAKS_COUNT: function=maxBySquare count=0 TARGET_BACKENDS=JS_IR
// CHECK_LABELS_COUNT: function=maxBySquare name=$l$block count=0 TARGET_BACKENDS=JS_IR
internal fun maxBySquare(a: Array<Int>, r: Result): Result {
    var invocationCount = 0
    val maxVal = maxBy(a, { x -> invocationCount++; x * x;})

    r.value = maxVal
    r.invocationCount = invocationCount

    return r
}

fun box(): String {
    var r1 = maxBySquare(arrayOf(1,2,3,4,5), Result())
    assertEquals(Result(5, 6), r1)

    var r2 = maxBySquare(arrayOf(-5,1,2,3,4), Result())
    assertEquals(Result(-5, 6), r2)","return ""OK"""
"// Auto-generated by GenerateInRangeExpressionTestData. Do not edit!
// WITH_STDLIB
// DONT_TARGET_EXACT_BACKEND: JVM
// !LANGUAGE: +RangeUntilOperator
@file:OptIn(ExperimentalStdlibApi::class)



val range0 = 1.0F..<3.0F
val range1 = 3.0F..<1.0F

val element0 = -1F
val element1 = 0F
val element2 = 1F
val element3 = 2F
val element4 = 3F
val element5 = 4F

fun box(): String {
    testR0xE0()
    testR0xE1()
    testR0xE2()
    testR0xE3()
    testR0xE4()
    testR0xE5()
    testR1xE0()
    testR1xE1()
    testR1xE2()
    testR1xE3()
    testR1xE4()
    testR1xE5()
    return ""OK""
}

fun testR0xE0() {
    // with possible local optimizations
    if (-1F in 1.0F..<3.0F != range0.contains(-1F)) throw AssertionError()
    if (-1F !in 1.0F..<3.0F != !range0.contains(-1F)) throw AssertionError()
    if (!(-1F in 1.0F..<3.0F) != !range0.contains(-1F)) throw AssertionError()
    if (!(-1F !in 1.0F..<3.0F) != range0.contains(-1F)) throw AssertionError()
    // no local optimizations
    if (element0 in 1.0F..<3.0F != range0.contains(element0)) throw AssertionError()
    if (element0 !in 1.0F..<3.0F != !range0.contains(element0)) throw AssertionError()",if (!(element0 in 1.0F..<3.0F) != !range0.contains(element0)) throw AssertionError()
"firFile = firFile,
        nonLocalDeclaration = nonLocalDeclaration,
    )?.declarationTarget

    fun findPathToDeclarationWithTarget(
        firFile: FirFile,
        nonLocalDeclaration: KtDeclaration,
    ): List<FirDeclaration>? = collectDesignationPath(
        firFile = firFile,
        nonLocalDeclaration = nonLocalDeclaration,
    )?.let { it.path + it.declarationTarget }

    fun collectDesignationPath(
        firFile: FirFile,
        nonLocalDeclaration: KtDeclaration,
    ): FirDesignation? = collectDesignationPath(
        firFile = firFile,
        containerClassId = nonLocalDeclaration.containingClassOrObject?.getClassId(),
        expectedDeclarationAcceptor = { it.psi == nonLocalDeclaration },
    )

    /**
     * @see collectDesignationPath
     */
    private val FirDesignation.declarationTarget: FirDeclaration get() = target as FirDeclaration

    /**
     * @return [FirDesignation] where [FirDesignation.target] is [FirDeclaration]
     *
     * @see declarationTarget
     */
    private fun collectDesignationPath(
        firFile: FirFile,
        containerClassId: ClassId?,
        expectedDeclarationAcceptor: (FirDeclaration) -> Boolean,
    ): FirDesignation? {
        if (containerClassId != null) {
            requireWithAttachment(!containerClassId.isLocal, { ""ClassId should not be local"" }) {
                withEntry(""classId"", containerClassId) { it.asString() }
            }

            requireWithAttachment(
                firFile.packageFqName == containerClassId.packageFqName,
                { ""ClassId should not be local"" }
            ) {
                withEntry(""FirFile.packageName"", firFile.packageFqName) { it.asString() }
                withEntry(""ClassId.packageName"", containerClassId.packageFqName) { it.asString() }
            }
        }

        val classIdPathSegment = containerClassId?.relativeClassName?.pathSegments().orEmpty()
        val path = ArrayList<FirDeclaration>(classIdPathSegment.size + 2)
        var result: FirDeclaration? = null

        fun find(declarations: Iterable<FirDeclaration>, classIdPathIndex: Int): Boolean {
            val currentClassSegment = classIdPathSegment.getOrNull(classIdPathIndex)
            for (subDeclaration in declarations) {
                when {
                    currentClassSegment == null && expectedDeclarationAcceptor(subDeclaration) -> {
                        result = subDeclaration
                        return true
                    }

                    subDeclaration is FirScript -> {
                        path += subDeclaration",val scriptParameters = subDeclaration.parameters
"/**
 * Returns the smaller of three values.
 * 
 * If there are multiple equal minimal values, returns the first of them.
 */
@SinceKotlin(""1.1"")
public actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {
    return minOf(a, minOf(b, c))
}

/**
 * Returns the smaller of three values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {
    return Math.min(a.toInt(), Math.min(b.toInt(), c.toInt())).toByte()
}

/**
 * Returns the smaller of three values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun minOf(a: Short, b: Short, c: Short): Short {
    return Math.min(a.toInt(), Math.min(b.toInt(), c.toInt())).toShort()
}

/**
 * Returns the smaller of three values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun minOf(a: Int, b: Int, c: Int): Int {
    return minOf(a, minOf(b, c))
}

/**
 * Returns the smaller of three values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun minOf(a: Long, b: Long, c: Long): Long {
    return minOf(a, minOf(b, c))
}

/**
 * Returns the smaller of three values.
 * 
 * If any value is `NaN`, returns `NaN`.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun minOf(a: Float, b: Float, c: Float): Float {
    return minOf(a, minOf(b, c))
}

/**
 * Returns the smaller of three values.
 * 
 * If any value is `NaN`, returns `NaN`.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun minOf(a: Double, b: Double, c: Double): Double {","return minOf(a, minOf(b, c))"
"*/

package org.jetbrains.kotlin.ir.descriptors

import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.builtins.StandardNames.KOTLIN_REFLECT_FQ_NAME
import org.jetbrains.kotlin.builtins.functions.FunctionClassDescriptor
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.incremental.components.NoLookupLocation
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.builders.declarations.UNDEFINED_PARAMETER_INDEX
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.symbols.IrClassSymbol
import org.jetbrains.kotlin.ir.symbols.IrPropertySymbol
import org.jetbrains.kotlin.ir.symbols.IrSimpleFunctionSymbol
import org.jetbrains.kotlin.ir.symbols.IrTypeParameterSymbol
import org.jetbrains.kotlin.ir.symbols.impl.IrValueParameterSymbolImpl
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.types.SimpleTypeNullability
import org.jetbrains.kotlin.ir.types.impl.IrSimpleTypeBuilder
import org.jetbrains.kotlin.ir.types.impl.IrStarProjectionImpl
import org.jetbrains.kotlin.ir.types.impl.buildSimpleType
import org.jetbrains.kotlin.ir.types.impl.makeTypeProjection
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.name.SpecialNames
import org.jetbrains.kotlin.psi2ir.descriptors.IrBuiltInsOverDescriptors
import org.jetbrains.kotlin.resolve.descriptorUtil.isEffectivelyExternal
import org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter
import org.jetbrains.kotlin.types.KotlinType
import org.jetbrains.kotlin.types.Variance
import org.jetbrains.kotlin.utils.filterIsInstanceAnd
import org.jetbrains.kotlin.utils.memoryOptimizedMap

@OptIn(ObsoleteDescriptorBasedAPI::class)
abstract class IrAbstractDescriptorBasedFunctionFactory {

    abstract fun functionClassDescriptor(arity: Int): FunctionClassDescriptor
    abstract fun kFunctionClassDescriptor(arity: Int): FunctionClassDescriptor
    abstract fun suspendFunctionClassDescriptor(arity: Int): FunctionClassDescriptor
    abstract fun kSuspendFunctionClassDescriptor(arity: Int): FunctionClassDescriptor

    abstract fun functionN(arity: Int, declarator: SymbolTable.((IrClassSymbol) -> IrClass) -> IrClass): IrClass
    abstract fun kFunctionN(arity: Int, declarator: SymbolTable.((IrClassSymbol) -> IrClass) -> IrClass): IrClass
    abstract fun suspendFunctionN(arity: Int, declarator: SymbolTable.((IrClassSymbol) -> IrClass) -> IrClass): IrClass
    abstract fun kSuspendFunctionN(arity: Int, declarator: SymbolTable.((IrClassSymbol) -> IrClass) -> IrClass): IrClass

    fun functionN(n: Int) = functionN(n) { callback ->
        val descriptor = functionClassDescriptor(n)
        descriptorExtension.declareClass(descriptor) { symbol ->
            callback(symbol)
        }
    }

    fun kFunctionN(n: Int): IrClass {
        return kFunctionN(n) { callback ->
            val descriptor = kFunctionClassDescriptor(n)
            descriptorExtension.declareClass(descriptor) { symbol ->
                callback(symbol)
            }
        }
    }

    fun suspendFunctionN(n: Int): IrClass = suspendFunctionN(n) { callback ->",val descriptor = suspendFunctionClassDescriptor(n)
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.compilerRunner

import org.jetbrains.annotations.Nls
import org.jetbrains.jps.ModuleChunk
import org.jetbrains.jps.incremental.CompileContext
import org.jetbrains.jps.incremental.messages.ProgressMessage
import org.jetbrains.kotlin.jps.KotlinJpsBundle

interface ProgressReporter {",fun progress(message: String)
"@kotlin.internal.InlineOnly
public inline fun kotlin.LongArray.asList(): kotlin.collections.List<kotlin.Long>

@kotlin.internal.InlineOnly
public inline fun kotlin.ShortArray.asList(): kotlin.collections.List<kotlin.Short>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UByteArray.asList(): kotlin.collections.List<kotlin.UByte>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UIntArray.asList(): kotlin.collections.List<kotlin.UInt>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.ULongArray.asList(): kotlin.collections.List<kotlin.ULong>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UShortArray.asList(): kotlin.collections.List<kotlin.UShort>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun kotlin.ULongArray.asLongArray(): kotlin.LongArray

public fun <T> kotlin.collections.List<T>.asReversed(): kotlin.collections.List<T>

@kotlin.jvm.JvmName(name = ""asReversedMutable"")
public fun <T> kotlin.collections.MutableList<T>.asReversed(): kotlin.collections.MutableList<T>

public fun <T> kotlin.Array<out T>.asSequence(): kotlin.sequences.Sequence<T>

public fun kotlin.BooleanArray.asSequence(): kotlin.sequences.Sequence<kotlin.Boolean>

public fun kotlin.ByteArray.asSequence(): kotlin.sequences.Sequence<kotlin.Byte>

public fun kotlin.CharArray.asSequence(): kotlin.sequences.Sequence<kotlin.Char>

public fun kotlin.DoubleArray.asSequence(): kotlin.sequences.Sequence<kotlin.Double>

public fun kotlin.FloatArray.asSequence(): kotlin.sequences.Sequence<kotlin.Float>

public fun kotlin.IntArray.asSequence(): kotlin.sequences.Sequence<kotlin.Int>

public fun kotlin.LongArray.asSequence(): kotlin.sequences.Sequence<kotlin.Long>

public fun kotlin.ShortArray.asSequence(): kotlin.sequences.Sequence<kotlin.Short>

public fun <T> kotlin.collections.Iterable<T>.asSequence(): kotlin.sequences.Sequence<T>

public fun <K, V> kotlin.collections.Map<out K, V>.asSequence(): kotlin.sequences.Sequence<kotlin.collections.Map.Entry<K, V>>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun kotlin.UShortArray.asShortArray(): kotlin.ShortArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun kotlin.ByteArray.asUByteArray(): kotlin.UByteArray

@kotlin.SinceKotlin(version = ""1.3"")",@kotlin.ExperimentalUnsignedTypes
"package org.jetbrains.kotlin.ir.backend.js.utils.serialization

import org.jetbrains.kotlin.ir.backend.js.transformers.irToJs.JsIrIcClassModel
import org.jetbrains.kotlin.ir.backend.js.transformers.irToJs.JsIrProgramFragment
import org.jetbrains.kotlin.ir.backend.js.transformers.irToJs.JsIrProgramFragments
import org.jetbrains.kotlin.js.backend.ast.*
import org.jetbrains.kotlin.js.backend.ast.metadata.*
import org.jetbrains.kotlin.utils.addToStdlib.safeAs
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.OutputStream
import java.util.*

fun JsIrProgramFragments.serializeTo(output: OutputStream) {
    JsIrAstSerializer().append(this).saveTo(output)
}

private class DataWriter {

    val data = ByteArrayOutputStream()
    private val output = DataOutputStream(data)

    fun saveTo(output: DataOutputStream) {
        output.let {
            data.writeTo(it)
        }
    }

    fun writeByte(byte: Int) {
        // Limit bytes to positive values to avoid conversion in deserializer
        if ((byte and 0x7F.inv()) != 0) error(""Byte out of bounds: $byte"")
        output.writeByte(byte)
    }

    fun writeByteArray(byteArray: ByteArray) {
        output.writeInt(byteArray.size)
        output.write(byteArray)
    }

    fun writeString(string: String) {
        writeByteArray(string.toByteArray(SerializationCharset))
    }

    fun writeBoolean(boolean: Boolean) {
        output.writeBoolean(boolean)
    }

    fun writeInt(int: Int) {
        output.writeInt(int)
    }

    fun writeDouble(double: Double) {
        output.writeDouble(double)
    }

    inline fun <T> writeCollection(collection: Collection<T>, writeItem: (T) -> Unit) {
        output.writeInt(collection.size)
        collection.forEach(writeItem)
    }

    inline fun <T> ifNotNull(t: T?, write: (T) -> Unit): T? {
        output.writeBoolean(t != null)
        if (t != null) {
            write(t)
        }",return t
"class B
            class Foo<X, Y>(val x: X, val y: Y)
        """""",
        classDefSrc = """"""
            class Test(val foo: Foo<A, B>)
        """""",
        stability = ""Runtime(B)"",
        externalTypes = setOf(""dependency.Foo<_,*>"")
    )

    @Test
    fun testExternalGenericDefinedTypesAreStable() = assertStability(
        externalSrc = """"""
            class A
            class Foo<T>(val x: T)
        """""",
        classDefSrc = """"""
            class Test(val foo: Foo<A>)
        """""",
        stability = ""Stable"",
        externalTypes = setOf(""dependency.Foo"", ""dependency.A"")
    )

    @Test
    fun testExternalDeepPackageNameIsStable() = assertStability(
        externalSrc = """"""
            class A
        """""",
        classDefSrc = """"""
            class Test(val foo: A)
        """""",
        stability = ""Stable"",
        externalTypes = setOf(""dependency.b.c.d.A""),
        packageName = ""dependency.b.c.d""
    )

    @Test
    fun testListOfCallWithPrimitiveTypeIsStable() = assertStability(
        """",
        """",
        ""listOf(1)"",
        ""Stable""
    )

    @Test
    fun testListOfCallWithLocalInferredStableTypeIsStable() = assertStability(
        """",
        ""class Foo"",
        ""listOf(Foo())"",
        ""Stable""
    )

    @Test
    fun testListOfCallWithExternalInferredStableTypeIsRuntimeStable() = assertStability(
        ""class Foo"",
        """",
        ""listOf(Foo())"",
        ""Runtime(Foo)""
    )

    @Test
    fun testMapOfCallWithPrimitiveTypesIsStable() = assertStability(
        """",
        """",
        ""mapOf(1 to 1)"",","""Stable,Stable"""
"buildOptions = defaultBuildOptions.copy(logLevel = LogLevel.DEBUG)
        ) {
            build(""assemble"") {
                //register build service for buildSrc.
                when {
                    // until 8.0, Gradle was embedding the Kotlin version that used a slightly different approach to detect build finish,
                    // so the service was unregistered after the finish of the buildSrc build
                    // and then registered again in the root build
                    gradleVersion < GradleVersion.version(TestVersions.Gradle.G_8_0) -> {
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsService: new instance"", // the  service for buildSrc
                            1
                        )
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsBeanService: new instance"", // the legacy service for compatibility
                            1
                        )
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsBeanService_v2: new instance"", // the current default version of the service
                            1
                        )
                    }
                    gradleVersion < GradleVersion.version(TestVersions.Gradle.G_8_3) -> {
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsService: new instance"", // the legacy service for compatibility
                            1
                        )
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsBeanService_v2: new instance"", // the current default version of the service
                            1
                        )
                    }
                    //for gradle 8.3 kotlin 1.9.0 is used, log message is changed
                    gradleVersion < GradleVersion.version(TestVersions.Gradle.G_8_5) -> {
                        assertOutputContainsExactTimes(
                            ""Register JMX service for backward compatibility"", // the legacy service for compatibility
                            1
                        )
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsService_v2: new instance"", // the current default version of the service
                            1
                        )
                    }
                    //for other versions KGP from buildSrc registered both services
                    else -> {
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsService: new instance"", // the legacy service for compatibility
                            1
                        )
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsService_v2: new instance"", // the current default version of the service
                            1
                        )

                    }
                }

                assertOutputDoesNotContain(""[org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatHandler] Could not execute"")
            }
        }
    }

    @DisplayName(""smoke test for fus-statistics-gradle-plugin"")
    @GradleTest
    fun smokeTestForFusStatisticsPlugin(gradleVersion: GradleVersion) {","val metricName = ""METRIC_NAME"""
"import org.jetbrains.kotlin.config.KotlinCompilerVersion
import org.jetbrains.kotlin.descriptors.SourceElement
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.ThreadSafeMutableState
import org.jetbrains.kotlin.fir.builder.toMutableOrEmpty
import org.jetbrains.kotlin.fir.declarations.FirDeclarationOrigin
import org.jetbrains.kotlin.fir.declarations.getDeprecationsProvider
import org.jetbrains.kotlin.fir.deserialization.*
import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.java.FirJavaFacade
import org.jetbrains.kotlin.fir.java.declarations.FirJavaClass
import org.jetbrains.kotlin.fir.languageVersionSettings
import org.jetbrains.kotlin.fir.resolve.transformers.setLazyPublishedVisibility
import org.jetbrains.kotlin.fir.scopes.FirKotlinScopeProvider
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.fir.types.ConeFlexibleType
import org.jetbrains.kotlin.fir.types.ConeRawType
import org.jetbrains.kotlin.fir.types.ConeSimpleKotlinType
import org.jetbrains.kotlin.load.kotlin.*
import org.jetbrains.kotlin.load.kotlin.header.KotlinClassHeader
import org.jetbrains.kotlin.metadata.ProtoBuf
import org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf
import org.jetbrains.kotlin.metadata.jvm.deserialization.JvmFlags
import org.jetbrains.kotlin.metadata.jvm.deserialization.JvmMetadataVersion
import org.jetbrains.kotlin.metadata.jvm.deserialization.JvmProtoBufUtil
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.StandardClassIds
import org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException
import org.jetbrains.kotlin.resolve.jvm.JvmClassName
import org.jetbrains.kotlin.serialization.deserialization.IncompatibleVersionErrorData
import org.jetbrains.kotlin.serialization.deserialization.builtins.BuiltInSerializerProtocol
import org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedContainerAbiStability
import org.jetbrains.kotlin.utils.toMetadataVersion
import java.nio.file.Path
import java.nio.file.Paths

// This symbol provider loads JVM classes, reading extra info from Kotlin `@Metadata` annotations
// if present. Use it for library and incremental compilation sessions. For source sessions use
// `JavaSymbolProvider`, as Kotlin classes should be parsed first.
@ThreadSafeMutableState
class JvmClassFileBasedSymbolProvider(
    session: FirSession,
    moduleDataProvider: ModuleDataProvider,
    kotlinScopeProvider: FirKotlinScopeProvider,
    private val packagePartProvider: PackagePartProvider,
    private val kotlinClassFinder: KotlinClassFinder,
    private val javaFacade: FirJavaFacade,
    defaultDeserializationOrigin: FirDeclarationOrigin = FirDeclarationOrigin.Library
) : AbstractFirDeserializedSymbolProvider(
    session, moduleDataProvider, kotlinScopeProvider, defaultDeserializationOrigin, BuiltInSerializerProtocol
) {
    private val annotationsLoader = AnnotationsLoader(session, kotlinClassFinder)
    private val ownMetadataVersion: JvmMetadataVersion = session.languageVersionSettings.languageVersion.toMetadataVersion()

    private val reportErrorsOnPreReleaseDependencies = with(session.languageVersionSettings) {
        !getFlag(AnalysisFlags.skipPrereleaseCheck) && !isPreRelease() && !KotlinCompilerVersion.isPreRelease()
    }

    override fun computePackagePartsInfos(packageFqName: FqName): List<PackagePartsCacheData> =
        packagePartProvider.findPackageParts(packageFqName.asString()).mapNotNull { partName ->
            computePackagePartInfo(packageFqName, partName)
        }

    private fun computePackagePartInfo(packageFqName: FqName, partName: String): PackagePartsCacheData? {",if (partName in KotlinBuiltins) return null
"// WITH_REFLECT
// TARGET_BACKEND: JVM
// FILE: Ann1.java
import java.lang.annotation.*;

@Target({ElementType.FIELD})",@Retention(RetentionPolicy.RUNTIME)
"// EXIT_CODE: !0
// OUTPUT_REGEX: Cannot run checkers when there are 1 alive runtimes at the shutdown.*
// MODULE: cinterop
// FILE: leakMemory.def
---
void test_RunInNewThread(void (*)());

// FILE: leakMemory.h
#ifdef __cplusplus
extern ""C"" {
#endif

void test_RunInNewThread(void (*)());

#ifdef __cplusplus
}
#endif

// FILE: leakMemory.cpp
#include ""leakMemory.h""

#include <atomic>
#include <thread>

extern ""C"" void test_RunInNewThread(void (*f)()) {
    std::atomic<bool> haveRun(false);
    std::thread t([f, &haveRun]() {
        f();
        haveRun = true;",while (true) {}
"}

    private fun generateOverridesInAClass(classDescriptor: ClassDescriptor, strategy: OverridingStrategy) {
        @Suppress(""UNCHECKED_CAST"")
        val membersFromSupertypesByName =
            classDescriptor.typeConstructor.supertypes.flatMapTo(linkedSetOf()) { type ->
                DescriptorUtils.getAllDescriptors(type.memberScope).filter {
                    it is PropertyDescriptor || it is SimpleFunctionDescriptor
                } as List<CallableMemberDescriptor>
            }.groupBy { it.name }

        for ((name, fromSupertypes) in membersFromSupertypesByName) {
            OverridingUtil.DEFAULT.generateOverridesInFunctionGroup(name, fromSupertypes, emptyList(), classDescriptor, strategy)
        }
    }

    private fun createSyntheticSubclass(): Pair<MutableClassDescriptor, List<TypeParameterDescriptor>> {
        val child = MutableClassDescriptor(
            descriptor.containingDeclaration,
            ClassKind.CLASS,
            /* isInner = */ false,
            /* isExternal */ false,
            Name.special(""<synthetic inheritor of ${descriptor.name}>""),
            descriptor.source,
            LockBasedStorageManager.NO_LOCKS
        )

        child.modality = Modality.FINAL
        child.visibility = DescriptorVisibilities.PUBLIC
        val typeParameters = descriptor.typeConstructor.parameters
        val newTypeParameters = ArrayList<TypeParameterDescriptor>(typeParameters.size)
        DescriptorSubstitutor.substituteTypeParameters(typeParameters, TypeSubstitution.EMPTY, child, newTypeParameters)
        child.setTypeParameterDescriptors(typeParameters)
        return Pair(child, newTypeParameters)
    }

    private fun FunctionDescriptor.findOverriddenFromDirectSuperClass(typeConstructor: TypeConstructor): FunctionDescriptor? =
        this.overriddenDescriptors.firstOrNull {
            (it.containingDeclaration as? ClassDescriptor)?.typeConstructor == typeConstructor
        }

    private fun newType(classDescriptor: ClassDescriptor, typeArguments: List<TypeProjection>): KotlinType {
        return KotlinTypeFactory.simpleNotNullType(TypeAttributes.Empty, classDescriptor, typeArguments)
    }

    private fun FunctionDescriptor.signature(): JvmMethodGenericSignature =
        typeMapper.mapSignatureWithGeneric(this, OwnerKind.IMPLEMENTATION)

    private fun generateMethodStub(v: ClassBuilder, signature: JvmMethodGenericSignature, synthetic: Boolean) {
        assert(descriptor.kind != ClassKind.INTERFACE) { ""No stubs should be generated for interface ${descriptor.fqNameUnsafe}"" }

        val access = ACC_PUBLIC or (if (synthetic) ACC_SYNTHETIC else 0)
        val asmMethod = signature.asmMethod
        val genericSignature = if (synthetic) null else signature.genericsSignature
        val mv = v.newMethod(CollectionStub, access, asmMethod.name, asmMethod.descriptor, genericSignature, null)
        mv.visitCode()
        AsmUtil.genThrow(
            InstructionAdapter(mv),
            ""java/lang/UnsupportedOperationException"",
            ""Operation is not supported for read-only collection""
        )
        FunctionCodegen.endVisit(mv, ""built-in stub for $signature"")
    }
}","private val READ_ONLY_ARE_EQUAL_TO_MUTABLE_TYPE_CHECKER = KotlinTypeCheckerImpl.withAxioms { x, y ->"
"return if (isAccessedBeforeAllClosureWriters(variableContainingDeclaration, writers, bindingContext, accessElement))
        DataFlowValue.Kind.STABLE_VARIABLE
    else
        DataFlowValue.Kind.CAPTURED_VARIABLE
}


fun hasNoWritersInClosures(
    variableContainingDeclaration: DeclarationDescriptor,
    writers: Set<AssignedVariablesSearcher.Writer>,
    bindingContext: BindingContext
): Boolean {
    return writers.none { (_, writerDeclaration) ->
        writerDeclaration != null &&
                variableContainingDeclaration != writerDeclaration.getDeclarationDescriptorIncludingConstructors(bindingContext)
    }
}

private fun isAccessedInsideClosureAfterAllWriters(
    writers: Set<AssignedVariablesSearcher.Writer>,
    accessElement: KtElement
): Boolean {
    val parent = accessElement.getElementParentDeclaration() ?: return false
    return writers.none { (assignment) -> !assignment.before(parent) }
}

private fun isAccessedBeforeAllClosureWriters(
    variableContainingDeclaration: DeclarationDescriptor,
    writers: Set<AssignedVariablesSearcher.Writer>,
    bindingContext: BindingContext,
    accessElement: KtElement
): Boolean {
    // All writers should be before access element, with the exception:
    // writer which is the same with declaration site does not count
    writers.mapNotNull { it.declaration }.forEach { writerDeclaration ->
        val writerDescriptor = writerDeclaration.getDeclarationDescriptorIncludingConstructors(bindingContext)
        // Access is after some writerDeclaration
        if (variableContainingDeclaration != writerDescriptor && !accessElement.before(writerDeclaration)) {
            return false
        }
    }
    // Access is before all writers
    return true
}

private fun DeclarationDescriptorWithVisibility.isInvisibleFromOtherModules(): Boolean {
    if (DescriptorVisibilities.INVISIBLE_FROM_OTHER_MODULES.contains(visibility)) return true

    val containingDeclaration = containingDeclaration
    return containingDeclaration is DeclarationDescriptorWithVisibility && containingDeclaration.isInvisibleFromOtherModules()
}

private fun PropertyDescriptor.hasDefaultGetter(): Boolean {
    val getter = getter
    return getter == null || getter.isDefault
}

private fun isAccessedInsideClosure(
    variableContainingDeclaration: DeclarationDescriptor,
    bindingContext: BindingContext,
    accessElement: KtElement
): Boolean {
    val parent = accessElement.getElementParentDeclaration()
    return if (parent != null) // Access is at the same declaration: not in closure, lower: in closure
        parent.getDeclarationDescriptorIncludingConstructors(bindingContext) != variableContainingDeclaration",else
"class Inv<X>
class In<in E>
class Out<out T>
class Final
open class Open

fun invOpen(x: Inv<Open>) {}
// method: TopLevelInvKt::invOpen
// generic signature: (LInv<LOpen;>;)V

fun invFinal(x: Inv<Final>) {}
// method: TopLevelInvKt::invFinal
// generic signature: (LInv<LFinal;>;)V

fun invOutOpen(x: Inv<Out<Open>>) {}
// method: TopLevelInvKt::invOutOpen
// generic signature: (LInv<LOut<LOpen;>;>;)V

fun invOutFinal(x: Inv<Out<Final>>) {}
// method: TopLevelInvKt::invOutFinal
// generic signature: (LInv<LOut<LFinal;>;>;)V",fun invInOutOpen(x: Inv<In<Out<Open>>>) {}
"import java.io.ObjectInputStream
import java.io.Serializable

class NativeDistributionCommonizerCache(
    private val outputDirectory: File,
    private val konanHome: File,
    private val logger: Logger,
    private val isCachingEnabled: Boolean
) : Serializable {
    fun isUpToDate(
        outputTargets: Set<SharedCommonizerTarget>
    ): Boolean = lock.withLock {
        todoTargets(outputTargets)
    }.isEmpty()

    /**
     * Calls [writeCacheAction] for uncached targets and marks them as cached if it succeeds
     */
    fun writeCacheForUncachedTargets(
        outputTargets: Set<SharedCommonizerTarget>,
        writeCacheAction: (todoTargets: Set<SharedCommonizerTarget>) -> Unit
    ) = lock.withLock {
        val todoOutputTargets = todoTargets(outputTargets)
        if (todoOutputTargets.isEmpty()) return@withLock

        writeCacheAction(todoOutputTargets)

        todoOutputTargets
            .map { outputTarget -> resolveCommonizedDirectory(outputDirectory, outputTarget) }
            .filter { commonizedDirectory -> commonizedDirectory.isDirectory }
            .forEach { commonizedDirectory -> commonizedDirectory.resolve("".success"").createNewFile() }
    }

    private fun todoTargets(
        outputTargets: Set<SharedCommonizerTarget>
    ): Set<SharedCommonizerTarget> {
        lock.checkLocked(outputDirectory)
        logInfo(""Calculating cache state for $outputTargets"")

        if (!isCachingEnabled) {
            logInfo(""Cache disabled"")
            return if (isMissingPlatformLibraries(outputTargets)) return emptySet()
            else outputTargets
        }

        val cachedOutputTargets = outputTargets
            .filter { outputTarget -> isCached(resolveCommonizedDirectory(outputDirectory, outputTarget)) }
            .onEach { outputTarget -> logInfo(""Cache hit: $outputTarget already commonized"") }
            .toSet()

        val todoOutputTargets = outputTargets - cachedOutputTargets

        if (todoOutputTargets.isEmpty() || isMissingPlatformLibraries(todoOutputTargets)) {
            logInfo(""All available targets are commonized already - Nothing to do"")
            if (todoOutputTargets.isNotEmpty()) {
                logInfo(""Platforms cannot be commonized, because of missing platform libraries: $todoOutputTargets"")
            }

            return emptySet()
        }

        return todoOutputTargets
    }

    private fun isMissingPlatformLibraries(",missingOutputTargets: Set<CommonizerTarget>
"// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE

interface ExpectedType

inline fun <reified M> parse(): M? = TODO()

fun test(s: String?, silent: Boolean) {
    val result: ExpectedType =
        if (s != null) {
            <!DEBUG_INFO_EXPRESSION_TYPE(""ExpectedType?"")!>parse()<!> ?: TODO()
        } else <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Nothing"")!>if (silent) {
            return
        } else {
            throw Exception()
        }<!>",<!DEBUG_INFO_SMARTCAST!>s<!>.length
"import kotlin.collections.*
import kotlin.text.isEmpty

const val result1 = <!EVALUATED: `OK`!>foo()<!>
const val result2 = <!EVALUATED: `OK`!>bar()<!>

const val result3 = <!EVALUATED: `fail 2; fail 3; fail 4; fail 5; fail 6; `!>checkForArrayList(1)<!>
const val result4 = <!EVALUATED: `fail 5; fail 6; `!>checkForArrayList(listOf<Int>())<!>
const val result5 = <!EVALUATED: `OK`!>checkForArrayList(arrayListOf<Int>())<!>

const val result6 = <!EVALUATED: `fail 1; fail 2; fail 3; fail 4; `!>checkForArray(1)<!>
const val result7 = <!EVALUATED: `fail 1; fail 2; fail 3; fail 4; `!>checkForArray(intArrayOf())<!>
const val result8 = <!EVALUATED: `fail 3; fail 4; `!>checkForArray(arrayOf<Int>())<!>

@CompileTimeCalculation
fun foo(): String {
    val a = arrayListOf<Int>()
    if (a !is Collection<Int>) return ""fail a 1""
    if (a !is Collection<Number>) return ""fail a 2""
    if (a !is Collection<*>) return ""fail a 3""

    val b: ArrayList<Int>? = null
    if (b is Collection<Int>) return ""fail b 1""
    if (b is Collection<Number>) return ""fail b 2""
    if (b is Collection<*>) return ""fail b 3""
    if (b is Collection<Any>) return ""fail b 4""

    if (b !is Collection<Int>?) return ""fail b 5""
    if (b !is Collection<Number>?) return ""fail b 6""
    if (b !is Collection<*>?) return ""fail b 7""
    if (b !is Collection<Any>?) return ""fail b 8""

    if (b is Collection<Int?>) return ""fail b 9""
    if (b is Collection<Number?>) return ""fail b 10""
    if (b is Collection<Any?>) return ""fail b 11""

    if (b !is Collection<Int?>?) return ""fail b 12""
    if (b !is Collection<Number?>?) return ""fail b 13""
    if (b !is Collection<Any?>?) return ""fail b 14""

    val c: ArrayList<*> = arrayListOf(1, 2)
    if (c !is Collection<*>) return ""fail c 1""
    if (c !is Collection<*>?) return ""fail c 2""
    if (c !is Collection<Any?>?) return ""fail c 3""

    val d: ArrayList<Any> = arrayListOf(1, 2)
    if (d !is Collection<*>) return ""fail d 1""
    if (d !is Collection<Any>) return ""fail d 2""
    if (d !is Collection<*>?) return ""fail d 3""
    if (d !is Collection<Any?>?) return ""fail d 4""

    val e: ArrayList<Any?> = arrayListOf(1, 2)
    if (e !is Collection<*>) return ""fail e 1""
    if (e !is Collection<*>?) return ""fail e 2""
    if (e !is Collection<Any?>?) return ""fail e 3""

    if (null is Any) return ""fail f 1""
    if (null !is Any?) return ""fail f 2""
    if (null is String) return ""fail f 3""
    if (null !is String?) return ""fail f 4""
    if (null is Nothing) return ""fail f 5""
    if (null !is Nothing?) return ""fail f 6""

    val g: Int? = 1
    if (g !is Int) return ""fail g 1""","if (g !is Int?) return ""fail g 2"""
")
        }
    ): IrValueParameter =
        valueParameterSlice.declareLocal(
            descriptor,
            { IrValueParameterSymbolImpl(descriptor) },
            valueParameterFactory
        )

    @OptIn(ObsoleteDescriptorBasedAPI::class)
    fun introduceValueParameter(irValueParameter: IrValueParameter) {
        valueParameterSlice.introduceLocal(irValueParameter.descriptor, irValueParameter.symbol)
    }

    override fun referenceValueParameter(declaration: ParameterDescriptor): IrValueParameterSymbol {
        return valueParameterSlice.referenced(declaration) {
            error(""Undefined parameter referenced: $declaration\n${valueParameterSlice.dump()}"")
        }
    }

    open fun referenceValue(value: ValueDescriptor): IrValueSymbol {
        return when (value) {
            is ParameterDescriptor -> valueParameterSlice.referenced(value) { error(""Undefined parameter referenced: $value"") }
            is VariableDescriptor -> variableSlice.referenced(value) { error(""Undefined variable referenced: $value"") }
            else -> error(""Unexpected value descriptor: $value"")
        }
    }


    // ------------------------------------ variable ------------------------------------

    fun declareVariable(
        startOffset: Int,
        endOffset: Int,
        origin: IrDeclarationOrigin,
        descriptor: VariableDescriptor,
        type: IrType,
    ): IrVariable =
        variableSlice.declareLocal(
            descriptor,
            { IrVariableSymbolImpl(descriptor) }
        ) {
            IrVariableImpl(
                startOffset, endOffset, origin, it, nameProvider.nameForDeclaration(descriptor), type,
                descriptor.isVar, descriptor.isConst, descriptor.isLateInit
            )
        }

    fun declareVariable(
        startOffset: Int,
        endOffset: Int,
        origin: IrDeclarationOrigin,
        descriptor: VariableDescriptor,
        type: IrType,
        irInitializerExpression: IrExpression?
    ): IrVariable =
        declareVariable(startOffset, endOffset, origin, descriptor, type).apply {
            initializer = irInitializerExpression
        }

    // ------------------------------------ local delegated property ------------------------------------

    fun declareLocalDelegatedProperty(
        startOffset: Int,
        endOffset: Int,","origin: IrDeclarationOrigin,"
"return contextReceiversGroup.map { contextReceiver ->
            collectMembers { getContributedVariablesAndIntercept(name, location, contextReceiver, extensionReceiver, scopeTower) }
        }.flatten()
    }

    override fun getObjects(
        name: Name,
        extensionReceiver: ReceiverValueWithSmartCastInfo?
    ): Collection<CandidateWithBoundDispatchReceiver> {
        return emptyList()
    }

    override fun getFunctions(
        name: Name,
        extensionReceiver: ReceiverValueWithSmartCastInfo?
    ): Collection<CandidateWithBoundDispatchReceiver> {
        val collectMembers = { contextReceiver: ReceiverValueWithSmartCastInfo ->
            collectMembers {
                getContributedFunctionsAndIntercept(
                    name,
                    location,
                    contextReceiver,
                    extensionReceiver,
                    scopeTower
                ) + it.getInnerConstructors(
                    name,
                    location
                ) + syntheticScopes.collectSyntheticMemberFunctions(listOfNotNull(it), name, location)
            }
        }
        return contextReceiversGroup.map(collectMembers).flatten()
    }

    override fun recordLookup(name: Name) {
        for (type in contextReceiversGroup.map { it.allOriginalTypes }.flatten()) {
            type.memberScope.recordLookup(name, location)
        }
    }
}

internal class QualifierScopeTowerLevel(scopeTower: ImplicitScopeTower, val qualifier: QualifierReceiver) :
    AbstractScopeTowerLevel(scopeTower) {
    override fun getVariables(name: Name, extensionReceiver: ReceiverValueWithSmartCastInfo?) = qualifier.staticScope
        .getContributedVariablesAndIntercept(
            name,
            location,
            qualifier.classValueReceiverWithSmartCastInfo,
            extensionReceiver,
            scopeTower
        ).map {
            createCandidateDescriptor(it, dispatchReceiver = null)
        }

    override fun getObjects(name: Name, extensionReceiver: ReceiverValueWithSmartCastInfo?) = qualifier.staticScope
        .getContributedObjectVariables(name, location).map {
            createCandidateDescriptor(it, dispatchReceiver = null)
        }

    override fun getFunctions(name: Name, extensionReceiver: ReceiverValueWithSmartCastInfo?) = qualifier.staticScope
        .getContributedFunctionsAndConstructors(
            name,
            location,
            qualifier.classValueReceiverWithSmartCastInfo,
            extensionReceiver,
            scopeTower",).map {
"}

fun builder(c: suspend Controller.() -> Unit) {
    val controller1 = Controller()
    val controller2 = Controller()

    c.startCoroutine(controller1, EmptyContinuation)
    c.startCoroutine(controller2, EmptyContinuation)

    runControllers(controller1, controller2)
}

// TODO: additional parameters are not supported yet
//fun builder2(coroutine c: Controller.(Long, String) -> Continuation<Unit>) {
//    val controller1 = Controller()
//    val controller2 = Controller()
//
//    c(controller1, 1234567890123456789L, ""Q"").resume(Unit)
//    c(controller2, 1234567890123456789L, ""Q"").resume(Unit)
//
//    runControllers(controller1, controller2)
//}

private fun runControllers(controller1: Controller, controller2: Controller) {
    while (controller1.hasNext()) {
        if (!controller2.hasNext()) throw RuntimeException(""fail 1"")

        if (controller1.lastSuspension === controller2.lastSuspension) throw RuntimeException(""equal references"")

        controller1.next()
        controller2.next()
    }

    if (controller2.hasNext()) throw RuntimeException(""fail 2"")

    if (controller1.result != ""OK"") throw RuntimeException(""fail 3"")
    if (controller2.result != ""OK"") throw RuntimeException(""fail 4"")
}

fun box(): String {
    // no suspension
    builder {
        result = ""OK""
    }

    // 1 suspension
    builder {
        if (suspendHere() != ""56"") return@builder
        result = ""OK""
    }

    // 2 suspensions
    builder {
        if (suspendHere() != ""56"") return@builder
        suspendHere()
        result = ""OK""
    }

    // with capture

    var x = ""O""
    var y = ""K""

    // no suspension
    builder {",result = x + y
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package kotlin.coroutines

import kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED

@SinceKotlin(""1.3"")
internal abstract class CoroutineImpl(private val resultContinuation: Continuation<Any?>?) : Continuation<Any?> {
    protected var state = 0
    protected var exceptionState = 0
    protected var result: Any? = null
    protected var exception: Throwable? = null
    protected var finallyPath: Array<Int>? = null

    private val _context: CoroutineContext? = resultContinuation?.context

    public override val context: CoroutineContext get() = _context!!

    private var intercepted_: Continuation<Any?>? = null

    public fun intercepted(): Continuation<Any?> =
        intercepted_
                ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)
                    .also { intercepted_ = it }

    override fun resumeWith(result: Result<Any?>) {
        var current = this
        var currentResult: Any? = result.getOrNull()
        var currentException: Throwable? = result.exceptionOrNull()

        // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume
        while (true) {
            with(current) {
                // Set result and exception fields in the current continuation
                if (currentException == null) {",this.result = currentResult
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.checkers.generator

import org.jetbrains.kotlin.fir.builder.SYNTAX_DIAGNOSTIC_LIST
import org.jetbrains.kotlin.fir.checkers.generator.diagnostics.DIAGNOSTICS_LIST
import org.jetbrains.kotlin.fir.checkers.generator.diagnostics.JS_DIAGNOSTICS_LIST
import org.jetbrains.kotlin.fir.checkers.generator.diagnostics.JVM_DIAGNOSTICS_LIST",import org.jetbrains.kotlin.fir.checkers.generator.diagnostics.NATIVE_DIAGNOSTICS_LIST
"// WITH_STDLIB
const val int = 456
const val uint = 456U

const val equal1 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, DEPRECATED_IDENTITY_EQUALS!>1 === 2<!>
const val equal2 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, DEPRECATED_IDENTITY_EQUALS!>int === 2<!>
const val equal3 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, DEPRECATED_IDENTITY_EQUALS!>1 === int<!>
const val equal4 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, EQUALITY_NOT_APPLICABLE, FORBIDDEN_IDENTITY_EQUALS!>1u === int<!>

const val equal5 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, FORBIDDEN_IDENTITY_EQUALS!>1u === 2u<!>
const val equal6 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, FORBIDDEN_IDENTITY_EQUALS!>uint === 2u<!>
const val equal7 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, EQUALITY_NOT_APPLICABLE, FORBIDDEN_IDENTITY_EQUALS!>1 === uint<!>
const val equal8 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, FORBIDDEN_IDENTITY_EQUALS!>1u === uint<!>

const val equal9 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, EQUALITY_NOT_APPLICABLE, FORBIDDEN_IDENTITY_EQUALS!>uint === int<!>
const val equal10 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, EQUALITY_NOT_APPLICABLE, FORBIDDEN_IDENTITY_EQUALS!>int === uint<!>","const val notEqual1 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, DEPRECATED_IDENTITY_EQUALS!>1 !== 2<!>"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.generators.tree.config

import org.jetbrains.kotlin.generators.tree.*
import org.jetbrains.kotlin.types.Variance
import kotlin.properties.PropertyDelegateProvider
import kotlin.properties.ReadOnlyProperty
import kotlin.reflect.KProperty

abstract class AbstractElementConfigurator<Element, Field, Category>
        where Element : AbstractElement<Element, Field, *>,
              Field : AbstractField<Field> {",inner class ElementDelegate(
"// NO_CHECK_LAMBDA_INLINING
// FILE: 1.kt

package test

inline fun <T> doSmth(a: T) : String {
    return { a.toString() }.let { it() }
}

inline fun <T> doSmth2(a: T) : String {
    return { { a.toString() }.let { it() } }.let { it() }
}

// FILE: 2.kt

import test.*

fun test1(s: Long): String {",return doSmth(s)
"if (check_is_I18(x0)) t = t + 19
    if (check_is_I19(x0)) t = t + 20
    if (check_is_I20(x0)) t = t + 21
    if (check_is_I21(x0)) t = t + 22
    if (check_is_I22(x0)) t = t + 23
    if (check_is_I23(x0)) t = t + 24
    if (check_is_I24(x0)) t = t + 25
    if (check_is_I25(x0)) t = t + 26
    if (check_is_I26(x0)) t = t + 27
    if (check_is_I27(x0)) t = t + 28
    if (check_is_I28(x0)) t = t + 29
    if (check_is_I29(x0)) t = t + 30
    if (check_is_I30(x0)) t = t + 31
    if (check_is_I31(x0)) t = t + 32
    if (check_is_I32(x0)) t = t + 33
    if (check_is_I33(x0)) t = t + 34
    if (check_is_I34(x0)) t = t + 35
    if (check_is_I35(x0)) t = t + 36
    if (check_is_I36(x0)) t = t + 37
    if (check_is_I37(x0)) t = t + 38
    if (check_is_I38(x0)) t = t + 39
    if (check_is_I39(x0)) t = t + 40
    if (check_is_I40(x0)) t = t + 41
    if (check_is_I41(x0)) t = t + 42
    if (check_is_I42(x0)) t = t + 43
    if (check_is_I43(x0)) t = t + 44
    if (check_is_I44(x0)) t = t + 45
    if (check_is_I45(x0)) t = t + 46
    if (check_is_I46(x0)) t = t + 47
    if (check_is_I47(x0)) t = t + 48
    if (check_is_I48(x0)) t = t + 49
    if (check_is_I49(x0)) t = t + 50
    if (check_is_I50(x0)) t = t + 51
    if (check_is_I51(x0)) t = t + 52
    if (check_is_I52(x0)) t = t + 53
    if (check_is_I53(x0)) t = t + 54
    if (check_is_I54(x0)) t = t + 55
    if (check_is_I55(x0)) t = t + 56
    if (check_is_I56(x0)) t = t + 57
    if (check_is_I57(x0)) t = t + 58
    if (check_is_I58(x0)) t = t + 59
    if (check_is_I59(x0)) t = t + 60
    if (check_is_I60(x0)) t = t + 61
    if (check_is_I61(x0)) t = t + 62
    if (check_is_I62(x0)) t = t + 63
    if (check_is_I63(x0)) t = t + 64
    if (check_is_I64(x0)) t = t + 65
    if (check_is_I65(x0)) t = t + 66
    if (check_is_I66(x0)) t = t + 67
    if (check_is_I67(x0)) t = t + 68
    if (check_is_I68(x0)) t = t + 69
    if (check_is_I69(x0)) t = t + 70
    if (check_is_I70(x0)) t = t + 71
    if (check_is_I71(x0)) t = t + 72
    if (check_is_I72(x0)) t = t + 73
    if (check_is_I73(x0)) t = t + 74
    if (check_is_I74(x0)) t = t + 75
    if (check_is_I75(x0)) t = t + 76
    if (check_is_I76(x0)) t = t + 77
    if (check_is_I77(x0)) t = t + 78
    if (check_is_I78(x0)) t = t + 79
    if (check_is_I79(x0)) t = t + 80
    if (check_is_I80(x0)) t = t + 81
    if (check_is_I81(x0)) t = t + 82
    if (check_is_I82(x0)) t = t + 83",if (check_is_I83(x0)) t = t + 84
"// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY
// NI_EXPECTED_FILE

class C {
    typealias Self = C
    class Nested {
        class N2
        typealias Root = C
    }
    companion object X {
        val ok = ""OK""
        class InCompanion
    }
}",val c = C.Self.<!UNRESOLVED_REFERENCE!>Self<!>()
"public fun foo(p: String?, y: String?): Int {
    do {
        // After this !!, y. should be smartcasted in loop as well as outside
        y!!.length
        if (p == null) break
        y.length
    } while (true)",return y.length
"// !LANGUAGE: +UnrestrictedBuilderInference
// WITH_STDLIB
// SKIP_TXT
// !DIAGNOSTICS: -CAST_NEVER_SUCCEEDS -UNCHECKED_CAST -UNUSED_PARAMETER -UNUSED_VARIABLE -OPT_IN_USAGE_ERROR -UNUSED_EXPRESSION

import kotlin.experimental.ExperimentalTypeInference

fun <K> FlowCollector<K>.bar(): K = null as K
fun <K> FlowCollector<K>.foo(): K = null as K

fun <K> K.bar3(): K = null as K
fun <K> K.foo3(): K = null as K

fun bar2(): Int = 1
fun foo2(): Float = 1f

val bar4: Int
    get() = 1

var foo4: Float
    get() = 1f
    set(value) {}",val <K> FlowCollector<K>.bar5: K get() = null as K
"}

fun BaseGradleIT.CompiledProject.assertNoDiagnostic(diagnosticFactory: ToolingDiagnosticFactory, withSubstring: String? = null) {
    output.assertNoDiagnostic(diagnosticFactory, withSubstring)
}

fun BuildResult.assertHasDiagnostic(diagnosticFactory: ToolingDiagnosticFactory, withSubstring: String? = null) {
    output.assertHasDiagnostic(diagnosticFactory, withSubstring)
}

fun BuildResult.assertNoDiagnostic(diagnosticFactory: ToolingDiagnosticFactory, withSubstring: String? = null) {
    output.assertNoDiagnostic(diagnosticFactory, withSubstring)
}

fun String.assertHasDiagnostic(diagnosticFactory: ToolingDiagnosticFactory, withSubstring: String? = null) {
    val diagnosticsMessages = extractRenderedDiagnostics(diagnosticFactory, this)
    assertTrue(diagnosticsMessages.isNotEmpty(), ""Diagnostic with id=${diagnosticFactory.id} not found. Full text output:\n\n"" + this)
    if (withSubstring != null) {
        assertTrue(
            diagnosticsMessages.any { withSubstring in it },
            ""Diagnostic ${diagnosticFactory.id} doesn't have expected substring $withSubstring. "" +
                    ""Actual diagnostic messages with that ID:\n"" +
                    diagnosticsMessages.joinToString(separator = ""\n"") +
                    ""\nFull text output:\n\n"" +
                    this
        )
    }
}

fun String.assertNoDiagnostic(diagnosticFactory: ToolingDiagnosticFactory, withSubstring: String? = null) {
    val diagnosticMessages = extractRenderedDiagnostics(diagnosticFactory, this)
    if (withSubstring != null) {
        val matchedWithSubstring = diagnosticMessages.find { withSubstring in it }
        assertNull(
            matchedWithSubstring,
            ""Diagnostic with id=${diagnosticFactory.id} and substring '${withSubstring}' was expected to be absent, but was reported. "" +
                    ""Actual diagnostic message: \n"" +
                    matchedWithSubstring +
                    ""\nFull text output:\n\n"" +
                    this
        )
    } else {
        assertTrue(
            diagnosticMessages.isEmpty(),
            ""Expected no diagnostics with id=${diagnosticFactory.id}, but some were reported:\n"" +
                    diagnosticMessages.joinToString(separator = ""\n"") +
                    ""\nFull text output:\n\n"" +
                    this
        )
    }
}

/**
 * NB: Needs parsable formatting of diagnostics, see [org.jetbrains.kotlin.gradle.plugin.PropertiesProvider.internalDiagnosticsUseParsableFormat]
 * Because this mode is enabled by the 'kotlin.internal'-property, actual output will always contain
 * [org.jetbrains.kotlin.gradle.plugin.diagnostics.KotlinToolingDiagnostics.InternalKotlinGradlePluginPropertiesUsed].
 * For the sake of clarity, this diagnostic is filtered by default.
 */
fun BuildResult.extractProjectsAndTheirDiagnostics(): String = buildString {
    var diagnosticStarted = false
    var stacktraceStarted = false
    val currentDiagnostic = mutableListOf<String>()

    fun startDiagnostic(line: String, lineIndex: Int) {
        require(!diagnosticStarted) {",printBuildOutput()
"catch (e: Exception) {
        return
    }
    a.hashCode() // a is never null here
}
class A: Exception()
class B: Exception()
fun test2() {
    var a: Int?
    try {
        a = 4
    }
    catch (e: A) {
        return
    }
    catch (e: B) {
        return
    }
    a.hashCode() // a is never null here
}
fun test3() {
    var a: Int? = null
    try {
        a = 5
    }
    catch (e: A) {
        // do nothing
    }
    catch (e: B) {
        return
    }
    a<!UNSAFE_CALL!>.<!>hashCode() // a is nullable here
}
fun test4() {
    var a: Int? = null
    try {
        // do nothing
    }
    catch (e: A) {
        return
    }
    catch (e: B) {
        return
    }
    a<!UNSAFE_CALL!>.<!>hashCode() // a is nullable here
}
fun test5() {
    var a: Int?// = null
    try {
        a = 3
    }
    catch (e: Exception) {
        return
    }
    finally {
        a = 5
    }
    a.hashCode() // a is never null here
}
fun test6() {
    var a: Int?// = null
    try {
        a = 3
    }
    catch (e: Exception) {",return
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.lower

import org.jetbrains.kotlin.backend.common.BodyLoweringPass
import org.jetbrains.kotlin.backend.common.compilationException
import org.jetbrains.kotlin.ir.backend.js.JsIrBackendContext
import org.jetbrains.kotlin.ir.declarations.IrDeclaration
import org.jetbrains.kotlin.ir.expressions.IrBody
import org.jetbrains.kotlin.ir.expressions.IrConst
import org.jetbrains.kotlin.ir.expressions.IrConstKind
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.expressions.impl.IrConstImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrConstructorCallImpl
import org.jetbrains.kotlin.ir.symbols.IrClassSymbol
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.types.classifierOrNull
import org.jetbrains.kotlin.ir.types.defaultType
import org.jetbrains.kotlin.ir.util.constructors
import org.jetbrains.kotlin.ir.util.isUnsigned
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
import org.jetbrains.kotlin.ir.visitors.transformChildrenVoid

class ConstTransformer(private val context: JsIrBackendContext) : IrElementTransformerVoid() {
    private fun <C> lowerConst(
        expression: IrConst<*>,
        irClass: IrClassSymbol,
        carrierFactory: (Int, Int, IrType, C) -> IrExpression,
        vararg args: C
    ): IrExpression {
        val constructor = irClass.constructors.single { it.owner.isPrimary }
        val argType = constructor.owner.valueParameters.first().type

        return IrConstructorCallImpl.fromSymbolOwner(
                expression.startOffset,
                expression.endOffset,
                irClass.defaultType,
                constructor",).apply {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""unused"", ""MemberVisibilityCanBePrivate"")

package org.jetbrains.kotlin.sir.tree.generator

import org.jetbrains.kotlin.generators.tree.StandardTypes.boolean
import org.jetbrains.kotlin.generators.tree.StandardTypes.string
import org.jetbrains.kotlin.generators.tree.config.element
import org.jetbrains.kotlin.generators.tree.config.sealedElement
import org.jetbrains.kotlin.sir.tree.generator.config.AbstractSwiftIrTreeBuilder
import org.jetbrains.kotlin.sir.tree.generator.model.Element

object SwiftIrTree : AbstractSwiftIrTreeBuilder() {

    override val rootElement by sealedElement(name = ""Element"") {
        kDoc = ""The root interface of the Swift IR tree.""
    }

    val declarationParent by sealedElement()

    val declarationContainer by sealedElement {
        parent(declarationParent)
        customParentInVisitor = rootElement","+listField(""declarations"", declaration)"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.decompiler.stub.files

import com.intellij.psi.stubs.StubElement
import org.jetbrains.kotlin.contracts.description.*
import org.jetbrains.kotlin.psi.KtProjectionKind
import org.jetbrains.kotlin.psi.stubs.impl.*

fun extractAdditionalStubInfo(stub: StubElement<*>): String {
    val builder = StringBuilder()
    extractAdditionInfo(stub, builder, 0)
    return builder.toString()
}

private fun extractAdditionInfo(stub: StubElement<*>, builder: StringBuilder, level: Int) {
    builder.append(stub.toString())
    when (stub) {
        is KotlinUserTypeStubImpl -> {
            val upperBound = stub.upperBound
            if (upperBound != null) {
                builder.append(""    ft: "")
                appendFlexibleTypeInfo(builder, upperBound)
            }
        }
        is KotlinFunctionStubImpl -> {
            val contract = stub.contract
            if (contract != null) {
                for (element in contract) {
                    builder.append(""\n"" + ""  "".repeat(level)).append(""effect:"")
                    element.accept(KotlinContractRenderer(builder), null)
                }
            }
        }
        is KotlinPropertyStubImpl -> {
            val initializer = stub.constantInitializer
            if (initializer != null) {
                builder.append(""\n"").append(""  "".repeat(level)).append(""initializer: ${initializer.value}"")
            }
        }
        is KotlinAnnotationEntryStubImpl -> {
            val arguments = stub.valueArguments
            if (arguments != null) {
                builder
                    .append(""\n"")
                    .append(""  "".repeat(level))
                    .append(""valueArguments: "")
                    .append(arguments.entries.joinToString("", "", ""("", "")"") { ""${it.key.asString()} = ${it.value}"" })
            }
        }
        is KotlinParameterStubImpl -> {
            stub.functionTypeParameterName?.let { builder.append(""   paramNameByAnnotation: "").append(it) }
        }
    }
    for (child in stub.childrenStubs) {
        builder.append(""\n"").append(""  "".repeat(level))
        extractAdditionInfo(child, builder, level + 1)
    }
}","private fun appendFlexibleTypeInfo(builder: StringBuilder, typeBean: KotlinTypeBean) {"
"isNullable = expandedType.isNullable,
        attributes = expandedType.attributes
    )
}

// ---------------------------------------------- function type subtyping ----------------------------------------------

// expectedfunctionType is kotlin.FunctionN or kotlin.reflect.KFunctionN
fun ConeKotlinType.findSubtypeOfBasicFunctionType(session: FirSession, expectedFunctionType: ConeClassLikeType): ConeKotlinType? {
    require(expectedFunctionType.isFunctionOrKFunctionType(session, errorOnNotFunctionType = true))
    return findSubtypeOfBasicFunctionTypeImpl(session, expectedFunctionType)
}

// Function, KFunction
private fun ConeKotlinType.isFunctionOrKFunctionType(session: FirSession, errorOnNotFunctionType: Boolean): Boolean {
    return isFunctionTypeWithPredicate(session, errorOnNotFunctionType) { it.isBasicFunctionOrKFunction }
}

private fun ConeKotlinType.findSubtypeOfBasicFunctionTypeImpl(
    session: FirSession,
    expectedFunctionType: ConeClassLikeType
): ConeKotlinType? {
    return when (this) {
        is ConeClassLikeType -> {
            when {
                // Expect the argument type is a simple function type.
                isNotBasicFunctionType(session) -> null
                isSubtypeOfFunctionType(session, expectedFunctionType) -> this
                else -> null
            }
        }

        is ConeIntersectionType -> {
            runUnless(intersectedTypes.any { it.isNotBasicFunctionType(session) }) {
                intersectedTypes.find { it.findSubtypeOfBasicFunctionTypeImpl(session, expectedFunctionType) != null }
            }
        }

        is ConeTypeParameterType -> {
            val bounds = lookupTag.typeParameterSymbol.resolvedBounds.map { it.coneType }
            runUnless(bounds.any { it.isNotBasicFunctionType(session) }) {
                bounds.find { it.findSubtypeOfBasicFunctionTypeImpl(session, expectedFunctionType) != null }
            }
        }
        else -> null
    }
}

private fun ConeKotlinType.isSubtypeOfFunctionType(session: FirSession, expectedFunctionType: ConeClassLikeType): Boolean {
    return AbstractTypeChecker.isSubtypeOf(session.typeContext, this, expectedFunctionType.replaceArgumentsWithStarProjections())
}

// ---------------------------------------------- function type scope utils ----------------------------------------------

fun ConeClassLikeType.findBaseInvokeSymbol(session: FirSession, scopeSession: ScopeSession): FirNamedFunctionSymbol? {
    require(this.isSomeFunctionType(session))
    val functionN = (lookupTag.toSymbol(session)?.fir as? FirClass) ?: return null
    var baseInvokeSymbol: FirNamedFunctionSymbol? = null
    functionN.unsubstitutedScope(
        session,
        scopeSession,
        withForcedTypeCalculator = false,
        memberRequiredPhase = null,
    ).processFunctionsByName(OperatorNameConventions.INVOKE) { functionSymbol ->
        baseInvokeSymbol = functionSymbol",return@processFunctionsByName
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin.diagnostics

import org.gradle.api.DefaultTask
import org.gradle.api.InvalidUserCodeException
import org.gradle.api.Project
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.*
import org.gradle.language.base.plugins.LifecycleBasePlugin
import org.gradle.work.DisableCachingByDefault
import org.jetbrains.kotlin.gradle.tasks.KotlinCompileTool
import org.jetbrains.kotlin.gradle.tasks.withType
import org.jetbrains.kotlin.gradle.utils.onlyIfCompat

@DisableCachingByDefault(
    because = ""This task renders reported diagnostics; caching this task will hide diagnostics and obscure issues in the build""
)
internal abstract class CheckKotlinGradlePluginConfigurationErrors : DefaultTask() {
    @get:Input
    abstract val errorDiagnostics: ListProperty<ToolingDiagnostic>

    @get:Internal
    abstract val renderingOptions: Property<ToolingDiagnosticRenderingOptions>

    @TaskAction
    fun checkNoErrors() {
        if (errorDiagnostics.get().isNotEmpty()) {
            renderReportedDiagnostics(errorDiagnostics.get(), logger, renderingOptions.get())
            throw InvalidUserCodeException(""Kotlin Gradle Plugin reported errors. Check the log for details"")
        }
    }

    companion object {
        internal const val TASK_NAME = ""checkKotlinGradlePluginConfigurationErrors""
    }
}

private const val DESCRIPTION =
    ""Checks that Kotlin Gradle Plugin hasn't reported project configuration errors, failing otherwise. "" +
            ""This task always runs before compileKotlin* or similar tasks.""

internal fun Project.locateOrRegisterCheckKotlinGradlePluginErrorsTask(): TaskProvider<CheckKotlinGradlePluginConfigurationErrors> {
    val taskProvider = tasks.register(","CheckKotlinGradlePluginConfigurationErrors.TASK_NAME,"
"useHandlers(
                ::ClassicDiagnosticsHandler
            )
        }

        configureFirHandlersStep {
            useHandlers(
                ::FirDiagnosticsHandler
            )
        }

        configureCommonHandlersForBoxTest()

        configureJvmArtifactsHandlersStep {
            useHandlers(
                ::BytecodeListingHandler,
                ::BytecodeTextHandler.bind(true)
            )
        }

        useAfterAnalysisCheckers(::BlackBoxCodegenSuppressor)
        if (targetBackend.isIR) {
            useAfterAnalysisCheckers(::BlackBoxInlinerCodegenSuppressor)
        }

        defaultDirectives {
            +REPORT_ONLY_EXPLICITLY_DEFINED_DEBUG_INFO
        }

        forTestsNotMatching(""compiler/testData/codegen/box/diagnostics/functions/tailRecursion/*"") {
            defaultDirectives {
                DIAGNOSTICS with ""-warnings""
            }
        }

        configureModernJavaWhenNeeded()

        forTestsMatching(""compiler/testData/codegen/box/coroutines/varSpilling/debugMode/*"") {
            defaultDirectives {
                +ENABLE_DEBUG_MODE
            }
        }

        forTestsMatching(""compiler/testData/codegen/box/javaInterop/foreignAnnotationsTests/tests/*"") {
            defaultDirectives {
                ForeignAnnotationsDirectives.ANNOTATIONS_PATH with JavaForeignAnnotationType.Annotations
            }
            useConfigurators(::JvmForeignAnnotationsConfigurator)
        }

        forTestsMatching(""compiler/testData/codegen/box/involvesIrInterpreter/*"") {
            configureJvmArtifactsHandlersStep {
                useHandlers(::JvmIrInterpreterDumpHandler)
            }
        }

        enableMetaInfoHandler()
    }
}

fun TestConfigurationBuilder.configureModernJavaWhenNeeded() {
    forTestsMatching(""compiler/testData/codegen/boxModernJdk/testsWithJava11/*"") {
        configureModernJavaTest(TestJdkKind.FULL_JDK_11, JvmTarget.JVM_11)
    }","forTestsMatching(""compiler/testData/codegen/boxModernJdk/testsWithJava17/*"") {"
"if (logger is GradleKotlinLogger) {
        process.inputStream!!.bufferedReader().forEachLine {
            logger.lifecycle(it)
        }
    } else {
        process.inputStream!!.bufferedReader().forEachLine {
            println(it)
        }
    }

    readErrThread.join()

    val exitCode = process.waitFor()
    logger.logFinish(KotlinCompilerExecutionStrategy.OUT_OF_PROCESS)
    return exitCodeFromProcessExitCode(logger, exitCode)
}

private fun writeArgumentsToFile(directory: File, argsArray: Array<String>): File {
    val prefix = LocalDateTime.now().format(DateTimeFormatter.BASIC_ISO_DATE) + ""_""
    val suffix = "".compiler.options""
    val compilerOptions = if (directory.exists())
        Files.createTempFile(directory.toPath(), prefix, suffix).toFile()
    else
        Files.createTempFile(prefix, suffix).toFile()
    compilerOptions.writeText(
        argsArray.joinToString("" "") {
            ""\""${it.escapeJavaStyleString()}\""""
        }
    )
    return compilerOptions
}

// Ported method from Groovy:
// https://github.com/apache/groovy/blob/73c0f12ab35427bc3e7fd76929b482df61e1b80d/subprojects/groovy-json/src/main/java/groovy/json/StringEscapeUtils.java#L175
// Note: using '/f' char produces a compilation error, so removed it
internal fun String.escapeJavaStyleString(
    escapeSingleQuote: Boolean = false,
    escapeForwardSlash: Boolean = false,
): String {
    return buildString {
        this@escapeJavaStyleString.forEach { ch ->
            when {
                ch.toInt() > 0xfff -> append(""\\u${ch.hex()}"")
                ch.toInt() > 0xff -> append(""\\u0${ch.hex()}"")
                ch.toInt() >= 0x7f -> append(""\\u00${ch.hex()}"")
                ch < 32.toChar() -> when (ch) {
                    '\b' -> append('\\').append('b')
                    '\n' -> append('\\').append('n')
                    '\t' -> append('\\').append('t')
                    '\r' -> append('\\').append('r')
                    else -> if (ch > 0xf.toChar()) {
                        append(""\\u00${ch.hex()}"")
                    } else {
                        append(""\\u000${ch.hex()}"")
                    }
                }
                else -> when (ch) {
                    '\'' -> {
                        if (escapeSingleQuote) append('\\')
                        append('\'')
                    }
                    '""' -> append('\\').append('""')
                    '\\' -> append('\\').append('\\')
                    '/' -> {",if (escapeForwardSlash) append('\\')
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.native.checkers

import org.jetbrains.kotlin.KtNodeTypes.REFERENCE_EXPRESSION
import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind",import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
"import org.jetbrains.kotlin.asJava.AbstractCompilerLightClassTest
import org.jetbrains.kotlin.cfg.AbstractControlFlowTest
import org.jetbrains.kotlin.cfg.AbstractDataFlowTest
import org.jetbrains.kotlin.cfg.AbstractPseudoValueTest
import org.jetbrains.kotlin.cli.AbstractCliTest
import org.jetbrains.kotlin.codegen.*
import org.jetbrains.kotlin.codegen.defaultConstructor.AbstractDefaultArgumentsReflectionTest
import org.jetbrains.kotlin.codegen.defaultConstructor.fir.AbstractFirLightTreeDefaultArgumentsReflectionTest
import org.jetbrains.kotlin.codegen.defaultConstructor.fir.AbstractFirPsiDefaultArgumentsReflectionTest
import org.jetbrains.kotlin.codegen.defaultConstructor.ir.AbstractIrDefaultArgumentsReflectionTest
import org.jetbrains.kotlin.codegen.fir.*
import org.jetbrains.kotlin.codegen.flags.AbstractWriteFlagsTest
import org.jetbrains.kotlin.codegen.ir.*
import org.jetbrains.kotlin.codegen.ir.AbstractIrWriteSignatureTest
import org.jetbrains.kotlin.fir.builder.AbstractRawFirBuilderLazyBodiesByAstTest
import org.jetbrains.kotlin.fir.builder.AbstractRawFirBuilderLazyBodiesByStubTest
import org.jetbrains.kotlin.fir.builder.AbstractRawFirBuilderSourceElementMappingTestCase
import org.jetbrains.kotlin.fir.builder.AbstractRawFirBuilderTestCase
import org.jetbrains.kotlin.fir.java.AbstractFirOldFrontendLightClassesTest
import org.jetbrains.kotlin.fir.java.AbstractFirTypeEnhancementTest
import org.jetbrains.kotlin.fir.java.AbstractOwnFirTypeEnhancementTest
import org.jetbrains.kotlin.fir.lightTree.AbstractLightTree2FirConverterTestCase
import org.jetbrains.kotlin.generators.impl.generateTestGroupSuite
import org.jetbrains.kotlin.generators.util.TestGeneratorUtil
import org.jetbrains.kotlin.generators.util.TestGeneratorUtil.KT_OR_KTS_WITHOUT_DOTS_IN_NAME
import org.jetbrains.kotlin.integration.AbstractAntTaskTest
import org.jetbrains.kotlin.jvm.compiler.*
import org.jetbrains.kotlin.jvm.compiler.fir.AbstractFirLightTreeCompileJavaAgainstKotlinTest
import org.jetbrains.kotlin.jvm.compiler.fir.AbstractFirPsiCompileJavaAgainstKotlinTest
import org.jetbrains.kotlin.jvm.compiler.ir.*
import org.jetbrains.kotlin.jvm.compiler.javac.AbstractLoadJavaUsingJavacTest
import org.jetbrains.kotlin.klib.AbstractKlibIrTextTestCase
import org.jetbrains.kotlin.klib.AbstractKlibJsIrTextTestCase
import org.jetbrains.kotlin.lexer.kdoc.AbstractKDocLexerTest
import org.jetbrains.kotlin.lexer.kotlin.AbstractKotlinLexerTest
import org.jetbrains.kotlin.modules.xml.AbstractModuleXmlParserTest
import org.jetbrains.kotlin.multiplatform.AbstractMultiPlatformIntegrationTest
import org.jetbrains.kotlin.parsing.AbstractParsingTest
import org.jetbrains.kotlin.repl.AbstractReplInterpreterTest
import org.jetbrains.kotlin.resolve.AbstractResolveTest
import org.jetbrains.kotlin.resolve.calls.AbstractResolvedCallsTest
import org.jetbrains.kotlin.resolve.calls.AbstractResolvedConstructorDelegationCallsTests
import org.jetbrains.kotlin.test.TargetBackend
import org.jetbrains.kotlin.test.utils.CUSTOM_TEST_DATA_EXTENSION_PATTERN
import org.jetbrains.kotlin.types.AbstractTypeBindingTest

fun generateJUnit3CompilerTests(args: Array<String>, mainClassName: String?) {
    val excludedCustomTestdataPattern = CUSTOM_TEST_DATA_EXTENSION_PATTERN

    generateTestGroupSuite(args, mainClassName) {
        testGroup(""compiler/tests-gen"", ""compiler/testData"") {
            testClass<AbstractMultiPlatformIntegrationTest> {
                model(""multiplatform"", extension = null, recursive = true, excludeParentDirs = true)
            }

            testClass<AbstractResolveTest> {
                model(""resolve"", extension = ""resolve"")
            }

            testClass<AbstractResolvedCallsTest> {
                model(""resolvedCalls"", excludeDirs = listOf(""enhancedSignatures""))
            }

            testClass<AbstractResolvedConstructorDelegationCallsTests> {","model(""resolveConstructorDelegationCalls"")"
"package org.jetbrains.kotlin.incremental

import org.jetbrains.kotlin.incremental.DifferenceCalculatorForClass.Companion.getNonPrivateMembers
import org.jetbrains.kotlin.metadata.ProtoBuf.Visibility.PRIVATE
import org.jetbrains.kotlin.metadata.deserialization.Flags
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.resolve.sam.SAM_LOOKUP_NAME

//TODO(valtman) Should be in gradle daemon.
class AbiSnapshotDiffService() {

    companion object {
        //Store list of changed lookups
        private val diffCache: MutableMap<Pair<AbiSnapshot, AbiSnapshot>, DirtyData> = mutableMapOf()

        //TODO(valtman) move out from Kotlin daemon
        fun compareJarsInternal(
            oldSnapshot: AbiSnapshot, newSnapshot: AbiSnapshot,
            caches: IncrementalCacheCommon
        ) = diffCache.computeIfAbsent(Pair(oldSnapshot, newSnapshot)) { (snapshot, actual) -> doCompute(snapshot, actual, caches, emptyList()) }

        fun inScope(fqName: FqName, scopes: Collection<String>) = scopes.any { scope -> fqName.toString().startsWith(scope) }

        fun doCompute(snapshot: AbiSnapshot, actual: AbiSnapshot, caches: IncrementalCacheCommon, scopes: Collection<String>): DirtyData {

            val dirtyFqNames = mutableListOf<FqName>()
            val dirtyLookupSymbols = mutableListOf<LookupSymbol>()

            for ((fqName, protoData) in snapshot.protos) {
                if (!inScope(fqName, scopes)) continue
                val newProtoData = actual.protos[fqName]
                if (newProtoData == null) {
                    val (fqNames, symbols) = addProtoInfo(protoData, fqName)
                    dirtyFqNames.addAll(fqNames)
                    dirtyLookupSymbols.addAll(symbols)
                } else {
                    if (protoData is ClassProtoData && newProtoData is ClassProtoData) {
                        ProtoCompareGenerated(
                            protoData.nameResolver, newProtoData.nameResolver,
                            protoData.proto.typeTable, newProtoData.proto.typeTable
                        )
                        val diff = DifferenceCalculatorForClass(protoData, newProtoData).difference()

                        if (diff.isClassAffected) {
                            //TODO(valtman) get cache to mark dirty all subtypes if subclass affected
//                            val fqNames = if (!diff.areSubclassesAffected) listOf(fqName) else withSubtypes(fqName, caches)
                            dirtyFqNames.add(fqName)
                            assert(!fqName.isRoot) { ""$fqName is root"" }

                            val scope = fqName.parent().asString()
                            val name = fqName.shortName().identifier
                            dirtyLookupSymbols.add(LookupSymbol(name, scope))
                        }
                        for (member in diff.changedMembersNames) {
                            //TODO(valtman) mark dirty symbols for subclasses
                            val subtypeFqNames = withSubtypes(fqName, listOf(caches))
                            dirtyFqNames.addAll(subtypeFqNames)

                            for (subtypeFqName in subtypeFqNames) {
                                dirtyLookupSymbols.add(LookupSymbol(member, subtypeFqName.asString()))
                                dirtyLookupSymbols.add(LookupSymbol(SAM_LOOKUP_NAME.asString(), subtypeFqName.asString()))
                            }
                        }",} else if (protoData is PackagePartProtoData && newProtoData is PackagePartProtoData) {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""FunctionName"")

package org.jetbrains.kotlin.gradle.unitTests

import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinMetadataLibrariesIndexFile
import org.junit.Rule
import org.junit.rules.TemporaryFolder
import java.io.File
import java.io.FileNotFoundException
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertFailsWith

class KotlinMetadataLibrariesIndexFileTest {",@get:Rule
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer.utils

import com.intellij.util.SmartFMap
import org.jetbrains.kotlin.utils.addToStdlib.firstIsInstance
import java.util.*
import java.util.Collections.singletonList
import java.util.Collections.singletonMap

internal inline fun <K : Any, V, R> Map<K, V>.compactMapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> =
    when (size) {
        0 -> emptyMap()
        1 -> with(entries.iterator().next()) { singletonMap(key, transform(this)) }
        2, 3 -> entries.fold(SmartFMap.emptyMap()) { acc, entry -> acc.plus(entry.key, transform(entry)) }
        else -> mapValuesTo(CommonizerMap(size), transform)
    }

internal inline fun <T, R> Collection<T>.compactMap(transform: (T) -> R): List<R> =
    when (size) {
        0 -> emptyList()
        1 -> singletonList(transform(if (this is List) this[0] else iterator().next()))
        else -> mapTo(ArrayList(size), transform)
    }

internal inline fun <T, R> Array<T>.compactMap(transform: (T) -> R): List<R> =
    when (size) {
        0 -> emptyList()
        1 -> singletonList(transform(this[0]))
        else -> mapTo(ArrayList(size), transform)
    }

internal inline fun <T, R : Any> Array<T>.compactMapNotNull(transform: (T) -> R): List<R> {
    return mapNotNullTo(ArrayList<R>(size), transform).also { it.trimToSize() }
}

internal inline fun <T, reified R : Any> Collection<T>.compactMapNotNull(transform: (T) -> R?): List<R> =
    if (isEmpty()) emptyList() else mapNotNullTo(ArrayList(size), transform).compact()

internal inline fun <T, R> Collection<T>.compactMapIndexed(transform: (index: Int, T) -> R): List<R> =
    when (size) {
        0 -> emptyList()
        1 -> singletonList(transform(0, if (this is List) this[0] else iterator().next()))
        else -> mapIndexedTo(ArrayList(size), transform)
    }

internal inline fun <reified T> List<T>.compact(): List<T> =
    when (size) {
        0 -> emptyList()
        1 -> singletonList(this[0])
        else -> when (this) {",is java.util.ArrayList -> {
"expectSuccess(0) { singleVarargArgument() }
    expectSuccess(1) { singleVarargArgument(1) }
    expectSuccess(3) { singleVarargArgument(1, 2) }
    expectSuccess(1) { singleVarargArgument(*intArrayOf(1)) }
    expectSuccess(3) { singleVarargArgument(*intArrayOf(1, 2)) }
    expectSuccess(-6) { singleVarargArgumentWithDefaultValue() }
    expectSuccess(1) { singleVarargArgumentWithDefaultValue(1) }
    expectSuccess(3) { singleVarargArgumentWithDefaultValue(1, 2) }
    expectSuccess(1) { singleVarargArgumentWithDefaultValue(*intArrayOf(1)) }
    expectSuccess(3) { singleVarargArgumentWithDefaultValue(*intArrayOf(1, 2)) }
    expectSuccess(110) { varargArgumentAndOtherArguments(100, last = 10) }
    expectSuccess(111) { varargArgumentAndOtherArguments(100, 1, last = 10) }
    expectSuccess(113) { varargArgumentAndOtherArguments(100, 1, 2, last = 10) }
    expectSuccess(111) { varargArgumentAndOtherArguments(100, *intArrayOf(1), last = 10) }
    expectSuccess(113) { varargArgumentAndOtherArguments(100, *intArrayOf(1, 2), last = 10) }
    expectSuccess(-110) { varargArgumentAndOtherArgumentsWithDefaultValues() }
    expectSuccess(90) { varargArgumentAndOtherArgumentsWithDefaultValues(100) }
    expectSuccess(110) { varargArgumentAndOtherArgumentsWithDefaultValues(100, last = 10) }
    expectSuccess(91) { varargArgumentAndOtherArgumentsWithDefaultValues(100, 1) }
    expectSuccess(93) { varargArgumentAndOtherArgumentsWithDefaultValues(100, 1, 2) }
    expectSuccess(113) { varargArgumentAndOtherArgumentsWithDefaultValues(100, 1, 2, last = 10) }
    expectSuccess(-109) { @Suppress(""REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_FUNCTION"") varargArgumentAndOtherArgumentsWithDefaultValues(elements = *intArrayOf(1)) }
    expectSuccess(-107) { @Suppress(""REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_FUNCTION"") varargArgumentAndOtherArgumentsWithDefaultValues(elements = *intArrayOf(1, 2)) }
    expectSuccess(104) { varargArgumentWithDefaultValueAndOtherArguments(100, last = 10) }
    expectSuccess(111) { varargArgumentWithDefaultValueAndOtherArguments(100, 1, last = 10) }
    expectSuccess(113) { varargArgumentWithDefaultValueAndOtherArguments(100, 1, 2, last = 10) }
    expectSuccess(111) { varargArgumentWithDefaultValueAndOtherArguments(100, *intArrayOf(1), last = 10) }
    expectSuccess(113) { varargArgumentWithDefaultValueAndOtherArguments(100, *intArrayOf(1, 2), last = 10) }
    expectSuccess(-116) { varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues() }
    expectSuccess(84) { varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(100) }
    expectSuccess(104) { varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(100, last = 10) }
    expectSuccess(91) { varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(100, 1) }
    expectSuccess(93) { varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(100, 1, 2) }
    expectSuccess(113) { varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(100, 1, 2, last = 10) }
    expectSuccess(-109) { @Suppress(""REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_FUNCTION"") varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(elements = *intArrayOf(1)) }
    expectSuccess(-107) { @Suppress(""REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_FUNCTION"") varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(elements = *intArrayOf(1, 2)) }

    expectSuccess(-1) { suspendToNonSuspendFunction1(1) }
    expectSuccess(-2) { suspendToNonSuspendFunction2(2) }
    expectSuccess(-3) { suspendToNonSuspendFunction3(3) }
    expectFailure(linkage(""Function 'nonSuspendToSuspendFunction' can not be called: Suspend function can be called only from a coroutine or another suspend function"")) { nonSuspendToSuspendFunction1(4) }
    expectSuccess(-5) { nonSuspendToSuspendFunction2(5) }
    expectFailure(linkage(""Function 'nonSuspendToSuspendFunction' can not be called: Suspend function can be called only from a coroutine or another suspend function"")) { nonSuspendToSuspendFunction3(6) }
    expectSuccess(-7) { nonSuspendToSuspendFunction4(7) }

    expectFailure(linkage(""Abstract function 'suspendToNonSuspendFunction' is not implemented in non-abstract class 'InterfaceImpl'"")) { suspendToNonSuspendFunctionInInterface(i, 1) }
    expectFailure(linkage(""Function 'nonSuspendToSuspendFunction' can not be called: Suspend function can be called only from a coroutine or another suspend function"")) { nonSuspendToSuspendFunctionInInterface(i, 2) }
    expectSuccess(""InterfaceImpl.suspendToNonSuspendFunction(3)"") { suspendToNonSuspendFunctionInInterfaceImpl(ii, 3) }
    expectSuccess(""InterfaceImpl.nonSuspendToSuspendFunction(4)"") { nonSuspendToSuspendFunctionInInterfaceImpl(ii, 4) }

    expectFailure(linkage(""Abstract function 'suspendToNonSuspendFunction' is not implemented in non-abstract class 'AbstractClassImpl'"")) { suspendToNonSuspendFunctionInAbstractClass(ac, 5) }
    expectFailure(linkage(""Function 'nonSuspendToSuspendFunction' can not be called: Suspend function can be called only from a coroutine or another suspend function"")) { nonSuspendToSuspendFunctionInAbstractClass(ac, 6) }
    expectSuccess(""AbstractClassImpl.suspendToNonSuspendFunction(7)"") { suspendToNonSuspendFunctionInAbstractClassImpl(aci, 7) }
    expectSuccess(""AbstractClassImpl.nonSuspendToSuspendFunction(8)"") { nonSuspendToSuspendFunctionInAbstractClassImpl(aci, 8) }

    expectSuccess(""OpenClassV2.suspendToNonSuspendFunction(9)"") { suspendToNonSuspendFunctionInOpenClass(oc, 9) } // Function of the base class is called instead of overridden function in inherited class.
    expectFailure(linkage(""Function 'nonSuspendToSuspendFunction' can not be called: Suspend function can be called only from a coroutine or another suspend function"")) { nonSuspendToSuspendFunctionInOpenClass(oc, 10) }
    expectSuccess(""OpenClassImpl.suspendToNonSuspendFunction(11)"") { suspendToNonSuspendFunctionInOpenClassImpl(oci, 11) }
    expectSuccess(""OpenClassImpl.nonSuspendToSuspendFunction(12)"") { nonSuspendToSuspendFunctionInOpenClassImpl(oci, 12) }
    expectSuccess(""OpenClassV2.suspendToNonSuspendFunctionWithDelegation(13) called from OpenClassImpl.suspendToNonSuspendFunctionWithDelegation(13)"") { suspendToNonSuspendFunctionWithDelegation(oci, 13) }
    expectFailure(linkage(""Function 'nonSuspendToSuspendFunctionWithDelegation' can not be called: Suspend function can be called only from a coroutine or another suspend function"")) { nonSuspendToSuspendFunctionWithDelegation(oci, 14) }

    expectSuccess(""OpenClassV2.openNonInlineToInlineFunction(1)"") { openNonInlineToInlineFunctionInOpenClass(oc, 1) }
    expectSuccess(""OpenClassV2.openNonInlineToInlineFunctionWithDelegation(2)"") { openNonInlineToInlineFunctionWithDelegationInOpenClass(oc, 2) }
    expectSuccess(""OpenClassV2.newInlineFunction1(3)"") { newInlineFunction1InOpenClass(oc, 3) }","expectSuccess(""OpenClassV2.newInlineFunction2(4)"") { newInlineFunction2InOpenClass(oc, 4) }"
"fun useUnit(fn: () -> Unit) {
    fn.invoke()
}

var cInit = false

class C {
    init {
        cInit = true
    }
}

var cWithDefaultInit = false

class CWithDefault(x: Int = 1) {
    init {
        cWithDefaultInit = true
    }
}

var cWithVarargInit = false",class CWithVararg(vararg x: Int) {
"class A<T>

class B<T1, T2>

class C {","fun foo<caret>() = object : B<String, A<Unknown>> {"
") {
            with(KotlinTypeMapper) {
                val parameters = parameterSymbols.map { ConeTypeParameterLookupTag(it) }
                typeContext.writeGenericArguments(sw, arguments, parameters, mode) { type, sw, mode ->
                    mapType(type as ConeKotlinType, mode, sw)
                }
            }
        }

        private fun writeInnerParts(
            innerTypesAsList: List<PossiblyInnerConeType>,
            sw: JvmSignatureWriter,
            mode: TypeMappingMode,
            index: Int
        ) {
            for (innerPart in innerTypesAsList.subList(index, innerTypesAsList.size)) {
                sw.writeInnerClass(getJvmShortName(innerPart.classifier?.classId ?: NON_EXISTENT_ID))
                writeGenericArguments(sw, innerPart, mode)
            }
        }
    }

    private class PossiblyInnerConeType(
        val classifier: FirRegularClassSymbol?,
        val arguments: List<ConeTypeProjection>,
        private val outerType: PossiblyInnerConeType?
    ) {
        fun segments(): List<PossiblyInnerConeType> = outerType?.segments().orEmpty() + this
    }

    internal fun getJvmShortName(classId: ClassId): String {
        val result = runUnless(classId.isLocal) {
            classId.asSingleFqName().toUnsafe().let { JavaToKotlinClassMap.mapKotlinToJava(it)?.shortClassName?.asString() }
        }
        return result ?: safeShortClassName(classId)
    }

    private fun safeShortClassName(classId: ClassId): String {
        return SpecialNames.safeIdentifier(classId.shortClassName).identifier
    }
}

val FirSession.jvmTypeMapper: FirJvmTypeMapper by FirSession.sessionComponentAccessor()

class ConeTypeSystemCommonBackendContextForTypeMapping(
    val context: ConeTypeContext,
    val unresolvedQualifierRemapper: (String) -> String?
) : TypeSystemCommonBackendContext by context, TypeSystemCommonBackendContextForTypeMapping {
    private val session = context.session
    private val symbolProvider = session.symbolProvider

    override fun TypeConstructorMarker.isTypeParameter(): Boolean {
        return this is ConeTypeParameterLookupTag
    }

    override fun TypeConstructorMarker.asTypeParameter(): TypeParameterMarker {
        require(isTypeParameter())
        return this as ConeTypeParameterLookupTag
    }

    override fun TypeConstructorMarker.defaultType(): ConeSimpleKotlinType {
        require(this is ConeClassifierLookupTag)
        return when (this) {
            is ConeTypeParameterLookupTag -> ConeTypeParameterTypeImpl(this, isNullable = false)
            is ConeClassLikeLookupTag -> {",val symbol = toSymbol(session) as? FirRegularClassSymbol
"package foo.bar

/*p:<root>(JavaClass)*/import JavaClass
/*p:foo(KotlinClass)*/import foo.KotlinClass

/*p:foo.bar*/fun test() {
    val j = /*p:<root>*/JavaClass()
    val k = /*p:foo*/KotlinClass()

    /*p:<root>(JavaClass)*/j./*p:JavaClass*/getFoo()
    /*p:<root>(JavaClass)*/j./*p:JavaClass p:JavaClass(getSETFoo) p:JavaClass(getSetFoo) p:foo.bar p:java.lang p:kotlin p:kotlin.annotation p:kotlin.collections p:kotlin.comparisons p:kotlin.io p:kotlin.jvm p:kotlin.ranges p:kotlin.sequences p:kotlin.text*/setFoo(2)
    /*p:<root>(JavaClass)*/j./*p:JavaClass p:JavaClass(getFOO) p:JavaClass(getFoo) p:JavaClass(setFoo)*/foo = 2
    /*p:<root>(JavaClass)*/j./*p:JavaClass p:JavaClass(getFOO) p:JavaClass(getFoo) p:JavaClass(setFoo)*/foo
    /*p:<root>(JavaClass)*/j./*p:JavaClass p:JavaClass(getBAR) p:JavaClass(getBar) p:JavaClass(setBar)*/bar
    /*p:<root>(JavaClass)*/j./*p:JavaClass p:JavaClass(getBAR) p:JavaClass(getBar) p:JavaClass(setBar)*/bar = """"",/*p:<root>(JavaClass)*/j./*p:JavaClass p:JavaClass(getBAZBaz) p:JavaClass(getBazBaz) p:foo.bar p:java.lang p:kotlin p:kotlin.annotation p:kotlin.collections p:kotlin.comparisons p:kotlin.io p:kotlin.jvm p:kotlin.ranges p:kotlin.sequences p:kotlin.text*/bazBaz
"// !LANGUAGE: +IntrinsicConstEvaluation
// DONT_TARGET_EXACT_BACKEND: JVM
// DONT_TARGET_EXACT_BACKEND: JS

fun <T> T.id() = this","var result = ""OK"""
"// TODO generate better name for set parameter `<set-?>`?
        declaration.getter?.printAccessor(""get"", declaration)
        declaration.setter?.printAccessor(""set"", declaration)

        p.popIndent()
        p.printlnWithNoIndent()
    }

    private fun IrSimpleFunction.printAccessor(s: String, property: IrDeclaration) {
        val isDefaultAccessor = origin != IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR
        printSimpleFunction(
            property,
            keyword = """",
            name = s,
            printTypeParametersAndExtensionReceiver = false,
            printSignatureAndBody = isDefaultAccessor,
            printExtraTrailingNewLine = false,
        )
    }

    override fun visitField(declaration: IrField, data: IrDeclaration?) = wrap(declaration, data) {
        declaration.printlnAnnotations()
        p.printIndent()

        declaration.run {
            printModifiersWithNoIndent(
                this,
                Modifiers(
                    visibility = visibility,
                    isExternal = isExternal,
                ),
            )
        }

        if (declaration.isStatic || declaration.isFinal) {
            // it's not valid kotlin unless it's commented
            p.printWithNoIndent(CUSTOM_MODIFIER_START)
            p(declaration.isStatic, ""static"")
            p(declaration.isFinal, ""final"")
            p.printWithNoIndent(""field"")
            p.printWithNoIndent(CUSTOM_MODIFIER_END)
            p.printWithNoIndent("" "")
        }

        p.printWithNoIndent(if (declaration.isFinal) ""val "" else ""var "")
        p.printWithNoIndent(declaration.name.asString() + "": "")
        declaration.type.printTypeWithNoIndent()

        declaration.initializer?.let {
            if (options.bodyPrintingStrategy == BodyPrintingStrategy.PRINT_BODIES) {
                p.printWithNoIndent("" = "")
            }
            it.accept(this, declaration)
        }

        // TODO correspondingPropertySymbol

        p.printlnWithNoIndent()
    }

    override fun visitVariable(declaration: IrVariable, data: IrDeclaration?) = wrap(declaration, data) {
        declaration.printlnAnnotations()
        p.printIndent()

        p(declaration.isLateinit, ""lateinit"")","p(declaration.isConst, ""const"")"
"// SKIP_INLINE_CHECK_IN: inlineFun$default
// FILE: 1.kt
package test

class A(val value: String) {
    fun ok() = value
}

inline fun inlineFun(a: A, lambda: () -> String = a::ok): String {
    return lambda()
}

// FILE: 2.kt

import test.*",fun box(): String {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""FunctionName"", ""DuplicatedCode"")

package org.jetbrains.kotlin.gradle.unitTests

import org.gradle.api.internal.project.ProjectInternal
import org.gradle.testfixtures.ProjectBuilder
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeCompilation
import org.jetbrains.kotlin.gradle.targets.native.internal.cInteropCommonizationEnabled
import org.jetbrains.kotlin.gradle.targets.native.internal.copyCommonizeCInteropForIdeTask
import org.jetbrains.kotlin.gradle.util.*
import kotlin.test.*

class CommonizerTaskTests {

    private val rootProject = ProjectBuilder.builder().build() as ProjectInternal
    private val subproject = ProjectBuilder.builder().withName(""subproject"").withParent(rootProject).build() as ProjectInternal

    companion object {
        const val JVM_ECOSYSTEM_PLUGIN_ID = ""jvm-ecosystem""
    }

    init {
        subproject.applyMultiplatformPlugin().apply {
            linuxX64()
            linuxArm64()

            targets.flatMap { it.compilations }
                .filterIsInstance<KotlinNativeCompilation>()
                .forEach { compilation -> compilation.cinterops.create(""dummy"") }
        }

        rootProject.enableCInteropCommonization()
        subproject.enableCInteropCommonization()

        rootProject.evaluate()
        subproject.evaluate()
    }

    @Test
    fun `test runCommonizer task`() {
        subproject.tasks.getByName(""runCommonizer"")
            .assertDependsOn(subproject.tasks.getByName(""commonize""))

        /*
        Since commonizing the native distribution is done on the root project,
        we can also expect that the umbrella tasks are present there as well!
         */
        rootProject.tasks.getByName(""runCommonizer"")
            .assertDependsOn(rootProject.tasks.getByName(""commonize""))
    }

    @Test
    fun `test commonizeNativeDistributionTask`() {
        val commonizeNativeDistributionTaskName = ""commonizeNativeDistribution""
        subproject.assertContainsNoTaskWithName(commonizeNativeDistributionTaskName)

        /* Native Distribution Commonization is only done on the root project */",val rootProjectCommonizeNativeDistributionTask = rootProject.assertContainsTaskWithName(commonizeNativeDistributionTaskName)
"// FILE: main.kt
package test

import dependency.JavaInterface
import dependency.JavaInterface.Nested

class Foo : JavaInterface {
    <expr>val prop: JavaInterface.Nested = JavaInterface.Nested()</expr>
}

// FILE: dependency/JavaInterface.java",package dependency;
"*
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.resolve.jvm.platform

import org.jetbrains.kotlin.load.java.lazy.types.RawTypeImpl
import org.jetbrains.kotlin.psi.KtExpression
import org.jetbrains.kotlin.resolve.calls.checkers.AdditionalTypeChecker
import org.jetbrains.kotlin.resolve.calls.context.ResolutionContext
import org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm
import org.jetbrains.kotlin.types.*
import org.jetbrains.kotlin.types.error.ErrorUtils
import org.jetbrains.kotlin.types.checker.KotlinTypeChecker
import org.jetbrains.kotlin.types.checker.TypeCheckingProcedure

object JavaGenericVarianceViolationTypeChecker : AdditionalTypeChecker {
    // Prohibits covariant type argument conversions `List<String> -> (MutableList<Any>..List<Any>)` when expected type's lower bound is invariant.
    // It's needed to prevent accident unsafe covariant conversions of mutable collections.
    //
    // Example:
    // class JavaClass { static void fillWithDefaultObjects(List<Object> list); // add Object's to list }
    //
    // val x: MutableList<String>
    // JavaClass.fillWithDefaultObjects(x) // using `x` after this call may lead to CCE
    override fun checkType(
            expression: KtExpression,
            expressionType: KotlinType,
            expressionTypeWithSmartCast: KotlinType,
            c: ResolutionContext<*>
    ) {
        val expectedType = c.expectedType
        if (TypeUtils.noExpectedType(expectedType) || ErrorUtils.containsErrorType(expectedType) || ErrorUtils.containsUninferredTypeVariable(expectedType)) return

        // optimization: if no arguments or flexibility, everything is OK
        if (expectedType.arguments.isEmpty() || !expectedType.isFlexible()) return

        val lowerBound = expectedType.asFlexibleType().lowerBound
        val upperBound = expectedType.asFlexibleType().upperBound

        // Use site variance projection is always the same for flexible types
        if (lowerBound.constructor == upperBound.constructor) return
        // Anything is acceptable for raw types
        if (expectedType.unwrap() is RawTypeImpl) return

        val correspondingSubType = TypeCheckingProcedure.findCorrespondingSupertype(expressionTypeWithSmartCast, lowerBound) ?: return

        assert(lowerBound.arguments.size == upperBound.arguments.size) {
            ""Different arguments count in flexible bounds: "" +
            ""($lowerBound(${lowerBound.arguments.size})..$upperBound(${upperBound.arguments.size})""
        }

        assert(lowerBound.arguments.size == correspondingSubType.arguments.size) {
            ""Different arguments count in corresponding subtype and supertype: "" +
            ""($lowerBound(${lowerBound.arguments.size})..$correspondingSubType(${correspondingSubType.arguments.size})""
        }


        val lowerParameters = lowerBound.constructor.parameters",val upperParameters = upperBound.constructor.parameters
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.lazy

import com.intellij.openapi.project.Project
import com.intellij.psi.search.GlobalSearchScope
import org.jetbrains.kotlin.TestsCompiletimeError
import org.jetbrains.kotlin.analyzer.AnalysisResult
import org.jetbrains.kotlin.cli.jvm.compiler.CliBindingTrace
import org.jetbrains.kotlin.cli.jvm.compiler.KotlinCoreEnvironment
import org.jetbrains.kotlin.cli.jvm.compiler.NoScopeRecordCliBindingTrace
import org.jetbrains.kotlin.cli.jvm.compiler.TopDownAnalyzerFacadeForJVM
import org.jetbrains.kotlin.config.CompilerConfiguration
import org.jetbrains.kotlin.container.ComponentProvider
import org.jetbrains.kotlin.library.KotlinLibrary
import org.jetbrains.kotlin.load.kotlin.PackagePartProvider
import org.jetbrains.kotlin.psi.KtFile",import org.jetbrains.kotlin.resolve.AnalyzingUtils
"visitScript(declaration)

    open fun visitSimpleFunction(declaration: IrSimpleFunction): IrStatement =
        visitFunction(declaration)

    final override fun visitSimpleFunction(declaration: IrSimpleFunction, data: Nothing?): IrStatement =
        visitSimpleFunction(declaration)

    open fun visitTypeAlias(declaration: IrTypeAlias): IrStatement =
        visitDeclaration(declaration)

    final override fun visitTypeAlias(declaration: IrTypeAlias, data: Nothing?): IrStatement =
        visitTypeAlias(declaration)

    open fun visitVariable(declaration: IrVariable): IrStatement =
        visitDeclaration(declaration)

    final override fun visitVariable(declaration: IrVariable, data: Nothing?): IrStatement =
        visitVariable(declaration)

    open fun visitPackageFragment(declaration: IrPackageFragment): IrPackageFragment {
        declaration.transformChildren(this, null)
        return declaration
    }

    final override fun visitPackageFragment(declaration: IrPackageFragment, data: Nothing?): IrElement =
        visitPackageFragment(declaration)

    open fun visitExternalPackageFragment(declaration: IrExternalPackageFragment): IrExternalPackageFragment =
        visitPackageFragment(declaration) as IrExternalPackageFragment

    final override fun visitExternalPackageFragment(declaration: IrExternalPackageFragment, data: Nothing?): IrExternalPackageFragment =
        visitExternalPackageFragment(declaration)

    open fun visitFile(declaration: IrFile): IrFile =
        visitPackageFragment(declaration) as IrFile

    final override fun visitFile(declaration: IrFile, data: Nothing?): IrFile =
        visitFile(declaration)

    open fun visitExpression(expression: IrExpression): IrExpression {
        expression.transformChildren(this, null)
        return expression
    }

    final override fun visitExpression(expression: IrExpression, data: Nothing?): IrExpression =
        visitExpression(expression)

    open fun visitBody(body: IrBody): IrBody {
        body.transformChildren(this, null)
        return body
    }

    final override fun visitBody(body: IrBody, data: Nothing?): IrBody =
        visitBody(body)

    open fun visitExpressionBody(body: IrExpressionBody): IrBody =
        visitBody(body)

    final override fun visitExpressionBody(body: IrExpressionBody, data: Nothing?): IrBody =
        visitExpressionBody(body)

    open fun visitBlockBody(body: IrBlockBody): IrBody =
        visitBody(body)","final override fun visitBlockBody(body: IrBlockBody, data: Nothing?): IrBody ="
"// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect
// !OPT_IN: kotlin.contracts.ExperimentalContracts
// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER

import kotlin.contracts.*

fun nullWhenNull(x: Int?): Int? {
    contract {",returnsNotNull() implies (x != null)
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.decompiler.stub

import com.intellij.psi.stubs.StubElement
import org.jetbrains.kotlin.metadata.ProtoBuf
import org.jetbrains.kotlin.psi.KtContextReceiverList
import org.jetbrains.kotlin.psi.stubs.elements.KtStubElementTypes
import org.jetbrains.kotlin.psi.stubs.impl.KotlinContextReceiverStubImpl",import org.jetbrains.kotlin.psi.stubs.impl.KotlinPlaceHolderStubImpl
"// SKIP_TXT
// ISSUE: KT-33917

class Inv<T>(val value: T)

private inline fun foo10(crossinline f: () -> Int) = object {
    fun bar(): Int = f()
}

private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo11<!>(crossinline f: () -> Int) = Inv(object {
    fun bar(): Int = f()
})

private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo12<!>(crossinline f: () -> Int) = Inv(Inv(object {
    fun bar(): Int = f()
}))

interface I1
interface I2

private inline fun foo20(crossinline f: () -> Int) = object : I1 {
    fun bar(): Int = f()
}

private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo21<!>(crossinline f: () -> Int) = Inv(object : I1 {
    fun bar(): Int = f()
})

private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo22<!>(crossinline f: () -> Int) = Inv(Inv(object : I1 {
    fun bar(): Int = f()
}))

<!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo30<!>(crossinline f: () -> Int)<!> = object : I1, I2 {
    fun bar(): Int = f()
}

private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo31<!>(crossinline f: () -> Int) = Inv(object : I1, I2 {
    fun bar(): Int = f()
})

private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo32<!>(crossinline f: () -> Int) = Inv(Inv(object : I1, I2 {
    fun bar(): Int = f()
}))

private fun foo40(f: () -> Int) = object {
    fun bar(): Int = f()
}

private fun foo41(f: () -> Int) = Inv(object {
    fun bar(): Int = f()
})

private fun foo42(f: () -> Int) = Inv(Inv(object {
    fun bar(): Int = f()
}))

// ------------------------------------------------------------------------------------------------",fun test10(b: Boolean) {
"}
                    }
                    return
                }
                is KtProperty -> {
                    // NOTE: since we're explicitly going down a different branch for
                    // KtPropertyAccessor, the ONLY time we make it into this branch is when the
                    // call was done in the initializer of the property/variable.
                    val descriptor = bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, node]

                    if (resolvedCall.isComposableDelegateOperator()) {
                        // The call is initializer for fields like `val foo by composableDelegate()`.
                        // Creating the property doesn't have any requirements from Compose side,
                        // we will recheck on the property call site instead.
                        if (
                            descriptor is VariableDescriptorWithAccessors &&
                                descriptor.isDelegated
                        ) {
                            if (descriptor.isVar) {
                                // setValue delegate is not allowed for now.
                                illegalComposableDelegate(context, reportOn)
                            }
                            if (descriptor is PropertyDescriptor &&
                                descriptor.getter?.hasComposableAnnotation() != true) {
                                composableExpected(context, node.nameIdentifier ?: node)
                            }
                            return
                        }
                    }

                    if (
                        descriptor !is LocalVariableDescriptor &&
                        node.annotationEntries.hasComposableAnnotation(bindingContext)
                    ) {
                        // composables shouldn't have initializers in the first place
                        illegalCall(context, reportOn)
                        return
                    }
                }
                is KtPropertyAccessor -> {
                    val property = node.property
                    val isComposable = node
                        .annotationEntries.hasComposableAnnotation(bindingContext)
                    if (!isComposable) {
                        illegalCall(context, reportOn, property.nameIdentifier ?: property)
                    }
                    val descriptor = bindingContext[BindingContext.PROPERTY_ACCESSOR, node]
                        ?: return
                    if (descriptor.hasReadonlyComposableAnnotation()) {
                        // enforce that the original call was readonly
                        if (!resolvedCall.isReadOnlyComposableInvocation()) {
                            illegalCallMustBeReadonly(
                                context,
                                reportOn
                            )
                        }
                    }
                    return
                }
                is KtCallableReferenceExpression -> {
                    illegalComposableFunctionReference(context, node)
                    return
                }
                is KtFile -> {
                    // if we've made it this far, the call was made in a non-composable context.","illegalCall(context, reportOn)"
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.js.test.converters.incremental

import org.jetbrains.kotlin.js.test.converters.ClassicJsBackendFacade
import org.jetbrains.kotlin.js.test.utils.jsClassicIncrementalDataProvider
import org.jetbrains.kotlin.test.Constructor
import org.jetbrains.kotlin.test.TargetBackend
import org.jetbrains.kotlin.test.backend.classic.ClassicBackendInput
import org.jetbrains.kotlin.test.builders.TestConfigurationBuilder
import org.jetbrains.kotlin.test.directives.JsEnvironmentConfigurationDirectives.RECOMPILE
import org.jetbrains.kotlin.test.model.Frontend2BackendConverter
import org.jetbrains.kotlin.test.model.FrontendFacade
import org.jetbrains.kotlin.test.model.ResultingArtifact
import org.jetbrains.kotlin.test.model.TestModule
import org.jetbrains.kotlin.test.services.TestServices
import java.io.File

@Suppress(""warnings"")
class RecompileModuleJsBackendFacade<R : ResultingArtifact.FrontendOutput<R>>(
    testServices: TestServices,
    private val frontendFacade: Constructor<FrontendFacade<R>>,
    private val frontend2BackendConverter: Constructor<Frontend2BackendConverter<R, ClassicBackendInput>>
) : CommonRecompileModuleJsBackendFacade<R, ClassicBackendInput>(testServices, TargetBackend.JS) {
    override fun TestConfigurationBuilder.configure(module: TestModule) {
        facadeStep(frontendFacade)
        facadeStep(frontend2BackendConverter)
        facadeStep { ClassicJsBackendFacade(it, incrementalCompilationEnabled = true) }
    }",override fun TestServices.register(module: TestModule) {
"fun x(): Boolean { return true }

public fun foo(pp: Any): Int {
    var p = pp
    while(true) {
        (p as String).length
        if (x()) break",p = 42
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"")

package org.jetbrains.kotlin.fir.expressions.impl

import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.FirImplementationDetail
import org.jetbrains.kotlin.fir.MutableOrEmptyList
import org.jetbrains.kotlin.fir.builder.toMutableOrEmpty
import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.expressions.FirExpression",import org.jetbrains.kotlin.fir.expressions.UnresolvedExpressionTypeAccess
"return single
            """"""
        }
        body(CharSequences) {
            """"""
            return if (length == 1) this[0] else null
            """"""
        }
        body(Lists, ArraysOfObjects, ArraysOfPrimitives, ArraysOfUnsigned) {
            """"""
            return if (size == 1) this[0] else null
            """"""
        }
    }

    val f_single_predicate = fn(""single(predicate: (T) -> Boolean)"") {
        includeDefault()
        include(CharSequences, ArraysOfUnsigned)
    } builder {
        inline()
        specialFor(ArraysOfUnsigned) { inlineOnly() }

        doc { ""Returns the single ${f.element} matching the given [predicate], or throws exception if there is no or more than one matching ${f.element}."" }
        returns(""T"")

        body {
            """"""
            var single: T? = null
            var found = false
            for (element in this) {
                if (predicate(element)) {
                    if (found) throw IllegalArgumentException(""${f.doc.collection.capitalize()} contains more than one matching element."")
                    single = element
                    found = true
                }
            }
            if (!found) throw NoSuchElementException(""${f.doc.collection.capitalize()} contains no ${f.doc.element} matching the predicate."")
            @Suppress(""UNCHECKED_CAST"")
            return single as T
            """"""
        }
    }

    val f_singleOrNull_predicate = fn(""singleOrNull(predicate: (T) -> Boolean)"") {
        includeDefault()
        include(CharSequences, ArraysOfUnsigned)
    } builder {
        inline()
        specialFor(ArraysOfUnsigned) { inlineOnly() }

        doc { ""Returns the single ${f.element} matching the given [predicate], or `null` if ${f.element} was not found or more than one ${f.element} was found."" }
        returns(""T?"")

        body {
            """"""
            var single: T? = null
            var found = false
            for (element in this) {
                if (predicate(element)) {
                    if (found) return null
                    single = element
                    found = true
                }
            }
            if (!found) return null",return single
"if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableT()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableAny()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.equals(null)

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propT

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propAny

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableT

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableAny

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funT()

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funAny()

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableT()

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableAny()
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.equals(null)
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.propT
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.propAny
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.propNullableT
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.propNullableAny
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.funT()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.funAny()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.funNullableT()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.funNullableAny()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.equals(null)
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propT
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propAny
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableT
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableAny
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funT()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funAny()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableT()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableAny()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.equals(null)
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.propT
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.propAny
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.propNullableT
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.propNullableAny
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.funT()
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.funAny()
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.funNullableT()
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.funNullableAny()
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.equals(null)
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propT
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propAny
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableT
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableAny
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funT()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funAny()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableT()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableAny()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.equals(null)
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.propT
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.propAny","if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.propNullableT"
"// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER
// MODULE: m1
// FILE: a.kt

package p

public interface A<T>
public interface C
public interface D<T>
public class B : A<Int>, C, D<Int>
public class M1 {",public val b: B = B()
"<!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.equals(null)
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.propT
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!><!UNSAFE_CALL!>.<!>propAny
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.propNullableT
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.propNullableAny
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.funT()
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!><!UNSAFE_CALL!>.<!>funAny()
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.funNullableT()
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.funNullableAny()
                }
            }
        }
    }
}

// TESTCASE NUMBER: 12
fun case_12(x: TypealiasNullableStringIndirect, y: TypealiasNullableStringIndirect) =
    if (<!DEPRECATED_IDENTITY_EQUALS!><!USELESS_IS_CHECK!>(x == null) !is Boolean<!> === false<!>) ""1""
    else if (<!USELESS_IS_CHECK!>(<!SENSELESS_COMPARISON!>y === null !== null<!>) is Boolean<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.equals(null)
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.propT
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!><!UNSAFE_CALL!>.<!>propAny
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.propNullableT
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.propNullableAny
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.funT()
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!><!UNSAFE_CALL!>.<!>funAny()
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.funNullableT()
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.funNullableAny()
    else ""-1""

// TESTCASE NUMBER: 13
fun <!IMPLICIT_NOTHING_RETURN_TYPE!>case_13<!>(x: <!UNRESOLVED_REFERENCE!>otherpackage<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>Case13<!>?) =
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Nothing"")!>if (<!DEPRECATED_IDENTITY_EQUALS!>(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>==<!> <!USELESS_IS_CHECK!>null !is Boolean<!>) !== true<!>) {
        throw Exception()
    } else {
        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Unresolved type for otherpackage.Case13]?"")!>x<!>
        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Unresolved type for otherpackage.Case13]?"")!>x<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>equals<!>(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>)
    }<!>

// TESTCASE NUMBER: 14
class Case14 {
    val x: <!UNRESOLVED_REFERENCE!>otherpackage<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>Case14<!>?
    init {
        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> = <!UNRESOLVED_REFERENCE!>otherpackage<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>Case14<!>()
    }
}

@Suppress(""UNREACHABLE_CODE"")
fun case_14() {
    val a = Case14()

    if (a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> <!USELESS_IS_CHECK!><!USELESS_IS_CHECK!>null !is Boolean<!> !is Boolean<!>) {
        if (a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null == true) {
            if (a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> !== null == false) {
                if (<!SENSELESS_COMPARISON!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null == null<!>) {
                    if (<!SENSELESS_COMPARISON!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null !== null<!>) {
                        if (<!DEPRECATED_IDENTITY_EQUALS!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null === true<!>) {
                            if (<!DEPRECATED_IDENTITY_EQUALS!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> !== null === <!USELESS_IS_CHECK!>true !is Boolean<!><!> == true) {
                                if (<!DEPRECATED_IDENTITY_EQUALS!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null !== false<!>) {
                                    if (<!DEPRECATED_IDENTITY_EQUALS!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null === false<!>) {
                                        if (<!DEPRECATED_IDENTITY_EQUALS!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> !== null === true<!>) {
                                            if (<!USELESS_IS_CHECK!>(a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null != true) !is Boolean<!>) {
                                                if (a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> <!USELESS_IS_CHECK!>null is Boolean<!>) {
                                                    if (a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> <!USELESS_IS_CHECK!><!USELESS_IS_CHECK!>null is Boolean<!> is Boolean<!>) {
                                                        if (<!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> !== <!USELESS_IS_CHECK!>null is Boolean<!><!>) {",if (a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> <!USELESS_IS_CHECK!>null is Boolean<!>) {
"val functionReturnType = LlvmRetType(llvm.int8PtrType)
        val functionParameterTypes = listOf(LlvmParamType(llvm.int8PtrType), LlvmParamType(llvm.int8PtrType))

        val normalMessenger = codegen.llvm.externalNativeRuntimeFunction(
                ""objc_msgSend$messengerNameSuffix"",
                functionReturnType,
                functionParameterTypes,
                isVararg = true
        )
        val superMessenger = codegen.llvm.externalNativeRuntimeFunction(
                ""objc_msgSendSuper$messengerNameSuffix"",
                functionReturnType,
                functionParameterTypes,
                isVararg = true
        )

        val superClass = args.single()
        val messenger = LLVMBuildSelect(builder,
                If = icmpEq(superClass, llvm.kNullInt8Ptr),
                Then = normalMessenger.toConstPointer().llvm,
                Else = superMessenger.toConstPointer().llvm,
                Name = """"
        )!!

        return bitcast(llvm.int8PtrType, messenger)
    }

    private fun FunctionGenerationContext.emitAreEqualByValue(args: List<LLVMValueRef>): LLVMValueRef {
        val (first, second) = args
        assert (first.type == second.type) { ""Types are different: '${llvmtype2string(first.type)}' and '${llvmtype2string(second.type)}'"" }

        return when (val typeKind = LLVMGetTypeKind(first.type)) {
            LLVMTypeKind.LLVMFloatTypeKind, LLVMTypeKind.LLVMDoubleTypeKind,
            LLVMTypeKind.LLVMVectorTypeKind -> {
                // TODO LLVM API does not provide guarantee for LLVMIntTypeInContext availability for longer types; consider meaningful diag message instead of NPE
                val integerType = LLVMIntTypeInContext(llvm.llvmContext, first.type.sizeInBits())!!
                icmpEq(bitcast(integerType, first), bitcast(integerType, second))
            }
            LLVMTypeKind.LLVMIntegerTypeKind, LLVMTypeKind.LLVMPointerTypeKind -> icmpEq(first, second)
            else -> error(typeKind)
        }
    }

    private fun FunctionGenerationContext.emitIeee754Equals(args: List<LLVMValueRef>): LLVMValueRef {
        val (first, second) = args
        assert (first.type == second.type)
                { ""Types are different: '${llvmtype2string(first.type)}' and '${llvmtype2string(second.type)}'"" }
        val type = LLVMGetTypeKind(first.type)
        assert (type == LLVMTypeKind.LLVMFloatTypeKind || type == LLVMTypeKind.LLVMDoubleTypeKind)
                { ""Should be of floating point kind, not: '${llvmtype2string(first.type)}'""}
        return fcmpEq(first, second)
    }

    private fun FunctionGenerationContext.emitReinterpret(callSite: IrCall, args: List<LLVMValueRef>) =
            bitcast(callSite.llvmReturnType, args[0])

    private fun FunctionGenerationContext.emitExtractElement(callSite: IrCall, args: List<LLVMValueRef>): LLVMValueRef {
        val (vector, index) = args
        val elementSize = LLVMSizeOfTypeInBits(codegen.llvmTargetData, callSite.llvmReturnType).toInt()
        val vectorSize = LLVMSizeOfTypeInBits(codegen.llvmTargetData, vector.type).toInt()

        assert(callSite.llvmReturnType.isVectorElementType()
                && vectorSize % elementSize == 0
        ) { ""Invalid vector element type ${LLVMGetTypeKind(callSite.llvmReturnType)}""}",val elementCount = vectorSize / elementSize
"val jsImplFqName = FqName(""${jsInterfaceFqName.asString()}$IMPLEMENTATION_SUFFIX"")
    withPrinterToFile(fileFromFqName(srcDir, jsImplFqName)) {
        generateImpl(
            jsImplFqName,
            commonCompilerImpl,
            jsInterfaceFqName,
            jsOptions
        )
    }

    val k2JsCompilerArgumentsFqName = FqName(K2JSCompilerArguments::class.qualifiedName!!)
    val jsCompilerOptionsHelperFqName = FqName(
        ""${jsInterfaceFqName.asString()}$IMPLEMENTATION_HELPERS_SUFFIX""
    )
    withPrinterToFile(fileFromFqName(srcDir, jsCompilerOptionsHelperFqName)) {
        generateCompilerOptionsHelper(
            jsInterfaceFqName,
            jsCompilerOptionsHelperFqName,
            commonCompilerHelperName,
            k2JsCompilerArgumentsFqName,
            jsOptions
        )
    }
}

private fun generateKotlinNativeOptions(
    apiSrcDir: File,
    commonCompilerOptions: GeneratedOptions,
    withPrinterToFile: (targetFile: File, Printer.() -> Unit) -> Unit
): GeneratedOptions {
    val nativeInterfaceFqName = FqName(""$OPTIONS_PACKAGE_PREFIX.KotlinNativeCompilerOptions"")
    val nativeOptions = gradleOptions<K2NativeCompilerArguments>()
    withPrinterToFile(fileFromFqName(apiSrcDir, nativeInterfaceFqName)) {
        generateInterface(
            nativeInterfaceFqName,
            nativeOptions,
            parentType = commonCompilerOptions.optionsName,
            interfaceKDoc = NATIVE_COMPILER_OPTIONS_KDOC
        )
    }

    println(""\n### Attributes specific for Native\n"")
    generateMarkdown(nativeOptions)

    return GeneratedOptions(nativeInterfaceFqName, null, nativeOptions)
}

private fun generateKotlinNativeOptionsImpl(
    srcDir: File,
    nativeInterfaceFqName: FqName,
    commonCompilerImpl: FqName,
    commonCompilerHelper: FqName,
    nativeOptions: List<KProperty1<*, *>>,
    withPrinterToFile: (targetFile: File, Printer.() -> Unit) -> Unit
) {
    val nativeImplFqName = FqName(""${nativeInterfaceFqName.asString()}$IMPLEMENTATION_SUFFIX"")
    withPrinterToFile(fileFromFqName(srcDir, nativeImplFqName)) {
        generateImpl(
            nativeImplFqName,
            commonCompilerImpl,
            nativeInterfaceFqName,
            nativeOptions
        )
    }",val k2NativeCompilerArgumentsFqName = FqName(K2NativeCompilerArguments::class.qualifiedName!!)
"}

/**
 * Checks if the specified [value] belongs to this range.
 */
@SinceKotlin(""1.5"")
@WasExperimental(ExperimentalUnsignedTypes::class)
public operator fun ULongRange.contains(value: UShort): Boolean {
    return contains(value.toULong())
}

/**
 * Returns a progression from this value down to the specified [to] value with the step -1.
 * 
 * The [to] value should be less than or equal to `this` value.
 * If the [to] value is greater than `this` value the returned progression is empty.
 */
@SinceKotlin(""1.5"")
@WasExperimental(ExperimentalUnsignedTypes::class)
public infix fun UByte.downTo(to: UByte): UIntProgression {
    return UIntProgression.fromClosedRange(this.toUInt(), to.toUInt(), -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the step -1.
 * 
 * The [to] value should be less than or equal to `this` value.
 * If the [to] value is greater than `this` value the returned progression is empty.
 */
@SinceKotlin(""1.5"")
@WasExperimental(ExperimentalUnsignedTypes::class)
public infix fun UInt.downTo(to: UInt): UIntProgression {
    return UIntProgression.fromClosedRange(this, to, -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the step -1.
 * 
 * The [to] value should be less than or equal to `this` value.
 * If the [to] value is greater than `this` value the returned progression is empty.
 */
@SinceKotlin(""1.5"")
@WasExperimental(ExperimentalUnsignedTypes::class)
public infix fun ULong.downTo(to: ULong): ULongProgression {
    return ULongProgression.fromClosedRange(this, to, -1L)
}

/**
 * Returns a progression from this value down to the specified [to] value with the step -1.
 * 
 * The [to] value should be less than or equal to `this` value.
 * If the [to] value is greater than `this` value the returned progression is empty.
 */
@SinceKotlin(""1.5"")
@WasExperimental(ExperimentalUnsignedTypes::class)
public infix fun UShort.downTo(to: UShort): UIntProgression {
    return UIntProgression.fromClosedRange(this.toUInt(), to.toUInt(), -1)
}

/**
 * Returns a progression that goes over the same range in the opposite direction with the same step.
 */
@SinceKotlin(""1.5"")
@WasExperimental(ExperimentalUnsignedTypes::class)
public fun UIntProgression.reversed(): UIntProgression {","return UIntProgression.fromClosedRange(last, first, -step)"
"set(value) { memberAt<IntVar>(44).value = value }
    
    var isModuleImport: Int
        get() = memberAt<IntVar>(48).value
        set(value) { memberAt<IntVar>(48).value = value }
}

@CNaturalStruct(""file"", ""module"", ""loc"", ""isImplicit"")
class CXIdxImportedASTFileInfo(rawPtr: NativePtr) : CStructVar(rawPtr) {
    
    @Deprecated(""Use sizeOf\u003CT\u003E() or alignOf\u003CT\u003E() instead."", ReplaceWith(""""), DeprecationLevel.WARNING)
    companion object : CStructVar.Type(48, 8)
    
    var file: CXFile?
        get() = memberAt<CXFileVar>(0).value
        set(value) { memberAt<CXFileVar>(0).value = value }
    
    var module: CXModule?
        get() = memberAt<CXModuleVar>(8).value
        set(value) { memberAt<CXModuleVar>(8).value = value }
    
    val loc: CXIdxLoc
        get() = memberAt(16)
    
    var isImplicit: Int
        get() = memberAt<IntVar>(40).value
        set(value) { memberAt<IntVar>(40).value = value }
}

@CNaturalStruct(""kind"", ""cursor"", ""loc"")
class CXIdxAttrInfo(rawPtr: NativePtr) : CStructVar(rawPtr) {
    
    @Deprecated(""Use sizeOf\u003CT\u003E() or alignOf\u003CT\u003E() instead."", ReplaceWith(""""), DeprecationLevel.WARNING)
    companion object : CStructVar.Type(64, 8)
    
    var kind: CXIdxAttrKind
        get() = memberAt<CXIdxAttrKindVar>(0).value
        set(value) { memberAt<CXIdxAttrKindVar>(0).value = value }
    
    val cursor: CXCursor
        get() = memberAt(8)
    
    val loc: CXIdxLoc
        get() = memberAt(40)
}

@CNaturalStruct(""kind"", ""templateKind"", ""lang"", ""name"", ""USR"", ""cursor"", ""attributes"", ""numAttributes"")
class CXIdxEntityInfo(rawPtr: NativePtr) : CStructVar(rawPtr) {
    
    @Deprecated(""Use sizeOf\u003CT\u003E() or alignOf\u003CT\u003E() instead."", ReplaceWith(""""), DeprecationLevel.WARNING)
    companion object : CStructVar.Type(80, 8)
    
    var kind: CXIdxEntityKind
        get() = memberAt<CXIdxEntityKind.Var>(0).value
        set(value) { memberAt<CXIdxEntityKind.Var>(0).value = value }
    
    var templateKind: CXIdxEntityCXXTemplateKind
        get() = memberAt<CXIdxEntityCXXTemplateKindVar>(4).value
        set(value) { memberAt<CXIdxEntityCXXTemplateKindVar>(4).value = value }
    
    var lang: CXIdxEntityLanguage
        get() = memberAt<CXIdxEntityLanguageVar>(8).value
        set(value) { memberAt<CXIdxEntityLanguageVar>(8).value = value }
    
    var name: CPointer<ByteVar>?",get() = memberAt<CPointerVar<ByteVar>>(16).value
"/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress(
    ""unused"",
    ""nothing_to_inline"",
    ""useless_cast"",
    ""unchecked_cast"",
    ""extension_shadowed_by_member"",
    ""redundant_projection"",
    ""RemoveRedundantBackticks"",
    ""ObjectPropertyName"",
    ""deprecation""
)
@file:org.gradle.api.Generated

/* ktlint-disable */

package gradle.kotlin.dsl.accessors._44a939cf26bc074355463a0d554ee592


import org.gradle.api.Action
import org.gradle.api.Incubating
import org.gradle.api.NamedDomainObjectProvider
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurablePublishArtifact
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.Dependency",import org.gradle.api.artifacts.DependencyConstraint
"* having distinct keys returned by the given [selector] function.
 * 
 * The elements in the resulting list are in the same order as they were in the source array.
 * 
 * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy
 */
public inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {
    val set = HashSet<K>()
    val list = ArrayList<Long>()
    for (e in this) {
        val key = selector(e)
        if (set.add(key))
            list.add(e)
    }
    return list
}

/**
 * Returns a list containing only elements from the given array
 * having distinct keys returned by the given [selector] function.
 * 
 * The elements in the resulting list are in the same order as they were in the source array.
 * 
 * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy
 */
public inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {
    val set = HashSet<K>()
    val list = ArrayList<Float>()
    for (e in this) {
        val key = selector(e)
        if (set.add(key))
            list.add(e)
    }
    return list
}

/**
 * Returns a list containing only elements from the given array
 * having distinct keys returned by the given [selector] function.
 * 
 * The elements in the resulting list are in the same order as they were in the source array.
 * 
 * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy
 */
public inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {
    val set = HashSet<K>()
    val list = ArrayList<Double>()
    for (e in this) {
        val key = selector(e)
        if (set.add(key))
            list.add(e)
    }
    return list
}

/**
 * Returns a list containing only elements from the given array
 * having distinct keys returned by the given [selector] function.
 * 
 * The elements in the resulting list are in the same order as they were in the source array.
 * 
 * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy
 */
public inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {
    val set = HashSet<K>()",val list = ArrayList<Boolean>()
"expectMinMaxOf((0u - 1U).toUInt(), (0u - 1U).toUInt(), uintArrayOf(1U), { (0u - it).toUInt() })
        expectMinMaxOf((0u - 2U).toUInt(), (0u - 1U).toUInt(), uintArrayOf(1U, 2U), { (0u - it).toUInt() })
        expectMinMaxOf((0u - UInt.MAX_VALUE).toUInt(), (0u - 1U).toUInt(), uintArrayOf(1U, 2U, UInt.MAX_VALUE), { (0u - it).toUInt() })

    }
    
    @Test
    fun minMaxOfDouble() {
        val middle = 2U
        val items = uintArrayOf(1U, 2U, UInt.MAX_VALUE).apply { shuffle() }
        assertTrue(items.minOf { it.compareTo(middle).toDouble().pow(0.5) }.isNaN())
        assertTrue(items.minOfOrNull { it.compareTo(middle).toDouble().pow(0.5) }!!.isNaN())
        assertTrue(items.maxOf { it.compareTo(middle).toDouble().pow(0.5) }.isNaN())
        assertTrue(items.maxOfOrNull { it.compareTo(middle).toDouble().pow(0.5) }!!.isNaN())
        
        assertIsNegativeZero(items.minOf { it.compareTo(middle) * 0.0 })
        assertIsNegativeZero(items.minOfOrNull { it.compareTo(middle) * 0.0 }!!)
        assertIsPositiveZero(items.maxOf { it.compareTo(middle) * 0.0 })
        assertIsPositiveZero(items.maxOfOrNull { it.compareTo(middle) * 0.0 }!!)
    }
    
    @Test
    fun minMaxOfFloat() {
        val middle = 2U
        val items = uintArrayOf(1U, 2U, UInt.MAX_VALUE).apply { shuffle() }
        assertTrue(items.minOf { it.compareTo(middle).toFloat().pow(0.5F) }.isNaN())
        assertTrue(items.minOfOrNull { it.compareTo(middle).toFloat().pow(0.5F) }!!.isNaN())
        assertTrue(items.maxOf { it.compareTo(middle).toFloat().pow(0.5F) }.isNaN())
        assertTrue(items.maxOfOrNull { it.compareTo(middle).toFloat().pow(0.5F) }!!.isNaN())
        
        assertIsNegativeZero(items.minOf { it.compareTo(middle) * 0.0F }.toDouble())
        assertIsNegativeZero(items.minOfOrNull { it.compareTo(middle) * 0.0F }!!.toDouble())
        assertIsPositiveZero(items.maxOf { it.compareTo(middle) * 0.0F }.toDouble())
        assertIsPositiveZero(items.maxOfOrNull { it.compareTo(middle) * 0.0F }!!.toDouble())
    }
    
    @Test
    fun minMaxOfEmpty() {
        val empty = uintArrayOf()

        assertNull(empty.minOfOrNull { it.toString() })
        assertNull(empty.maxOfOrNull { it.toString() })
        assertFailsWith<NoSuchElementException> { empty.minOf { it.toString() } }
        assertFailsWith<NoSuchElementException> { empty.maxOf { it.toString() } }                       


        assertNull(empty.minOfOrNull { 0.0 })
        assertNull(empty.maxOfOrNull { 0.0 })
        assertFailsWith<NoSuchElementException> { empty.minOf { 0.0 } }
        assertFailsWith<NoSuchElementException> { empty.maxOf { 0.0 } }                       


        assertNull(empty.minOfOrNull { 0.0F })
        assertNull(empty.maxOfOrNull { 0.0F })
        assertFailsWith<NoSuchElementException> { empty.minOf { 0.0F } }
        assertFailsWith<NoSuchElementException> { empty.maxOf { 0.0F } }                       


    }
    
    
    private inline fun <R> expectMinMaxOfWith(min: R, max: R, elements: UIntArray, comparator: Comparator<R>, selector: (UInt) -> R) {
        assertEquals(min, elements.minOfWith(comparator, selector))
        assertEquals(min, elements.minOfWithOrNull(comparator, selector))
        assertEquals(max, elements.maxOfWith(comparator, selector))","assertEquals(max, elements.maxOfWithOrNull(comparator, selector))"
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package org.jetbrains.kotlin.ir.util
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.targets.js.typescript

import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.*
import org.gradle.work.DisableCachingByDefault
import org.gradle.work.NormalizeLineEndings
import org.jetbrains.kotlin.gradle.internal.execWithProgress
import org.jetbrains.kotlin.gradle.targets.js.RequiredKotlinJsDependency
import org.jetbrains.kotlin.gradle.targets.js.ir.KotlinIrJsGeneratedTSValidationStrategy
import org.jetbrains.kotlin.gradle.targets.js.ir.KotlinJsIrCompilation
import org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootPlugin.Companion.kotlinNodeJsExtension
import org.jetbrains.kotlin.gradle.targets.js.npm.RequiresNpmDependencies
import org.jetbrains.kotlin.gradle.targets.js.npm.npmProject
import javax.inject.Inject

@DisableCachingByDefault
abstract class TypeScriptValidationTask
@Inject
constructor(
    @Internal
    @Transient
    override val compilation: KotlinJsIrCompilation
) : DefaultTask(), RequiresNpmDependencies {
    private val npmProject = compilation.npmProject

    @get:Internal
    @Transient
    protected val nodeJs = project.rootProject.kotlinNodeJsExtension",private val versions = nodeJs.versions
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.light.classes.symbol.annotations

import com.intellij.psi.PsiAnnotation
import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.light.classes.symbol.methods.SymbolLightMethodBase
import org.jetbrains.kotlin.load.java.JvmAnnotationNames

internal object MethodAdditionalAnnotationsProvider : AdditionalAnnotationsProvider {
    override fun addAllAnnotations(
        currentRawAnnotations: MutableList<in PsiAnnotation>,
        foundQualifiers: MutableSet<String>,
        owner: PsiElement,
    ) {
        if (owner.parent.isMethodWithOverride()) {
            addSimpleAnnotationIfMissing(JvmAnnotationNames.OVERRIDE_ANNOTATION.asString(), currentRawAnnotations, foundQualifiers, owner)
        }
    }

    override fun findSpecialAnnotation(
        annotationsBox: GranularAnnotationsBox,
        qualifiedName: String,
        owner: PsiElement,
    ): PsiAnnotation? = if (owner.parent.isMethodWithOverride())
        createSimpleAnnotationIfMatches(
            qualifier = qualifiedName,
            expectedQualifier = JvmAnnotationNames.OVERRIDE_ANNOTATION.asString(),
            owner = owner,
        )",else
"* 
 * Note that `acc` value passed to [operation] function should not be mutated;
 * otherwise it would affect the previous value in resulting list.
 * 
 * @param [operation] function that takes the index of an element, current accumulator value
 * and the element itself, and calculates the next accumulator value.
 * 
 * @sample samples.collections.Collections.Aggregates.scan
 */
@SinceKotlin(""1.4"")
@kotlin.internal.InlineOnly
public inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {
    return runningFoldIndexed(initial, operation)
}

/**
 * Returns a list containing successive accumulation values generated by applying [operation] from left to right
 * to each element, its index in the original array and current accumulator value that starts with [initial] value.
 * 
 * Note that `acc` value passed to [operation] function should not be mutated;
 * otherwise it would affect the previous value in resulting list.
 * 
 * @param [operation] function that takes the index of an element, current accumulator value
 * and the element itself, and calculates the next accumulator value.
 * 
 * @sample samples.collections.Collections.Aggregates.scan
 */
@SinceKotlin(""1.4"")
@kotlin.internal.InlineOnly
public inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {
    return runningFoldIndexed(initial, operation)
}

/**
 * Returns a list containing successive accumulation values generated by applying [operation] from left to right
 * to each element, its index in the original array and current accumulator value that starts with [initial] value.
 * 
 * Note that `acc` value passed to [operation] function should not be mutated;
 * otherwise it would affect the previous value in resulting list.
 * 
 * @param [operation] function that takes the index of an element, current accumulator value
 * and the element itself, and calculates the next accumulator value.
 * 
 * @sample samples.collections.Collections.Aggregates.scan
 */
@SinceKotlin(""1.4"")
@kotlin.internal.InlineOnly
public inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {
    return runningFoldIndexed(initial, operation)
}

/**
 * Returns a list containing successive accumulation values generated by applying [operation] from left to right
 * to each element, its index in the original array and current accumulator value that starts with [initial] value.
 * 
 * Note that `acc` value passed to [operation] function should not be mutated;
 * otherwise it would affect the previous value in resulting list.
 * 
 * @param [operation] function that takes the index of an element, current accumulator value
 * and the element itself, and calculates the next accumulator value.
 * 
 * @sample samples.collections.Collections.Aggregates.scan
 */
@SinceKotlin(""1.4"")
@kotlin.internal.InlineOnly","public inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {"
"// Binds comments on the same line
object TrailingCommentsBinder : WhitespacesAndCommentsBinder {
    override fun getEdgePosition(
        tokens: List<IElementType>, atStreamEdge: Boolean, getter: WhitespacesAndCommentsBinder.TokenTextGetter
    ): Int {
        if (tokens.isEmpty()) return 0

        var result = 0
        tokens@ for (idx in tokens.indices) {
            val tokenType = tokens[idx]
            when (tokenType) {
                KtTokens.WHITE_SPACE -> if (StringUtil.containsLineBreak(getter[idx])) break@tokens

                KtTokens.EOL_COMMENT, KtTokens.BLOCK_COMMENT -> result = idx + 1

                else -> break@tokens
            }
        }

        return result
    }
}

private class AllCommentsBinder(val isTrailing: Boolean) : WhitespacesAndCommentsBinder {
    override fun getEdgePosition(
        tokens: List<IElementType>, atStreamEdge: Boolean, getter: WhitespacesAndCommentsBinder.TokenTextGetter
    ): Int {
        if (tokens.isEmpty()) return 0

        val size = tokens.size

        // Skip one whitespace if needed. Expect that there can't be several consecutive whitespaces
        val endToken = tokens[if (isTrailing) size - 1 else 0]
        val shift = if (endToken == KtTokens.WHITE_SPACE) 1 else 0

        return if (isTrailing) size - shift else shift
    }
}

@JvmField
val PRECEDING_ALL_COMMENTS_BINDER: WhitespacesAndCommentsBinder = AllCommentsBinder(false)

@JvmField
val TRAILING_ALL_COMMENTS_BINDER: WhitespacesAndCommentsBinder = AllCommentsBinder(true)

object DoNotBindAnything : WhitespacesAndCommentsBinder {
    override fun getEdgePosition(
        tokens: List<IElementType>, atStreamEdge: Boolean, getter: WhitespacesAndCommentsBinder.TokenTextGetter
    ): Int {
        return 0
    }
}

object BindFirstShebangWithWhitespaceOnly : WhitespacesAndCommentsBinder {
    override fun getEdgePosition(
        tokens: List<IElementType>, atStreamEdge: Boolean, getter: WhitespacesAndCommentsBinder.TokenTextGetter
    ): Int {
        if (tokens.firstOrNull() == KtTokens.SHEBANG_COMMENT) {
            return if (tokens.getOrNull(1) == KtTokens.WHITE_SPACE) 2 else 1
        }

        return 0
    }
}",class BindAll(val isTrailing: Boolean) : WhitespacesAndCommentsBinder {
"<!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.compareTo(it)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.get(0)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.iterator()
        }
    }
}

/*
 * TESTCASE NUMBER: 47
 * ISSUES: KT-28785
 */
fun <T> case_47(x: T?) where T : Inv<T>, T: Comparable<*>?, T: InterfaceWithTypeParameter1<out T>? {
    if (x != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.test()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.ip1test1()

        x.equals(null)

        x.propT

        x.propAny

        x.propNullableT

        x.propNullableAny

        x.funT()

        x.funAny()

        x.funNullableT()

        x.funNullableAny()
        x.test()
        x.ip1test1()
        x.apply {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>
            equals(null)
            propT
            propAny
            propNullableT
            propNullableAny
            funT()
            funAny()
            funNullableT()
            funNullableAny()
            test()
            ip1test1()","<!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.equals(null)"
"fun byteArg(b: Byte) {}
fun charArg(c: Char) {}
fun shortArg(s: Short) {}

fun box(): String {
    var b = 42.toByte()
    b++
    ++b
    byteArg(b)

    var c = 'x'
    c++
    ++c
    charArg(c)",var s = 239.toShort()
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer.cli",internal object InputLibrariesOptionType : LibrariesSetOptionType(
"import org.jetbrains.kotlin.fir.declarations.utils.isStatic
import org.jetbrains.kotlin.fir.declarations.utils.modality
import org.jetbrains.kotlin.fir.declarations.utils.visibility
import org.jetbrains.kotlin.fir.symbols.SyntheticSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirSyntheticPropertySymbol
import org.jetbrains.kotlin.fir.symbols.impl.isExtension
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.Name

internal class KtFirSyntheticJavaPropertySymbol(
    override val firSymbol: FirSyntheticPropertySymbol,
    override val analysisSession: KtFirAnalysisSession,
) : KtSyntheticJavaPropertySymbol(), KtFirSymbol<FirSyntheticPropertySymbol> {
    override val psi: PsiElement? by cached { firSymbol.findPsi() }

    override val isVal: Boolean get() = withValidityAssertion { firSymbol.isVal }
    override val name: Name get() = withValidityAssertion { firSymbol.name }

    override val returnType: KtType get() = withValidityAssertion { firSymbol.returnType(builder) }
    override val receiverParameter: KtReceiverParameterSymbol? get() = withValidityAssertion { firSymbol.receiver(builder) }

    override val typeParameters: List<KtTypeParameterSymbol>
        get() = withValidityAssertion { firSymbol.createKtTypeParameters(builder) }


    override val isExtension: Boolean get() = withValidityAssertion { firSymbol.isExtension }

    override val initializer: KtInitializerValue? by cached { firSymbol.getKtConstantInitializer(builder) }

    override val modality: Modality get() = withValidityAssertion { firSymbol.modality }
    override val visibility: Visibility get() = withValidityAssertion { firSymbol.visibility }

    override val annotationsList by cached {
        KtFirAnnotationListForDeclaration.create(firSymbol, builder)
    }

    override val callableIdIfNonLocal: CallableId? get() = withValidityAssertion { firSymbol.getCallableIdIfNonLocal() }

    override val getter: KtPropertyGetterSymbol
        get() = withValidityAssertion {
            builder.callableBuilder.buildGetterSymbol(firSymbol.getterSymbol!!)
        }
    override val javaGetterSymbol: KtFunctionSymbol
        get() = withValidityAssertion {
            val fir = firSymbol.fir as FirSyntheticProperty
            return builder.functionLikeBuilder.buildFunctionSymbol(fir.getter.delegate.symbol)
        }
    override val javaSetterSymbol: KtFunctionSymbol?
        get() = withValidityAssertion {
            val fir = firSymbol.fir as FirSyntheticProperty
            return fir.setter?.delegate?.let { builder.functionLikeBuilder.buildFunctionSymbol(it.symbol) }
        }

    override val setter: KtPropertySetterSymbol?
        get() = withValidityAssertion {
            firSymbol.setterSymbol?.let { builder.callableBuilder.buildPropertyAccessorSymbol(it) } as? KtPropertySetterSymbol
        }

    override val backingFieldSymbol: KtBackingFieldSymbol?
        get() = null

    override val isFromPrimaryConstructor: Boolean get() = withValidityAssertion { false }
    override val isOverride: Boolean get() = withValidityAssertion { firSymbol.isOverride }
    override val isStatic: Boolean get() = withValidityAssertion { firSymbol.isStatic }",override val hasSetter: Boolean get() = withValidityAssertion { firSymbol.setterSymbol != null }
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.declarations

import org.jetbrains.kotlin.GeneratedDeclarationKey
import org.jetbrains.kotlin.fir.declarations.utils.FirScriptCustomizationKind

sealed class FirDeclarationOrigin(
    private val displayName: String? = null,
    val fromSupertypes: Boolean = false,
    val generated: Boolean = false,
    val fromSource: Boolean = false,
    val generatedAnyMethod: Boolean = false,
) {
    object Source : FirDeclarationOrigin(fromSource = true)
    object Library : FirDeclarationOrigin()
    object Precompiled : FirDeclarationOrigin() // currently used for incremental compilation
    object BuiltIns : FirDeclarationOrigin()","sealed class Java(displayName: String, fromSource: Boolean = false) : FirDeclarationOrigin(displayName, fromSource = fromSource) {"
"x.propT

        x.propAny

        x.propNullableT

        x.propNullableAny

        x.funT()

        x.funAny()

        x.funNullableT()

        x.funNullableAny()
        x.ip1test1()
        x.apply {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>
            equals(null)
            propT
            propAny
            propNullableT
            propNullableAny
            funT()
            funAny()
            funNullableT()
            funNullableAny()
            ip1test1()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.ip1test1()
        }
        x.also {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.ip1test1()
        }
    }
}

// TESTCASE NUMBER: 61
interface Case61_1<T>: InterfaceWithTypeParameter1<T>, Case61_2<T> { fun test1() }
interface Case61_2<T>: InterfaceWithTypeParameter1<T> { fun test2() }

class Case61_3<T>: InterfaceWithTypeParameter1<T>, Case61_1<T>, Case61_2<T> {
    override fun test1() {}
    override fun test2() {}
    fun test4() {}
}","fun <T> T.case_61(x: T) where T : InterfaceWithTypeParameter1<T>?, T: Case61_3<T>?, T: Case61_1<T>?, T: Case61_2<T>? {"
"/*
 * Copyright 2000-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.calls.components

import org.jetbrains.kotlin.builtins.isFunctionTypeOrSubtype
import org.jetbrains.kotlin.config.LanguageFeature
import org.jetbrains.kotlin.config.LanguageVersionSettings
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.descriptors.synthetic.SyntheticMemberDescriptor
import org.jetbrains.kotlin.resolve.calls.components.candidate.CallableReferenceResolutionCandidate
import org.jetbrains.kotlin.resolve.calls.components.candidate.ResolutionCandidate
import org.jetbrains.kotlin.resolve.calls.components.candidate.SimpleResolutionCandidate
import org.jetbrains.kotlin.resolve.calls.inference.NewConstraintSystem
import org.jetbrains.kotlin.resolve.calls.inference.addEqualityConstraintIfCompatible
import org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintSystemCompletionMode
import org.jetbrains.kotlin.resolve.calls.inference.components.KotlinConstraintSystemCompleter
import org.jetbrains.kotlin.resolve.calls.inference.components.NewTypeSubstitutorByConstructorMap
import org.jetbrains.kotlin.resolve.calls.inference.components.TrivialConstraintTypeInferenceOracle
import org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintStorage.Empty.hasContradiction
import org.jetbrains.kotlin.resolve.calls.inference.model.ExpectedTypeConstraintPositionImpl
import org.jetbrains.kotlin.resolve.calls.model.*
import org.jetbrains.kotlin.resolve.calls.tower.CandidateFactory
import org.jetbrains.kotlin.resolve.calls.tower.forceResolution",import org.jetbrains.kotlin.types.TypeUtils
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.checkers.context

import org.jetbrains.kotlin.fir.resolve.SessionHolder
import org.jetbrains.kotlin.fir.resolve.transformers.ReturnTypeCalculator

abstract class AbstractCheckerContext(
    override val sessionHolder: SessionHolder,
    override val returnTypeCalculator: ReturnTypeCalculator,
    override val allInfosSuppressed: Boolean,
    override val allWarningsSuppressed: Boolean,",override val allErrorsSuppressed: Boolean
"is CauseRendering.UsedFromSomewhere -> with(rendering) {
                    if (objectSymbol == rootCause.symbol) {
                        // 'rootCause.symbol' is already mentioned in `rendering.objectText`, so use shorter message
                        objectUses().unacceptableClassifier().via()
                    } else
                        objectUses().subject(capitalized = false).via().append("" that has "").unacceptableClassifier()
                }
            }
        }
    }

    return this
}

private fun Appendable.noDeclarationForSymbol(symbol: IrSymbol): Appendable =
    append(""No "").declarationKind(symbol, capitalized = false).append("" found for symbol "").signature(symbol)

private fun Appendable.declarationWithUnusableClassifier(
    declarationSymbol: IrSymbol,
    cause: Unusable,
    forExpression: Boolean
): Appendable {
    val functionDeclaration = declarationSymbol.owner as? IrFunction
    val functionIsUnusableDueToContainingClass = (functionDeclaration?.parent as? IrClass)?.symbol == cause.symbol

    // The user (object) of the unusable classifier. In case the current declaration is a function with its own parent class being
    // the dispatch receiver, the class is the ""object"".
    val objectSymbol = if (functionIsUnusableDueToContainingClass) cause.symbol else declarationSymbol

    val objectDescription = buildString {
        if (functionIsUnusableDueToContainingClass) {
            // Callable member is unusable due to unusable dispatch receiver.
            val functionIsConstructor = functionDeclaration is IrConstructor

            if (forExpression) {
                if (functionIsConstructor)
                    declarationKindName(objectSymbol, capitalized = true) // ""Class 'Foo'""
                else
                    append(""Dispatch receiver "").declarationKindName(objectSymbol, capitalized = false) // ""Dispatch receiver class 'Foo'""
            } else {
                declarationKindName(objectSymbol, capitalized = true) // ""Class 'Foo'""
                    .append(if (functionIsConstructor) "" created by "" else "", the dispatch receiver of "") // "", the dispatch receiver of""
                    .declarationKindName(declarationSymbol, capitalized = false) // ""function 'foo'""
            }
        } else {
            if (forExpression)
                declarationKind(objectSymbol, capitalized = true) // ""Function""
            else
                declarationKindName(objectSymbol, capitalized = true) // ""Function 'foo'""
        }
    }

    return unusableClassifier(
        cause,
        CauseRendering.UsedFromDeclaration(objectDescription, objectSymbol),
        printIntermediateCause = !functionIsUnusableDueToContainingClass
    )
}

private fun StringBuilder.expressionWithUnusableClassifier(
    expression: IrExpression,
    cause: Unusable
): Appendable = expression(expression) { expressionKind ->
    // Printing the intermediate cause may pollute certain types of error messages. Need to avoid it when possible.",val printIntermediateCause = when {
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.generators.protobuf

import org.jetbrains.kotlin.generators.util.GeneratorsFileUtil
import org.jetbrains.kotlin.library.metadata.DebugKlibMetadataProtoBuf
import org.jetbrains.kotlin.metadata.DebugExtOptionsProtoBuf
import org.jetbrains.kotlin.metadata.DebugProtoBuf
import org.jetbrains.kotlin.metadata.builtins.DebugBuiltInsProtoBuf
import org.jetbrains.kotlin.metadata.java.DebugJavaClassProtoBuf
import org.jetbrains.kotlin.metadata.js.DebugJsProtoBuf
import org.jetbrains.kotlin.metadata.jvm.DebugJvmProtoBuf
import org.jetbrains.kotlin.protobuf.Descriptors
import org.jetbrains.kotlin.utils.Printer
import java.io.File
import java.util.*

class GenerateProtoBufCompare {
    companion object {
        val DEST_FILE: File = File(""build-common/src/org/jetbrains/kotlin/incremental/ProtoCompareGenerated.kt"")

        @JvmStatic
        fun main(args: Array<String>) {
            generate(DEST_FILE)
        }

        fun generate(destFile: File, forbidGenerationOnTeamcity: Boolean = true) {
            GeneratorsFileUtil.writeFileIfContentChanged(
                destFile, GenerateProtoBufCompare().generate(),
                forbidGenerationOnTeamcity = forbidGenerationOnTeamcity
            )
        }
    }

    private val JAVA_TYPES_WITH_INLINED_EQUALS: EnumSet<Descriptors.FieldDescriptor.JavaType> = EnumSet.of(
        Descriptors.FieldDescriptor.JavaType.INT,
        Descriptors.FieldDescriptor.JavaType.LONG,
        Descriptors.FieldDescriptor.JavaType.FLOAT,
        Descriptors.FieldDescriptor.JavaType.DOUBLE,
        Descriptors.FieldDescriptor.JavaType.BOOLEAN,
        Descriptors.FieldDescriptor.JavaType.STRING,
        Descriptors.FieldDescriptor.JavaType.ENUM

    )

    private val RESULT_NAME = ""result""
    private val STRING_INDEXES_NAME = ""StringIndexes""
    private val CLASS_ID_INDEXES_NAME = ""ClassIdIndexes""","private val OLD_PREFIX = ""old"""
"import org.gradle.api.Action
import org.gradle.api.Incubating
import org.gradle.api.NamedDomainObjectProvider
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurablePublishArtifact
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.Dependency
import org.gradle.api.artifacts.DependencyConstraint
import org.gradle.api.artifacts.ExternalModuleDependency
import org.gradle.api.artifacts.ModuleDependency
import org.gradle.api.artifacts.PublishArtifact
import org.gradle.api.artifacts.dsl.ArtifactHandler
import org.gradle.api.artifacts.dsl.DependencyConstraintHandler
import org.gradle.api.artifacts.dsl.DependencyHandler
import org.gradle.api.provider.Provider
import org.gradle.api.provider.ProviderConvertible
import org.gradle.api.tasks.TaskContainer
import org.gradle.api.tasks.TaskProvider

import org.gradle.kotlin.dsl.*
import org.gradle.kotlin.dsl.accessors.runtime.*


/**
 * Adds a dependency to the 'testApiDependenciesMetadata' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`testApiDependenciesMetadata`(dependencyNotation: Any): Dependency? =
    add(""testApiDependenciesMetadata"", dependencyNotation)

/**
 * Adds a dependency to the 'testApiDependenciesMetadata' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`testApiDependenciesMetadata`(
    dependencyNotation: String,
    dependencyConfiguration: Action<ExternalModuleDependency>
): ExternalModuleDependency = addDependencyTo(
    this, ""testApiDependenciesMetadata"", dependencyNotation, dependencyConfiguration
) as ExternalModuleDependency

/**
 * Adds a dependency to the 'testApiDependenciesMetadata' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`testApiDependenciesMetadata`(","dependencyNotation: Provider<*>,"
"if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.equals(null)
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.propT
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.propAny
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.propNullableT
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.propNullableAny
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.funT()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.funAny()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableT()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableAny()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.equals(null)
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.propT
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.propAny
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.propNullableT
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.propNullableAny
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.funT()
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.funAny()
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableT()
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableAny()
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.equals(null)
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.propT
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.propAny
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.propNullableT
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.propNullableAny
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.funT()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.funAny()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.funNullableT()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.funNullableAny()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.equals(null)
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.propT
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.propAny
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.propNullableT
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.propNullableAny
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.funT()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.funAny()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.funNullableT()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.funNullableAny()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.equals(null)
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.propT
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.propAny
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.propNullableT
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.propNullableAny
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.funT()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.funAny()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableT()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableAny()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.equals(null)

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propT

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propAny

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableT

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableAny

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funT()

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funAny()","if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableT()"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"", ""unused"")

package org.jetbrains.kotlin.fir.references.builder

import kotlin.contracts.*
import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.builder.FirBuilderDsl
import org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic
import org.jetbrains.kotlin.fir.references.FirResolvedErrorReference
import org.jetbrains.kotlin.fir.references.impl.FirResolvedErrorReferenceImpl
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.name.Name

@FirBuilderDsl
class FirResolvedErrorReferenceBuilder {
    var source: KtSourceElement? = null
    lateinit var name: Name",lateinit var resolvedSymbol: FirBasedSymbol<*>
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.js.inline.clean

import org.jetbrains.kotlin.js.backend.ast.JsNode
import org.jetbrains.kotlin.js.inline.util.IdentitySet
import java.util.*

internal class ReferenceTracker<in Reference, RemoveCandidate : JsNode> {
    private val reachable = IdentityHashMap<Reference, Boolean>()
    private val removableCandidates = IdentityHashMap<Reference, RemoveCandidate>()
    private val referenceFromTo = IdentityHashMap<Reference, MutableSet<Reference>>()
    private val visited = IdentitySet<Reference>()

    val removable: List<RemoveCandidate>
        get() {
            return reachable
                        .filter { !it.value }
                        .map { removableCandidates[it.key]!! }
        }

    fun addCandidateForRemoval(reference: Reference, candidate: RemoveCandidate) {
        assert(!isReferenceToRemovableCandidate(reference)) { ""Candidate for removal cannot be reassigned: $candidate"" }

        removableCandidates.put(reference, candidate)
        reachable.put(reference, false)
    }

    fun addRemovableReference(referrer: Reference, referenced: Reference) {
        if (!isReferenceToRemovableCandidate(referenced)) return

        getReferencedBy(referrer).add(referenced)

        if (isReachable(referrer)) {
            markReachable(referenced)
        }
    }

    fun markReachable(reference: Reference) {
        if (!isReferenceToRemovableCandidate(reference)) return",visited.add(reference)
"fun box() : String {
    test {
        <!RETURN_NOT_ALLOWED!>return@box<!> ""123""
    }

    return ""OK""
}

<!NOTHING_TO_INLINE!>inline<!> fun <T> test(p: T) {",p.toString()
"// !DIAGNOSTICS: -UNUSED_VARIABLE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_PARAMETER -UNUSED_EXPRESSION
// SKIP_TXT

/*
 * KOTLIN DIAGNOSTICS SPEC TEST (NEGATIVE)
 *
 * SPEC VERSION: 0.1-387
 * MAIN LINK: overload-resolution, choosing-the-most-specific-candidate-from-the-overload-candidate-set, algorithm-of-msc-selection -> paragraph 14 -> sentence 1
 * PRIMARY LINKS: overload-resolution, choosing-the-most-specific-candidate-from-the-overload-candidate-set, algorithm-of-msc-selection -> paragraph 7 -> sentence 3
 * overload-resolution, choosing-the-most-specific-candidate-from-the-overload-candidate-set, algorithm-of-msc-selection -> paragraph 11 -> sentence 1
 * overload-resolution, choosing-the-most-specific-candidate-from-the-overload-candidate-set, algorithm-of-msc-selection -> paragraph 11 -> sentence 2
 * overload-resolution, choosing-the-most-specific-candidate-from-the-overload-candidate-set, algorithm-of-msc-selection -> paragraph 11 -> sentence 4
 * NUMBER: 5
 * DESCRIPTION:  Both candidates are more applicable and few of them is non-parameterized
 */

// FILE: TestCase1.kt
/*
 * TESTCASE NUMBER: 1
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-38912
 */
package testPackCase1

import testPackCase1.I2.Companion.foo
import testPackCase1.I1.Companion.foo
import testPackCase1.I3.Companion.foo
import testPackCase1.I4.Companion.foo

class Case1() : I2, I1, I3, I4  {

    fun test() {
       <!CANNOT_INFER_PARAMETER_TYPE, NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>(1)
    }
}

interface I2 {
    companion object {
        fun <T> foo(x: Int): Unit = print(1) // (1)
    }
}

interface I1 {
    companion object {
        fun foo(x: Int, y: Any = """"): String = ""print(2)"" // (2)
    }
}

interface I3 {",companion object {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.native.executors

import org.jetbrains.kotlin.konan.target.AppleConfigurables
import org.jetbrains.kotlin.konan.target.Configurables",import org.jetbrains.kotlin.konan.target.HostManager
"}


    fun testObjectJvmStaticFunctionMainClass() {
        val mainKt = tmpdir.resolve(""main.kt"").apply {
            writeText(
                """"""
                    object ObjectMain {
                        @JvmStatic
                        fun main(args: Array<String>) = println(""hello"")
                    }
                """"""
            )
        }
        compileAndCheckMainClass(listOf(mainKt), expectedMainClass = ""ObjectMain"")
    }

    fun testCompanionObjectJvmStaticFunctionMainClass() {
        val mainKt = tmpdir.resolve(""main.kt"").apply {
            writeText(
                """"""
                    class Test {
                        companion object {
                            @JvmStatic
                            fun main(args: Array<String>) = println(""hello"")
                        }
                    }
                """"""
            )
        }
        compileAndCheckMainClass(listOf(mainKt), expectedMainClass = ""Test"")
    }

    fun testInterfaceCompanionObjectJvmStaticFunctionMainClass() {
        val mainKt = tmpdir.resolve(""main.kt"").apply {
            writeText(
                """"""
                    interface Test {
                        companion object {
                            @JvmStatic
                            fun main(args: Array<String>) = println(""hello"")
                        }
                    }
                """"""
            )
        }
        compileAndCheckMainClass(listOf(mainKt), expectedMainClass = ""Test"")
    }

    fun testMultipleMainsInOneFile() {
        val mainKt = tmpdir.resolve(""main.kt"").apply {
            writeText(
                """"""
                    object ObjectMain {
                        @JvmStatic
                        fun main(args: Array<String>) = println(""hello"")
                    }
                    object ObjectMain2 {
                        @JvmStatic
                        fun main(args: Array<String>) = println(""hello2"")
                    }
                    fun main(args: Array<String>) = println(""hello3"")
                """"""
            )
        }","compileAndCheckMainClass(listOf(mainKt), expectedMainClass = null)"
"// FIR_IDENTICAL
// FILE: A.java
import java.io.Closeable;

public class A {",public static void foo(Runnable r) {
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.backend.konan.optimizations

import org.jetbrains.kotlin.backend.konan.Context
import org.jetbrains.kotlin.backend.konan.InteropFqNames
import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.util.defaultType
import org.jetbrains.kotlin.ir.util.isFunction
import org.jetbrains.kotlin.ir.util.isReal
import org.jetbrains.kotlin.ir.util.parentAsClass
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
import org.jetbrains.kotlin.ir.visitors.IrElementVisitorVoid
import org.jetbrains.kotlin.ir.visitors.acceptChildrenVoid
import org.jetbrains.kotlin.ir.visitors.transformChildrenVoid
import org.jetbrains.kotlin.util.OperatorNameConventions",internal fun dce(
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.internal.testing.tcsmc

import jetbrains.buildServer.messages.serviceMessages.TestFinished
import jetbrains.buildServer.messages.serviceMessages.TestStarted
import jetbrains.buildServer.messages.serviceMessages.TestSuiteFinished
import jetbrains.buildServer.messages.serviceMessages.TestSuiteStarted
import org.junit.Test

class TestFailureTest : TCServiceMessagesClientTest() {
    @Test
    fun testJs() {
        assertEvents(
            """"""
STARTED SUITE root // root
  STARTED SUITE  // root/
    STARTED TEST displayName: Test, classDisplayName: , className: , name: Test // root//Test
      FAILURE AssertionError: Expected value to be true.
    at AssertionError_init_0 (mpplib2/build/tmp/expandedArchives/kotlin-stdlib-js-1.3-SNAPSHOT.jar_730a1b227513cf16a9b639e009a985fc/kotlin/exceptions.kt:102:37)
    at DefaultJsAsserter.failWithMessage_0 (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/DefaultJsAsserter.kt:80:19)
    at DefaultJsAsserter.assertTrue_o10pc4${'$'} (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/DefaultJsAsserter.kt:60:13)
    at DefaultJsAsserter.assertTrue_4mavae${'$'} (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/DefaultJsAsserter.kt:67:9)
    at assertTrue_0 (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/Assertions.kt:36:21)
    at SampleTestsJS.testHello (mpplib2/src/jsTest/kotlin/sample/SampleTestsJS.kt:9:9)
    at mpplib2/build/js_test_node_modules/mpplib2_test.js:59:38
    at Object.fn [as test] (mpplib2/build/tmp/expandedArchives/src/KotlinTestRunner.ts:12:25)
    at Object.test (mpplib2/build/tmp/expandedArchives/src/KotlinTestTeamCityReporter.ts:80:28)
    at test (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/TestApi.kt:57:15) // root//Test
    COMPLETED FAILURE // root//Test
  COMPLETED FAILURE // root/
COMPLETED FAILURE // root
        """"""
        ) {
            serviceMessage(TestSuiteStarted(""""))
            serviceMessage(TestStarted(""Test"", false, null))
            serviceMessage(
                ""testFailed"",
                mapOf(
                    ""name"" to ""Test"",
                    ""message"" to ""Expected value to be true"",
                    ""details"" to """"""AssertionError: Expected value to be true.
    at AssertionError_init_0 (mpplib2/build/tmp/expandedArchives/kotlin-stdlib-js-1.3-SNAPSHOT.jar_730a1b227513cf16a9b639e009a985fc/kotlin/exceptions.kt:102:37)
    at DefaultJsAsserter.failWithMessage_0 (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/DefaultJsAsserter.kt:80:19)
    at DefaultJsAsserter.assertTrue_o10pc4$ (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/DefaultJsAsserter.kt:60:13)
    at DefaultJsAsserter.assertTrue_4mavae$ (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/DefaultJsAsserter.kt:67:9)
    at assertTrue_0 (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/Assertions.kt:36:21)
    at SampleTestsJS.testHello (mpplib2/src/jsTest/kotlin/sample/SampleTestsJS.kt:9:9)
    at mpplib2/build/js_test_node_modules/mpplib2_test.js:59:38
    at Object.fn [as test] (mpplib2/build/tmp/expandedArchives/src/KotlinTestRunner.ts:12:25)
    at Object.test (mpplib2/build/tmp/expandedArchives/src/KotlinTestTeamCityReporter.ts:80:28)
    at test (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/TestApi.kt:57:15)""""""
                )
            )
            serviceMessage(TestFinished(""Test"", 0))
            serviceMessage(TestSuiteFinished(""""))
        }
    }

    @Test
    fun testNative() {",treatFailedTestOutputAsStacktrace = true
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.jvm",import org.jetbrains.kotlin.config.JvmTarget
"// FILE: test.kt

infix fun String.execute(p: String) = this + p

fun box(){
    test() execute
            fail()

    fail() execute
            test()
}

inline fun test() : String {
    return ""123""
}

fun fail() : String {","return ""fail"""
"object IMPORT_DIRECTIVE : CallType<KtExpression?>(DescriptorKindFilter.ALL)

    object PACKAGE_DIRECTIVE : CallType<KtExpression?>(DescriptorKindFilter.PACKAGES)

    object TYPE : CallType<KtExpression?>(
        DescriptorKindFilter(DescriptorKindFilter.CLASSIFIERS_MASK or DescriptorKindFilter.PACKAGES_MASK)
                exclude DescriptorKindExclude.EnumEntry
    )

    object DELEGATE : CallType<KtExpression?>(DescriptorKindFilter.FUNCTIONS exclude NonOperatorExclude)

    object ANNOTATION : CallType<KtExpression?>(
        DescriptorKindFilter(DescriptorKindFilter.CLASSIFIERS_MASK or DescriptorKindFilter.PACKAGES_MASK)
                exclude NonAnnotationClassifierExclude
    )

    private object NonInfixExclude : DescriptorKindExclude() {
        override fun excludes(descriptor: DeclarationDescriptor) =
            !(descriptor is SimpleFunctionDescriptor && descriptor.isInfix)

        override val fullyExcludedDescriptorKinds: Int
            get() = 0
    }

    private object NonOperatorExclude : DescriptorKindExclude() {
        override fun excludes(descriptor: DeclarationDescriptor) =
            !(descriptor is SimpleFunctionDescriptor && descriptor.isOperator)

        override val fullyExcludedDescriptorKinds: Int
            get() = 0
    }

    private object CallableReferenceExclude : DescriptorKindExclude() {
        override fun excludes(descriptor: DeclarationDescriptor) /* currently not supported for locals and synthetic */ =
            descriptor !is CallableMemberDescriptor || descriptor.kind == CallableMemberDescriptor.Kind.SYNTHESIZED

        override val fullyExcludedDescriptorKinds: Int
            get() = 0
    }

    private object NonAnnotationClassifierExclude : DescriptorKindExclude() {
        override fun excludes(descriptor: DeclarationDescriptor): Boolean {
            if (descriptor !is ClassifierDescriptor) return false
            return descriptor !is ClassDescriptor || descriptor.kind != ClassKind.ANNOTATION_CLASS
        }

        override val fullyExcludedDescriptorKinds: Int get() = 0
    }

    private object AbstractMembersExclude : DescriptorKindExclude() {
        override fun excludes(descriptor: DeclarationDescriptor) =
            descriptor is CallableMemberDescriptor && descriptor.modality == Modality.ABSTRACT

        override val fullyExcludedDescriptorKinds: Int
            get() = 0
    }
}

sealed class CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<TReceiver>>(
    val callType: TCallType,
    val receiver: TReceiver
) {
    object UNKNOWN : CallTypeAndReceiver<Nothing?, CallType.UNKNOWN>(CallType.UNKNOWN, null)
    object DEFAULT : CallTypeAndReceiver<Nothing?, CallType.DEFAULT>(CallType.DEFAULT, null)","class DOT(receiver: KtExpression) : CallTypeAndReceiver<KtExpression, CallType.DOT>(CallType.DOT, receiver)"
"import org.jetbrains.kotlin.codegen.pseudoInsns.fakeAlwaysTrueIfeq
import org.jetbrains.kotlin.lexer.KtTokens
import org.jetbrains.kotlin.types.KotlinType
import org.jetbrains.org.objectweb.asm.Label
import org.jetbrains.org.objectweb.asm.Opcodes.*
import org.jetbrains.org.objectweb.asm.Type
import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter

open class BranchedValue(
    val arg1: StackValue,
    val arg2: StackValue? = null,
    val operandType: Type,
    val opcode: Int
) : StackValue(Type.BOOLEAN_TYPE) {

    override fun putSelector(type: Type, kotlinType: KotlinType?, v: InstructionAdapter) {
        val branchJumpLabel = Label()
        condJump(branchJumpLabel, v, true)
        val endLabel = Label()
        v.iconst(1)
        v.visitJumpInsn(GOTO, endLabel)
        v.visitLabel(branchJumpLabel)
        v.iconst(0)
        v.visitLabel(endLabel)
        coerceTo(type, kotlinType, v)
    }

    open fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean) {
        if (arg1 is CondJump) arg1.condJump(jumpLabel, v, jumpIfFalse) else arg1.put(operandType, v)
        arg2?.put(operandType, v)
        v.visitJumpInsn(patchOpcode(if (jumpIfFalse) opcode else negatedOperations[opcode]!!, v), jumpLabel)
    }

    open fun loopJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean) {
        condJump(jumpLabel, v, jumpIfFalse)
    }

    protected open fun patchOpcode(opcode: Int, v: InstructionAdapter): Int = opcode

    companion object {
        val negatedOperations = hashMapOf<Int, Int>()

        val TRUE: BranchedValue = object : BranchedValue(StackValue.none()/*not used*/, null, Type.BOOLEAN_TYPE, IFEQ) {
            override fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean) {
                v.nop()
                if (!jumpIfFalse) {
                    v.goTo(jumpLabel)
                }
            }

            override fun loopJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean) {
                v.nop()
                if (!jumpIfFalse) {
                    v.fakeAlwaysTrueIfeq(jumpLabel)
                } else {
                    v.fakeAlwaysFalseIfeq(jumpLabel)
                }
            }

            override fun putSelector(type: Type, kotlinType: KotlinType?, v: InstructionAdapter) {
                v.iconst(1)
                coerceTo(type, kotlinType, v)
            }
        }","val FALSE: BranchedValue = object : BranchedValue(StackValue.none()/*not used*/, null, Type.BOOLEAN_TYPE, IFEQ) {"
"// DONT_TARGET_EXACT_BACKEND: JS
// ES_MODULES
// MODULE: lib
// FILE: lib.kt
package lib

val foo = 23

val boo: Int
    get() = 42

external val bar: Int = definedExternally

external val far: Int",get() = definedExternally
"// !LANGUAGE: +AssigningArraysToVarargsInNamedFormInAnnotations

// FILE: JavaAnn.java

@interface JavaAnn {
    String[] value() default {};
    String[] path() default {};
}

// FILE: test.kt

annotation class Ann(vararg val s: String)

@Ann(s = arrayOf())
fun test1() {}

@Ann(s = <!TYPE_MISMATCH!>intArrayOf()<!>)
fun test2() {}

@Ann(s = <!TYPE_MISMATCH!>arrayOf(1)<!>)
fun test3() {}

@Ann(""value1"", ""value2"")
fun test4() {}

@Ann(s = [""value""])
fun test5() {}

@JavaAnn(value = arrayOf(""value""))
fun jTest1() {}

@JavaAnn(value = [""value""])
fun jTest2() {}

@JavaAnn(value = [""value""], path = [""path""])
fun jTest3() {}


annotation class IntAnn(vararg val i: Int)

@IntAnn(i = [1, 2])
fun foo1() {}

@IntAnn(i = intArrayOf(0))",fun foo2() {}
"// WITH_REFLECT

// TARGET_BACKEND: JVM

// FILE: JavaAnn.java

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
@interface JavaAnn {
    String[] value() default {};
    String[] path() default {};
}

// FILE: test.kt

import java.util.Arrays
import kotlin.reflect.KClass",import kotlin.reflect.KFunction0
"PartialLinkageSupportForLoweringsImpl(builtIns, PartialLinkageLogger(messageLogger, partialLinkageConfig.logLevel))
else
    PartialLinkageSupportForLowerings.DISABLED

internal class PartialLinkageSupportForLoweringsImpl(
    private val builtIns: IrBuiltIns,
    private val logger: PartialLinkageLogger
) : PartialLinkageSupportForLowerings {
    override val isEnabled get() = true

    /** To track the amount of rendered linkage issues. */
    var linkageIssuesRendered = 0
        private set

    /**
     * To track the amount of logged linkage issues.
     * Note that the following condition is always true: [linkageIssuesLogged] <= [linkageIssuesRendered].
     */
    var linkageIssuesLogged = 0
        private set

    /**
     * To track the amount of generated `throw` expressions.
     * Note that the following condition is always true: [throwExpressionsGenerated] <= [linkageIssuesRendered].
     */
    var throwExpressionsGenerated = 0
        private set

    override fun throwLinkageError(
        partialLinkageCase: PartialLinkageCase,
        element: IrElement,
        file: PLFile,
        doNotLog: Boolean
    ): IrCall {
        val errorMessage = if (doNotLog)
            renderLinkageError(partialLinkageCase) // Just render a message.
        else
            renderAndLogLinkageError(partialLinkageCase, element, file) // Render + log with the appropriate severity.

        throwExpressionsGenerated++ // Track each generated `throw` expression.

        return IrCallImpl(
            startOffset = element.startOffset,
            endOffset = element.endOffset,
            type = builtIns.nothingType,
            symbol = builtIns.linkageErrorSymbol,
            typeArgumentsCount = 0,
            valueArgumentsCount = 1,
            origin = IrStatementOrigin.PARTIAL_LINKAGE_RUNTIME_ERROR
        ).apply {
            putValueArgument(0, IrConstImpl.string(startOffset, endOffset, builtIns.stringType, errorMessage))
        }
    }

    fun renderAndLogLinkageError(partialLinkageCase: PartialLinkageCase, element: IrElement, file: PLFile): String {
        val errorMessage = renderLinkageError(partialLinkageCase)
        val locationInSourceCode = file.computeLocationForOffset(element.startOffsetOfFirstDenotableIrElement())

        linkageIssuesLogged++ // Track each logged linkage issue.
        logger.log(errorMessage, locationInSourceCode)

        return errorMessage
    }

    private fun renderLinkageError(partialLinkageCase: PartialLinkageCase): String {",linkageIssuesRendered++ // Track each rendered linkage issue.
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/ir/ir.tree/tree-generator/ReadMe.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"")

package org.jetbrains.kotlin.ir.declarations.impl

import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.ir.IrImplementationDetail
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrDeclarationOrigin
import org.jetbrains.kotlin.ir.declarations.IrEnumEntry
import org.jetbrains.kotlin.ir.declarations.IrFactory
import org.jetbrains.kotlin.ir.expressions.IrConstructorCall
import org.jetbrains.kotlin.ir.expressions.IrExpressionBody
import org.jetbrains.kotlin.ir.symbols.IrEnumEntrySymbol
import org.jetbrains.kotlin.name.Name

class IrEnumEntryImpl @IrImplementationDetail constructor(
    override val startOffset: Int,","override val endOffset: Int,"
"override fun setUp() {
        super.setUp()
        header = null
        packageParts.clear()
        serializedIrFiles.clear()
    }

    override fun Services.Builder.registerAdditionalServices() {
        if (header != null) {
            register(
                IncrementalDataProvider::class.java,
                IncrementalDataProviderImpl(
                    headerMetadata = header!!,
                    compiledPackageParts = packageParts,
                    metadataVersion = JsMetadataVersion.INSTANCE.toArray(),
                    packageMetadata = emptyMap(), // TODO pass correct metadata
                    serializedIrFiles = serializedIrFiles
                )
            )
        }

        register(IncrementalResultsConsumer::class.java, IncrementalResultsConsumerImpl())
    }

    override fun markDirty(removedAndModifiedSources: Iterable<File>) {
        removedAndModifiedSources.forEach {
            packageParts.remove(it)
            serializedIrFiles.remove(it)
        }
    }

    override fun processCompilationResults(outputItemsCollector: OutputItemsCollectorImpl, services: Services) {
        val incrementalResults = services[IncrementalResultsConsumer::class.java] as IncrementalResultsConsumerImpl
        header = incrementalResults.headerMetadata
        packageParts.putAll(incrementalResults.packageParts)
        serializedIrFiles.putAll(incrementalResults.irFileData)
    }

    protected open val jsStdlibFile: File
        get() = PathUtil.kotlinPathsForDistDirectoryForTests.jsStdLibKlibPath

    protected open fun configureAdditionalArgs(args: K2JSCompilerArguments) {
    }

    override fun runCompiler(filesToCompile: Iterable<File>, env: JpsCompilerEnvironment): Any? {
        val args = K2JSCompilerArguments().apply {
            val libPaths = arrayListOf(jsStdlibFile.absolutePath) + (libraries ?: """").split(File.pathSeparator)
            libraries = libPaths.joinToString(File.pathSeparator)
            reportOutputFiles = true
            freeArgs = filesToCompile.map { it.canonicalPath }
            useFirLT = false
        }
        configureAdditionalArgs(args)
        return runJSCompiler(args, env)
    }
}

abstract class AbstractLookupTrackerTest : TestWithWorkingDir() {
    private val DECLARATION_KEYWORDS = listOf(""interface"", ""class"", ""enum class"", ""object"", ""fun"", ""operator fun"", ""val"", ""var"")
    private val DECLARATION_STARTS_WITH = DECLARATION_KEYWORDS.map { it + "" "" }

    // ignore KDoc like comments which starts with `/**`, example: /** text */
    private val COMMENT_WITH_LOOKUP_INFO = ""/\\*[^*]+\\*/"".toRegex()",protected lateinit var srcDir: File
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_PARAMETER
// !OPT_IN: kotlin.RequiresOptIn

import kotlin.experimental.ExperimentalTypeInference

suspend fun main() {",iFlow { emit(1) }
"expect class PClass
expect interface PInterface
expect object PObject
expect enum class PEnumClass
expect annotation class PAnnotationClass

internal expect object InternalObject
public expect object PublicObject

open expect class OpenClass
abstract expect class AbstractClass
final expect class FinalClass

expect class C1<A>
expect class C2<B>
expect class C3<D, E : D>

expect class C4<F>


expect abstract class ExtendsNumber : Number",expect fun interface FunInterface {
"fun actualizeClassifiers() {
        val classSymbolRemapper = object : SymbolRemapper.Empty() {
            override fun getReferencedClass(symbol: IrClassSymbol): IrClassSymbol {
                if (!symbol.owner.isExpect) return symbol
                if (symbol.owner.containsOptionalExpectation()) return symbol
                val classId = symbol.owner.classIdOrFail
                classActualizationInfo.actualTypeAliases[classId]?.let { return it.owner.expandedType.classOrFail }
                classActualizationInfo.actualClasses[classId]?.let { return it }
                // Can't happen normally, but possible on incorrect code.
                // In that case, it would later fail with error in matching inside [actualizeCallablesAndMergeModules]
                // Let's leave to expect class as is for that case, it is probably best effort to make errors reasonable.
                return symbol
            }

            override fun getReferencedClassifier(symbol: IrClassifierSymbol): IrClassifierSymbol {
                if (symbol !is IrClassSymbol) return symbol
                return getReferencedClass(symbol)
            }
        }
        dependentFragments.forEach { it.transform(ActualizerVisitor(classSymbolRemapper), null) }
    }

    fun actualizeCallablesAndMergeModules(): Map<IrSymbol, IrSymbol> {
        // 1. Collect expect-actual links for members of classes found on step 1.
        val expectActualMap = collector.matchAllExpectDeclarations(classActualizationInfo)

        if (useFirBasedFakeOverrideGenerator) {
            //   2. Actualize expect fake overrides in non-expect classes inside common or multi-platform module.
            //      It's probably important to run FakeOverridesActualizer before ActualFakeOverridesAdder
            FakeOverridesActualizer(expectActualMap, ktDiagnosticReporter).apply { dependentFragments.forEach { visitModuleFragment(it) } }

            //   3. Add fake overrides to non-expect classes inside common or multi-platform module,
            //      taken from these non-expect classes actualized super classes.
            ActualFakeOverridesAdder(
                expectActualMap,
                classActualizationInfo.actualClasses,
                typeSystemContext
            ).apply { dependentFragments.forEach { visitModuleFragment(it) } }
        }

        //   4. Copy and actualize function parameter default values from expect functions
        val symbolRemapper = ActualizerSymbolRemapper(expectActualMap)
        FunctionDefaultParametersActualizer(symbolRemapper, expectActualMap).actualize()

        //   5. Actualize expect calls in dependent fragments using info obtained in the previous steps
        val actualizerVisitor = ActualizerVisitor(symbolRemapper)
        dependentFragments.forEach { it.transform(actualizerVisitor, null) }

        //   6. Move all declarations to mainFragment
        mergeIrFragments(mainFragment, dependentFragments)
        return expectActualMap
    }

    fun runChecksAndFinalize(expectActualMap: Map<IrSymbol, IrSymbol>) : IrActualizedResult {
        //   Remove top-only expect declarations since they are not needed anymore and should not be presented in the final IrFragment
        //   Also, it doesn't remove unactualized expect declarations marked with @OptionalExpectation
        val removedExpectDeclarations = removeExpectDeclarations(dependentFragments, expectActualMap)

        IrExpectActualCheckers(expectActualMap, classActualizationInfo, typeSystemContext, ktDiagnosticReporter).check()
        return IrActualizedResult(removedExpectDeclarations, expectActualMap)
    }

    private fun removeExpectDeclarations(dependentFragments: List<IrModuleFragment>, expectActualMap: Map<IrSymbol, IrSymbol>): List<IrDeclaration> {
        val removedExpectDeclarations = mutableListOf<IrDeclaration>()",for (fragment in dependentFragments) {
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.jvm.checkers.expression

import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.expression.FirFunctionCallChecker
import org.jetbrains.kotlin.fir.analysis.diagnostics.jvm.FirJvmErrors
import org.jetbrains.kotlin.fir.declarations.FirAnonymousFunction
import org.jetbrains.kotlin.fir.declarations.FirFunction
import org.jetbrains.kotlin.fir.declarations.utils.isSuspend
import org.jetbrains.kotlin.fir.expressions.FirFunctionCall
import org.jetbrains.kotlin.fir.expressions.resolvedArgumentMapping
import org.jetbrains.kotlin.fir.references.toResolvedCallableSymbol
import org.jetbrains.kotlin.fir.resolve.transformers.unwrapAnonymousFunctionExpression
import org.jetbrains.kotlin.fir.types.FirResolvedTypeRef
import org.jetbrains.kotlin.fir.types.isSuspendOrKSuspendFunctionType
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.utils.addToStdlib.runIf

object FirJvmSuspensionPointInsideMutexLockChecker : FirFunctionCallChecker(MppCheckerKind.Common) {
    private val synchronizedCallableId = CallableId(FqName(""kotlin""), Name.identifier(""synchronized""))
    private val withLockCallableId = CallableId(FqName(""kotlin.concurrent""), Name.identifier(""withLock""))
    private val synchronizedBlockParamName = Name.identifier(""block"")

    override fun check(expression: FirFunctionCall, context: CheckerContext, reporter: DiagnosticReporter) {
        val symbol = expression.calleeReference.toResolvedCallableSymbol() ?: return
        if (!symbol.isSuspend) return
        var anonymousFunctionArg: FirAnonymousFunction? = null
        var isMutexLockFound = false
        var isSuspendFunctionFound = false

        for (element in context.containingElements.asReversed()) {
            if (element is FirFunctionCall) {
                val callableSymbol = element.calleeReference.toResolvedCallableSymbol() ?: continue
                val enclosingAnonymousFuncParam = element.resolvedArgumentMapping?.firstNotNullOfOrNull { entry ->",entry.key.unwrapAnonymousFunctionExpression()?.let {
"dfs(it)
                }
            sortedLibraries += library
        }

        for (library in artifactsLibraries.values)
            if (library !in visitedLibraries)
                dfs(library)

        for (library in sortedLibraries) {
            if (File(cacheDirectory, library.uniqueName.cachedName).listFilesOrEmpty().isNotEmpty())
                continue
            logger.info(""Compiling ${library.uniqueName} to cache"")
            val args = mutableListOf(
                ""-p"", konanCacheKind.produce!!,
                ""-target"", target
            )
            if (debuggable) args += ""-g""
            args += konanPropertiesService.additionalCacheFlags(konanTarget)
            args += settings.externalDependenciesArgs
            args += ""$PARTIAL_LINKAGE_PARAMETER=$partialLinkageMode""
            args += ""-Xadd-cache=${library.libraryFile.absolutePath}""
            args += ""-Xcache-directory=${cacheDirectory.absolutePath}""
            args += ""-Xcache-directory=${rootCacheDirectory.absolutePath}""

            dependenciesCacheDirectories.forEach {
                args += ""-Xcache-directory=${it.absolutePath}""
            }
            getAllDependencies(dependency)
                .flatMap { getArtifacts(it) }
                .map { it.file }
                .filterKlibsPassedToCompiler()
                .forEach {
                    args += ""-l""
                    args += it.absolutePath
                }
            library.unresolvedDependencies
                .mapNotNull { artifactsLibraries[it.path] }
                .forEach {
                    args += ""-l""
                    args += it.libraryFile.absolutePath
                }
            objectFactory.KotlinNativeCompilerRunner(settings.runnerSettings, GradleBuildMetricsReporter()).run(args)
        }
    }

    private val String.cachedName
        get() = getCacheFileName(this, konanCacheKind)

    private fun ensureCompilerProvidedLibPrecached(
        platformLibName: String,
        platformLibs: Map<String, File>,
        visitedLibs: MutableSet<String>,
    ) {
        if (platformLibName in visitedLibs)
            return
        visitedLibs += platformLibName
        val platformLib = platformLibs[platformLibName] ?: error(""$platformLibName is not found in platform libs"")
        if (File(rootCacheDirectory, platformLibName.cachedName).listFilesOrEmpty().isNotEmpty())
            return
        val unresolvedDependencies = resolveSingleFileKlib(
            KFile(platformLib.absolutePath),
            logger = GradleLoggerAdapter(logger),
            strategy = nativeSingleFileResolveStrategy
        ).unresolvedDependencies",for (dependency in unresolvedDependencies)
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.js.backend.ast

class JsImport(
    val module: String,
    val target: Target,
) : SourceInfoAwareJsNode(), JsStatement {
    constructor(module: String, vararg elements: Element) : this(module, Target.Elements(elements.toMutableList()))

    val elements: MutableList<Element>
        get() = (target as Target.Elements).elements

    sealed class Target {
        object Effect : Target()
        class Elements(val elements: MutableList<Element>) : Target()
        class Default(val name: JsNameRef) : Target() {
            constructor(name: String) : this(JsNameRef(name))
        }

        class All(val alias: JsNameRef) : Target() {
            constructor(alias: String) : this(JsNameRef(alias))
        }
    }

    class Element(
        val name: JsName,
        val alias: JsNameRef? = null
    )

    override fun accept(visitor: JsVisitor) {
        visitor.visitImport(this)
    }

    override fun acceptChildren(visitor: JsVisitor) {
        when (target) {
            is Target.Effect -> {}
            is Target.All -> visitor.accept(target.alias)",is Target.Default -> visitor.accept(target.name)
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.types

import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.container.DefaultImplementation
import org.jetbrains.kotlin.container.PlatformSpecificExtension
import org.jetbrains.kotlin.descriptors.annotations.Annotations
import org.jetbrains.kotlin.renderer.DescriptorRenderer
import org.jetbrains.kotlin.renderer.DescriptorRendererOptions
import org.jetbrains.kotlin.types.checker.KotlinTypeRefiner
import org.jetbrains.kotlin.types.model.DynamicTypeMarker
import org.jetbrains.kotlin.types.typeUtil.builtIns

@DefaultImplementation(impl = DynamicTypesSettings::class)
open class DynamicTypesSettings : PlatformSpecificExtension<DynamicTypesSettings> {
    open val dynamicTypesAllowed: Boolean
        get() = false
}

class DynamicTypesAllowed : DynamicTypesSettings() {
    override val dynamicTypesAllowed: Boolean
        get() = true
}

fun KotlinType.isDynamic(): Boolean = unwrap() is DynamicType

fun createDynamicType(builtIns: KotlinBuiltIns) = DynamicType(builtIns, TypeAttributes.Empty)

class DynamicType(","builtIns: KotlinBuiltIns,"
"assertEquals(
                setOf(""commonMain"", ""nativeMain""),
                sourceJarSourceRoots[null]
            )
            assertEquals(setOf(""commonMain"", ""jvm6Main""), sourceJarSourceRoots[""jvm6""])
            assertEquals(setOf(""commonMain"", ""nodeJsMain""), sourceJarSourceRoots[""nodejs""])
            assertEquals(setOf(""commonMain"", ""nativeMain"", ""linux64Main""), sourceJarSourceRoots[""linux64""])
        }
    }

    @Test
    fun testConsumeMppLibraryFromNonKotlinProject() {
        val libRepo = with(transformNativeTestProject(""sample-lib"", gradleVersion, ""new-mpp-lib-and-app"")) {
            build(""publish"") { assertSuccessful() }
            projectDir.resolve(""repo"")
        }

        with(transformNativeTestProject(""sample-app-without-kotlin"", gradleVersion, ""new-mpp-lib-and-app"")) {
            setupWorkingDir()
            gradleBuildScript().appendText(""\nrepositories { maven { url '${libRepo.toURI()}' } }"")

            build(""assemble"") {
                assertSuccessful()
                assertTasksExecuted("":compileJava"")
                assertFileExists(""build/classes/java/main/A.class"")
            }
        }
    }

    @Test
    fun testPublishMultimoduleProjectWithMetadata() {
        val libProject = transformNativeTestProject(""sample-lib"", gradleVersion, ""new-mpp-lib-and-app"")
        libProject.setupWorkingDir()

        transformNativeTestProject(""sample-external-lib"", gradleVersion, ""new-mpp-lib-and-app"").apply {
            setupWorkingDir()
            // Publish it into local repository of adjacent lib:
            gradleBuildScript().appendText(
                ""\n"" + """"""
                publishing {
                    repositories {
                        maven { url ""${'$'}{rootProject.projectDir.absolutePath.replace('\\', '/')}/../sample-lib/repo"" }
                    }
                }
                """""".trimIndent()
            )
            build(""publish"") {
                assertSuccessful()
            }
        }

        val appProject = transformNativeTestProject(""sample-app"", gradleVersion, ""new-mpp-lib-and-app"")

        with(libProject) {
            setupWorkingDir()
            appProject.setupWorkingDir(false)
            appProject.projectDir.copyRecursively(projectDir.resolve(""sample-app""))

            gradleSettingsScript().writeText(""include 'sample-app'"")
            gradleBuildScript(""sample-app"").modify {
                it.replace(""'com.example:sample-lib:1.0'"", ""project(':')"") + ""\n"" + """"""
                apply plugin: 'maven-publish'
                group = ""com.exampleapp""
                version = ""1.0""
                publishing {",repositories {
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.ic

import org.jetbrains.kotlin.backend.common.linkage.issues.checkNoUnboundSymbols
import org.jetbrains.kotlin.backend.common.linkage.partial.createPartialLinkageSupportForLinker
import org.jetbrains.kotlin.backend.common.serialization.DeserializationStrategy
import org.jetbrains.kotlin.backend.common.serialization.checkIsFunctionInterface
import org.jetbrains.kotlin.backend.common.serialization.encodings.BinarySymbolData
import org.jetbrains.kotlin.backend.common.serialization.signature.IdSignatureDescriptor
import org.jetbrains.kotlin.config.CompilerConfiguration
import org.jetbrains.kotlin.config.languageVersionSettings
import org.jetbrains.kotlin.descriptors.ModuleDescriptor
import org.jetbrains.kotlin.descriptors.impl.ModuleDescriptorImpl
import org.jetbrains.kotlin.incremental.components.LookupTracker
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.backend.js.FunctionTypeInterfacePackages
import org.jetbrains.kotlin.ir.backend.js.JsFactories
import org.jetbrains.kotlin.ir.backend.js.lower.serialization.ir.JsIrLinker
import org.jetbrains.kotlin.ir.backend.js.lower.serialization.ir.JsManglerDesc
import org.jetbrains.kotlin.ir.declarations.IrFactory",import org.jetbrains.kotlin.ir.declarations.IrFile
"for (mask in 0 until (1 shl 4)) {
                        val casedBefore = cased().repeat((mask shr 0) and 1)
                        val casedAfter = cased().repeat((mask shr 1) and 1)
                        val otherBefore = other().repeat((mask shr 2) and 1)
                        val otherAfter = other().repeat((mask shr 3) and 1)

                        val resultSigmaNearby =
                                if (otherBefore.isEmpty() && casedBefore.isNotEmpty() && (otherAfter.isNotEmpty() || casedAfter.isEmpty()))
                                    specialSigmaNearby
                                else
                                    lowerSigmaNearby

                        val actual = (casedBefore + otherBefore + sigmaNearby + otherAfter + casedAfter).lowercase()
                        val expected = casedBefore.lowercase() + otherBefore + resultSigmaNearby + otherAfter + casedAfter.lowercase()

                        assertEquals(
                                expected,
                                actual,
                                ""Expected <$expected>${expected.map { it.hex() }}, Actual <$actual>${actual.map { it.hex() }}""
                        )
                    }
                }
            }
        }
    }

    @Test
    fun uppercase() {
        // Non-ASCII
        assertEquals(""\u00DE\u03A9\u0403\uA779"", ""\u00FE\u03A9\u0453\uA77A"".uppercase())

        // Surrogate pairs
        assertEquals(""\ud801\udc00"", ""\ud801\udc28"".uppercase())
        assertEquals(""\ud801\udc00"", ""\ud801\udc00"".uppercase())
    }

    @Test
    fun capitalize() {
        // Non-ASCII
        assertEquals(""\u00DE\u03A9\u0453\uA77A"", ""\u00FE\u03A9\u0453\uA77A"".capitalize())
    }

    @Test fun indexOfString() {
        assertEquals(1, ""bceded"".indexOf(""ced"", -1))

        assertEquals(-1, ""bceded"".indexOf(""e"", 7))
        assertEquals(-1, ""bceded"".indexOf(""e"", Int.MAX_VALUE))
        assertEquals(6, ""bceded"".indexOf("""", Int.MAX_VALUE))

        assertEquals(-1, """".indexOf(""a"", -3))
        assertEquals(0, """".indexOf("""", 0))
    }

    @Test
    fun indexOfChar() {
        assertEquals(-1, ""bcedef"".indexOf('e', 5))

        assertEquals(-1, """".indexOf('a', -3))
        assertEquals(-1, """".indexOf('a', 10))

        assertEquals(-1, """".indexOf(0.toChar(), -3))
        assertEquals(-1, """".indexOf(0.toChar(), 10))
    }

    @Test",fun equalsIgnoreCase() {
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin

import org.gradle.api.Project
import org.gradle.api.file.FileCollection
import org.gradle.api.provider.Provider
import org.gradle.api.tasks.TaskProvider
import org.jetbrains.kotlin.gradle.dsl.*
import org.jetbrains.kotlin.gradle.internal.KaptGenerateStubsTask
import org.jetbrains.kotlin.gradle.internal.KaptWithoutKotlincTask
import org.jetbrains.kotlin.gradle.tasks.*
import org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile
import org.jetbrains.kotlin.gradle.tasks.configuration.KaptGenerateStubsConfig
import org.jetbrains.kotlin.gradle.tasks.configuration.KaptWithoutKotlincConfig
import org.jetbrains.kotlin.gradle.tasks.configuration.KotlinCompileConfig
import org.jetbrains.kotlin.gradle.utils.configureExperimentalTryNext

/** Plugin that can be used by third-party plugins to create Kotlin-specific DSL and tasks (compilation and KAPT) for JVM platform. */
abstract class KotlinBaseApiPlugin : DefaultKotlinBasePlugin(), KotlinJvmFactory {

    private lateinit var myProject: Project
    private val taskCreator = KotlinTasksProvider()

    override fun apply(project: Project) {
        super.apply(project)
        myProject = project
        setupAttributeMatchingStrategy(project, isKotlinGranularMetadata = false)
    }

    override fun addCompilerPluginDependency(dependency: Provider<Any>) {
        myProject.dependencies.addProvider(
            PLUGIN_CLASSPATH_CONFIGURATION_NAME,
            dependency
        )
    }

    override fun getCompilerPlugins(): FileCollection {
        return myProject.configurations.getByName(PLUGIN_CLASSPATH_CONFIGURATION_NAME)
    }

    override fun createCompilerJvmOptions(): KotlinJvmCompilerOptions {",return myProject.objects
")
    ),
    ""BasicText"" to Function(
        ""BasicText"",
        annotations = composable,
        body = listOf(
            call(""CoreText"")
        )
    ),
    ""Text"" to Function(
        ""Text"",
        annotations = composable,
        body = listOf(
            call(""BasicText"")
        )
    ),
    ""Circle"" to Function(
        ""Circle"",
        annotations = composable,
        body = listOf(
            call(""Vector/1"")
        )
    ),
    ""Square"" to Function(
        ""Square"",
        annotations = composable,
        body = listOf(
            call(""Vector/1"")
        )
    ),
    ""Provider"" to Function(
        ""Provider"",
        annotations = composable,
        parameters = listOf(Parameter(""content"", composableLambda())),
        body = listOf(
            call(""content"")
        )
    ),
    ""Row"" to Function(
        ""Row"",
        annotations = composable,
        parameters = listOf(Parameter(""content"", composableLambda())),
        body = listOf(
            call(""Layout/2"", Ref(""content""))
        )
    ),
    ""Button"" to Function(
        ""Button"",
        annotations = composable,
        parameters = listOf(Parameter(""content"", composableLambda())),
        body = listOf(
            call(""Row"", Ref(""content""))
        )
    ),
    ""Layer"" to Function(
        ""Layer"",
        annotations = composable,
        parameters = listOf(Parameter(""content"", composableLambda())),
        body = listOf(
            call(""Vector/2"", Ref(""content""))
        )
    ),

    ""SimpleOpen"" to Function(""SimpleOpen"", annotations = composable),","""OpenRecursive"" to Function("
"package test

import android.app.Activity
import android.view.View
import android.widget.*
import kotlinx.android.synthetic.main.layout.*
import kotlinx.android.synthetic.main.layout1.*

class R {
    class id {
        companion object {
            const val item_detail_container = 0
            const val textView1 = 1
            const val password = 2",const val textView2 = 3
")

        MAP.put(
            ErrorsParcelize.PARCELABLE_SHOULD_NOT_BE_ENUM_CLASS,
            ""'Parcelable' should not be a 'enum class'""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_SHOULD_BE_INSTANTIABLE,
            ""'Parcelable' should not be an 'abstract' class""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_CANT_BE_INNER_CLASS,
            ""'Parcelable' can't be an inner class""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_CANT_BE_LOCAL_CLASS,
            ""'Parcelable' can't be a local class""
        )

        MAP.put(
            ErrorsParcelize.NO_PARCELABLE_SUPERTYPE,
            ""No 'Parcelable' supertype""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_SHOULD_HAVE_PRIMARY_CONSTRUCTOR,
            ""'Parcelable' should have a primary constructor""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_PRIMARY_CONSTRUCTOR_IS_EMPTY,
            ""The primary constructor is empty, no data will be serialized to 'Parcel'""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_CONSTRUCTOR_PARAMETER_SHOULD_BE_VAL_OR_VAR,
            ""'Parcelable' constructor parameter should be 'val' or 'var'""
        )

        MAP.put(
            ErrorsParcelize.PROPERTY_WONT_BE_SERIALIZED,
            ""Property would not be serialized into a 'Parcel'. Add '@IgnoredOnParcel' annotation to remove the warning""
        )

        MAP.put(
            ErrorsParcelize.OVERRIDING_WRITE_TO_PARCEL_IS_NOT_ALLOWED,
            ""Overriding 'writeToParcel' is not allowed. Use 'Parceler' companion object instead""
        )

        MAP.put(
            ErrorsParcelize.CREATOR_DEFINITION_IS_NOT_ALLOWED,
            ""'CREATOR' definition is not allowed. Use 'Parceler' companion object instead""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_TYPE_NOT_SUPPORTED,
            ""Type is not directly supported by 'Parcelize'. "" +
                    ""Annotate the parameter type with '@RawValue' if you want it to be serialized using 'writeValue()'""
        )

        MAP.put(
            ErrorsParcelize.PARCELER_SHOULD_BE_OBJECT,","""Parceler should be an object"""
"interface KonanArtifactSpec {
    fun artifactName(name: String)
}

interface KonanArtifactWithLibrariesSpec: KonanArtifactSpec {
    fun libraries(closure: Closure<Unit>)
    fun libraries(action: Action<KonanLibrariesSpec>)
    fun libraries(configure: KonanLibrariesSpec.() -> Unit)

    fun noDefaultLibs(flag: Boolean)
    fun noEndorsedLibs(flag: Boolean)
    fun dependencies(closure: Closure<Unit>)
}

interface KonanBuildingSpec: KonanArtifactWithLibrariesSpec {
    fun dumpParameters(flag: Boolean)

    fun extraOpts(vararg values: Any)
    fun extraOpts(values: List<Any>)
}

interface KonanCompileSpec: KonanBuildingSpec {
    fun srcDir(dir: Any)

    fun srcFiles(vararg files: Any)
    fun srcFiles(files: Collection<Any>)

    // DSL. Native libraries.

    fun nativeLibrary(lib: Any)
    fun nativeLibraries(vararg libs: Any)
    fun nativeLibraries(libs: FileCollection)

    // DSL. Multiplatform projects
    fun enableMultiplatform(flag: Boolean)

    // TODO: Get rid of commonSourceSet in 0.7
    @Deprecated(""Use commonSourceSets instead"", ReplaceWith(""commonSourceSets(sourceSetName)""))
    fun commonSourceSet(sourceSetName: String)
    fun commonSourceSets(vararg sourceSetNames: String)

    fun commonSrcDir(dir: Any)

    fun commonSrcFiles(vararg files: Any)
    fun commonSrcFiles(files: Collection<Any>)

    // DSL. Other parameters.

    fun linkerOpts(vararg values: String)
    fun linkerOpts(values: List<String>)

    fun enableDebug(flag: Boolean)
    fun noStdLib(flag: Boolean)
    fun noMain(flag: Boolean)
    fun noPack(flag: Boolean)
    fun enableOptimizations(flag: Boolean)
    fun enableAssertions(flag: Boolean)

    fun entryPoint(entryPoint: String)

    fun measureTime(flag: Boolean)
}

interface KonanInteropSpec: KonanBuildingSpec {",interface IncludeDirectoriesSpec {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.unitTests

import org.jetbrains.kotlin.gradle.internal.properties.PropertiesBuildService
import org.jetbrains.kotlin.gradle.plugin.extraProperties
import org.jetbrains.kotlin.gradle.util.buildProject
import org.jetbrains.kotlin.gradle.util.registerMinimalVariantImplementationFactoriesForTests
import org.junit.Assert.assertEquals
import org.junit.Test

class PropertiesBuildServiceTest {

    @Test
    fun testPrecedenceOrder() {
        val project = buildProject()
        project.extraProperties.apply {
            set(""a"", ""extra"")","set(""b"", ""extra"")"
"@CompileTimeCalculation fun ifGreaterOrEqualToZero(a: Int): Boolean {
    return if (a >= 0) {
        true
    } else {
        false
    }
}

@CompileTimeCalculation fun whenGreaterOrEqualToZero(a: Int): Boolean {
    return when {",a >= 0 -> true
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""FunctionName"")

package org.jetbrains.kotlin.gradle.unitTests

import org.jetbrains.kotlin.gradle.plugin.*
import org.jetbrains.kotlin.gradle.plugin.KotlinPluginLifecycle.IllegalLifecycleException
import org.jetbrains.kotlin.gradle.plugin.KotlinPluginLifecycle.Stage.*
import org.jetbrains.kotlin.gradle.util.buildProjectWithMPP
import org.jetbrains.kotlin.gradle.util.runLifecycleAwareTest
import org.jetbrains.kotlin.gradle.utils.newProperty
import org.junit.Test
import kotlin.test.assertEquals
import kotlin.test.assertFails
import kotlin.test.assertFailsWith
import kotlin.test.assertNull

class LifecycleAwaitFinalPropertyValueTest {
    private val project = buildProjectWithMPP()

    @Test
    fun `test - awaitFinalValue`() = project.runLifecycleAwareTest {
        val property = project.newProperty<Int>()

        launchInStage(FinaliseDsl.previousOrThrow.previousOrThrow) {",property.set(1)
"* ISSUES: KT-28329
 */
fun case_44(x: TypealiasNullableString<!REDUNDANT_NULLABLE!>?<!>, z1: Nothing?) {
    if (true && true && true && true && x !== z1) {

    } else if (false) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!><!UNSAFE_CALL!>.<!>propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!><!UNSAFE_CALL!>.<!>funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 45
fun case_45() {
    val a = Class()
    <!CAN_BE_VAL!>var<!> z: Nothing? = null

    if (a.prop_4 != z || true) {
        if (a.prop_4 == null) {
            a.prop_4
            a.prop_4.hashCode()
        }
    }
}

// TESTCASE NUMBER: 46
fun case_46(x: TypealiasNullableString<!REDUNDANT_NULLABLE!>?<!>, y: TypealiasNullableString) {
    val t: TypealiasNullableString = null
    <!CAN_BE_VAL!>var<!> z: Nothing? = null

    if (x != nullableNothingProperty) {

    } else {
        if (y === nullableNothingProperty) {
            if (z != nullableStringProperty) {
                if (z === t || <!SENSELESS_COMPARISON!>t == nullableNothingProperty<!>) {
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString? & kotlin.Nothing?"")!>x<!>
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString? & kotlin.Nothing?"")!>x<!>.hashCode()
                }
            }
        }
    }
}

/*
 * TESTCASE NUMBER: 47
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28328
 */
fun case_47(x: TypealiasNullableString, y: TypealiasNullableString, z: Nothing?) = if (x !== z && true && true && true) ""1""
    else if (y != z) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!><!UNSAFE_CALL!>.<!>propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!>.funT()","<!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!><!UNSAFE_CALL!>.<!>funAny()"
"return context.session.symbolProvider.getClassLikeSymbolByClassId(this)
    }

    private fun ClassId.resolveToClass(context: CheckerContext): FirRegularClassSymbol? {
        val classSymbol = resolveToClassLike(context) ?: return null
        return when (classSymbol) {
            is FirRegularClassSymbol -> classSymbol
            is FirTypeAliasSymbol -> classSymbol.fullyExpandedClass(context.session)
            is FirAnonymousObjectSymbol -> null
        }
    }

    private fun FirRegularClassSymbol.hasFunction(
        context: CheckerContext,
        name: Name,
        predicate: (FirNamedFunctionSymbol) -> Boolean
    ): Boolean {
        var result = false
        context.session.declaredMemberScope(this, memberRequiredPhase = null).processFunctionsByName(name) { sym ->
            if (!result) {
                result = predicate(sym)
            }
        }
        return result
    }

    private sealed class ImportStatus {
        data object OK : ImportStatus()
        data class Invisible(val symbol: FirCallableSymbol<*>) : ImportStatus()
        data object CannotBeImported : ImportStatus()
        data object Unresolved : ImportStatus()
    }

    private fun FirRegularClassSymbol.getImportStatusOfCallableMembers(context: CheckerContext, name: Name): ImportStatus {
        return if (classKind.isSingleton) {
            // Use declaredMemberScope first because it's faster, and it's relatively rare to import members declared from super types.
            val scopes = listOf(context.session.declaredMemberScope(this, memberRequiredPhase = null), unsubstitutedScope(context))
            getImportStatus(scopes, context, name) { true }
        } else {
            val scopes = listOfNotNull(
                // We first try resolution with declaredMemberScope because it's faster and typically imported members are not from
                // super types.
                context.session.declaredMemberScope(this, memberRequiredPhase = null),

                // Next, we try static scope, which can provide static (Java) members from super classes. Note that it's not available
                // for pure Kotlin classes.
                staticScope(context.sessionHolder),

                // Finally, we fall back to unsubstitutedScope to catch all
                unsubstitutedScope(context)
            )
            getImportStatus(scopes, context, name) { it.isStatic }
        }
    }

    private inline fun getImportStatus(
        scopes: List<FirContainingNamesAwareScope>,
        context: CheckerContext,
        name: Name,
        crossinline isApplicable: (FirCallableSymbol<*>) -> Boolean
    ): ImportStatus {
        var found = false
        var symbol: FirCallableSymbol<*>? = null

        for (scope in scopes) {",scope.processFunctionsByName(name) { sym ->
"// ISSUE: KT-62956

abstract class Builder<S, B : Builder<S, B>>(var s: S) {
    fun <T : B> test(x: T): T {
        s = x.s
        return x
    }
}

class BS : Builder<String, BS>("""")
class BI : Builder<Int, BI>(1)

fun bar(b: Builder<String, *>, bb: Builder<*, *>) {
    b.test<Builder<*, *>>(bb)
}

fun main() {
    val b = BS()
    bar(b, BI())",b.s.length
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlinx.serialization.compiler.backend.ir

import org.jetbrains.kotlin.backend.jvm.functionByName
import org.jetbrains.kotlin.builtins.StandardNames
import org.jetbrains.kotlin.ir.builders.*
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.declarations.IrVariable
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.expressions.impl.IrGetValueImpl
import org.jetbrains.kotlin.ir.symbols.IrClassSymbol
import org.jetbrains.kotlin.ir.symbols.IrFunctionSymbol
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlinx.serialization.compiler.extensions.SerializationPluginContext
import org.jetbrains.kotlinx.serialization.compiler.resolve.CallingConventions
import org.jetbrains.kotlinx.serialization.compiler.resolve.SerialEntityNames

class SerializerForEnumsGenerator(
    irClass: IrClass,
    compilerContext: SerializationPluginContext,",") : SerializerIrGenerator(irClass, compilerContext, null) {"
"class DescriptorKindFilter(
        kindMask: Int,
        val excludes: List<DescriptorKindExclude> = listOf()
) {
    val kindMask: Int

    init {
        var mask = kindMask
        excludes.forEach { mask = mask and it.fullyExcludedDescriptorKinds.inv() }
        this.kindMask = mask
    }

    fun accepts(descriptor: DeclarationDescriptor): Boolean
            = kindMask and descriptor.kind() != 0 && excludes.all { !it.excludes(descriptor) }

    fun acceptsKinds(kinds: Int): Boolean
            = kindMask and kinds != 0

    infix fun exclude(exclude: DescriptorKindExclude): DescriptorKindFilter
            = DescriptorKindFilter(kindMask, excludes + listOf(exclude))

    fun withoutKinds(kinds: Int): DescriptorKindFilter
            = DescriptorKindFilter(kindMask and kinds.inv(), excludes)

    fun withKinds(kinds: Int): DescriptorKindFilter
            = DescriptorKindFilter(kindMask or kinds, excludes)

    fun restrictedToKinds(kinds: Int): DescriptorKindFilter
            = DescriptorKindFilter(kindMask and kinds, excludes)

    fun restrictedToKindsOrNull(kinds: Int): DescriptorKindFilter? {
        val mask = kindMask and kinds
        if (mask == 0) return null
        return DescriptorKindFilter(mask, excludes)
    }

    fun intersect(other: DescriptorKindFilter) = DescriptorKindFilter(kindMask and other.kindMask, excludes + other.excludes)

    override fun toString(): String {
        val predefinedFilterName = DEBUG_PREDEFINED_FILTERS_MASK_NAMES.firstOrNull { it.mask == kindMask } ?.name
        val kindString = predefinedFilterName ?: DEBUG_MASK_BIT_NAMES
                .mapNotNull { if (acceptsKinds(it.mask)) it.name else null }
                .joinToString(separator = "" | "")

        return ""DescriptorKindFilter($kindString, $excludes)""
    }

    private fun DeclarationDescriptor.kind(): Int {
        return when (this) {
            is ClassDescriptor -> if (this.kind.isSingleton) SINGLETON_CLASSIFIERS_MASK else NON_SINGLETON_CLASSIFIERS_MASK
            is TypeAliasDescriptor -> TYPE_ALIASES_MASK
            is ClassifierDescriptor -> NON_SINGLETON_CLASSIFIERS_MASK
            is PackageFragmentDescriptor, is PackageViewDescriptor -> PACKAGES_MASK
            is FunctionDescriptor -> FUNCTIONS_MASK
            is VariableDescriptor -> VARIABLES_MASK
            else -> 0
        }
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as DescriptorKindFilter",if (excludes != other.excludes) return false
"// FIR_IDENTICAL
// !CHECK_TYPE
// FILE: a.kt

package a.b.c

class D {
    fun foo() = 42
}

// FILE: b.kt

import kotlin.reflect.KFunction1

fun main() {",val x = a.b.c.D::foo
"/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.codegen.range.forLoop

import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.codegen.DescriptorAsmUtil
import org.jetbrains.kotlin.codegen.ExpressionCodegen
import org.jetbrains.kotlin.codegen.StackValue
import org.jetbrains.kotlin.psi.KtForExpression
import org.jetbrains.kotlin.resolve.jvm.AsmTypes.OBJECT_TYPE
import org.jetbrains.kotlin.types.KotlinType
import org.jetbrains.org.objectweb.asm.Label
import org.jetbrains.org.objectweb.asm.Type

class ForInArrayLoopGenerator(
    codegen: ExpressionCodegen,
    forExpression: KtForExpression,
    private val canCacheArrayLength: Boolean,
    private val shouldAlwaysStoreArrayInNewVar: Boolean
) : AbstractForLoopGenerator(codegen, forExpression) {
    private var indexVar: Int = 0
    private var arrayVar: Int = 0
    private var arrayLengthVar: Int = 0
    private val loopRangeType: KotlinType = bindingContext.getType(forExpression.loopRange!!)!!

    override fun beforeLoop() {
        super.beforeLoop()

        indexVar = createLoopTempVariable(Type.INT_TYPE)

        val loopRange = forExpression.loopRange
        val value = codegen.gen(loopRange)
        val asmLoopRangeType = codegen.asmType(loopRangeType)
        if (!shouldAlwaysStoreArrayInNewVar && value is StackValue.Local && value.type == asmLoopRangeType) {
            arrayVar = value.index // no need to copy local variable into another variable
        } else {",arrayVar = createLoopTempVariable(OBJECT_TYPE)
"// EXPECTED_REACHABLE_NODES: 1289
package foo

fun box(): String {
    val ints: Any? = arrayOf(1, 2)
    val strings: Any? = arrayOf(""a"", ""b"")
    val nil: Any? = null",val obj: Any? = object{}
"// WITH_STDLIB
// WORKS_WHEN_VALUE_CLASS
// LANGUAGE: +ValueClasses

var result = ""Fail""

OPTIONAL_JVM_INLINE_ANNOTATION
value class A(val value: String) {","constructor() : this(""OK"")"
"fun runNoInline(block: ()-> Unit): Unit {
    block()
}

fun use(x: Int) {}",fun test(): Unit {
"// MODULE: library
// FILE: library.kt

inline fun bar(crossinline block: () -> Unit) {
    object {
        fun baz(param: Int) {
            val b = 2
            block()
            inlineCall {
                val g = 7
            }
            block()
            inlineCall {
                val g = 7
            }
            block()
            inlineCall {
                val g = 7
            }
        }
    }.baz(6)
}

inline fun inlineCall(block: () -> Unit) {
    block()
}

// MODULE: test(library)
// USE_INLINE_SCOPES_NUMBERS
// FILE: test.kt",fun box() {
"suspend fun dummy() {}

class C {
    suspend fun dummy() = ""OK""
}

class WithNested {
    class Nested {","suspend fun dummy() = ""OK"""
"fun testR0xE3() {
    // with possible local optimizations
    if (3u in 1u..<3u != range0.contains(3u)) throw AssertionError()
    if (3u !in 1u..<3u != !range0.contains(3u)) throw AssertionError()
    if (!(3u in 1u..<3u) != !range0.contains(3u)) throw AssertionError()
    if (!(3u !in 1u..<3u) != range0.contains(3u)) throw AssertionError()
    // no local optimizations
    if (element3 in 1u..<3u != range0.contains(element3)) throw AssertionError()
    if (element3 !in 1u..<3u != !range0.contains(element3)) throw AssertionError()
    if (!(element3 in 1u..<3u) != !range0.contains(element3)) throw AssertionError()
    if (!(element3 !in 1u..<3u) != range0.contains(element3)) throw AssertionError()
}

fun testR0xE4() {
    // with possible local optimizations
    if (4u in 1u..<3u != range0.contains(4u)) throw AssertionError()
    if (4u !in 1u..<3u != !range0.contains(4u)) throw AssertionError()
    if (!(4u in 1u..<3u) != !range0.contains(4u)) throw AssertionError()
    if (!(4u !in 1u..<3u) != range0.contains(4u)) throw AssertionError()
    // no local optimizations
    if (element4 in 1u..<3u != range0.contains(element4)) throw AssertionError()
    if (element4 !in 1u..<3u != !range0.contains(element4)) throw AssertionError()
    if (!(element4 in 1u..<3u) != !range0.contains(element4)) throw AssertionError()
    if (!(element4 !in 1u..<3u) != range0.contains(element4)) throw AssertionError()
}

fun testR1xE0() {
    // with possible local optimizations
    if (0u in 3u..<1u != range1.contains(0u)) throw AssertionError()
    if (0u !in 3u..<1u != !range1.contains(0u)) throw AssertionError()
    if (!(0u in 3u..<1u) != !range1.contains(0u)) throw AssertionError()
    if (!(0u !in 3u..<1u) != range1.contains(0u)) throw AssertionError()
    // no local optimizations
    if (element0 in 3u..<1u != range1.contains(element0)) throw AssertionError()
    if (element0 !in 3u..<1u != !range1.contains(element0)) throw AssertionError()
    if (!(element0 in 3u..<1u) != !range1.contains(element0)) throw AssertionError()
    if (!(element0 !in 3u..<1u) != range1.contains(element0)) throw AssertionError()
}

fun testR1xE1() {
    // with possible local optimizations
    if (1u in 3u..<1u != range1.contains(1u)) throw AssertionError()
    if (1u !in 3u..<1u != !range1.contains(1u)) throw AssertionError()
    if (!(1u in 3u..<1u) != !range1.contains(1u)) throw AssertionError()
    if (!(1u !in 3u..<1u) != range1.contains(1u)) throw AssertionError()
    // no local optimizations
    if (element1 in 3u..<1u != range1.contains(element1)) throw AssertionError()
    if (element1 !in 3u..<1u != !range1.contains(element1)) throw AssertionError()
    if (!(element1 in 3u..<1u) != !range1.contains(element1)) throw AssertionError()
    if (!(element1 !in 3u..<1u) != range1.contains(element1)) throw AssertionError()
}

fun testR1xE2() {
    // with possible local optimizations
    if (2u in 3u..<1u != range1.contains(2u)) throw AssertionError()
    if (2u !in 3u..<1u != !range1.contains(2u)) throw AssertionError()
    if (!(2u in 3u..<1u) != !range1.contains(2u)) throw AssertionError()
    if (!(2u !in 3u..<1u) != range1.contains(2u)) throw AssertionError()
    // no local optimizations
    if (element2 in 3u..<1u != range1.contains(element2)) throw AssertionError()
    if (element2 !in 3u..<1u != !range1.contains(element2)) throw AssertionError()
    if (!(element2 in 3u..<1u) != !range1.contains(element2)) throw AssertionError()
    if (!(element2 !in 3u..<1u) != range1.contains(element2)) throw AssertionError()
}",fun testR1xE3() {
"return this is ConeIntegerConstantOperatorType
    }

    override fun TypeConstructorMarker.isLocalType(): Boolean {
        if (this !is ConeClassLikeLookupTag) return false
        return classId.isLocal
    }

    override fun TypeConstructorMarker.isAnonymous(): Boolean {
        if (this !is ConeClassLikeLookupTag) return false
        return name == SpecialNames.ANONYMOUS
    }

    override val TypeVariableTypeConstructorMarker.typeParameter: TypeParameterMarker?
        get() {
            require(this is ConeTypeVariableTypeConstructor)
            return this.originalTypeParameter
        }

    override fun SimpleTypeMarker.possibleIntegerTypes(): Collection<KotlinTypeMarker> {
        return (this as? ConeIntegerLiteralType)?.possibleTypes ?: emptyList()
    }

    override fun SimpleTypeMarker.fastCorrespondingSupertypes(constructor: TypeConstructorMarker): List<SimpleTypeMarker>? {
        require(this is ConeKotlinType)
        return session.correspondingSupertypesCache.getCorrespondingSupertypes(this, constructor)
    }

    override fun SimpleTypeMarker.isIntegerLiteralType(): Boolean {
        return this is ConeIntegerLiteralType
    }

    override fun KotlinTypeMarker.asSimpleType(): SimpleTypeMarker? {
        assert(this is ConeKotlinType)
        return when (this) {
            is ConeClassLikeType -> fullyExpandedType(session)
            is ConeSimpleKotlinType -> this
            is ConeFlexibleType -> null
            else -> errorWithAttachment(""Unknown simpleType: ${this::class}"") {
                withConeTypeEntry(""type"", this@asSimpleType as? ConeKotlinType)
            }
        }
    }

    override fun KotlinTypeMarker.asFlexibleType(): FlexibleTypeMarker? {
        assert(this is ConeKotlinType)
        return this as? ConeFlexibleType
    }

    override fun KotlinTypeMarker.isError(): Boolean {
        assert(this is ConeKotlinType)
        return this is ConeErrorType || this is ConeErrorType || this.typeConstructor().isError() ||
                (this is ConeClassLikeType && this.lookupTag is ConeClassLikeErrorLookupTag)
    }

    override fun KotlinTypeMarker.isUninferredParameter(): Boolean {
        assert(this is ConeKotlinType)
        return this is ConeErrorType && this.isUninferredParameter
    }

    override fun FlexibleTypeMarker.asDynamicType(): ConeDynamicType? {
        assert(this is ConeKotlinType)
        return this as? ConeDynamicType
    }",override fun KotlinTypeMarker.isRawType(): Boolean {
"}

    @Test
    fun `test - mainClass - set via DSL`() = buildProjectWithMPP().runLifecycleAwareTest {
        val kotlin = project.multiplatformExtension
        val mainRun = assertNotNull(kotlin.jvm().mainRun.await())
        val mainRunTask = mainRun.task.get()

        assertNull(
            mainRunTask.mainClass.orNull,
            ""Expected mainClass to be null: No mainClass set via DSL or property""
        )

        // Set mainClass via DSL
        mainRun.mainClass.set(""Foo"")
        assertEquals(""Foo"", mainRunTask.mainClass.orNull)
    }


    @Test
    fun `test - args`() = buildProjectWithMPP().runLifecycleAwareTest {
        val kotlin = project.multiplatformExtension
        val task = assertNotNull(kotlin.jvm().mainRun.await()).task.get()

        /* Set properties using 'args()' */
        kotlin.jvm().mainRun {
            args(""first"", ""second"")
            args(listOf(""third"", ""fourth""))
        }

        launch {
            assertEquals(listOf(""first"", ""second"", ""third"", ""fourth""), task.args)
        }


        /* Set property using .setArgs */
        kotlin.jvm().mainRun {
            setArgs(listOf(""1"", ""2""))
        }

        launch {
            assertEquals(listOf(""1"", ""2""), task.args)
        }
    }

    @Test
    fun `test - classpath - contains main compilation output by default`() = buildProjectWithMPP().runLifecycleAwareTest {
        repositories.mavenLocal()
        repositories.mavenCentralCacheRedirector()

        val kotlin = project.multiplatformExtension
        val mainRunTask = assertNotNull(kotlin.jvm().mainRun.await()).task.get()
        val mainCompilation = kotlin.jvm().compilations.main

        configurationResult.await()

        mainCompilation.output.allOutputs.files.ifEmpty { fail(""Expected some file in 'allOutputs'"") }
        if (!mainRunTask.classpath.files.containsAll(mainCompilation.output.allOutputs.files)) {
            fail(""Missing output from main compilation in '$mainRunTask'"")
        }
    }

    @Test
    fun `test - classpath - contains main compilation runtime dependencies`() = buildProjectWithMPP().runLifecycleAwareTest {
        repositories.mavenLocal()",repositories.mavenCentralCacheRedirector()
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.mpp.publication

import org.jetbrains.kotlin.gradle.testbase.GradleProject
import org.jetbrains.kotlin.gradle.util.replaceText
import org.jetbrains.kotlin.tooling.core.KotlinToolingVersion
import kotlin.io.path.appendText

fun GradleProject.prepareProjectForPublication(
    scenarioProject: Scenario.Project,
) {
    buildGradleKts.appendText(""\n"" + """"""group = ""${scenarioProject.packageName}"" """""")
    buildGradleKts.appendText(""\n"" + """"""version = ""1.0"" """""")
    settingsGradleKts.appendText(""\n"" + """"""rootProject.name = ""${scenarioProject.artifactName}"" """""")

    when (scenarioProject.variant) {
        ProjectVariant.AndroidOnly -> prepareAndroidOnlyProjectForPublication(scenarioProject)
        ProjectVariant.JavaOnly -> Unit
        is ProjectVariant.Kmp -> prepareKmpProjectForPublication(scenarioProject)
    }
}

private fun GradleProject.prepareAndroidOnlyProjectForPublication(
    scenarioProject: Scenario.Project
) {
    generateCode(scenarioProject, ""main"")
}

private fun GradleProject.prepareKmpProjectForPublication(
    scenarioProject: Scenario.Project,
) {
    val projectVariant = scenarioProject.variant
    check(projectVariant is ProjectVariant.Kmp)
    val kotlinVersion = checkNotNull(scenarioProject.kotlinVersion)

    generateCode(scenarioProject, ""commonMain"")
    generateCode(scenarioProject, ""nativeMain"")

    if (projectVariant.withJvm) {
        buildGradleKts.replaceText(""// jvm() // JVM"", ""jvm() // JVM"")
        generateCode(scenarioProject, ""jvmMain"")
    }

    if (projectVariant.withAndroid) {
        if (kotlinVersion < KotlinToolingVersion(""1.9.20"")) {
            buildGradleKts.replaceText(""androidTarget"", ""android"")
        }
        buildGradleKts.replaceText(""// id(\""com.android.library\"") // AGP"", ""id(\""com.android.library\"") // AGP"")","buildGradleKts.replaceText(""/* Begin AGP"", ""// /* Begin AGP"")"
"annotation class RawDelimiter

    object Delimiters {
        const val default = "",""
        const val none = """"
        const val pathSeparator = ""<path_separator>""
    }
}

val Argument.isAdvanced: Boolean
    get() = isSpecial(ADVANCED_ARGUMENT_PREFIX)

val Argument.isInternal: Boolean
    get() = isSpecial(INTERNAL_ARGUMENT_PREFIX)

private fun Argument.isSpecial(prefix: String): Boolean {
    return value.startsWith(prefix) && value.length > prefix.length
}

@OptIn(Argument.RawDelimiter::class)
val Argument.resolvedDelimiter: String?
    get() = when (delimiter) {
        Argument.Delimiters.none -> null
        Argument.Delimiters.pathSeparator -> File.pathSeparator
        else -> delimiter
    }

private const val ADVANCED_ARGUMENT_PREFIX = ""-X""
internal const val INTERNAL_ARGUMENT_PREFIX = ""-XX""
private const val FREE_ARGS_DELIMITER = ""--""

data class ArgumentParseErrors(
    val unknownArgs: MutableList<String> = SmartList(),

    val unknownExtraFlags: MutableList<String> = SmartList(),

    // Names of extra (-X...) arguments which have been passed in an obsolete form (""-Xaaa bbb"", instead of ""-Xaaa=bbb"")
    val extraArgumentsPassedInObsoleteForm: MutableList<String> = SmartList(),

    // Non-boolean arguments which have been passed multiple times, possibly with different values.
    // The key in the map is the name of the argument, the value is the last passed value.
    val duplicateArguments: MutableMap<String, String> = mutableMapOf(),

    // Arguments where [Argument.deprecatedName] was used; the key is the deprecated name, the value is the new name ([Argument.value])
    val deprecatedArguments: MutableMap<String, String> = mutableMapOf(),

    var argumentWithoutValue: String? = null,

    var booleanArgumentWithValue: String? = null,

    val argfileErrors: MutableList<String> = SmartList(),

    // Reports from internal arguments parsers
    val internalArgumentsParsingProblems: MutableList<String> = SmartList()
)

inline fun <reified T : CommonToolArguments> parseCommandLineArguments(args: List<String>): T {
    return parseCommandLineArguments(T::class, args)
}

fun <T : CommonToolArguments> parseCommandLineArguments(clazz: KClass<T>, args: List<String>): T {
    val constructor = clazz.java.constructors.find { it.parameters.isEmpty() }
        ?: error(""Missing empty constructor on '${clazz.java.name}"")
    val arguments = clazz.cast(constructor.newInstance())
    parseCommandLineArguments(args, arguments)",return arguments
"assertNoDuplicateLibraryWarning()
                }

                build("":p1:compileAppleMainKotlinMetadata"") {
                    assertDirectoryInProjectExists(""p1/build/classes/kotlin/metadata/appleMain/klib/p1_appleMain"")
                    assertNoDuplicateLibraryWarning()
                }
            }

            build("":p1:compileLinuxMainKotlinMetadata"") {
                assertDirectoryInProjectExists(""p1/build/classes/kotlin/metadata/linuxMain/klib/p1_linuxMain"")
                assertNoDuplicateLibraryWarning()
            }

            build("":p1:compileAppleAndLinuxMainKotlinMetadata"") {
                assertDirectoryInProjectExists(""p1/build/classes/kotlin/metadata/appleAndLinuxMain/klib/p1_appleAndLinuxMain"")
                assertNoDuplicateLibraryWarning()
            }

            build("":p1:compileNativeMainKotlinMetadata"") {
                assertDirectoryInProjectExists(""p1/build/classes/kotlin/metadata/nativeMain/klib/p1_nativeMain"")
                assertNoDuplicateLibraryWarning()
            }

            build("":p1:compileConcurrentMainKotlinMetadata"") {
                assertDirectoryInProjectExists(""p1/build/classes/kotlin/metadata/concurrentMain/default"")
                assertNoDuplicateLibraryWarning()
            }
        }
    }

    @DisplayName(""Commonize hierarchically Klibrary compilations"")
    @GradleTest
    fun testCommonizeHierarchicallyKlibraryCompilations(gradleVersion: GradleVersion) {
        nativeProject(""commonizeHierarchically"", gradleVersion) {
            if (HostManager.hostIsMac) {
                build("":p1:iosArm64MainKlibrary"", "":p1:iosX64MainKlibrary"", "":p1:macosX64MainKlibrary"", "":p1:macosArm64MainKLibrary"") {
                    assertFileInProjectExists(""p1/build/classes/kotlin/iosArm64/main/klib/p1.klib"")
                    assertFileInProjectExists(""p1/build/classes/kotlin/iosX64/main/klib/p1.klib"")
                    assertFileInProjectExists(""p1/build/classes/kotlin/macosX64/main/klib/p1.klib"")
                    assertFileInProjectExists(""p1/build/classes/kotlin/macosArm64/main/klib/p1.klib"")
                    assertNoDuplicateLibraryWarning()
                }
            }

            build("":p1:linuxX64MainKlibrary"", "":p1:linuxArm64MainKlibrary"") {
                assertFileInProjectExists(""p1/build/classes/kotlin/linuxX64/main/klib/p1.klib"")
                assertFileInProjectExists(""p1/build/classes/kotlin/linuxArm64/main/klib/p1.klib"")
                assertNoDuplicateLibraryWarning()
            }

            build("":p1:mingwX64MainKlibrary"") {
                assertFileInProjectExists(""p1/build/classes/kotlin/mingwX64/main/klib/p1.klib"")
                assertNoDuplicateLibraryWarning()
            }
        }
    }

    @DisplayName(""Commonize hierarchically multi module"")
    @GradleTest
    fun testCommonizeHierarchicallyMultiModule(gradleVersion: GradleVersion) {
        nativeProject(""commonizeHierarchicallyMultiModule"", gradleVersion) {
            build(""assemble"") {
                assertTasksExecuted("":p1:commonizeCInterop"")
                assertTasksExecuted("":p2:commonizeCInterop"")","assertTasksExecuted("":p3:commonizeCInterop"")"
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.psi

import com.intellij.lang.ASTNode
import com.intellij.psi.PsiElement
import com.intellij.psi.PsiNameIdentifierOwner",import com.intellij.psi.search.LocalSearchScope
"// MODULE: m1-common
// FILE: common.kt

expect class A private constructor() {
    <!EXPECTED_PRIVATE_DECLARATION, EXPECTED_PRIVATE_DECLARATION{JVM}!>private<!> fun foo()
    <!EXPECTED_PRIVATE_DECLARATION, EXPECTED_PRIVATE_DECLARATION{JVM}!>private<!> val bar: String
    <!EXPECTED_PRIVATE_DECLARATION, EXPECTED_PRIVATE_DECLARATION{JVM}!>private<!> fun Int.memExt(): Any

    <!EXPECTED_PRIVATE_DECLARATION, EXPECTED_PRIVATE_DECLARATION{JVM}!>private<!> class Nested

    var baz: Any?
        private set
}

// MODULE: m1-jvm()()(m1-common)
// FILE: jvm.kt",actual class A actual private constructor() {
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.transformers.irToJs

import org.jetbrains.kotlin.ir.backend.js.utils.JsMainFunctionDetector
import org.jetbrains.kotlin.ir.backend.js.utils.emptyScope
import org.jetbrains.kotlin.js.backend.ast.*
import org.jetbrains.kotlin.serialization.js.ModuleKind
import org.jetbrains.kotlin.utils.DFS
import org.jetbrains.kotlin.utils.addToStdlib.partitionIsInstance

class Merger(
    private val moduleName: String,
    private val moduleKind: ModuleKind,","private val fragments: List<JsIrProgramFragment>,"
"// IGNORE_BACKEND: WASM
// WASM_MUTE_REASON: FAILS_IN_JS_IR
// IGNORE_BACKEND: JS, JS_IR
// IGNORE_BACKEND: JS_IR_ES6
// FILE: test.kt

fun checkEqual(x: Any, y: Any) {
    if (x != y || y != x) throw AssertionError(""$x and $y should be equal"")
    if (x.hashCode() != y.hashCode()) throw AssertionError(""$x and $y should have the same hash code"")
}

fun checkNotEqual(x: Any, y: Any) {
    if (x == y || y == x) throw AssertionError(""$x and $y should NOT be equal"")
}

fun target(x: Int, y: String = """", z: String = """"): Int = x

fun captureNoDefaults(fn: (Int, String, String) -> Unit): Any = fn
fun captureOneDefault(fn: (Int, String) -> Unit): Any = fn
fun captureAllDefaults(fn: (Int) -> Unit): Any = fn
fun captureOneDefaultWithoutCoercionToUnit(fn: (Int, String) -> Int): Any = fn

fun box(): String {
    checkEqual(captureNoDefaults(::target), captureNoDefaults(::target))","checkEqual(captureOneDefault(::target), captureOneDefault(::target))"
"// WITH_STDLIB

/*
 * KOTLIN CODEGEN BOX SPEC TEST (POSITIVE)
 *
 * SPEC VERSION: 0.1-268
 * MAIN LINK: overload-resolution, callables-and-invoke-convention -> paragraph 5 -> sentence 1
 * PRIMARY LINKS: overload-resolution, callables-and-invoke-convention -> paragraph 2 -> sentence 2
 * overload-resolution, callables-and-invoke-convention -> paragraph 2 -> sentence 8
 * overload-resolution, callables-and-invoke-convention -> paragraph 2 -> sentence 10
 * NUMBER: 9
 * DESCRIPTION: function-like prio is higher than property-like callables
 */

// FILE: KotlinLib.kt
package test.lib
class MyClass {
    //property-like (II prio)
    companion object foo {
        var fooCompanionObj = false",operator fun invoke() {
"// FILE: lib.kt

package utils

inline fun foo(a: Int) {
    bar(a)
}

inline fun bar(a: Int) {
    try {
        if (a > 0) throw Exception()","log(""foo($a) #1"")"
"fun testR0xE0() {
    // with possible local optimizations
    if (0uL in 1uL..<3uL != range0.contains(0uL)) throw AssertionError()
    if (0uL !in 1uL..<3uL != !range0.contains(0uL)) throw AssertionError()
    if (!(0uL in 1uL..<3uL) != !range0.contains(0uL)) throw AssertionError()
    if (!(0uL !in 1uL..<3uL) != range0.contains(0uL)) throw AssertionError()
    // no local optimizations
    if (element0 in 1uL..<3uL != range0.contains(element0)) throw AssertionError()
    if (element0 !in 1uL..<3uL != !range0.contains(element0)) throw AssertionError()
    if (!(element0 in 1uL..<3uL) != !range0.contains(element0)) throw AssertionError()
    if (!(element0 !in 1uL..<3uL) != range0.contains(element0)) throw AssertionError()
}

fun testR0xE1() {
    // with possible local optimizations
    if (1uL in 1uL..<3uL != range0.contains(1uL)) throw AssertionError()
    if (1uL !in 1uL..<3uL != !range0.contains(1uL)) throw AssertionError()
    if (!(1uL in 1uL..<3uL) != !range0.contains(1uL)) throw AssertionError()
    if (!(1uL !in 1uL..<3uL) != range0.contains(1uL)) throw AssertionError()
    // no local optimizations
    if (element1 in 1uL..<3uL != range0.contains(element1)) throw AssertionError()
    if (element1 !in 1uL..<3uL != !range0.contains(element1)) throw AssertionError()
    if (!(element1 in 1uL..<3uL) != !range0.contains(element1)) throw AssertionError()
    if (!(element1 !in 1uL..<3uL) != range0.contains(element1)) throw AssertionError()
}

fun testR0xE2() {
    // with possible local optimizations
    if (2uL in 1uL..<3uL != range0.contains(2uL)) throw AssertionError()
    if (2uL !in 1uL..<3uL != !range0.contains(2uL)) throw AssertionError()
    if (!(2uL in 1uL..<3uL) != !range0.contains(2uL)) throw AssertionError()
    if (!(2uL !in 1uL..<3uL) != range0.contains(2uL)) throw AssertionError()
    // no local optimizations
    if (element2 in 1uL..<3uL != range0.contains(element2)) throw AssertionError()
    if (element2 !in 1uL..<3uL != !range0.contains(element2)) throw AssertionError()
    if (!(element2 in 1uL..<3uL) != !range0.contains(element2)) throw AssertionError()
    if (!(element2 !in 1uL..<3uL) != range0.contains(element2)) throw AssertionError()
}

fun testR0xE3() {
    // with possible local optimizations
    if (3uL in 1uL..<3uL != range0.contains(3uL)) throw AssertionError()
    if (3uL !in 1uL..<3uL != !range0.contains(3uL)) throw AssertionError()
    if (!(3uL in 1uL..<3uL) != !range0.contains(3uL)) throw AssertionError()
    if (!(3uL !in 1uL..<3uL) != range0.contains(3uL)) throw AssertionError()
    // no local optimizations
    if (element3 in 1uL..<3uL != range0.contains(element3)) throw AssertionError()
    if (element3 !in 1uL..<3uL != !range0.contains(element3)) throw AssertionError()
    if (!(element3 in 1uL..<3uL) != !range0.contains(element3)) throw AssertionError()
    if (!(element3 !in 1uL..<3uL) != range0.contains(element3)) throw AssertionError()
}

fun testR0xE4() {
    // with possible local optimizations
    if (4uL in 1uL..<3uL != range0.contains(4uL)) throw AssertionError()
    if (4uL !in 1uL..<3uL != !range0.contains(4uL)) throw AssertionError()
    if (!(4uL in 1uL..<3uL) != !range0.contains(4uL)) throw AssertionError()
    if (!(4uL !in 1uL..<3uL) != range0.contains(4uL)) throw AssertionError()
    // no local optimizations
    if (element4 in 1uL..<3uL != range0.contains(element4)) throw AssertionError()
    if (element4 !in 1uL..<3uL != !range0.contains(element4)) throw AssertionError()
    if (!(element4 in 1uL..<3uL) != !range0.contains(element4)) throw AssertionError()
    if (!(element4 !in 1uL..<3uL) != range0.contains(element4)) throw AssertionError()
}",fun testR1xE0() {
"source,
                    origin = defaultDeserializationOrigin,
                    deserializeNestedClass = this::getClass,
                )

                if (resolvedLibrary is KotlinLibrary) {
                    symbol.fir.klibSourceFile = loadKlibSourceFileExtensionOrNull(
                        resolvedLibrary, nameResolver, classProto, KlibMetadataProtoBuf.classFile
                    )
                }

                symbol.fir.isNewPlaceForBodyGeneration = isNewPlaceForBodyGeneration(classProto)
            }
        }

        return null
    }

    private inline fun forEachFragmentInPackage(
        packageFqName: FqName,
        f: (L, ProtoBuf.PackageFragment, NameResolver) -> Unit
    ) {
        val packageStringName = packageFqName.asString()

        val librariesWithFragment = fragmentNamesInLibraries[packageStringName] ?: return

        for (resolvedLibrary in librariesWithFragment) {
            for (packageMetadataPart in resolvedLibrary.packageMetadataParts(packageStringName)) {

                val fragment = getPackageFragment(resolvedLibrary, packageStringName, packageMetadataPart)

                val nameResolver = NameResolverImpl(
                    fragment.strings,
                    fragment.qualifiedNames,
                )

                f(resolvedLibrary, fragment, nameResolver)
            }
        }
    }

    override fun loadFunctionExtensions(packagePart: PackagePartsCacheData, proto: ProtoBuf.Function, fir: FirFunction) {
        fir.klibSourceFile = loadKlibSourceFileExtensionOrNull(packagePart, proto, KlibMetadataProtoBuf.functionFile) ?: return
    }

    override fun loadPropertyExtensions(packagePart: PackagePartsCacheData, proto: ProtoBuf.Property, fir: FirProperty) {
        fir.klibSourceFile = loadKlibSourceFileExtensionOrNull(packagePart, proto, KlibMetadataProtoBuf.propertyFile) ?: return
    }

    private fun <T : GeneratedMessageLite.ExtendableMessage<T>> loadKlibSourceFileExtensionOrNull(
        packagePart: PackagePartsCacheData, proto: T, sourceFileExtension: GeneratedExtension<T, Int>,
    ): DeserializedSourceFile? {
        val library = (packagePart.extra as? MetadataLibraryPackagePartCacheDataExtra)?.library as? KotlinLibrary ?: return null
        return loadKlibSourceFileExtensionOrNull(library, packagePart.context.nameResolver, proto, sourceFileExtension)
    }

    private fun <T : GeneratedMessageLite.ExtendableMessage<T>> loadKlibSourceFileExtensionOrNull(
        library: KotlinLibrary, nameResolver: NameResolver, proto: T, sourceFileExtension: GeneratedExtension<T, Int>,
    ): DeserializedSourceFile? {
        return proto.getExtensionOrNull(sourceFileExtension)
            ?.let { fileId -> nameResolver.getString(fileId) }
            ?.let { fileName -> DeserializedSourceFile(fileName, library) }
    }",protected abstract fun createDeserializedContainerSource(
"IrConstKind.Byte -> Type.BYTE_TYPE
                    IrConstKind.Short -> Type.SHORT_TYPE
                    IrConstKind.String -> JAVA_STRING_TYPE
                    IrConstKind.Null -> OBJECT_TYPE
                }
                generator.putValueOrProcessConstant(StackValue.constant(arg.value, type, null))
            } else {
                val value = arg.accept(this, data)
                val generatingType = if (value.type == Type.VOID_TYPE) AsmTypes.UNIT_TYPE else value.type
                value.materializeAt(generatingType, value.irType)
                generator.invokeAppend(generatingType)
            }
        }
        generator.genToString()
        return MaterialValue(this@ExpressionCodegen, JAVA_STRING_TYPE, context.irBuiltIns.stringType)
    }

    override fun visitGetClass(expression: IrGetClass, data: BlockInfo): PromisedValue =
        generateClassLiteralReference(expression, wrapIntoKClass = true, wrapPrimitives = false, data = data)

    override fun visitClassReference(expression: IrClassReference, data: BlockInfo): PromisedValue =
        generateClassLiteralReference(expression, wrapIntoKClass = true, wrapPrimitives = false, data = data)

    fun generateClassLiteralReference(
        classReference: IrExpression,
        wrapIntoKClass: Boolean,
        wrapPrimitives: Boolean,
        data: BlockInfo
    ): MaterialValue {
        when (classReference) {
            is IrGetClass -> {
                // TODO transform one sort of access into the other?
                JavaClassProperty.invokeWith(classReference.argument.accept(this, data), wrapPrimitives)
            }
            is IrClassReference -> {
                val classType = classReference.classType
                val classifier = classType.classifierOrNull
                if (classifier is IrTypeParameterSymbol) {
                    val success = putReifiedOperationMarkerIfTypeIsReifiedParameter(classType, ReifiedTypeInliner.OperationKind.JAVA_CLASS)
                    assert(success) {
                        ""Non-reified type parameter under ::class should be rejected by type checker: ${classType.render()}""
                    }
                }

                generateClassInstance(mv, classType, typeMapper, wrapPrimitives)
            }
            else -> {
                throw AssertionError(""not an IrGetClass or IrClassReference: ${classReference.dump()}"")
            }
        }

        if (wrapIntoKClass) {
            wrapJavaClassIntoKClass(mv)
        }
        return classReference.onStack
    }

    private fun getOrCreateCallGenerator(
        element: IrFunctionAccessExpression,
        data: BlockInfo,
        signature: JvmMethodSignature
    ): IrCallGenerator {
        if (!element.symbol.owner.isInlineFunctionCall(context) ||
            classCodegen.irClass.fileParent.fileEntry is MultifileFacadeFileEntry ||
            irFunction.origin == JvmLoweredDeclarationOrigin.JVM_STATIC_WRAPPER ||",irFunction.isInvokeSuspendOfContinuation()
"package a

internal interface InternalInterface",public class PublicClass {
"}

    override fun transformDesugaredAssignmentValueReferenceExpression(
        desugaredAssignmentValueReferenceExpression: FirDesugaredAssignmentValueReferenceExpression,
        data: ResolutionMode,
    ): FirStatement {
        val referencedExpression = desugaredAssignmentValueReferenceExpression.expressionRef.value
        if (referencedExpression is FirQualifiedAccessExpression) {
            val typeFromCallee = components.typeFromCallee(referencedExpression)
            desugaredAssignmentValueReferenceExpression.resultType = session.typeApproximator.approximateToSubType(
                typeFromCallee.type,
                TypeApproximatorConfiguration.FinalApproximationAfterResolutionAndInference
            ) ?: typeFromCallee.type
        } else {
            desugaredAssignmentValueReferenceExpression.resultType = referencedExpression.resolvedType
        }
        return desugaredAssignmentValueReferenceExpression
    }

    override fun transformVariableAssignment(
        variableAssignment: FirVariableAssignment,
        data: ResolutionMode,
    ): FirStatement = whileAnalysing(session, variableAssignment) {
        variableAssignment.transformAnnotations(transformer, ResolutionMode.ContextIndependent)

        variableAssignment.transformLValue(transformer, ResolutionMode.AssignmentLValue(variableAssignment))

        val resolvedReference = variableAssignment.calleeReference

        if (assignAltererExtensions != null && resolvedReference is FirResolvedNamedReference) {
            val alteredAssignments = assignAltererExtensions.mapNotNull { alterer ->
                alterer.transformVariableAssignment(variableAssignment)?.let { it to alterer }
            }
            when (alteredAssignments.size) {
                0 -> {}
                1 -> {
                    val transformedAssignment = alteredAssignments.first().first
                    return transformedAssignment.transform(transformer, ResolutionMode.ContextIndependent)
                }

                else -> {
                    val extensionNames = alteredAssignments.map { it.second::class.qualifiedName }
                    val errorLValue = buildErrorExpression {
                        expression = variableAssignment.lValue
                        source = variableAssignment.lValue.source?.fakeElement(KtFakeSourceElementKind.AssignmentLValueError)
                        diagnostic = ConeAmbiguousAlteredAssign(extensionNames)
                    }
                    variableAssignment.replaceLValue(errorLValue)
                }
            }
        }

        val result = context.withAssignmentRhs {
            variableAssignment.transformRValue(
                transformer,
                withExpectedType(
                    variableAssignment.lValue.resolvedType.toFirResolvedTypeRef(),
                    expectedTypeMismatchIsReportedInChecker = true,
                ),
            )
        }

        // for cases like
        // buildSomething { tVar = """" // Should infer TV from String assignment }
        context.inferenceSession.addSubtypeConstraintIfCompatible(","lowerType = variableAssignment.rValue.resolvedType,"
"interface TextField {
    fun getText(): String
    fun setText(text: String)
}

class SimpleTextField : TextField {","private var text2 = """""
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer.mergedtree

import org.jetbrains.kotlin.commonizer.cir.CirName
import org.jetbrains.kotlin.commonizer.cir.CirPackage
import org.jetbrains.kotlin.commonizer.cir.CirPackageName
import org.jetbrains.kotlin.commonizer.utils.CommonizedGroup
import org.jetbrains.kotlin.commonizer.utils.CommonizerMap
import org.jetbrains.kotlin.commonizer.utils.firstNonNull
import org.jetbrains.kotlin.storage.NullableLazyValue

class CirPackageNode(
    override val targetDeclarations: CommonizedGroup<CirPackage>,
    override val commonDeclaration: NullableLazyValue<CirPackage>",") : CirNodeWithMembers<CirPackage, CirPackage> {"
"internal fun getMethodImplForTextTrackCueList(obj: TextTrackCueList, index: Int): TextTrackCue? { js(""return obj[index];"") }

public operator fun TextTrackCueList.get(index: Int): TextTrackCue? = getMethodImplForTextTrackCueList(this, index)

/**
 * Exposes the JavaScript [TextTrackCue](https://developer.mozilla.org/en/docs/Web/API/TextTrackCue) to Kotlin
 */
public external abstract class TextTrackCue : EventTarget, JsAny {
    open val track: TextTrack?
    open var id: String
    open var startTime: Double
    open var endTime: Double
    open var pauseOnExit: Boolean
    open var onenter: ((Event) -> Unit)?
    open var onexit: ((Event) -> Unit)?
}

/**
 * Exposes the JavaScript [TimeRanges](https://developer.mozilla.org/en/docs/Web/API/TimeRanges) to Kotlin
 */
public external abstract class TimeRanges : JsAny {
    open val length: Int
    fun start(index: Int): Double
    fun end(index: Int): Double
}

/**
 * Exposes the JavaScript [TrackEvent](https://developer.mozilla.org/en/docs/Web/API/TrackEvent) to Kotlin
 */
public external open class TrackEvent(type: String, eventInitDict: TrackEventInit = definedExternally) : Event, JsAny {
    open val track: UnionAudioTrackOrTextTrackOrVideoTrack?

    companion object {
        val NONE: Short
        val CAPTURING_PHASE: Short
        val AT_TARGET: Short
        val BUBBLING_PHASE: Short
    }
}

public external interface TrackEventInit : EventInit, JsAny {
    var track: UnionAudioTrackOrTextTrackOrVideoTrack? /* = null */
        get() = definedExternally
        set(value) = definedExternally
}

@Suppress(""UNUSED_PARAMETER"")
public fun TrackEventInit(track: UnionAudioTrackOrTextTrackOrVideoTrack? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): TrackEventInit { js(""return { track, bubbles, cancelable, composed };"") }

/**
 * Exposes the JavaScript [HTMLMapElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMapElement) to Kotlin
 */
public external abstract class HTMLMapElement : HTMLElement, JsAny {
    open var name: String
    open val areas: HTMLCollection

    companion object {
        val ELEMENT_NODE: Short
        val ATTRIBUTE_NODE: Short
        val TEXT_NODE: Short
        val CDATA_SECTION_NODE: Short
        val ENTITY_REFERENCE_NODE: Short
        val ENTITY_NODE: Short
        val PROCESSING_INSTRUCTION_NODE: Short
        val COMMENT_NODE: Short",val DOCUMENT_NODE: Short
"// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect
// !OPT_IN: kotlin.contracts.ExperimentalContracts
// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER

import kotlin.contracts.*

fun isString(x: Any?): Boolean {
    contract {
        returns(true) implies (x is String)
    }
    return x is String
}

fun exhaustive(x: Any?) {
    when (isString(x)) {
        true -> <!DEBUG_INFO_SMARTCAST!>x<!>.length
        false -> x.<!UNRESOLVED_REFERENCE!>length<!>
    }",when(!isString(x)) {
"// IGNORE_BACKEND: JS
// WITH_STDLIB
// WITH_COROUTINES
import helpers.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*


class Controller {
    var result = """"

    suspend fun <T> suspendWithResult(value: T): T = suspendCoroutineUninterceptedOrReturn { c ->
        c.resume(value)
        COROUTINE_SUSPENDED
    }
}

fun builder(c: suspend Controller.() -> Unit): String {",val controller = Controller()
"// FILE: B.kt

import aa.A.use
import aa.A.useList

fun testPrimitives(b: Byte, ss: Short, i: Int, l: Long, d: Double, s: String, f: Float, bool: Boolean) {
    use(b)
    use(ss)
    use(i)
    use(l)
    use(s)
    use(f)
    use(d)
    use(bool)
}

class N
class S: java.io.Serializable

fun testArrays(ia: IntArray, ai: Array<Int>, an: Array<N>, a: Array<S>) {
    use(ia)
    use(ai)
    use(an)
    use(a)
}

fun testLiterals() {
    use(1)
    use(1.0)
    use(11111111111111)
    use(""Asdsd"")
    use(true)
}

fun testNotSerializable(l: List<Int>) {
    use(<!TYPE_MISMATCH!>l<!>)
    use(<!TYPE_MISMATCH!>N()<!>)
}

enum class C {
    E, E2
}

fun testEnums(a: Enum<*>) {
    use(C.E)
    use(C.E2)
    use(a)
}

fun testLists(a: List<Int>) {",useList(a)
"* @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.
 * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].
 */
public actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {
    checkCopyOfRangeArguments(fromIndex, toIndex, size)
    return copyOfUninitializedElements(fromIndex, toIndex)
}

/**
 * Returns a new array which is a copy of the specified range of the original array.
 * 
 * @param fromIndex the start of the range (inclusive) to copy.
 * @param toIndex the end of the range (exclusive) to copy.
 * 
 * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.
 * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].
 */
public actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {
    checkCopyOfRangeArguments(fromIndex, toIndex, size)
    return copyOfUninitializedElements(fromIndex, toIndex)
}

/**
 * Returns a new array which is a copy of the specified range of the original array.
 * 
 * @param fromIndex the start of the range (inclusive) to copy.
 * @param toIndex the end of the range (exclusive) to copy.
 * 
 * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.
 * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].
 */
public actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {
    checkCopyOfRangeArguments(fromIndex, toIndex, size)
    return copyOfUninitializedElements(fromIndex, toIndex)
}

/**
 * Returns new array which is a copy of the original array's range between [fromIndex] (inclusive)
 * and [toIndex] (exclusive) with new elements filled with **lateinit** _uninitialized_ values.
 * Attempts to read _uninitialized_ values from this array work in implementation-dependent manner,
 * either throwing exception or returning some kind of implementation-specific default value.
 */
internal fun <T> Array<T>.copyOfUninitializedElements(fromIndex: Int, toIndex: Int): Array<T> {
    val newSize = toIndex - fromIndex
    if (newSize < 0) {
        throw IllegalArgumentException(""$fromIndex > $toIndex"")
    }
    val result = arrayOfUninitializedElements<T>(newSize)
    this.copyInto(result, 0, fromIndex, toIndex.coerceAtMost(size))
    return result
}

/**
 * Returns new array which is a copy of the original array's range between [fromIndex] (inclusive)
 * and [toIndex] (exclusive) with new elements filled with **lateinit** _uninitialized_ values.
 * Attempts to read _uninitialized_ values from this array work in implementation-dependent manner,
 * either throwing exception or returning some kind of implementation-specific default value.
 */
internal fun ByteArray.copyOfUninitializedElements(fromIndex: Int, toIndex: Int): ByteArray {
    val newSize = toIndex - fromIndex
    if (newSize < 0) {
        throw IllegalArgumentException(""$fromIndex > $toIndex"")
    }
    val result = ByteArray(newSize)
    this.copyInto(result, 0, fromIndex, toIndex.coerceAtMost(size))",return result
"// EXPECTED_REACHABLE_NODES: 1286
/*
 * Copy of JVM-backend test
 * Found at: compiler/testData/codegen/boxInline/lambdaTransformation/lambdaCloning.1.kt
 */

// FILE: foo.kt
package foo

import test.*

fun test1(s: Long): String {
    return doSmth(s)
}

fun test2(s: Int): String {
    return doSmth2(s)
}

fun box(): String {",var result = test1(11)
"package com.example.dagger.kotlin

class DemoApplication : BaseApplication() {
    lateinit var component: ApplicationComponent

    override fun onCreate() {
        super.onCreate()
        val component = initDaggerComponent()","component.inject(this) // As of now, LocationManager should be injected into this."
"// !DIAGNOSTICS: -UNUSED_VARIABLE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_PARAMETER -UNUSED_EXPRESSION
// SKIP_TXT

/*
 * KOTLIN DIAGNOSTICS SPEC TEST (POSITIVE)
 *
 * SPEC VERSION: 0.1-268
 * MAIN LINK: overload-resolution, building-the-overload-candidate-set-ocs, call-with-an-explicit-receiver -> paragraph 6 -> sentence 1
 * PRIMARY LINKS: overload-resolution, c-level-partition -> paragraph 1 -> sentence 1
 * overload-resolution, building-the-overload-candidate-set-ocs, call-with-an-explicit-receiver -> paragraph 3 -> sentence 1
 * overload-resolution, building-the-overload-candidate-set-ocs, call-with-an-explicit-receiver -> paragraph 2 -> sentence 1
 * overload-resolution, receivers -> paragraph 7 -> sentence 2
 * overload-resolution, receivers -> paragraph 7 -> sentence 3
 * NUMBER: 1
 * DESCRIPTION: sets of non-extension member callables only
 */

package tests.test2

// TESTCASE NUMBER: 1
open class Case1() {",companion object foo {
"internal val serializationExceptionName = ""kotlinx/serialization/$SERIAL_EXC""
internal val serializationExceptionMissingFieldName = ""kotlinx/serialization/$MISSING_FIELD_EXC""
internal val serializationExceptionUnknownIndexName = ""kotlinx/serialization/$UNKNOWN_FIELD_EXC""

internal val annotationType = Type.getObjectType(""java/lang/annotation/Annotation"")
internal val annotationArrayType = Type.getObjectType(""[${annotationType.descriptor}"")
internal val doubleAnnotationArrayType = Type.getObjectType(""[${annotationArrayType.descriptor}"")
internal val stringType = AsmTypes.JAVA_STRING_TYPE
internal val stringArrayType = Type.getObjectType(""[${stringType.descriptor}"")

internal val descriptorGetterName = JvmAbi.getterName(SERIAL_DESC_FIELD)
internal val getLazyValueName = JvmAbi.getterName(""value"")

val OPT_MASK_TYPE: Type = Type.INT_TYPE
val OPT_MASK_BITS = 32

// compare with zero. if result == 0, property was not seen.
internal fun InstructionAdapter.genValidateProperty(index: Int, bitMaskAddress: Int) {
    load(bitMaskAddress, OPT_MASK_TYPE)
    iconst(1 shl (index % OPT_MASK_BITS))
    and(OPT_MASK_TYPE)
    iconst(0)
}

internal fun InstructionAdapter.genMissingFieldExceptionThrow(fieldName: String) {
    anew(Type.getObjectType(serializationExceptionMissingFieldName))
    dup()
    aconst(fieldName)
    invokespecial(serializationExceptionMissingFieldName, ""<init>"", ""(Ljava/lang/String;)V"", false)
    checkcast(Type.getObjectType(""java/lang/Throwable""))
    athrow()
}

fun InstructionAdapter.genKOutputMethodCall(
    property: SerializableProperty, classCodegen: ImplementationBodyCodegen, expressionCodegen: ExpressionCodegen,
    propertyOwnerType: Type, ownerVar: Int, fromClassStartVar: Int? = null,
    generator: AbstractSerialGenerator
) {
    val propertyType = classCodegen.typeMapper.mapType(property.type)
    val sti = generator.getSerialTypeInfo(property, propertyType)
    val useSerializer = if (fromClassStartVar == null) stackValueSerializerInstanceFromSerializer(expressionCodegen, classCodegen, sti, generator)
    else stackValueSerializerInstanceFromClass(expressionCodegen, classCodegen, sti, fromClassStartVar, generator)
    val actualType = ImplementationBodyCodegen.genPropertyOnStack(
        this,
        expressionCodegen.context,
        property.descriptor,
        propertyOwnerType,
        ownerVar,
        classCodegen.state
    )
    actualType?.type?.let { type -> StackValue.coerce(type, sti.type, this) }
    invokeinterface(
        kOutputType.internalName,
        CallingConventions.encode + sti.elementMethodPrefix + (if (useSerializer) ""Serializable"" else """") + CallingConventions.elementPostfix,
        ""("" + descType.descriptor + ""I"" +
                (if (useSerializer) kSerialSaverType.descriptor else """") +
                (sti.type.descriptor) + "")V""
    )
}

internal fun InstructionAdapter.buildInternalConstructorDesc(
    propsStartVar: Int,
    bitMaskBase: Int,
    codegen: ClassBodyCodegen,
    args: List<SerializableProperty>",): String {
"fun IrConstantArrayImpl(
    startOffset: Int,
    endOffset: Int,
    type: IrType,
    initElements: List<IrConstantValue>,
) = IrConstantArrayImpl(
    constructorIndicator = null,
    startOffset = startOffset,
    endOffset = endOffset,
    type = type,
).apply {
    elements.addAll(initElements)
}

fun IrConstantObjectImpl(
    startOffset: Int,
    endOffset: Int,
    constructor: IrConstructorSymbol,
    initValueArguments: List<IrConstantValue>,
    initTypeArguments: List<IrType>,
    type: IrType = constructor.owner.constructedClassType,
) = IrConstantObjectImpl(
    constructorIndicator = null,
    startOffset = startOffset,
    endOffset = endOffset,
    constructor = constructor,
    type = type,
).apply {
    valueArguments.addAll(initValueArguments)
    typeArguments.addAll(initTypeArguments)
}

fun IrConstantPrimitiveImpl(
    startOffset: Int,
    endOffset: Int,
    value: IrConst<*>,
) = IrConstantPrimitiveImpl(
    constructorIndicator = null,
    startOffset = startOffset,
    endOffset = endOffset,
    value = value,
    type = value.type,
)

fun <T> IrConstImpl(
    startOffset: Int,
    endOffset: Int,
    type: IrType,
    kind: IrConstKind<T>,
    value: T,
) = IrConstImpl(
    constructorIndicator = null,
    startOffset = startOffset,
    endOffset = endOffset,
    type = type,
    kind = kind,
    value = value,
)

fun IrContinueImpl(
    startOffset: Int,
    endOffset: Int,
    type: IrType,
    loop: IrLoop,",) = IrContinueImpl(
"// FIR_IDENTICAL

fun test1(a: Int, b: Int) = a == b
fun test2(a: Int, b: Int) = a != b","fun test3(a: Any?, b: Any?) = a == b"
"fun `test - sample0 - assemble`(gradleVersion: GradleVersion) {
        val producer = project(""mpp-composite-build/sample0/producerBuild"", gradleVersion)

        project(""mpp-composite-build/sample0/consumerBuild"", gradleVersion) {
            settingsGradleKts.toFile().replaceText(""<producer_path>"", producer.projectPath.toUri().path)
            build(""cleanNativeDistributionCommonization"")

            build(""assemble"") {
                assertTasksExecuted("":consumerA:compileCommonMainKotlinMetadata"")
                assertTasksExecuted("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksExecuted("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksExecuted("":consumerA:compileKotlinLinuxX64"")
                assertTasksExecuted("":consumerA:compileKotlinJvm"")
            }

            build(""assemble"") {
                assertTasksUpToDate("":consumerA:compileCommonMainKotlinMetadata"")
                assertTasksUpToDate("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksUpToDate("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksUpToDate("":consumerA:compileKotlinLinuxX64"")
                assertTasksUpToDate("":consumerA:compileKotlinJvm"")
            }
        }
    }

    @GradleTest
    fun `test - sample0 - assemble - enableCInteropCommonization=true`(gradleVersion: GradleVersion) {
        val producer = project(""mpp-composite-build/sample0/producerBuild"", gradleVersion)

        project(
            ""mpp-composite-build/sample0/consumerBuild"", gradleVersion, defaultBuildOptions.copy(
                freeArgs = defaultBuildOptions.freeArgs + ""-Pkotlin.mpp.enableCInteropCommonization=true""
            )
        ) {
            settingsGradleKts.toFile().replaceText(""<producer_path>"", producer.projectPath.toUri().path)
            build(""assemble"") {
                assertTasksExecuted("":consumerA:compileCommonMainKotlinMetadata"")
                assertTasksExecuted("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksExecuted("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksExecuted("":consumerA:compileKotlinLinuxX64"")
                assertTasksExecuted("":consumerA:compileKotlinJvm"")
            }

            build(""assemble"") {
                assertTasksUpToDate("":consumerA:compileCommonMainKotlinMetadata"")
                assertTasksUpToDate("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksUpToDate("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksUpToDate("":consumerA:compileKotlinLinuxX64"")
                assertTasksUpToDate("":consumerA:compileKotlinJvm"")
            }
        }
    }

    /**
     * Test that verifies that after moving to 'buildPath' and 'buildName' in project coordinates (1.9.20),
     * the shape of the resolved coordinate are the same across different versions of Gradle.
     */
    @GradleTest
    fun `test - sample0 - buildId buildPath buildName`(gradleVersion: GradleVersion) {
        val producer = project(""mpp-composite-build/sample0/producerBuild"", gradleVersion)

        project(""mpp-composite-build/sample0/consumerBuild"", gradleVersion) {
            settingsGradleKts.toFile().replaceText(""<producer_path>"", producer.projectPath.toUri().path)
            resolveIdeDependencies("":consumerA"") { dependencies ->
                /* Pick some known dependency  and run check on it */","val dependency = dependencies[""commonMain""].getOrFail(regularSourceDependency("":producerBuild::producerA/commonMain""))"
"// FIR_IDENTICAL
// FILE: J.java

class J extends K {
    void foo() {}
}

// FILE: K.kt",class K : <!CYCLIC_INHERITANCE_HIERARCHY!>J<!>() {
"// Auto-generated by GenerateInRangeExpressionTestData. Do not edit!
// WITH_STDLIB",val range0 = 1u..3u
"// WITH_STDLIB
// ISSUE: KT-55379

fun test_1(b: Any) {
    require(b is Boolean)
    val x = <!NO_ELSE_IN_WHEN!>when<!> (b) {
        true -> 1
    }
    val y = when (b) {",true -> 1
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.fir.symbols

import org.jetbrains.kotlin.KtFakeSourceElementKind
import org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession
import org.jetbrains.kotlin.analysis.api.fir.KtSymbolByFirBuilder
import org.jetbrains.kotlin.analysis.api.fir.utils.firSymbol
import org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeOwner
import org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken
import org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion
import org.jetbrains.kotlin.analysis.api.symbols.KtClassLikeSymbol
import org.jetbrains.kotlin.analysis.api.symbols.KtSymbol
import org.jetbrains.kotlin.analysis.api.symbols.KtSymbolOrigin
import org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolKind
import org.jetbrains.kotlin.analysis.low.level.api.fir.util.errorWithFirSpecificEntries
import org.jetbrains.kotlin.fir.utils.exceptions.withFirEntry
import org.jetbrains.kotlin.utils.exceptions.errorWithAttachment
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.declarations.synthetic.FirSyntheticProperty",import org.jetbrains.kotlin.fir.declarations.synthetic.FirSyntheticPropertyAccessor
"// !LANGUAGE: +ProperFinally
var result = """"

fun test() {",for (z in 1..2) {
"// FIR_IDENTICAL
@file:OptIn(ExperimentalSubclassOptIn::class)

@RequiresOptIn
annotation class ApiMarker

@SubclassOptInRequired(ApiMarker::class)
interface Interface

fun foo() {
    // error: inheriting Interface requires an explicit opt-in
    open class LocalOpenKlassA: <!OPT_IN_USAGE_ERROR!>Interface<!>
    abstract class LocalAbstractKlassA: <!OPT_IN_USAGE_ERROR!>Interface<!>
    class LocalKlassA: <!OPT_IN_USAGE_ERROR!>Interface<!>
    data class LocalDataKlassA(val arg: Int): <!OPT_IN_USAGE_ERROR!>Interface<!>
    object: <!OPT_IN_USAGE_ERROR!>Interface<!> {}

    // opt-in is present, no errors
    @OptIn(ApiMarker::class) open class LocalOpenKlassB: Interface
    @OptIn(ApiMarker::class) abstract class LocalAbstractKlassB: Interface
    @OptIn(ApiMarker::class) class LocalKlassB: Interface",@OptIn(ApiMarker::class) data class LocalDataKlassB(val arg: Int): Interface
"@see IrFileEntry.getSourceRangeInfo
            """""".trimIndent()
        }

        +offsetField(""start"")
        +offsetField(""end"")

        kDoc = ""The root interface of the IR tree. Each IR node implements this interface.""
    }
    val statement: Element by element(Other)

    val declaration: Element by element(Declaration) {
        parent(statement)
        parent(symbolOwner)
        parent(mutableAnnotationContainer)

        +descriptor(""DeclarationDescriptor"")
        +field(""origin"", type(Packages.declarations, ""IrDeclarationOrigin""))
        +factory

        generationCallback = {
            println()
            printPropertyDeclaration(""parent"", declarationParent, VariableKind.VAR)
            println()
        }
    }
    val declarationBase: Element by element(Declaration) {
        // This class is defined manually, but the entry here needs to be kept actual as well,
        // to correctly generate related code.
        doPrint = false
        typeKind = TypeKind.Class
        transformByChildren = true
        transformerReturnType = statement
        nameInVisitorMethod = ""Declaration""

        parent(declaration)
    }
    val declarationParent: Element by element(Declaration)
    val declarationWithVisibility: Element by element(Declaration) {
        parent(declaration)

        +field(""visibility"", type(Packages.descriptors, ""DescriptorVisibility""))
    }
    val declarationWithName: Element by element(Declaration) {
        parent(declaration)

        +field(""name"", type<Name>())
    }
    val possiblyExternalDeclaration: Element by element(Declaration) {
        parent(declarationWithName)

        +field(""isExternal"", boolean) {
            useFieldInIrFactory(defaultValue = ""false"")
        }
    }
    val symbolOwner: Element by element(Declaration) {
        +declaredSymbol(symbolType)
    }
    val metadataSourceOwner: Element by element(Declaration) {
        val metadataField = +field(""metadata"", type(Packages.declarations, ""MetadataSource""), nullable = true) {
            skipInIrFactory()
            kDoc = """"""
            The arbitrary metadata associated with this IR node.
            
            @see ${render()}",""""""".trimIndent()"
"it.name == KtxNameConventions.ENDRESTARTGROUP && it.valueParameters.size == 0
            }
    }

    private val sourceInformationFunction by guardedLazy {
        getTopLevelFunction(ComposeCallableIds.sourceInformation).owner
    }

    private val sourceInformationMarkerStartFunction by guardedLazy {
        getTopLevelFunction(ComposeCallableIds.sourceInformationMarkerStart).owner
    }

    private val updateChangedFlagsFunction: IrSimpleFunction? by guardedLazy {
        getTopLevelFunctionOrNull(
            ComposeCallableIds.updateChangedFlags
        )?.let {
            val owner = it.owner
            if (owner.valueParameters.size == 1) owner else null
        }
    }

    private val isTraceInProgressFunction by guardedLazy {
        getTopLevelFunctions(ComposeCallableIds.isTraceInProgress).singleOrNull {
            it.owner.valueParameters.isEmpty()
        }?.owner
    }

    private val traceEventStartFunction by guardedLazy {
        getTopLevelFunctions(ComposeCallableIds.traceEventStart).singleOrNull {
            it.owner.valueParameters.map { p -> p.type } == listOf(
                context.irBuiltIns.intType,
                context.irBuiltIns.intType,
                context.irBuiltIns.intType,
                context.irBuiltIns.stringType
            )
        }?.owner
    }

    private val traceEventEndFunction by guardedLazy {
        getTopLevelFunctions(ComposeCallableIds.traceEventEnd).singleOrNull {
            it.owner.valueParameters.isEmpty()
        }?.owner
    }

    private val traceEventMarkersEnabled get() =
        traceMarkersEnabled && traceEventEndFunction != null

    private val sourceInformationMarkerEndFunction by guardedLazy {
        getTopLevelFunction(ComposeCallableIds.sourceInformationMarkerEnd).owner
    }

    private val rememberComposableLambdaFunction by guardedLazy {
        getTopLevelFunctions(ComposeCallableIds.rememberComposableLambda).singleOrNull()
    }

    private val useNonSkippingGroupOptimization by guardedLazy {
        // Uses `rememberComposableLambda` as a indication that the runtime supports
        // generating remember after call as it was added at the same time as the slot table was
        // modified to support remember after call.
        FeatureFlag.OptimizeNonSkippingGroups.enabled && rememberComposableLambdaFunction != null
    }

    private val IrType.arguments: List<IrTypeArgument>
        get() = (this as? IrSimpleType)?.arguments.orEmpty()",private val updateScopeFunction by guardedLazy {
"// EXPECTED_REACHABLE_NODES: 1291
package foo

class A(val value: Int) : Comparable<A> {
    override public fun compareTo(other: A): Int = other.value.compareTo(value)
}

class B(val value: Int)",fun testExtensionFunctionAsCompareTo() {
"// IGNORE_BACKEND: WASM
// WASM_MUTE_REASON: IGNORED_IN_JS
// TARGET_BACKEND: JVM

// FILE: Bar.java
public class Bar {
    public static String bar() {
        return null;
    }
}

// FILE: main.kt
fun foo(): Any? {
    return if (true) {
        if (true) {
            Bar.bar()",} else {
"package foo

class A {
    @JsName(""x_"") val x: Int
        <!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@JsName(""get_x"")<!> get() = 23

    @JsName(""y_"") val y = 0

    @JsName(""m_"") var m: Int
        <!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@JsName(""get_m"")<!> get() = 23","<!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@JsName(""set_m"")<!> set(value) {}"
"trace.report(
                    COMPATIBILITY_WARNING.on(callElement.getCalleeExpressionIfAny() ?: callElement, diagnostic.candidate)
                )
            }
            is NoContextReceiver -> {
                val callElement = psiKotlinCall.psiCall.callElement
                trace.report(
                    NO_CONTEXT_RECEIVER.on(
                        callElement.getCalleeExpressionIfAny() ?: callElement,
                        diagnostic.receiverDescriptor.value.toString()
                    )
                )
            }
            is MultipleArgumentsApplicableForContextReceiver -> {
                val callElement = psiKotlinCall.psiCall.callElement
                trace.report(
                    MULTIPLE_ARGUMENTS_APPLICABLE_FOR_CONTEXT_RECEIVER.on(callElement, diagnostic.receiverDescriptor.value.toString())
                )
            }
            is ContextReceiverAmbiguity -> {
                val callElement = psiKotlinCall.psiCall.callElement
                trace.report(AMBIGUOUS_CALL_WITH_IMPLICIT_CONTEXT_RECEIVER.on(callElement))
            }
            is UnsupportedContextualDeclarationCall -> {
                val callElement = psiKotlinCall.psiCall.callElement
                trace.report(UNSUPPORTED_CONTEXTUAL_DECLARATION_CALL.on(callElement))
            }

            is AdaptedCallableReferenceIsUsedWithReflection, is NotCallableMemberReference, is CallableReferencesDefaultArgumentUsed -> {
                // AdaptedCallableReferenceIsUsedWithReflection -> reported in onCallArgument
                // NotCallableMemberReference -> UNSUPPORTED reported in DoubleColonExpressionResolver
                // CallableReferencesDefaultArgumentUsed -> possible in 1.3 and earlier versions only
                return
            }

            else -> {
                unknownError(diagnostic, ""onCall"")
            }
        }
    }

    override fun onTypeArguments(diagnostic: KotlinCallDiagnostic) {
        val psiCallElement = psiKotlinCall.psiCall.callElement
        val reportElement =
            if (psiCallElement is KtCallExpression)
                psiCallElement.typeArgumentList ?: psiCallElement.calleeExpression ?: psiCallElement
            else
                psiCallElement

        when (diagnostic) {
            is WrongCountOfTypeArguments -> {
                val expectedTypeArgumentsCount = diagnostic.descriptor.typeParameters.size
                trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(reportElement, expectedTypeArgumentsCount, diagnostic.descriptor))
            }
            else -> {
                unknownError(diagnostic, ""onTypeArguments"")
            }
        }
    }

    private fun unknownError(diagnostic: KotlinCallDiagnostic, onTarget: String) {
        if (AbstractTypeChecker.RUN_SLOW_ASSERTIONS) {
            throw AssertionError(""$onTarget should not be called with ${diagnostic::class.java}"")
        } else if (reportAdditionalErrors) {
            trace.report(",NEW_INFERENCE_UNKNOWN_ERROR.on(
"/**
 * Returns the greater of two values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun maxOf(a: Int, b: Int): Int {
    return JsMath.max(a, b)
}

/**
 * Returns the greater of two values.
 */
@SinceKotlin(""1.1"")
@Suppress(""NOTHING_TO_INLINE"")
public actual inline fun maxOf(a: Long, b: Long): Long {
    return if (a >= b) a else b
}

/**
 * Returns the greater of two values.
 * 
 * If either value is `NaN`, returns `NaN`.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun maxOf(a: Float, b: Float): Float {
    return JsMath.max(a, b)
}

/**
 * Returns the greater of two values.
 * 
 * If either value is `NaN`, returns `NaN`.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun maxOf(a: Double, b: Double): Double {
    return JsMath.max(a, b)
}

/**
 * Returns the greater of three values.
 * 
 * If there are multiple equal maximal values, returns the first of them.
 */
@SinceKotlin(""1.1"")
public actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {
    return maxOf(a, maxOf(b, c))
}

/**
 * Returns the greater of three values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {
    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()
}

/**
 * Returns the greater of three values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun maxOf(a: Short, b: Short, c: Short): Short {","return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()"
"/*
 * Copyright 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:OptIn(UnsafeDuringIrConstructionAPI::class)

package androidx.compose.compiler.plugins.kotlin.lower

import androidx.compose.compiler.plugins.kotlin.KtxNameConventions
import androidx.compose.compiler.plugins.kotlin.hasComposableAnnotation
import java.util.Locale
import org.jetbrains.kotlin.descriptors.DescriptorVisibilities
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.ir.IrBuiltIns
import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.declarations.IrAnnotationContainer
import org.jetbrains.kotlin.ir.declarations.IrAnonymousInitializer
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrConstructor
import org.jetbrains.kotlin.ir.declarations.IrDeclaration
import org.jetbrains.kotlin.ir.declarations.IrDeclarationOrigin
import org.jetbrains.kotlin.ir.declarations.IrDeclarationWithName
import org.jetbrains.kotlin.ir.declarations.IrField
import org.jetbrains.kotlin.ir.declarations.IrFile
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.declarations.IrLocalDelegatedProperty
import org.jetbrains.kotlin.ir.declarations.IrModuleFragment
import org.jetbrains.kotlin.ir.declarations.IrPackageFragment
import org.jetbrains.kotlin.ir.declarations.IrProperty
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.declarations.IrTypeAlias
import org.jetbrains.kotlin.ir.declarations.IrTypeParameter
import org.jetbrains.kotlin.ir.declarations.IrValueDeclaration
import org.jetbrains.kotlin.ir.declarations.IrValueParameter
import org.jetbrains.kotlin.ir.declarations.IrVariable
import org.jetbrains.kotlin.ir.expressions.IrBlock
import org.jetbrains.kotlin.ir.expressions.IrBlockBody
import org.jetbrains.kotlin.ir.expressions.IrBranch
import org.jetbrains.kotlin.ir.expressions.IrBreak
import org.jetbrains.kotlin.ir.expressions.IrBreakContinue
import org.jetbrains.kotlin.ir.expressions.IrCall
import org.jetbrains.kotlin.ir.expressions.IrCatch
import org.jetbrains.kotlin.ir.expressions.IrClassReference
import org.jetbrains.kotlin.ir.expressions.IrComposite
import org.jetbrains.kotlin.ir.expressions.IrConst
import org.jetbrains.kotlin.ir.expressions.IrConstKind",import org.jetbrains.kotlin.ir.expressions.IrConstructorCall
"}

fun test12(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out kotlin.Any)"")!>foo12 { 1 }.value.value<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out kotlin.Any)"")!>foo12 { 2 }.value.value<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

// ------------------------------------------------------------------------------------------------

fun test20(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""I1"")!>foo20 { 1 }<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""I1"")!>foo20 { 2 }<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

fun test21(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo21 { 1 }.value<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo21 { 2 }.value<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

fun test22(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo22 { 1 }.value.value<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo22 { 2 }.value.value<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

// ------------------------------------------------------------------------------------------------

fun test30(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""I1"")!>foo30 { 1 }<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""I1"")!>foo30 { 2 }<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

fun test31(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo31 { 1 }.value<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo31 { 2 }.value<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

fun test32(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo32 { 1 }.value.value<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo32 { 2 }.value.value<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

// ------------------------------------------------------------------------------------------------

fun test40(b: Boolean) {","var x = <!DEBUG_INFO_EXPRESSION_TYPE(""<anonymous>"")!>foo40 { 1 }<!>"
"For language feature testing, use `// !LANGUAGE: [+-]FeatureName` directive instead,
            where FeatureName is an entry of the enum `LanguageFeature`
        """""".trimIndent()
    )


    // --------------------- Analysis Flags ---------------------

    val OPT_IN by stringDirective(
        description = ""List of opted in annotations (AnalysisFlags.optIn)""
    )

    val IGNORE_DATA_FLOW_IN_ASSERT by directive(
        description = ""Enables corresponding analysis flag (AnalysisFlags.ignoreDataFlowInAssert)""
    )

    val EXPLICIT_API_MODE by enumDirective(
        ""Configures explicit API mode (AnalysisFlags.explicitApiMode)"",
        additionalParser = ExplicitApiMode.Companion::fromString
    )

    val EXPLICIT_RETURN_TYPES_MODE by enumDirective(
        ""Configures explicit API mode (AnalysisFlags.explicitReturnTypes)"",
        additionalParser = ExplicitApiMode.Companion::fromString
    )

    val ALLOW_KOTLIN_PACKAGE by directive(
        description = ""Allow compiling code in package 'kotlin' and allow not requiring kotlin.stdlib in module-info (AnalysisFlags.allowKotlinPackage)""
    )

    val STDLIB_COMPILATION by directive(
        description = ""Enables corresponding analysis flag (AnalysisFlags.stdlibCompilation)""
    )

    // It's inverted because otherwise we would have warnings in almost all KMP tests
    val ENABLE_EXPECT_ACTUAL_CLASSES_WARNING by stringDirective(
        description = ""Disables -Xexpect-actual-classes key""
    )

    // --------------------- Jvm Analysis Flags ---------------------

    val JVM_DEFAULT_MODE by enumDirective(
        description = ""Configures corresponding analysis flag (JvmAnalysisFlags.jvmDefaultMode)"",
        additionalParser = JvmDefaultMode.Companion::fromStringOrNull
    )

    val JDK_RELEASE by valueDirective(
        description = ""Configures corresponding release flag"",
        parser = Integer::valueOf
    )

    val INHERIT_MULTIFILE_PARTS by directive(
        description = ""Enables corresponding analysis flag (JvmAnalysisFlags.inheritMultifileParts)""
    )

    val SANITIZE_PARENTHESES by directive(
        description = ""Enables corresponding analysis flag (JvmAnalysisFlags.sanitizeParentheses)""
    )

    val ENABLE_JVM_PREVIEW by directive(""Enable JVM preview features"")
    val EMIT_JVM_TYPE_ANNOTATIONS by directive(""Enable emitting jvm type annotations"")
    val NO_OPTIMIZED_CALLABLE_REFERENCES by directive(""Don't optimize callable references"")
    val DISABLE_PARAM_ASSERTIONS by directive(""Disable assertions on parameters"")
    val DISABLE_CALL_ASSERTIONS by directive(""Disable assertions on calls"")","val NO_UNIFIED_NULL_CHECKS by directive(""No unified null checks"")"
""""""".trimIndent()
            )

            build("":compileDebugKotlin"") {
                assertTasksExecuted("":compileDebugKotlin"")
                assertCompilerArgument("":compileDebugKotlin"", ""-jvm-target 11"")
            }
        }
    }

    private fun BuildResult.assertJdkHomeIsUsingJdk(
        javaexecPath: String
    ) = assertOutputContains(""[KOTLIN] Kotlin compilation 'jdkHome' argument: $javaexecPath"")

    private fun getUserJdk(): JavaInfo = Jvm.forHome(File(System.getProperty(""java.home"")))
    private fun getJdk11(): JavaInfo = Jvm.forHome(File(System.getProperty(""jdk11Home"")))
    // replace required for windows paths so Groovy will not complain about unexpected char '\'
    private fun getJdk11Path(): String = getJdk11().javaHome.absolutePath.replace(""\\"", ""\\\\"")
    private val JavaInfo.javaHomeRealPath
        get() = javaHome
            .toPath()
            .toRealPath()
            .toAbsolutePath()
            .toString()

    private val String.fullProjectName get() = ""kotlin-java-toolchain/$this""

    private fun TestProject.setJvmTarget(
        jvmTarget: String
    ) {
        //language=Groovy
        buildGradle.append(
            """"""
            import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
            
            tasks.withType(KotlinCompile).configureEach {
                 kotlinOptions {
                      jvmTarget = ""$jvmTarget""
                 }            
            }
            """""".trimIndent()
        )
    }

    private fun TestProject.setJavaCompilationCompatibility(
        target: JavaVersion
    ) {
        //language=Groovy
        buildGradle.append(
            """"""

            tasks.withType(JavaCompile.class).configureEach {
                sourceCompatibility = JavaVersion.${target.name}
                targetCompatibility = JavaVersion.${target.name}
            }
            
            """""".trimIndent()
        )
    }

    private fun TestProject.useJdkToCompile(
        jdkPath: String,
        jdkVersion: JavaVersion
    ) {
        //language=Groovy",buildGradle.append(
"// EXPECTED_REACHABLE_NODES: 1282
package test

external fun foo(): dynamic

external fun bar(): dynamic

fun box(): String {","val foo = ""local foo;"""
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir

import org.jetbrains.kotlin.fir.declarations.FirSimpleFunction
import org.jetbrains.kotlin.fir.declarations.utils.isLocal
import org.jetbrains.kotlin.fir.types.ConeKotlinType
import org.jetbrains.kotlin.fir.types.arrayElementType
import org.jetbrains.kotlin.fir.types.coneType",import org.jetbrains.kotlin.fir.types.isArrayType
"object EmptyTypeHierarchy : TypeHierarchy {
            override val allTypes: Array<DataFlowIR.Type.Declared> = emptyArray()

            override fun inheritorsOf(type: DataFlowIR.Type.Declared): BitSet {
                return BitSet()
            }
        }

        inner class TypeHierarchyImpl(override val allTypes: Array<DataFlowIR.Type.Declared>) : TypeHierarchy {
            private val typesSubTypes = Array(allTypes.size) { mutableListOf<DataFlowIR.Type.Declared>() }
            private val allInheritors = Array(allTypes.size) { BitSet() }

            init {
                val visited = BitSet()

                fun processType(type: DataFlowIR.Type.Declared) {
                    if (visited[type.index]) return
                    visited.set(type.index)
                    type.superTypes
                            .map { it.resolved() }
                            .forEach { superType ->
                                val subTypes = typesSubTypes[superType.index]
                                subTypes += type
                                processType(superType)
                            }
                }

                allTypes.forEach { processType(it) }
            }

            override fun inheritorsOf(type: DataFlowIR.Type.Declared): BitSet {
                val typeId = type.index
                val inheritors = allInheritors[typeId]
                if (!inheritors.isEmpty || type == DataFlowIR.Type.Virtual) return inheritors
                inheritors.set(typeId)
                for (subType in typesSubTypes[typeId])
                    inheritors.or(inheritorsOf(subType))
                return inheritors
            }
        }

        private fun DataFlowIR.Type.Declared.calleeAt(callSite: DataFlowIR.Node.VirtualCall) = when (callSite) {
            is DataFlowIR.Node.VtableCall ->
                vtable[callSite.calleeVtableIndex]

            is DataFlowIR.Node.ItableCall ->
                itable[callSite.interfaceId]!![callSite.calleeItableIndex]

            else -> error(""Unreachable"")
        }

        fun logPathToType(reversedEdges: IntArray, node: Node, type: Int) {
            val nodes = constraintGraph.nodes
            val visited = BitSet()
            val prev = mutableMapOf<Node, Node>()
            var front = mutableListOf<Node>()
            front.add(node)
            visited.set(node.id)
            lateinit var source: Node.Source
            bfs@while (front.isNotEmpty()) {
                val prevFront = front
                front = mutableListOf()
                for (from in prevFront) {
                    var endBfs = false
                    reversedEdges.forEachEdge(from.id) { toId ->",val to = nodes[toId]
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.scripting.compiler.plugin.repl

import com.intellij.core.JavaCoreProjectEnvironment
import org.jetbrains.kotlin.cli.common.CLIConfigurationKeys
import org.jetbrains.kotlin.cli.common.messages.*
import org.jetbrains.kotlin.cli.common.repl.ReplClassLoader
import org.jetbrains.kotlin.cli.common.repl.ReplEvalResult
import org.jetbrains.kotlin.cli.jvm.compiler.EnvironmentConfigFiles",import org.jetbrains.kotlin.cli.jvm.compiler.KotlinCoreEnvironment
"type.orExpected(index)
            } ?: expectedParameters.map { it.type.unwrap() }) to (if (receiverFromExpected) expectedReceiver else null)
    }
    val contextReceivers = (argumentAsFunctionExpression?.contextReceiversTypes ?: expectedContextReceivers).filterNotNull()

    val returnType = argumentAsFunctionExpression?.returnType ?: expectedType.getReturnTypeFromFunctionType().unwrap()

    return ResolvedLambdaAtom(
        argument,
        expectedType.isSuspendFunctionType,
        receiver,
        contextReceivers,
        parameters,
        returnType,
        typeVariableForLambdaReturnType = returnTypeVariable,
        expectedType = expectedType
    )
}

fun LambdaWithTypeVariableAsExpectedTypeAtom.transformToResolvedLambda(
    csBuilder: ConstraintSystemBuilder,
    diagnosticsHolder: KotlinDiagnosticsHolder,
    expectedType: UnwrappedType? = null,
    returnTypeVariable: TypeVariableForLambdaReturnType? = null
): ResolvedLambdaAtom {
    val fixedExpectedType = (csBuilder.buildCurrentSubstitutor() as NewTypeSubstitutor)
        .safeSubstitute(expectedType ?: this.expectedType)
    val resolvedLambdaAtom = preprocessLambdaArgument(
        csBuilder,
        atom,
        fixedExpectedType,
        diagnosticsHolder,
        forceResolution = true,
        returnTypeVariable = returnTypeVariable
    ) as ResolvedLambdaAtom

    setAnalyzed(resolvedLambdaAtom)

    return resolvedLambdaAtom
}

fun ResolvedLambdaAtom.transformToResolvedLambda(
    csBuilder: ConstraintSystemBuilder,
    diagnosticsHolder: KotlinDiagnosticsHolder,
    expectedType: UnwrappedType,
    returnTypeVariable: TypeVariableForLambdaReturnType? = null
): ResolvedLambdaAtom {
    return preprocessLambdaArgument(
        csBuilder,
        atom,
        expectedType,
        diagnosticsHolder,
        forceResolution = true,
        returnTypeVariable = returnTypeVariable
    ).also {
        this.setAnalyzedResults(null, listOf(it))
    } as ResolvedLambdaAtom
}

private fun preprocessCallableReference(
    csBuilder: ConstraintSystemBuilder,
    argument: CallableReferenceKotlinCallArgument,
    expectedType: UnwrappedType?,
    diagnosticsHolder: KotlinDiagnosticsHolder
): ResolvedAtom {","val result = EagerCallableReferenceAtom(argument, expectedType)"
// !DIAGNOSTICS: -UNUSED_PARAMETER,open class B(x: Int)
"// TODO: find out what to use instead here and in the dependent code
@OptIn(ObsoleteDescriptorBasedAPI::class)
private val ObjCExportBlockCodeGenerator.mappedFunctionNClasses get() =
    // failed attempt to migrate to descriptor-less IrBuiltIns
    ((context.irBuiltIns as IrBuiltInsOverDescriptors).functionFactory as BuiltInFictitiousFunctionIrClassFactory).builtFunctionNClasses
        .filter { it.descriptor.isMappedFunctionClass() }

private fun ObjCExportBlockCodeGenerator.emitFunctionConverters() {
    require(generationState.shouldDefineFunctionClasses)
    mappedFunctionNClasses.forEach { functionClass ->
        val convertToRetained = kotlinFunctionToRetainedBlockConverter(BlockPointerBridge(functionClass.arity, returnsVoid = false))

        val writableTypeInfoValue = buildWritableTypeInfoValue(convertToRetained = convertToRetained.toConstPointer())
        setOwnWritableTypeInfo(functionClass.irClass, writableTypeInfoValue)
    }
}

private fun ObjCExportBlockCodeGenerator.emitBlockToKotlinFunctionConverters() {
    require(generationState.shouldDefineFunctionClasses)
    val functionClassesByArity = mappedFunctionNClasses.associateBy { it.arity }

    val arityLimit = (functionClassesByArity.keys.maxOrNull() ?: -1) + 1

    val converters = (0 until arityLimit).map { arity ->
        functionClassesByArity[arity]?.let {
            val bridge = BlockPointerBridge(numberOfParameters = arity, returnsVoid = false)
            blockToKotlinFunctionConverter(bridge).toConstPointer()
        } ?: NullPointer(objCToKotlinFunctionType)
    }

    val type = pointerType(objCToKotlinFunctionType)
    val ptr = staticData.placeGlobalArray(
            """",
            type,
            converters
    ).pointer.getElementPtr(llvm, LLVMArrayType(type, converters.size)!!, 0)

    // Note: defining globals declared in runtime.
    staticData.placeGlobal(""Kotlin_ObjCExport_blockToFunctionConverters"", ptr, isExported = true)
    staticData.placeGlobal(""Kotlin_ObjCExport_blockToFunctionConverters_size"", llvm.constInt32(arityLimit), isExported = true)
}

private fun ObjCExportCodeGenerator.emitSpecialClassesConvertions() {
    setObjCExportTypeInfo(
            symbols.string.owner,
            llvm.Kotlin_ObjCExport_CreateRetainedNSStringFromKString.toConstPointer()
    )

    emitCollectionConverters()

    emitBoxConverters()
}

private fun ObjCExportCodeGenerator.emitCollectionConverters() {

    fun importConverter(name: String): ConstPointer =
            llvm.externalNativeRuntimeFunction(name, kotlinToObjCFunctionType).toConstPointer()

    setObjCExportTypeInfo(
            symbols.list.owner,
            importConverter(""Kotlin_Interop_CreateRetainedNSArrayFromKList"")
    )

    setObjCExportTypeInfo(
            symbols.mutableList.owner,","importConverter(""Kotlin_Interop_CreateRetainedNSMutableArrayFromKList"")"
"public fun kotlin.UShortArray.maxOrNull(): kotlin.UShort?

@kotlin.SinceKotlin(version = ""1.4"")
public fun <T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.maxOrNull(): T?

@kotlin.SinceKotlin(version = ""1.4"")
public fun kotlin.collections.Iterable<kotlin.Double>.maxOrNull(): kotlin.Double?

@kotlin.SinceKotlin(version = ""1.4"")
public fun kotlin.collections.Iterable<kotlin.Float>.maxOrNull(): kotlin.Float?

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun <T> kotlin.Array<out T>.maxWith(comparator: kotlin.Comparator<in T>): T

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.BooleanArray.maxWith(comparator: kotlin.Comparator<in kotlin.Boolean>): kotlin.Boolean

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.ByteArray.maxWith(comparator: kotlin.Comparator<in kotlin.Byte>): kotlin.Byte

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.CharArray.maxWith(comparator: kotlin.Comparator<in kotlin.Char>): kotlin.Char

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.DoubleArray.maxWith(comparator: kotlin.Comparator<in kotlin.Double>): kotlin.Double

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.FloatArray.maxWith(comparator: kotlin.Comparator<in kotlin.Float>): kotlin.Float

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.IntArray.maxWith(comparator: kotlin.Comparator<in kotlin.Int>): kotlin.Int

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.LongArray.maxWith(comparator: kotlin.Comparator<in kotlin.Long>): kotlin.Long

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.ShortArray.maxWith(comparator: kotlin.Comparator<in kotlin.Short>): kotlin.Short

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UByteArray.maxWith(comparator: kotlin.Comparator<in kotlin.UByte>): kotlin.UByte

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UIntArray.maxWith(comparator: kotlin.Comparator<in kotlin.UInt>): kotlin.UInt

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.ULongArray.maxWith(comparator: kotlin.Comparator<in kotlin.ULong>): kotlin.ULong

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes",public fun kotlin.UShortArray.maxWith(comparator: kotlin.Comparator<in kotlin.UShort>): kotlin.UShort
"private fun renderResolverModuleInfos(): String = projectContext.storageManager.compute {
        moduleInfoByDescriptor.entries.joinToString("",\n"") { (descriptor, moduleInfo) ->
            """"""
            {
                moduleDescriptor: $descriptor
                moduleInfo: $moduleInfo
            }
            """""".trimIndent()
        }
    }
}

private class DelegatingPackageFragmentProvider<M : ModuleInfo>(
    private val resolverForProject: AbstractResolverForProject<M>,
    private val module: ModuleDescriptor,
    moduleContent: ModuleContent<M>,
    private val packageOracle: PackageOracle
) : PackageFragmentProviderOptimized {
    private val syntheticFilePackages = moduleContent.syntheticFiles.map { it.packageFqName }.toSet()

    @Suppress(""OverridingDeprecatedMember"", ""OVERRIDE_DEPRECATION"")
    override fun getPackageFragments(fqName: FqName): List<PackageFragmentDescriptor> {
        if (certainlyDoesNotExist(fqName)) return emptyList()

        @Suppress(""DEPRECATION"")
        return resolverForProject.resolverForModuleDescriptor(module).packageFragmentProvider.getPackageFragments(fqName)
    }

    override fun collectPackageFragments(fqName: FqName, packageFragments: MutableCollection<PackageFragmentDescriptor>) {
        if (certainlyDoesNotExist(fqName)) return

        resolverForProject.resolverForModuleDescriptor(module)
            .packageFragmentProvider
            .collectPackageFragmentsOptimizedIfPossible(fqName, packageFragments)
    }

    override fun isEmpty(fqName: FqName): Boolean {
        if (certainlyDoesNotExist(fqName)) return true

        return resolverForProject.resolverForModuleDescriptor(module).packageFragmentProvider.isEmpty(fqName)
    }

    override fun getSubPackagesOf(fqName: FqName, nameFilter: (Name) -> Boolean): Collection<FqName> {
        if (certainlyDoesNotExist(fqName)) return emptyList()

        return resolverForProject.resolverForModuleDescriptor(module).packageFragmentProvider.getSubPackagesOf(fqName, nameFilter)
    }

    private fun certainlyDoesNotExist(fqName: FqName): Boolean {
        if (resolverForProject.isResolverForModuleDescriptorComputed(module)) return false // let this request get cached inside delegate

        return !packageOracle.packageExists(fqName) && fqName !in syntheticFilePackages
    }

    override fun toString(): String {
        return ""DelegatingProvider for $module in ${resolverForProject.name}""
    }
}

private object DiagnoseUnknownModuleInfoReporter {
    fun report(name: String, infos: List<ModuleInfo>, allModules: Collection<ModuleInfo>): Nothing {
        val message = ""$name does not know how to resolve""
        val error = when {
            name.contains(ResolverForProject.resolverForSdkName) -> errorInSdkResolver(message)
            name.contains(ResolverForProject.resolverForLibrariesName) -> errorInLibrariesResolver(message)",name.contains(ResolverForProject.resolverForModulesName) -> {
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.generators.impl

import org.jetbrains.kotlin.generators.MethodGenerator
import org.jetbrains.kotlin.generators.TestGenerator
import org.jetbrains.kotlin.generators.TestGroup
import org.jetbrains.kotlin.generators.model.*
import org.jetbrains.kotlin.generators.util.GeneratorsFileUtil
import org.jetbrains.kotlin.test.JUnit3RunnerWithInners
import org.jetbrains.kotlin.test.KotlinTestUtils
import org.jetbrains.kotlin.test.TestMetadata
import org.jetbrains.kotlin.test.util.KtTestUtil
import org.jetbrains.kotlin.utils.Printer
import org.junit.Test
import org.junit.runner.RunWith
import org.junit.runners.BlockJUnit4ClassRunner
import java.io.File
import java.io.IOException

private val METHOD_GENERATORS = listOf(
    RunTestMethodGenerator,
    SimpleTestClassModelTestAllFilesPresentMethodGenerator,
    SimpleTestMethodGenerator,
    SingleClassTestModelAllFilesPresentedMethodGenerator,
    TransformingTestMethodGenerator,
)",object TestGeneratorImpl : TestGenerator(METHOD_GENERATORS) {
"val supertypesSupplier: SupertypeSupplier = object : SupertypeSupplier() {
        override fun forClass(firClass: FirClass, useSiteSession: FirSession): List<ConeClassLikeType> {
            val typeRefsFromSession = (getSupertypesComputationStatus(firClass) as? SupertypeComputationStatus.Computed)?.supertypeRefs
            val typeRefsToReturn = typeRefsFromSession ?: getResolvedSuperTypeRefsForOutOfSessionDeclaration(firClass)
            return typeRefsToReturn?.mapNotNull { it.coneTypeSafe<ConeClassLikeType>() }.orEmpty()
        }

        override fun expansionForTypeAlias(typeAlias: FirTypeAlias, useSiteSession: FirSession): ConeClassLikeType? {
            if (typeAlias.expandedTypeRef is FirResolvedTypeRef) return typeAlias.expandedConeType
            return (getSupertypesComputationStatus(typeAlias) as? SupertypeComputationStatus.Computed)
                ?.supertypeRefs
                ?.getOrNull(0)?.coneTypeSafe()
        }
    }

    fun getSupertypesComputationStatus(classLikeDeclaration: FirClassLikeDeclaration): SupertypeComputationStatus =
        supertypeStatusMap[classLikeDeclaration] ?: SupertypeComputationStatus.NotComputed

    fun getOrPutFileScope(file: FirFile, scope: () -> ScopePersistentList): ScopePersistentList =
        fileScopesMap.getOrPut(file) { scope() }

    fun getOrPutScopeForNestedClasses(klass: FirClass, scope: () -> ScopePersistentList): ScopePersistentList =
        scopesForNestedClassesMap.getOrPut(klass) { scope() }

    fun getOrPutScopeForStaticNestedClasses(klass: FirClass, scope: () -> ScopePersistentList): ScopePersistentList =
        scopesForStaticNestedClassesMap.getOrPut(klass) { scope() }

    fun getOrPutScopeForCompanion(klass: FirClass, scope: () -> ScopePersistentList): ScopePersistentList =
        scopesForCompanionMap.getOrPut(klass) { scope() }

    fun startComputingSupertypes(classLikeDeclaration: FirClassLikeDeclaration) {
        require(supertypeStatusMap[classLikeDeclaration] == null) {
            ""Unexpected in startComputingSupertypes supertype status for $classLikeDeclaration: ${supertypeStatusMap[classLikeDeclaration]}""
        }

        supertypeStatusMap[classLikeDeclaration] = SupertypeComputationStatus.Computing
    }

    fun storeSupertypes(classLikeDeclaration: FirClassLikeDeclaration, resolvedTypesRefs: List<FirResolvedTypeRef>) {
        require(supertypeStatusMap[classLikeDeclaration] is SupertypeComputationStatus.Computing) {
            ""Unexpected in storeSupertypes supertype status for $classLikeDeclaration: ${supertypeStatusMap[classLikeDeclaration]}""
        }

        supertypeStatusMap[classLikeDeclaration] = SupertypeComputationStatus.Computed(resolvedTypesRefs)
        newClassifiersForBreakingLoops.add(classLikeDeclaration)
    }

    private val newClassifiersForBreakingLoops = mutableListOf<FirClassLikeDeclaration>()

    /**
     * @param supertypeRefs a collection where at least one element is [FirErrorTypeRef] for looped references
     */
    protected open fun reportLoopErrorRefs(classLikeDeclaration: FirClassLikeDeclaration, supertypeRefs: List<FirResolvedTypeRef>) {
        supertypeStatusMap[classLikeDeclaration] = SupertypeComputationStatus.Computed(supertypeRefs)
    }

    protected open fun getResolvedSuperTypeRefsForOutOfSessionDeclaration(
        classLikeDeclaration: FirClassLikeDeclaration,
    ): List<FirResolvedTypeRef>? = when (classLikeDeclaration) {
        is FirClass -> classLikeDeclaration.superTypeRefs.filterIsInstance<FirResolvedTypeRef>()
        is FirTypeAlias -> listOfNotNull(classLikeDeclaration.expandedTypeRef as? FirResolvedTypeRef)
        else -> null
    }",internal open fun supertypeRefs(declaration: FirClassLikeDeclaration): List<FirTypeRef> = when (declaration) {
"typeParameter.getStubType(originalReturnType.isNullable)
                    } else {
                        // This shouldn't happen actually.
                        this.stubReturnType
                    }
                    val typeArgument = TypeArgumentStub(typeParameter.getStubType(false))
                    val receiverType = ClassifierStubType(KotlinTypes.objCClassOf, listOf(typeArgument))
                    val receiver = ReceiverParameterStub(receiverType)
                    val createMethod = FunctionStub(
                            ""create"",
                            returnType,
                            parameters,
                            receiver = receiver,
                            typeParameters = listOf(typeParameter),
                            external = true,
                            origin = StubOrigin.ObjCCategoryInitMethod(method),
                            annotations = annotations.toMutableList(),
                            modality = MemberStubModality.FINAL
                    )
                    // TODO: Should we deprecate it as well?
                    createMethod
                }
                is ObjCProtocol -> null
            }
        } else {
            null
        }
        if (isDeprecatedCategoryMethod && annotations.filterIsInstance<AnnotationStub.Deprecated>().isEmpty()) {
            val target = if (method.isClass) ""class"" else ""instance""
            annotations += AnnotationStub.Deprecated(message = ""Use $target method instead"", replaceWith = """", level = DeprecationLevel.WARNING)
        }
        return listOfNotNull(
                FunctionStub(
                        name,
                        stubReturnType,
                        kotlinMethodParameters.toList(),
                        origin,
                        annotations.toMutableList(),
                        external,
                        receiver,
                        modality,
                        emptyList(),
                        isOverride),
                replacement
        )
    }
}

internal val ObjCContainer.classOrProtocol: ObjCClassOrProtocol
    get() = when (this) {
        is ObjCClassOrProtocol -> this
        is ObjCCategory -> this.clazz
    }

private fun deprecatedInit(className: String, initParameterNames: List<String>, factory: Boolean): AnnotationStub {
    val replacement = if (factory) ""$className.create"" else className
    val replacementKind = if (factory) ""factory method"" else ""constructor""
    val replaceWith = ""$replacement(${initParameterNames.joinToString { it.asSimpleName() }})""
    return AnnotationStub.Deprecated(""Use $replacementKind instead"", replaceWith, DeprecationLevel.ERROR)
}

private fun ObjCMethod.isAlloc(): Boolean =
        this.isClass && (this.selector == ""alloc"" || this.selector == ""allocWithZone:"")

internal val ObjCMethod.kotlinName: String",get() {
"/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress(
    ""unused"",
    ""nothing_to_inline"",
    ""useless_cast"",
    ""unchecked_cast"",
    ""extension_shadowed_by_member"",
    ""redundant_projection"",
    ""RemoveRedundantBackticks"",
    ""ObjectPropertyName"",
    ""deprecation""
)
@file:org.gradle.api.Generated

/* ktlint-disable */

package gradle.kotlin.dsl.accessors._44a939cf26bc074355463a0d554ee592


import org.gradle.api.Action
import org.gradle.api.Incubating
import org.gradle.api.NamedDomainObjectProvider
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurablePublishArtifact
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.Dependency
import org.gradle.api.artifacts.DependencyConstraint
import org.gradle.api.artifacts.ExternalModuleDependency
import org.gradle.api.artifacts.ModuleDependency
import org.gradle.api.artifacts.PublishArtifact
import org.gradle.api.artifacts.dsl.ArtifactHandler
import org.gradle.api.artifacts.dsl.DependencyConstraintHandler",import org.gradle.api.artifacts.dsl.DependencyHandler
""""""".trimIndent())
        output(""typedef unsigned short     ${prefix}_KChar;"")
        output(""typedef signed char        ${prefix}_KByte;"")
        output(""typedef short              ${prefix}_KShort;"")
        output(""typedef int                ${prefix}_KInt;"")
        output(""typedef long long          ${prefix}_KLong;"")
        output(""typedef unsigned char      ${prefix}_KUByte;"")
        output(""typedef unsigned short     ${prefix}_KUShort;"")
        output(""typedef unsigned int       ${prefix}_KUInt;"")
        output(""typedef unsigned long long ${prefix}_KULong;"")
        output(""typedef float              ${prefix}_KFloat;"")
        output(""typedef double             ${prefix}_KDouble;"")

        val typedef_KVector128 = ""typedef float __attribute__ ((__vector_size__ (16))) ${prefix}_KVector128;""
        if (target.family == Family.MINGW) {
            // Separate `output` for each line to ensure Windows EOL (LFCR), otherwise generated file will have inconsistent line ending.
            output(""#ifndef _MSC_VER"")
            output(typedef_KVector128)
            output(""#else"")
            output(""#include <xmmintrin.h>"")
            output(""typedef __m128 ${prefix}_KVector128;"")
            output(""#endif"")
        } else {
            output(typedef_KVector128)
        }

        output(""typedef void*              ${prefix}_KNativePtr;"")
        output(""struct ${prefix}_KType;"")
        output(""typedef struct ${prefix}_KType ${prefix}_KType;"")

        output("""")
        defineUsedTypes(top, 0)

        output("""")
        makeScopeDefinitions(top, DefinitionKind.C_HEADER_DECLARATION, 0)

        output("""")
        output(""typedef struct {"")
        output(""/* Service functions. */"", 1)
        output(""void (*DisposeStablePointer)(${prefix}_KNativePtr ptr);"", 1)
        output(""void (*DisposeString)(const char* string);"", 1)
        output(""${prefix}_KBoolean (*IsInstance)(${prefix}_KNativePtr ref, const ${prefix}_KType* type);"", 1)
        predefinedTypes.forEach {
            val nullableIt = it.makeNullable()
            val argument = if (!it.isUnit()) typeTranslator.translateType(it) else ""void""
            output(""${typeTranslator.translateType(nullableIt)} (*${it.createNullableNameForPredefinedType})($argument);"", 1)
            if (!it.isUnit())
                output(""$argument (*${it.createGetNonNullValueOfPredefinedType})(${typeTranslator.translateType(nullableIt)});"", 1)
        }

        output("""")
        output(""/* User functions. */"", 1)
        makeScopeDefinitions(top, DefinitionKind.C_HEADER_STRUCT, 1)
        output(""} ${prefix}_ExportedSymbols;"")

        output(""extern ${prefix}_ExportedSymbols* $exportedSymbol(void);"")
        output(""""""
    #ifdef __cplusplus
    }  /* extern ""C"" */
    #endif"""""".trimIndent())

        output(""#endif  /* KONAN_${prefix.uppercase()}_H */"")

        outputStreamWriter.close()",outputStreamWriter = cppAdapterFile.printWriter()
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer.core

import org.jetbrains.kotlin.commonizer.cir.CirExtensionReceiver

class ExtensionReceiverCommonizer(
    private val typeCommonizer: TypeCommonizer",") : NullableContextualSingleInvocationCommonizer<CirExtensionReceiver?, ExtensionReceiverCommonizer.Commonized> {"
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.backend.konan.objcexport

import org.jetbrains.kotlin.backend.konan.InternalKotlinNativeApi

object StubRenderer {
    fun render(stub: ObjCExportStub): List<String> = render(stub, false)

    private fun findPositionToInsertGeneratedCommentLine(kDoc: List<String>, generatedCommentLine: String): Int {
        val generatedWords = generatedCommentLine.trim().split("" "").map { it.trim() }
        if (generatedWords.size >= 2 && generatedWords[0] == ""@param"") {
            for (i in kDoc.indices.reversed()) {
                val kDocLineWords = kDoc[i].trim().split("" "").map { it.trim() }.filter { it.isNotEmpty() }.filterNot { it == ""*"" }
                if (kDocLineWords.size >= 2 && kDocLineWords[0] == generatedWords[0] && kDocLineWords[1] == generatedWords[1]) {
                    return i + 1  // position after last `@param` kDoc line, describing same parameter as in generatedCommentLine
                }
            }
        }
        return kDoc.size
    }

    @InternalKotlinNativeApi
    fun render(stub: ObjCExportStub, shouldExportKDoc: Boolean): List<String> = collect {
        stub.run {
            val (kDocEnding, commentBlockEnding) = if (comment?.contentLines == null) {","Pair(""*/"", null)  // Close kDoc with `*/`, and print nothing after empty comment"
"}
@Bar class ClassMarkedWithAnotherFoo {
    class NonMarkedClass {
        class NonMarkedClass
        @Foo class ClassMarkedWithFoo
        @Bar class ClassMarkedWithAnotherFoo
        @Another.Foo class ClassMarkedWithBar
        @Another.Bar class ClassMarkedWithAnotherBar
    }
    @Foo class ClassMarkedWithFoo
    @Bar class ClassMarkedWithAnotherFoo
    @Another.Foo class ClassMarkedWithBar
    @Another.Bar class ClassMarkedWithAnotherBar
}
@Another.Foo class ClassMarkedWithBar {
    class NonMarkedClass {
        class NonMarkedClass
        @Foo class ClassMarkedWithFoo
        @Bar class ClassMarkedWithAnotherFoo
        @Another.Foo class ClassMarkedWithBar
        @Another.Bar class ClassMarkedWithAnotherBar
    }
    @Foo class ClassMarkedWithFoo
    @Bar class ClassMarkedWithAnotherFoo
    @Another.Foo class ClassMarkedWithBar
    @Another.Bar class ClassMarkedWithAnotherBar
}
@Another.Bar class ClassMarkedWithAnotherBar {
    class NonMarkedClass {
        class NonMarkedClass
        @Foo class ClassMarkedWithFoo
        @Bar class ClassMarkedWithAnotherFoo
        @Another.Foo class ClassMarkedWithBar
        @Another.Bar class ClassMarkedWithAnotherBar
    }
    @Foo class ClassMarkedWithFoo
    @Bar class ClassMarkedWithAnotherFoo
    @Another.Foo class ClassMarkedWithBar
    @Another.Bar class ClassMarkedWithAnotherBar
}

class ClassWithConstructorMarkedWithFoo @Foo constructor()
class ClassWithConstructorMarkedWithAnotherFoo @Another.Foo constructor()
class ClassWithConstructorMarkedWithBar @Bar constructor()
class ClassWithConstructorMarkedWithAnotherBar @Another.Bar constructor()

fun nonMarkedFunction(): String = """"
@Foo fun functionMarkedWithFoo(): String = """"
@Bar fun functionMarkedWithAnotherFoo(): String = """"
@Another.Foo fun functionMarkedWithBar(): String = """"
@Another.Bar fun functionMarkedWithAnotherBar(): String = """"

var nonMarkedProperty: String get() = """"
    set(_) = Unit

@Foo var propertyWholeMarkedWithFoo: String get() = """"
    set(_) = Unit
@Another.Foo var propertyWholeMarkedWithAnotherFoo: String get() = """"
    set(_) = Unit
@Bar var propertyWholeMarkedWithBar: String get() = """"
    set(_) = Unit
@Another.Bar var propertyWholeMarkedWithAnotherBar: String get() = """"
    set(_) = Unit

var propertyGetterMarkedWithFoo: String @Foo get() = """"",set(_) = Unit
"} else {
            withTowerDataCleanup {
                addLocalScope(buildSecondaryConstructorParametersScope(constructor, session))
                f()
            }
        }
    }

    @OptIn(PrivateForInline::class)
    fun <T> withAnonymousFunction(
        anonymousFunction: FirAnonymousFunction,
        holder: SessionHolder,
        mode: ResolutionMode,
        f: () -> T
    ): T {
        require(mode !is ResolutionMode.ContextDependent)
        if (mode !is ResolutionMode.LambdaResolution) {
            storeContextForAnonymousFunction(anonymousFunction)
        }
        return withTowerDataCleanup {
            addLocalScope(FirLocalScope(holder.session))
            val receiverTypeRef = anonymousFunction.receiverParameter?.typeRef
            val labelName = anonymousFunction.label?.name?.let { Name.identifier(it) }
            withContainer(anonymousFunction) {
                withLabelAndReceiverType(labelName, anonymousFunction, receiverTypeRef?.coneType, holder) {
                    if (mode is ResolutionMode.LambdaResolution && mode.expectedReturnTypeRef == null) {
                        withLambdaBeingAnalyzedInDependentContext(anonymousFunction.symbol, f)
                    } else {
                        f()
                    }
                }
            }
        }
    }

    @OptIn(PrivateForInline::class)
    fun storeContextForAnonymousFunction(anonymousFunction: FirAnonymousFunction) {
        specialTowerDataContexts.storeAnonymousFunctionContext(
            anonymousFunction.symbol, towerDataContext, inferenceSession
        )
    }

    @OptIn(PrivateForInline::class)
    inline fun <T> withField(
        field: FirField,
        f: () -> T
    ): T {
        return withTowerDataMode(FirTowerDataMode.CONSTRUCTOR_HEADER) {
            withContainer(field) {
                withTowerDataCleanup {
                    getPrimaryConstructorAllParametersScope()?.let { addLocalScope(it) }
                    f()
                }
            }
        }
    }

    @OptIn(PrivateForInline::class)
    inline fun <T> withEnumEntry(
        enumEntry: FirEnumEntry,
        f: () -> T
    ): T = withTowerDataMode(FirTowerDataMode.ENUM_ENTRY) {
        withContainer(enumEntry, f)
    }",@OptIn(PrivateForInline::class)
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.components

import org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion
import org.jetbrains.kotlin.analysis.api.types.KtType

public abstract class KtSubtypingComponent : KtAnalysisSessionComponent() {
    public abstract fun isEqualTo(first: KtType, second: KtType, errorTypePolicy: KaSubtypingErrorTypePolicy): Boolean
    public abstract fun isSubTypeOf(subType: KtType, superType: KtType, errorTypePolicy: KaSubtypingErrorTypePolicy): Boolean
}

public interface KtSubtypingComponentMixIn : KtAnalysisSessionMixIn {
    public fun KtType.isEqualTo(other: KtType): Boolean =
        withValidityAssertion { analysisSession.subtypingComponent.isEqualTo(this, other, KaSubtypingErrorTypePolicy.STRICT) }","public fun KtType.isEqualTo(other: KtType, errorTypePolicy: KaSubtypingErrorTypePolicy): Boolean ="
"open val scrollX: Double
    open val pageXOffset: Double
    open val scrollY: Double
    open val pageYOffset: Double
    open val screenX: Int
    open val screenY: Int
    open val outerWidth: Int
    open val outerHeight: Int
    open val devicePixelRatio: Double
    fun close()
    fun stop()
    fun focus()
    fun blur()
    fun open(url: String = definedExternally, target: String = definedExternally, features: String = definedExternally): Window?
    fun alert()
    fun alert(message: String)
    fun confirm(message: String = definedExternally): Boolean
    fun prompt(message: String = definedExternally, default: String = definedExternally): String?
    fun print()
    fun requestAnimationFrame(callback: (Double) -> Unit): Int
    fun cancelAnimationFrame(handle: Int)
    fun postMessage(message: JsAny?, targetOrigin: String, transfer: JsArray<JsAny> = definedExternally)
    fun captureEvents()
    fun releaseEvents()
    fun matchMedia(query: String): MediaQueryList
    fun moveTo(x: Int, y: Int)
    fun moveBy(x: Int, y: Int)
    fun resizeTo(x: Int, y: Int)
    fun resizeBy(x: Int, y: Int)
    fun scroll(options: ScrollToOptions = definedExternally)
    fun scroll(x: Double, y: Double)
    fun scrollTo(options: ScrollToOptions = definedExternally)
    fun scrollTo(x: Double, y: Double)
    fun scrollBy(options: ScrollToOptions = definedExternally)
    fun scrollBy(x: Double, y: Double)
    fun getComputedStyle(elt: Element, pseudoElt: String? = definedExternally): CSSStyleDeclaration
}

@Suppress(""UNUSED_PARAMETER"")
internal fun getMethodImplForWindow(obj: Window, name: String): JsAny? { js(""return obj[name];"") }

public operator fun Window.get(name: String): JsAny? = getMethodImplForWindow(this, name)

public external abstract class BarProp : JsAny {
    open val visible: Boolean
}

/**
 * Exposes the JavaScript [History](https://developer.mozilla.org/en/docs/Web/API/History) to Kotlin
 */
public external abstract class History : JsAny {
    open val length: Int
    open var scrollRestoration: ScrollRestoration
    open val state: JsAny?
    fun go(delta: Int = definedExternally)
    fun back()
    fun forward()
    fun pushState(data: JsAny?, title: String, url: String? = definedExternally)
    fun replaceState(data: JsAny?, title: String, url: String? = definedExternally)
}

/**
 * Exposes the JavaScript [Location](https://developer.mozilla.org/en/docs/Web/API/Location) to Kotlin
 */
public external abstract class Location : JsAny {",open var href: String
"override fun transformField(field: FirField, data: Any?): FirField = whileAnalysing(session, field) {
        withScopeCleanup {
            field.transformReturnTypeRef(this, data).transformAnnotations(this, data)
            field
        }
    }

    override fun transformBackingField(backingField: FirBackingField, data: Any?): FirStatement = whileAnalysing(session, backingField) {
        backingField.transformAnnotations(this, data)
        super.transformBackingField(backingField, data)
    }

    override fun transformSimpleFunction(
        simpleFunction: FirSimpleFunction,
        data: Any?,
    ): FirSimpleFunction = whileAnalysing(session, simpleFunction) {
        withScopeCleanup {
            withDeclaration(simpleFunction) {
                addTypeParametersScope(simpleFunction)
                val result = transformDeclaration(simpleFunction, data).also {
                    unboundCyclesInTypeParametersSupertypes(it as FirTypeParametersOwner)
                }

                if (result.source?.kind == KtFakeSourceElementKind.DataClassGeneratedMembers &&
                    result is FirSimpleFunction &&
                    result.name == StandardNames.DATA_CLASS_COPY
                ) {
                    for (valueParameter in result.valueParameters) {
                        valueParameter.moveOrDeleteIrrelevantAnnotations()
                    }
                }

                result
            }
        } as FirSimpleFunction
    }

    private fun unboundCyclesInTypeParametersSupertypes(typeParametersOwner: FirTypeParameterRefsOwner) {
        for (typeParameter in typeParametersOwner.typeParameters) {
            if (typeParameter !is FirTypeParameter) continue
            if (hasSupertypePathToParameter(typeParameter, typeParameter, mutableSetOf())) {
                val errorType = buildErrorTypeRef {
                    diagnostic = ConeCyclicTypeBound(typeParameter.symbol, typeParameter.bounds.toImmutableList())
                }
                typeParameter.replaceBounds(
                    listOf(errorType)
                )
            }
        }
    }

    private fun hasSupertypePathToParameter(
        currentTypeParameter: FirTypeParameter,
        typeParameter: FirTypeParameter,
        visited: MutableSet<FirTypeParameter>
    ): Boolean {
        if (visited.isNotEmpty() && currentTypeParameter == typeParameter) return true
        if (!visited.add(currentTypeParameter)) return false

        fun ConeKotlinType.toNextTypeParameter(): FirTypeParameter? = when (this) {
            is ConeTypeParameterType -> lookupTag.typeParameterSymbol.fir
            is ConeDefinitelyNotNullType -> original.toNextTypeParameter()
            else -> null
        }",return currentTypeParameter.bounds.any {
"/**
 * Asserts Gradle output contains [expectedSubString] string.
 */
fun BuildResult.assertOutputContains(
    expectedSubString: String,
    message: String = ""Build output does not contain \""$expectedSubString\"""",
) {
    assert(output.contains(expectedSubString)) {
        printBuildOutput()
        message
    }
}

/**
 * Asserts Gradle output contains any of [expectedSubStrings] strings.
 */
fun BuildResult.assertOutputContainsAny(
    vararg expectedSubStrings: String,
) {
    assert(expectedSubStrings.any { output.contains(it) }) {
        printBuildOutput()
        ""Build output does not contain any of \""${expectedSubStrings.toList()}\""""
    }
}

/**
 * Asserts Gradle output contains [expectedSubString] string exact times.
 */
fun BuildResult.assertOutputContainsExactTimes(
    expectedSubString: String,
    expectedRepetitionTimes: Int = 1,
) {
    var currentOffset = 0
    var count = 0
    var nextIndex = output.indexOf(expectedSubString, currentOffset)

    while (nextIndex != -1 && count < expectedRepetitionTimes + 1) {
        count++
        currentOffset = nextIndex + expectedSubString.length
        nextIndex = output.indexOf(expectedSubString, currentOffset)
    }

    assert(count == expectedRepetitionTimes) {
        printBuildOutput()
        ""Build output contains \""$expectedSubString\"" $count times""
    }
}


/**
 * Asserts Gradle output does not contain [notExpectedSubString] string.
 *
 * @param wrappingCharsCount amount of chars to include before and after [notExpectedSubString] occurrence
 */
fun BuildResult.assertOutputDoesNotContain(
    notExpectedSubString: String,
    wrappingCharsCount: Int = 100,
) {
    assert(!output.contains(notExpectedSubString)) {
        printBuildOutput()

        // In case if notExpectedSubString is multiline string
        val occurrences = mutableListOf<Pair<Int, Int>>()
        var startIndex = output.indexOf(notExpectedSubString)",var endIndex = startIndex + notExpectedSubString.length
"open fun visitContinue(x: JsContinue): Unit =
            visitElement(x)

    open fun visitYield(x: JsYield): Unit =
        visitElement(x)

    open fun visitDebugger(x: JsDebugger): Unit =
            visitElement(x)

    open fun visitDefault(x: JsDefault): Unit =
            visitElement(x)

    open fun visitDoWhile(x: JsDoWhile): Unit =
            visitLoop(x)

    open fun visitEmpty(x: JsEmpty): Unit =
            visitElement(x)

    open fun visitExpressionStatement(x: JsExpressionStatement): Unit =
            visitElement(x)

    open fun visitFor(x: JsFor): Unit =
            visitLoop(x)

    open fun visitForIn(x: JsForIn): Unit =
            visitLoop(x)

    open fun visitFunction(x: JsFunction): Unit =
            visitElement(x)

    open fun visitIf(x: JsIf): Unit =
            visitElement(x)

    open fun visitInvocation(invocation: JsInvocation): Unit =
            visitElement(invocation)

    open fun visitLabel(x: JsLabel): Unit =
            visitElement(x)

    open fun visitLoop(x: JsLoop): Unit =
        visitElement(x)

    open fun visitNameRef(nameRef: JsNameRef): Unit =
            visitElement(nameRef)

    open fun visitNew(x: JsNew): Unit =
            visitElement(x)

    open fun visitNull(x: JsNullLiteral): Unit =
            visitElement(x)

    open fun visitInt(x: JsIntLiteral): Unit =
            visitElement(x)

    open fun visitDouble(x: JsDoubleLiteral): Unit =
            visitElement(x)

    open fun visitObjectLiteral(x: JsObjectLiteral): Unit =
            visitElement(x)

    open fun visitParameter(x: JsParameter): Unit =
            visitElement(x)

    open fun visitPostfixOperation(x: JsPostfixOperation): Unit =",visitElement(x)
class A {,"inner class B(val a: String = ""a"", val b: Int = 55, val c: String = ""c"")"
"fun B<(@A C)>.receiverArgument()
fun B<(@A C)?>.receiverArgumentN()

fun parameter(a: (@A C))
fun parameterN(a: (@A C)?)

fun parameterArgument(a: B<(@A C)>)
fun parameterArgumentN(a: B<(@A C)?>)

fun returnValue(): (@A C)
fun returnValueN(): (@A C)?

fun <T> returnTypeParameterValue(): (@A T)
fun <T> returnTypeParameterValueN(): (@A T)?

fun returnArgument(): B<(@A C)>
fun returnArgumentN(): B<(@A C)>?

val lambdaType: (@A() (() -> C))
val lambdaTypeN: (@A() (() -> C))?

val lambdaParameter: ((@A C)) -> C",val lambdaParameterN: ((@A C))? -> C
"if (nodeElementType == KtNodeTypes.NULL) return NullValue().wrap()

        val result: Any = when (nodeElementType) {
            KtNodeTypes.INTEGER_CONSTANT, KtNodeTypes.FLOAT_CONSTANT -> parseNumericLiteral(text, nodeElementType)
            KtNodeTypes.BOOLEAN_CONSTANT -> parseBoolean(text)
            KtNodeTypes.CHARACTER_CONSTANT -> CompileTimeConstantChecker.parseChar(expression)
            else -> throw IllegalArgumentException(""Unsupported constant: $expression"")
        } ?: return null

        if (result is Double) {
            if (result.isInfinite()) {
                trace.report(Errors.FLOAT_LITERAL_CONFORMS_INFINITY.on(expression))
            }
            if (result == 0.0 && !TypeConversionUtil.isFPZero(text)) {
                trace.report(Errors.FLOAT_LITERAL_CONFORMS_ZERO.on(expression))
            }
        }

        if (result is Float) {
            if (result.isInfinite()) {
                trace.report(Errors.FLOAT_LITERAL_CONFORMS_INFINITY.on(expression))
            }
            if (result == 0.0f && !TypeConversionUtil.isFPZero(text)) {
                trace.report(Errors.FLOAT_LITERAL_CONFORMS_ZERO.on(expression))
            }
        }

        val isIntegerConstant = nodeElementType == KtNodeTypes.INTEGER_CONSTANT
        val isUnsignedLong = isIntegerConstant && hasUnsignedLongSuffix(text)
        val isUnsigned = isUnsignedLong || hasUnsignedSuffix(text)
        val isTyped = isUnsigned || hasLongSuffix(text)

        return createConstant(
            result,
            expectedType,
            CompileTimeConstant.Parameters(
                canBeUsedInAnnotation = true,
                isPure = !isTyped,
                isUnsignedNumberLiteral = isUnsigned,
                isUnsignedLongNumberLiteral = isUnsignedLong,
                usesVariableAsConstant = false,
                usesNonConstValAsConstant = false,
                isConvertableConstVal = false
            )
        )
    }

    override fun visitParenthesizedExpression(expression: KtParenthesizedExpression, expectedType: KotlinType?): CompileTimeConstant<*>? {
        val deparenthesizedExpression = KtPsiUtil.deparenthesize(expression)
        if (deparenthesizedExpression != null && deparenthesizedExpression != expression) {
            return evaluate(deparenthesizedExpression, expectedType)
        }
        return null
    }

    override fun visitLabeledExpression(expression: KtLabeledExpression, expectedType: KotlinType?): CompileTimeConstant<*>? {
        val baseExpression = expression.baseExpression
        if (baseExpression != null) {
            return evaluate(baseExpression, expectedType)
        }
        return null
    }

    override fun visitStringTemplateExpression(expression: KtStringTemplateExpression, expectedType: KotlinType?): CompileTimeConstant<*>? {
        val sb = StringBuilder()",var interupted = false
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.resolve.substitution

import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.diagnostics.ConeSimpleDiagnostic
import org.jetbrains.kotlin.fir.diagnostics.ConeTypeVariableTypeIsNotInferred
import org.jetbrains.kotlin.fir.diagnostics.DiagnosticKind
import org.jetbrains.kotlin.fir.resolve.fullyExpandedType
import org.jetbrains.kotlin.fir.resolve.toFirRegularClassSymbol
import org.jetbrains.kotlin.fir.resolve.withCombinedAttributesFrom",import org.jetbrains.kotlin.fir.symbols.impl.FirTypeParameterSymbol
"/*
 * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the LICENSE file.
 */
// WITH_STDLIB

import kotlin.test.*

class A(val x: Int)",fun box(): String {
"i++
        }
        keysArray.resetRange(j, length)
        valuesArray?.resetRange(j, length)
        length = j
        //check(length == size) { ""Internal invariant violated during compact: length=$length != size=$size"" }
    }

    private fun rehash(newHashSize: Int) {
        registerModification()
        if (length > _size) compact()
        if (newHashSize != hashSize) {
            hashArray = IntArray(newHashSize)
            hashShift = computeShift(newHashSize)
        } else {
            hashArray.fill(0, 0, hashSize)
        }
        var i = 0
        while (i < length) {
            if (!putRehash(i++)) {
                throw IllegalStateException(""This cannot happen with fixed magic multiplier and grow-only hash array. "" +
                        ""Have object hashCodes changed?"")
            }
        }
    }

    private fun putRehash(i: Int): Boolean {
        var hash = hash(keysArray[i])
        var probesLeft = maxProbeDistance
        while (true) {
            val index = hashArray[hash]
            if (index == 0) {
                hashArray[hash] = i + 1
                presenceArray[i] = hash
                return true
            }
            if (--probesLeft < 0) return false
            if (hash-- == 0) hash = hashSize - 1
        }
    }

    private fun findKey(key: K): Int {
        var hash = hash(key)
        var probesLeft = maxProbeDistance
        while (true) {
            val index = hashArray[hash]
            if (index == 0) return TOMBSTONE
            if (index > 0 && keysArray[index - 1] == key) return index - 1
            if (--probesLeft < 0) return TOMBSTONE
            if (hash-- == 0) hash = hashSize - 1
        }
    }

    private fun findValue(value: V): Int {
        var i = length
        while (--i >= 0) {
            if (presenceArray[i] >= 0 && valuesArray!![i] == value)
                return i
        }
        return TOMBSTONE
    }

    internal fun addKey(key: K): Int {
        checkIsMutable()
        retry@ while (true) {",var hash = hash(key)
"<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!><!UNSAFE_CALL!>.<!>not()
}

/*
 * TESTCASE NUMBER: 4
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28333
 */
fun case_4(x: Boolean?, y: Boolean?) {
    do {
        y != null && break
        x!!
    } while (true)

    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!><!UNSAFE_CALL!>.<!>not()
}

// TESTCASE NUMBER: 5
fun case_5(x: Boolean?, y: Boolean?) {
    while (true) {
        y.to(break)
        x!!
    }

    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!><!UNSAFE_CALL!>.<!>not()
}

// TESTCASE NUMBER: 6
fun case_6(x: Boolean?, y: ((x: Nothing) -> Unit)?) {
    while (true) {
        y!!(break)
        x!!
    }

    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!><!UNSAFE_CALL!>.<!>not()
}

// TESTCASE NUMBER: 7
fun case_7(x: Boolean?, y: Boolean?) {
    while (true) {
        y ?: break
        x!!
    }

    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!><!UNSAFE_CALL!>.<!>not()
}

/*
 * TESTCASE NUMBER: 8
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28333
 */
fun case_8(x: Boolean?, y: Boolean?) {
    while (true) {
        y ?: (y!! || break)
        x!!
    }

    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!>","<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!><!UNSAFE_CALL!>.<!>not()"
"@kotlin.internal.InlineOnly
public inline fun kotlin.DoubleArray.sumOf(selector: (kotlin.Double) -> kotlin.Long): kotlin.Long

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfUInt"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
@kotlin.internal.InlineOnly
public inline fun kotlin.DoubleArray.sumOf(selector: (kotlin.Double) -> kotlin.UInt): kotlin.UInt

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfULong"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
@kotlin.internal.InlineOnly
public inline fun kotlin.DoubleArray.sumOf(selector: (kotlin.Double) -> kotlin.ULong): kotlin.ULong

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfDouble"")
@kotlin.internal.InlineOnly
public inline fun kotlin.FloatArray.sumOf(selector: (kotlin.Float) -> kotlin.Double): kotlin.Double

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfInt"")
@kotlin.internal.InlineOnly
public inline fun kotlin.FloatArray.sumOf(selector: (kotlin.Float) -> kotlin.Int): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfLong"")
@kotlin.internal.InlineOnly
public inline fun kotlin.FloatArray.sumOf(selector: (kotlin.Float) -> kotlin.Long): kotlin.Long

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfUInt"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
@kotlin.internal.InlineOnly
public inline fun kotlin.FloatArray.sumOf(selector: (kotlin.Float) -> kotlin.UInt): kotlin.UInt

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfULong"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
@kotlin.internal.InlineOnly
public inline fun kotlin.FloatArray.sumOf(selector: (kotlin.Float) -> kotlin.ULong): kotlin.ULong

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfDouble"")
@kotlin.internal.InlineOnly
public inline fun kotlin.IntArray.sumOf(selector: (kotlin.Int) -> kotlin.Double): kotlin.Double

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfInt"")
@kotlin.internal.InlineOnly
public inline fun kotlin.IntArray.sumOf(selector: (kotlin.Int) -> kotlin.Int): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfLong"")
@kotlin.internal.InlineOnly",public inline fun kotlin.IntArray.sumOf(selector: (kotlin.Int) -> kotlin.Long): kotlin.Long
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.diagnostics.impl

import org.jetbrains.kotlin.diagnostics.DiagnosticContext
import org.jetbrains.kotlin.diagnostics.KtDiagnostic
import org.jetbrains.kotlin.diagnostics.Severity

class SimpleDiagnosticsCollectorWithSuppress(override val rawReport: (Boolean, String) -> Unit) : BaseDiagnosticsCollector() {
    private val _diagnosticsByFilePath: MutableMap<String?, MutableList<KtDiagnostic>> = mutableMapOf()
    override val diagnostics: List<KtDiagnostic>
        get() = _diagnosticsByFilePath.flatMap { it.value }","override val diagnosticsByFilePath: Map<String?, List<KtDiagnostic>>"
"icFeatures = icFeatures,
) {
    override val shouldTrackChangesInLookupCache
        get() = false

    override val shouldStoreFullFqNamesInLookupCache
        get() = icFeatures.withAbiSnapshot

    override fun createCacheManager(icContext: IncrementalCompilationContext, args: K2JSCompilerArguments) =
        IncrementalJsCachesManager(icContext, if (!args.isIrBackendEnabled()) JsSerializerProtocol else KlibMetadataSerializerProtocol, cacheDirectory)

    override fun destinationDir(args: K2JSCompilerArguments): File {
        return File(args.outputDir!!)
    }

    override fun calculateSourcesToCompile(
        caches: IncrementalJsCachesManager,
        changedFiles: ChangedFiles.Known,
        args: K2JSCompilerArguments,
        messageCollector: MessageCollector,
        classpathAbiSnapshots: Map<String, AbiSnapshot> //Ignore for now
    ): CompilationMode {
        if (buildHistoryFile == null) {
            error(""The build is configured to use the build-history based IC approach, but doesn't specify the buildHistoryFile"")
        }
        if (!icFeatures.withAbiSnapshot && !buildHistoryFile.isFile) {
            return CompilationMode.Rebuild(BuildAttribute.NO_BUILD_HISTORY)
        }
        val lastBuildInfo = BuildInfo.read(lastBuildInfoFile, messageCollector) ?: return CompilationMode.Rebuild(BuildAttribute.INVALID_LAST_BUILD_INFO)

        val dirtyFiles = DirtyFilesContainer(caches, reporter, kotlinSourceFilesExtensions)
        initDirtyFiles(dirtyFiles, changedFiles)

        val libs = (args.libraries ?: """").split(File.pathSeparator).map { File(it) }
        //TODO(valtman) check for JS
        val classpathChanges = getClasspathChanges(
            libs, changedFiles, lastBuildInfo, modulesApiHistory, reporter,
            mapOf(), false, caches.platformCache,
            caches.lookupCache.lookupSymbols.map { if (it.scope.isBlank()) it.name else it.scope }.distinct()
        )

        when (classpathChanges) {
            is ChangesEither.Unknown -> {
                reporter.info { ""Could not get classpath's changes: ${classpathChanges.reason}"" }
                return CompilationMode.Rebuild(classpathChanges.reason)
            }
            is ChangesEither.Known -> {
                dirtyFiles.addByDirtySymbols(classpathChanges.lookupSymbols)
                dirtyFiles.addByDirtyClasses(classpathChanges.fqNames)
            }
        }

        val removedClassesChanges = getRemovedClassesChanges(caches, changedFiles)
        dirtyFiles.addByDirtySymbols(removedClassesChanges.dirtyLookupSymbols)
        dirtyFiles.addByDirtyClasses(removedClassesChanges.dirtyClassesFqNames)
        dirtyFiles.addByDirtyClasses(removedClassesChanges.dirtyClassesFqNamesForceRecompile)

        if (dirtyFiles.isEmpty() && changedFiles.removed.isNotEmpty()) {
            return CompilationMode.Rebuild(BuildAttribute.DEP_CHANGE_REMOVED_ENTRY)
        }
        return CompilationMode.Incremental(dirtyFiles)
    }

    override fun makeServices(
        args: K2JSCompilerArguments,","lookupTracker: LookupTracker,"
"*
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`metadataCompilationApi`(
    dependencyNotation: String,
    dependencyConfiguration: Action<ExternalModuleDependency>
): ExternalModuleDependency = addDependencyTo(
    this, ""metadataCompilationApi"", dependencyNotation, dependencyConfiguration
) as ExternalModuleDependency

/**
 * Adds a dependency to the 'metadataCompilationApi' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`metadataCompilationApi`(
    dependencyNotation: Provider<*>,
    dependencyConfiguration: Action<ExternalModuleDependency>
): Unit = addConfiguredDependencyTo(
    this, ""metadataCompilationApi"", dependencyNotation, dependencyConfiguration
)

/**
 * Adds a dependency to the 'metadataCompilationApi' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`metadataCompilationApi`(
    dependencyNotation: ProviderConvertible<*>,
    dependencyConfiguration: Action<ExternalModuleDependency>
): Unit = addConfiguredDependencyTo(
    this, ""metadataCompilationApi"", dependencyNotation, dependencyConfiguration
)

/**
 * Adds a dependency to the 'metadataCompilationApi' configuration.
 *
 * @param group the group of the module to be added as a dependency.
 * @param name the name of the module to be added as a dependency.
 * @param version the optional version of the module to be added as a dependency.
 * @param configuration the optional configuration of the module to be added as a dependency.
 * @param classifier the optional classifier of the module artifact to be added as a dependency.
 * @param ext the optional extension of the module artifact to be added as a dependency.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.create]
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`metadataCompilationApi`(
    group: String,
    name: String,
    version: String? = null,","configuration: String? = null,"
"}
            }
            val originalSuperMethod = context.mapping.functionWithContinuationsToSuspendFunctions[transformedSuperMethod] ?: transformedSuperMethod
            buildInvokeMethod(originalSuperMethod)

            functionReferenceClass.superTypes += superTypes
            if (!isLambda) {
                fun addOverrideInner(name: String, value: IrBuilderWithScope.(IrFunction) -> IrExpression) {
                    val overridden = functionReferenceClass.superTypes.mapNotNull { superType ->
                        superType.getClass()
                                ?.declarations
                                ?.filterIsInstance<IrSimpleFunction>()
                                ?.singleOrNull { it.name.asString() == name }
                                ?.symbol
                    }
                    require(overridden.isNotEmpty())
                    val function = functionReferenceClass.addFunction {
                        startOffset = SYNTHETIC_OFFSET
                        endOffset = SYNTHETIC_OFFSET
                        this.name = Name.identifier(name)
                        modality = Modality.FINAL
                        returnType = overridden[0].owner.returnType
                    }
                    function.createDispatchReceiverParameter()
                    function.overriddenSymbols += overridden
                    function.body = context.createIrBuilder(function.symbol, SYNTHETIC_OFFSET, SYNTHETIC_OFFSET).irBlockBody {
                        +irReturn(
                                value(function)
                        )
                    }
                }

                fun addOverride(name: String, value: IrBuilderWithScope.() -> IrExpression) {
                    addOverrideInner(name) { _ -> value() }
                }


                listOfNotNull(
                        functionReference.symbol.owner.dispatchReceiverParameter,
                        functionReference.symbol.owner.extensionReceiverParameter
                ).singleOrNull { it in boundFunctionParameters }
                        ?.let { receiver ->
                            addOverrideInner(""computeReceiver"") { f ->
                                irGetField(irGet(f.dispatchReceiverParameter!!), argumentToPropertiesMap[receiver]!!)
                            }
                        }
            }

            functionReferenceClass.addFakeOverrides(
                    context.typeSystem,
                    // Built function overrides originalSuperMethod, while, if parent class is already lowered, it would
                    // transformedSuperMethod in its declaration list. We need not fake override in that case.
                    // Later lowerings will fix it and replace function with one overriding transformedSuperMethod.
                    ignoredParentSymbols = listOf(transformedSuperMethod.symbol)
            )

            functionReferenceClass.remapTypes(typeParameterRemapper)

            return functionReferenceClass
        }

        private fun buildConstructor() = functionReferenceClass.addConstructor {
            startOffset = this@FunctionReferenceBuilder.startOffset
            endOffset = this@FunctionReferenceBuilder.endOffset
            origin = DECLARATION_ORIGIN_FUNCTION_REFERENCE_IMPL",isPrimary = true
"functionalType.lookupTag,
            Array(size) { index -> if (index != size - 1) functionalType.typeArguments[index] else returnVariable.defaultType },
            isNullable = functionalType.isNullable,
            functionalType.attributes
        )
        csBuilder.addSubtypeConstraint(expectedType, functionalType, ConeArgumentConstraintPosition(atom.atom))
        atom.replaceExpectedType(expectedType, returnVariable.defaultType)
        atom.replaceTypeVariableForLambdaReturnType(returnVariable)
    }

    fun createCompletionResultsWriter(
        substitutor: ConeSubstitutor,
        mode: FirCallCompletionResultsWriterTransformer.Mode = FirCallCompletionResultsWriterTransformer.Mode.Normal,
    ): FirCallCompletionResultsWriterTransformer {
        return FirCallCompletionResultsWriterTransformer(
            session, components.scopeSession, substitutor, components.returnTypeCalculator,
            session.typeApproximator,
            components.dataFlowAnalyzer,
            components.integerLiteralAndOperatorApproximationTransformer,
            components.samResolver,
            components.context,
            mode,
        )
    }

    fun createPostponedArgumentsAnalyzer(context: ResolutionContext): PostponedArgumentsAnalyzer {
        val lambdaAnalyzer = LambdaAnalyzerImpl()
        return PostponedArgumentsAnalyzer(
            context,
            lambdaAnalyzer,
            session.inferenceComponents,
            transformer.components.callResolver
        )
    }

    private inner class LambdaAnalyzerImpl : LambdaAnalyzer {
        override fun analyzeAndGetLambdaReturnArguments(
            lambdaAtom: ResolvedLambdaAtom,
            receiverType: ConeKotlinType?,
            contextReceivers: List<ConeKotlinType>,
            parameters: List<ConeKotlinType>,
            expectedReturnType: ConeKotlinType?,
            candidate: Candidate,
            withPCLASession: Boolean,
            forOverloadByLambdaReturnType: Boolean,
        ): ReturnArgumentsAnalysisResult {
            val lambdaArgument: FirAnonymousFunction = lambdaAtom.atom
            val needItParam = lambdaArgument.valueParameters.isEmpty() && parameters.size == 1

            val matchedParameter = candidate.argumentMapping?.firstNotNullOfOrNull { (currentArgument, currentValueParameter) ->
                val currentLambdaArgument =
                    (currentArgument as? FirAnonymousFunctionExpression)?.anonymousFunction
                if (currentLambdaArgument === lambdaArgument) {
                    currentValueParameter
                } else {
                    null
                }
            }

            lambdaArgument.matchingParameterFunctionType = matchedParameter?.returnTypeRef?.coneType

            val itParam = when {
                needItParam -> {
                    val name = StandardNames.IMPLICIT_LAMBDA_PARAMETER_NAME
                    val itType = parameters.single()",buildValueParameter {
"listBuilder.addMarkerInterfaceIfNeeded(superType.classId)
                    }
                }
            }
        }

    return listBuilder
}

context(KtAnalysisSession)
internal fun KtSymbolWithMembers.createInnerClasses(
    manager: PsiManager,
    containingClass: SymbolLightClassBase,
    classOrObject: KtClassOrObject?
): List<SymbolLightClassBase> {
    val result = SmartList<SymbolLightClassBase>()

    getStaticDeclaredMemberScope().getClassifierSymbols().filterIsInstance<KtNamedClassOrObjectSymbol>().mapNotNullTo(result) {
        val classOrObjectDeclaration = it.sourcePsiSafe<KtClassOrObject>()
        if (classOrObjectDeclaration != null) {
            classOrObjectDeclaration.toLightClass() as? SymbolLightClassBase
        } else {
            createLightClassNoCache(it, ktModule = containingClass.ktModule, manager)
        }
    }

    val jvmDefaultMode = classOrObject
        ?.let { getModule(it) as? KtSourceModule }
        ?.languageVersionSettings
        ?.getFlag(JvmAnalysisFlags.jvmDefaultMode)
        ?: JvmDefaultMode.DISABLE

    if (containingClass is SymbolLightClassForInterface &&
        classOrObject?.hasInterfaceDefaultImpls == true &&
        jvmDefaultMode != JvmDefaultMode.ALL
    ) {
        result.add(SymbolLightClassForInterfaceDefaultImpls(containingClass))
    }

    if (containingClass is SymbolLightClassForAnnotationClass &&
        this is KtNamedClassOrObjectSymbol &&
        hasAnnotation(StandardClassIds.Annotations.Repeatable) &&
        !hasAnnotation(JvmStandardClassIds.Annotations.Java.Repeatable)
    ) {
        result.add(SymbolLightClassForRepeatableAnnotationContainer(containingClass))
    }

    return result
}

context(KtAnalysisSession)
internal fun KtClassOrObject.checkIsInheritor(superClassOrigin: KtClassOrObject, checkDeep: Boolean): Boolean {
    if (this == superClassOrigin) return false
    if (superClassOrigin is KtEnumEntry) {
        return false // enum entry cannot have inheritors
    }
    if (!superClassOrigin.canBeAnalysed()) {
        return false
    }

    val superClassSymbol = superClassOrigin.getClassOrObjectSymbol() ?: return false

    when (this) {
        is KtEnumEntry -> {
            val enumEntrySymbol = this.getEnumEntrySymbol()",val classId = enumEntrySymbol.containingEnumClassIdIfNonLocal ?: return false
"import abitestutils.abiTest
import lib1.*
import lib2.*

fun box() = abiTest {
    val abstractClass: AbstractClass = AbstractClassImpl()
    val _interface: Interface = InterfaceImpl()","expectFailure(nonImplementedCallable(""function 'foo'"", ""class 'AbstractClassImpl'"")) { abstractClass.foo() }"
"DOWNLOAD_COMPILER              (""download.compiler""),

        // Properties used instead of env vars until https://github.com/gradle/gradle/issues/3468 is fixed.
        // TODO: Remove them when an API for env vars is provided.
        KONAN_CONFIGURATION_BUILD_DIR  (""konan.configuration.build.dir""),
        KONAN_DEBUGGING_SYMBOLS        (""konan.debugging.symbols""),
        KONAN_OPTIMIZATIONS_ENABLE     (""konan.optimizations.enable""),
    }

    companion object {
        internal const val ARTIFACTS_CONTAINER_NAME = ""konanArtifacts""
        internal const val COMPILE_ALL_TASK_NAME = ""compileKonan""

        internal const val KONAN_EXTENSION_NAME = ""konan""

        internal val REQUIRED_GRADLE_VERSION = GradleVersion.version(""6.7"")
    }

    private fun checkGradleVersion() =  GradleVersion.current().let { current ->
        check(current >= REQUIRED_GRADLE_VERSION) {
            ""Kotlin/Native Gradle plugin is incompatible with this version of Gradle.\n"" +
            ""The minimal required version is $REQUIRED_GRADLE_VERSION\n"" +
            ""Current version is ${current}""
        }
    }

    private lateinit var konanJvmLauncher: JavaLauncher

    private fun getJavaLauncher(project: Project): Provider<JavaLauncher> = project.providers.provider {
        if (!::konanJvmLauncher.isInitialized) {
            val toolchain = project.extensions.getByType(JavaPluginExtension::class.java).toolchain
            val service = project.extensions.getByType(JavaToolchainService::class.java)
            konanJvmLauncher = try {
                service.launcherFor(toolchain).get()
            } catch (ex: GradleException) {
                // If the JDK that was set is not available get the JDK 11 as a default
                service.launcherFor(object : Action<JavaToolchainSpec> {
                    override fun execute(toolchainSpec: JavaToolchainSpec) {
                        toolchainSpec.languageVersion.set(JavaLanguageVersion.of(11))   // FIXME: not resolved from buildSrc JdkMajorVersion.JDK_11_0.majorVersion))
                    }
                }).get()
            }
        }
        konanJvmLauncher
    }

    override fun apply(project: ProjectInternal) {
        checkGradleVersion()
        project.plugins.apply(""base"")
        project.plugins.apply(""java"")
        // Create necessary tasks and extensions.
        project.extensions.create(KONAN_EXTENSION_NAME, KonanExtension::class.java)
        val container = project.extensions.create(
            KonanArtifactContainer::class.java,
            ARTIFACTS_CONTAINER_NAME,
            KonanArtifactContainer::class.java,
            project
        )
        project.setProperty(ProjectProperty.KONAN_JVM_LAUNCHER, getJavaLauncher(project))

        project.warnAboutDeprecatedProperty(ProjectProperty.KONAN_HOME)

        // Set additional project properties like org.jetbrains.kotlin.native.home, konan.build.targets etc.
        if (!project.useCustomDist) {
            project.setProperty(ProjectProperty.KONAN_HOME, project.konanCompilerDownloadDir())","project.setProperty(ProjectProperty.DOWNLOAD_COMPILER, true)"
"// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_VARIABLE -UNUSED_VALUE
// SKIP_TXT

/*
 * KOTLIN DIAGNOSTICS NOT LINKED SPEC TEST (NEGATIVE)
 *
 * SECTIONS: dfa
 * NUMBER: 25
 * DESCRIPTION: Raw data flow analysis test
 * HELPERS: classes, objects, typealiases, functions, enumClasses, interfaces, sealedClasses
 */

// TESTCASE NUMBER: 1, 2
class ClassWithEqualsOverride {
    override fun equals(other: Any?) = true",fun fun_1() = true
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.resolve.calls.smartcasts

import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.calls.context.ResolutionContext
import org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValue
import org.jetbrains.kotlin.types.KotlinType

/**
 * This class is intended to create data flow values for different kind of expressions.
 * Then data flow values serve as keys to obtain data flow information for these expressions.
 */
interface DataFlowValueFactory {
    fun createDataFlowValue(
        expression: KtExpression,
        type: KotlinType,
        resolutionContext: ResolutionContext<*>
    ): DataFlowValue

    fun createDataFlowValue(
        expression: KtExpression,
        type: KotlinType,
        bindingContext: BindingContext,
        containingDeclarationOrModule: DeclarationDescriptor
    ): DataFlowValue

    fun createDataFlowValueForStableReceiver(receiver: ReceiverValue): DataFlowValue

    fun createDataFlowValue(
        receiverValue: ReceiverValue,
        resolutionContext: ResolutionContext<*>
    ): DataFlowValue

    fun createDataFlowValue(
        receiverValue: ReceiverValue,
        bindingContext: BindingContext,
        containingDeclarationOrModule: DeclarationDescriptor
    ): DataFlowValue

    fun createDataFlowValueForProperty(
        property: KtProperty,
        variableDescriptor: VariableDescriptor,
        bindingContext: BindingContext,",usageContainingModule: ModuleDescriptor?
".distinctBy { namer.getPropertyName(it) }
                .forEach { base -> add { buildProperty(property, base, objCExportScope) } }
        }
    }

    private fun StubBuilder<ObjCExportStub>.translateBaseMembers(members: List<CallableMemberDescriptor>) {
        // TODO: add some marks about modality.

        val methods = mutableListOf<FunctionDescriptor>()
        val properties = mutableListOf<PropertyDescriptor>()

        members.toObjCMembers(methods, properties)

        methods.forEach { exportThrown(it) }

        methods.retainAll { mapper.isBaseMethod(it) }

        properties.retainAll {
            if (mapper.isBaseProperty(it)) {
                true
            } else {
                methods.addIfNotNull(it.setter?.takeIf(mapper::isBaseMethod))
                false
            }
        }

        translatePlainMembers(methods, properties, ObjCRootExportScope)
    }

    private fun StubBuilder<ObjCExportStub>.translatePlainMembers(
        members: List<CallableMemberDescriptor>,
        objCExportScope: ObjCExportScope,
    ) {
        val methods = mutableListOf<FunctionDescriptor>()
        val properties = mutableListOf<PropertyDescriptor>()

        members.toObjCMembers(methods, properties)

        methods.forEach { exportThrown(it) }

        translatePlainMembers(methods, properties, objCExportScope)
    }

    private fun StubBuilder<ObjCExportStub>.translatePlainMembers(
        methods: List<FunctionDescriptor>,
        properties: List<PropertyDescriptor>,
        objCExportScope: ObjCExportScope,
    ) {
        methods.makeMethodsOrderStable().forEach { add { buildMethod(it, it, objCExportScope) } }
        properties.makePropertiesOrderStable().forEach { add { buildProperty(it, it, objCExportScope) } }
    }
    // TODO: consider checking that signatures for bases with same selector/name are equal.

    private fun getSelector(method: FunctionDescriptor): String {
        return namer.getSelector(method)
    }

    private fun buildProperty(
        property: PropertyDescriptor,
        baseProperty: PropertyDescriptor,
        objCExportScope: ObjCExportScope,
    ): ObjCProperty {
        assert(mapper.isBaseProperty(baseProperty))
        assert(mapper.isObjCProperty(baseProperty))",val getterBridge = mapper.bridgeMethod(baseProperty.getter!!)
"* Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.mainKts.test

import org.jetbrains.kotlin.mainKts.COMPILED_SCRIPTS_CACHE_DIR_ENV_VAR
import org.jetbrains.kotlin.mainKts.COMPILED_SCRIPTS_CACHE_DIR_PROPERTY
import org.jetbrains.kotlin.scripting.compiler.plugin.*
import org.jetbrains.kotlin.utils.KotlinPaths
import org.jetbrains.kotlin.utils.PathUtil
import org.junit.Assert
import org.junit.Ignore
import org.junit.Test
import java.io.File
import java.nio.file.Path
import kotlin.io.path.*

class MainKtsIT {

    @Test
    fun testResolveJunit() {
        runWithKotlincAndMainKts(""$TEST_DATA_ROOT/hello-resolve-junit.main.kts"", listOf(""Hello, World!""))
    }

    @Test
    @Ignore // Fails on TC most likely due to repo proxying
    fun testKotlinxHtml() {
        runWithK2JVMCompilerAndMainKts(
            ""$TEST_DATA_ROOT/kotlinx-html.main.kts"",
            listOf(""<html>"", ""  <body>"", ""    <h1>Hello, World!</h1>"", ""  </body>"", ""</html>"")
        )
    }

    @Test
    fun testImport() {
        val mainKtsJar = File(""dist/kotlinc/lib/kotlin-main-kts.jar"")
        Assert.assertTrue(""kotlin-main-kts.jar not found, run dist task: ${mainKtsJar.absolutePath}"", mainKtsJar.exists())

        runWithK2JVMCompiler(
            ""$TEST_DATA_ROOT/import-test.main.kts"",
            listOf(""Hi from common"", ""Hi from middle"", ""Hi from main"", ""sharedVar == 5""),
            classpath = listOf(mainKtsJar)
        )
    }

    @Test
    fun testThreadContextClassLoader() {
        runWithKotlincAndMainKts(""$TEST_DATA_ROOT/context-classloader.main.kts"", listOf(""MainKtsConfigurator""))
    }

    @OptIn(ExperimentalPathApi::class)
    @Test
    fun testCachedReflection() {
        val cache = createTempDirectory(""main.kts.test"")

        try {
            runWithKotlinRunner(""$TEST_DATA_ROOT/use-reflect.main.kts"", listOf(""false""), cacheDir = cache)
            // second run uses the cached script
            runWithKotlinRunner(""$TEST_DATA_ROOT/use-reflect.main.kts"", listOf(""false""), cacheDir = cache)
        } finally {
            cache.toFile().deleteRecursively()
        }
    }",@OptIn(ExperimentalPathApi::class)
"}

    /**
     * Gets the next random `Long` from the random number generator.
     *
     * Generates a `Long` random value uniformly distributed between `Long.MIN_VALUE` and `Long.MAX_VALUE` (inclusive).
     *
     * @sample samples.random.Randoms.nextLong
     */
    public open fun nextLong(): Long = nextInt().toLong().shl(32) + nextInt()

    /**
     * Gets the next random non-negative `Long` from the random number generator less than the specified [until] bound.
     *
     * Generates a `Long` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).
     *
     * @param until must be positive.
     *
     * @throws IllegalArgumentException if [until] is negative or zero.
     *
     * @sample samples.random.Randoms.nextLongFromUntil
     */
    public open fun nextLong(until: Long): Long = nextLong(0, until)

    /**
     * Gets the next random `Long` from the random number generator in the specified range.
     *
     * Generates a `Long` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.
     *
     * @throws IllegalArgumentException if [from] is greater than or equal to [until].
     *
     * @sample samples.random.Randoms.nextLongFromUntil
     */
    public open fun nextLong(from: Long, until: Long): Long {
        checkRangeBounds(from, until)
        val n = until - from
        if (n > 0) {
            val rnd: Long
            if (n and -n == n) {
                val nLow = n.toInt()
                val nHigh = (n ushr 32).toInt()
                rnd = when {
                    nLow != 0 -> {
                        val bitCount = fastLog2(nLow)
                        // toUInt().toLong()
                        nextBits(bitCount).toLong() and 0xFFFF_FFFF
                    }
                    nHigh == 1 ->
                        // toUInt().toLong()
                        nextInt().toLong() and 0xFFFF_FFFF
                    else -> {
                        val bitCount = fastLog2(nHigh)
                        nextBits(bitCount).toLong().shl(32) + (nextInt().toLong() and 0xFFFF_FFFF)
                    }
                }
            } else {
                var v: Long
                do {
                    val bits = nextLong().ushr(1)
                    v = bits % n
                } while (bits - v + (n - 1) < 0)
                rnd = v
            }
            return from + rnd
        } else {",while (true) {
"// TARGET_BACKEND: JVM

class MyListIterator<T> : ListIterator<T> {
    override fun next(): T = null!!
    override fun hasNext(): Boolean = null!!
    override fun hasPrevious(): Boolean = null!!
    override fun previous(): T = null!!
    override fun nextIndex(): Int = null!!
    override fun previousIndex(): Int = null!!
}

fun expectUoe(block: () -> Any) {
    try {",block()
"<!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 20
fun <K, V: K>case_20(map: MutableMap<K?, V>) {
    for ((k, v) in map) {
        if (true && true && true && k !== null && v != null && true) else continue
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 21
fun <K, V>case_21(map: MutableMap<out K?, in V>) {
    for ((k, v) in map) {
        if (k == null) continue
        if (v === null || false) break
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?"")!>v<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?""), DEBUG_INFO_SMARTCAST!>v<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?""), DEBUG_INFO_SMARTCAST!>v<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?""), DEBUG_INFO_SMARTCAST!>v<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?"")!>v<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?"")!>v<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?""), DEBUG_INFO_SMARTCAST!>v<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?""), DEBUG_INFO_SMARTCAST!>v<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?"")!>v<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?"")!>v<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 22
fun <T> case_22(x: T?) {",while (true) {
"}
                }

                is FirProperty -> {
                    if (innerDeclaration.isRelatedToParameter(primaryConstructorParametersByName[innerDeclaration.name])) {
                        primaryConstructorPropertiesByName[innerDeclaration.name] = innerDeclaration
                    } else {
                        when {
                            innerDeclaration.delegate != null ->
                                reporter.reportOn(
                                    innerDeclaration.delegate!!.source,
                                    FirErrors.DELEGATED_PROPERTY_INSIDE_VALUE_CLASS,
                                    context
                                )

                            innerDeclaration.hasBackingField &&
                                    innerDeclaration.source?.kind !is KtFakeSourceElementKind -> {
                                reporter.reportOn(
                                    innerDeclaration.source, FirErrors.PROPERTY_WITH_BACKING_FIELD_INSIDE_VALUE_CLASS,
                                    context
                                )
                            }
                        }
                    }
                }

                else -> {}
            }
        }

        val reservedNames = boxAndUnboxNames + if (isCustomEqualsSupported) emptySet() else equalsAndHashCodeNames
        val classScope = declaration.unsubstitutedScope(context)
        for (reservedName in reservedNames) {
            classScope.processFunctionsByName(Name.identifier(reservedName)) {
                val functionSymbol = it.unwrapFakeOverrides()
                if (functionSymbol.isAbstract) return@processFunctionsByName
                val containingClassSymbol = functionSymbol.getContainingClassSymbol(context.session) ?: return@processFunctionsByName
                if (containingClassSymbol == declaration.symbol) {
                    if (functionSymbol.source?.kind is KtRealSourceElementKind) {
                        reporter.reportOn(
                            functionSymbol.source,
                            FirErrors.RESERVED_MEMBER_INSIDE_VALUE_CLASS,
                            reservedName,
                            context
                        )
                    }
                } else if (containingClassSymbol.classKind == ClassKind.INTERFACE) {
                    reporter.reportOn(
                        declaration.source,
                        FirErrors.RESERVED_MEMBER_FROM_INTERFACE_INSIDE_VALUE_CLASS,
                        containingClassSymbol.name.asString(),
                        reservedName,
                        context
                    )
                }
            }
        }

        if (primaryConstructor?.source?.kind !is KtRealSourceElementKind) {
            reporter.reportOn(declaration.source, FirErrors.ABSENCE_OF_PRIMARY_CONSTRUCTOR_FOR_VALUE_CLASS, context)
            return
        }

        if (context.languageVersionSettings.supportsFeature(LanguageFeature.ValueClasses)) {
            if (primaryConstructorParametersByName.isEmpty()) {","reporter.reportOn(primaryConstructor.source, FirErrors.VALUE_CLASS_EMPTY_CONSTRUCTOR, context)"
"* you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.js.translate.declaration

import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.builtins.StandardNames
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.js.backend.ast.*
import org.jetbrains.kotlin.js.translate.context.Namer
import org.jetbrains.kotlin.js.translate.context.TranslationContext
import org.jetbrains.kotlin.js.translate.general.AbstractTranslator
import org.jetbrains.kotlin.js.translate.utils.JsAstUtils
import org.jetbrains.kotlin.resolve.DescriptorUtils
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe

class EnumTranslator(
        context: TranslationContext,
        val descriptor: ClassDescriptor,
        val entries: List<ClassDescriptor>,
        private val psi: PsiElement
) : AbstractTranslator(context) {
    fun generateStandardMethods() {
        generateValuesFunction()
        generateValueOfFunction()
    }

    private fun generateValuesFunction() {
        val function = createFunction(DescriptorUtils.getFunctionByName(descriptor.staticScope, StandardNames.ENUM_VALUES))

        val values = entries.map {
            JsInvocation(JsAstUtils.pureFqn(context().getNameForObjectInstance(it), null)).source(psi)
        }
        function.body.statements += JsReturn(JsArrayLiteral(values).source(psi)).apply { source = psi }
    }

    private fun generateValueOfFunction() {
        val function = createFunction(DescriptorUtils.getFunctionByName(descriptor.staticScope, StandardNames.ENUM_VALUE_OF))

        val nameParam = JsScope.declareTemporaryName(""name"")
        function.parameters += JsParameter(nameParam)

        val clauses = entries.map { entry ->
            JsCase().apply {
                caseExpression = JsStringLiteral(entry.name.asString()).source(psi)
                statements += JsReturn(JsInvocation(JsAstUtils.pureFqn(context().getNameForObjectInstance(entry), null)).source(psi))
                        .apply { source = psi }
                source = psi
            }
        }

        val message = JsBinaryOperation(JsBinaryOperator.ADD,
                                        JsStringLiteral(""No enum constant ${descriptor.fqNameSafe}.""),
                                        nameParam.makeRef())
        val throwFunction = context().getReferenceToIntrinsic(Namer.THROW_ILLEGAL_ARGUMENT_EXCEPTION_FUN_NAME)","val throwStatement = JsExpressionStatement(JsInvocation(throwFunction, message).source(psi))"
"/*
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-37431
 */

class Case1() {

    fun foo() {
        val x = sequence<String> {

            val  y = this
            //this is Case1 instead of SequenceScope<String>","yield("""") // UNRESOLVED_REFERENCE"
"// !DIAGNOSTICS: -UNUSED_PARAMETER

fun test(a: D1, b: D2) {
    id<Out<Base>>(
        makeOut(
            select(a, b)
        )
    )
    id<Inv<Base>>(
        makeInv(
            select(a, b)
        )
    )
    id<In<Base>>(
        makeIn(
            select(a, b)
        )
    )
    id<In<In<Base>>>(
        makeInIn(
            select(a, b)
        )
    )
}

interface Base
interface B1 : Base
interface B2 : Base
interface D1 : B1, B2
interface D2 : B1, B2

fun <S> select(a: S, b: S): S = TODO()
class Inv<T>",class Out<out O>
"// FIR_IDENTICAL
// !LANGUAGE: +DefinitelyNonNullableTypes

interface A<T> {
    fun foo(x: T): T
    fun bar(x: T & Any): T & Any
}

interface B<T1> : A<T1> {
    override fun foo(x: T1): T1
    override fun bar(x: T1 & Any): T1 & Any
}

interface C<T2> : A<T2> {
    <!NOTHING_TO_OVERRIDE!>override<!> fun foo(x: T2 & Any): T2 & Any
    <!NOTHING_TO_OVERRIDE!>override<!> fun bar(x: T2): T2
}

interface D : A<String?> {
    override fun foo(x: String?): String?
    override fun bar(x: String): String
}

interface E : A<String> {
    override fun foo(x: String): String
    override fun bar(x: String): String
}

interface F : A<String?> {",<!NOTHING_TO_OVERRIDE!>override<!> fun foo(x: String): String
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.ir.expressions.impl

import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.declarations.IrAttributeContainer
import org.jetbrains.kotlin.ir.expressions.IrEnumConstructorCall
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.expressions.IrStatementOrigin
import org.jetbrains.kotlin.ir.symbols.IrConstructorSymbol
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.util.initializeParameterArguments
import org.jetbrains.kotlin.ir.util.initializeTypeArguments

class IrEnumConstructorCallImpl(
    override val startOffset: Int,
    override val endOffset: Int,
    override var type: IrType,
    override var symbol: IrConstructorSymbol,
    typeArgumentsCount: Int,
    valueArgumentsCount: Int
) : IrEnumConstructorCall() {",override var origin: IrStatementOrigin? = null
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""FunctionName"")

package org.jetbrains.kotlin.gradle.unitTests.compilerArgumetns

import org.jetbrains.kotlin.compilerRunner.ArgumentUtils
import org.jetbrains.kotlin.gradle.dsl.multiplatformExtension
import org.jetbrains.kotlin.gradle.plugin.CreateCompilerArgumentsContext
import org.jetbrains.kotlin.gradle.plugin.KotlinCompilerArgumentsProducer.ArgumentType.*
import org.jetbrains.kotlin.gradle.plugin.KotlinCompilerArgumentsProducer.CreateCompilerArgumentsContext.Companion.default",import org.jetbrains.kotlin.gradle.plugin.KotlinCompilerArgumentsProducer.CreateCompilerArgumentsContext.Companion.lenient
"if (0.toShort() !in 3L..1L != !range1.contains(0.toShort())) throw AssertionError()
    if (!(0.toShort() in 3L..1L) != !range1.contains(0.toShort())) throw AssertionError()
    if (!(0.toShort() !in 3L..1L) != range1.contains(0.toShort())) throw AssertionError()
    // no local optimizations
    if (element5 in 3L..1L != range1.contains(element5)) throw AssertionError()
    if (element5 !in 3L..1L != !range1.contains(element5)) throw AssertionError()
    if (!(element5 in 3L..1L) != !range1.contains(element5)) throw AssertionError()
    if (!(element5 !in 3L..1L) != range1.contains(element5)) throw AssertionError()
}

fun testR1xE6() {
    // with possible local optimizations
    if (0 in 3L..1L != range1.contains(0)) throw AssertionError()
    if (0 !in 3L..1L != !range1.contains(0)) throw AssertionError()
    if (!(0 in 3L..1L) != !range1.contains(0)) throw AssertionError()
    if (!(0 !in 3L..1L) != range1.contains(0)) throw AssertionError()
    // no local optimizations
    if (element6 in 3L..1L != range1.contains(element6)) throw AssertionError()
    if (element6 !in 3L..1L != !range1.contains(element6)) throw AssertionError()
    if (!(element6 in 3L..1L) != !range1.contains(element6)) throw AssertionError()
    if (!(element6 !in 3L..1L) != range1.contains(element6)) throw AssertionError()
}

fun testR1xE7() {
    // with possible local optimizations
    if (0L in 3L..1L != range1.contains(0L)) throw AssertionError()
    if (0L !in 3L..1L != !range1.contains(0L)) throw AssertionError()
    if (!(0L in 3L..1L) != !range1.contains(0L)) throw AssertionError()
    if (!(0L !in 3L..1L) != range1.contains(0L)) throw AssertionError()
    // no local optimizations
    if (element7 in 3L..1L != range1.contains(element7)) throw AssertionError()
    if (element7 !in 3L..1L != !range1.contains(element7)) throw AssertionError()
    if (!(element7 in 3L..1L) != !range1.contains(element7)) throw AssertionError()
    if (!(element7 !in 3L..1L) != range1.contains(element7)) throw AssertionError()
}

fun testR1xE8() {
    // with possible local optimizations
    if (1.toByte() in 3L..1L != range1.contains(1.toByte())) throw AssertionError()
    if (1.toByte() !in 3L..1L != !range1.contains(1.toByte())) throw AssertionError()
    if (!(1.toByte() in 3L..1L) != !range1.contains(1.toByte())) throw AssertionError()
    if (!(1.toByte() !in 3L..1L) != range1.contains(1.toByte())) throw AssertionError()
    // no local optimizations
    if (element8 in 3L..1L != range1.contains(element8)) throw AssertionError()
    if (element8 !in 3L..1L != !range1.contains(element8)) throw AssertionError()
    if (!(element8 in 3L..1L) != !range1.contains(element8)) throw AssertionError()
    if (!(element8 !in 3L..1L) != range1.contains(element8)) throw AssertionError()
}

fun testR1xE9() {
    // with possible local optimizations
    if (1.toShort() in 3L..1L != range1.contains(1.toShort())) throw AssertionError()
    if (1.toShort() !in 3L..1L != !range1.contains(1.toShort())) throw AssertionError()
    if (!(1.toShort() in 3L..1L) != !range1.contains(1.toShort())) throw AssertionError()
    if (!(1.toShort() !in 3L..1L) != range1.contains(1.toShort())) throw AssertionError()
    // no local optimizations
    if (element9 in 3L..1L != range1.contains(element9)) throw AssertionError()
    if (element9 !in 3L..1L != !range1.contains(element9)) throw AssertionError()
    if (!(element9 in 3L..1L) != !range1.contains(element9)) throw AssertionError()
    if (!(element9 !in 3L..1L) != range1.contains(element9)) throw AssertionError()
}

fun testR1xE10() {
    // with possible local optimizations
    if (1 in 3L..1L != range1.contains(1)) throw AssertionError()",if (1 !in 3L..1L != !range1.contains(1)) throw AssertionError()
"parentSerializer ?: create(container, extension, null, languageVersionSettings, project)
            else
                createTopLevel(extension, languageVersionSettings)
            val plugins = project?.let { DescriptorSerializerPlugin.getInstances(it) }.orEmpty()
            val typeAttributeTranslators = project?.let { TypeAttributeTranslatorExtension.createTranslators(it) }

            // Calculate type parameter ids for the outer class beforehand, as it would've had happened if we were always
            // serializing outer classes before nested classes.
            // Otherwise our interner can get wrong ids because we may serialize classes in any order.
            val serializer = DescriptorSerializer(
                descriptor,
                Interner(parent.typeParameters),
                extension,
                MutableTypeTable(),
                if (container is ClassDescriptor && !isVersionRequirementTableWrittenCorrectly(extension.metadataVersion))
                    parent.versionRequirementTable else MutableVersionRequirementTable(),
                serializeTypeTableToFunction = false,
                languageVersionSettings,
                plugins,
                typeAttributeTranslators
            )
            for (typeParameter in descriptor.declaredTypeParameters) {
                serializer.typeParameters.intern(typeParameter)
            }
            return serializer
        }

        private fun variance(variance: Variance): ProtoBuf.TypeParameter.Variance = when (variance) {
            Variance.INVARIANT -> ProtoBuf.TypeParameter.Variance.INV
            Variance.IN_VARIANCE -> ProtoBuf.TypeParameter.Variance.IN
            Variance.OUT_VARIANCE -> ProtoBuf.TypeParameter.Variance.OUT
        }

        private fun projection(projectionKind: Variance): ProtoBuf.Type.Argument.Projection = when (projectionKind) {
            Variance.INVARIANT -> ProtoBuf.Type.Argument.Projection.INV
            Variance.IN_VARIANCE -> ProtoBuf.Type.Argument.Projection.IN
            Variance.OUT_VARIANCE -> ProtoBuf.Type.Argument.Projection.OUT
        }

        private fun hasAnnotations(descriptor: Annotated?): Boolean =
            descriptor != null && descriptor.nonSourceAnnotations.isNotEmpty()

        fun <T : DeclarationDescriptor> sort(descriptors: Collection<T>): List<T> =
            ArrayList(descriptors).apply {
                //NOTE: the exact comparator does matter here
                Collections.sort(this, MemberComparator.INSTANCE)
            }

        fun writeLanguageVersionRequirement(
            languageFeature: LanguageFeature,
            versionRequirementTable: MutableVersionRequirementTable
        ): Int {
            val languageVersion = languageFeature.sinceVersion!!
            return writeVersionRequirement(
                languageVersion.major, languageVersion.minor, 0,
                ProtoBuf.VersionRequirement.VersionKind.LANGUAGE_VERSION,
                versionRequirementTable
            )
        }

        fun writeVersionRequirement(
            major: Int,
            minor: Int,
            patch: Int,
            versionKind: ProtoBuf.VersionRequirement.VersionKind,",versionRequirementTable: MutableVersionRequirementTable
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.buildtools.api

import java.io.File

/**
 * Allows users to customize the compiler execution strategy.
 *
 * This interface is not intended to be implemented by the API consumers.
 */
@ExperimentalBuildToolsApi
public interface CompilerExecutionStrategyConfiguration {
    /**
     * Marks the compilation to be run inside the same JVM as the caller.
     * The default strategy.
     */
    public fun useInProcessStrategy(): CompilerExecutionStrategyConfiguration

    /**
     * Marks the compilation to be run in Kotlin daemon launched as a separate process and shared across similar compilation requests.
     * See Kotlin daemon documentation here: https://kotlinlang.org/docs/gradle-compilation-and-caches.html#the-kotlin-daemon-and-how-to-use-it-with-gradle
     * @param jvmArguments a list of JVM startup arguments for the daemon
     */
    public fun useDaemonStrategy(","jvmArguments: List<String>,"
"var intNWrapper: IntNWrapper
    var intNWrapperN: /*boxed*/ IntNWrapper?
    var fooWrapper: FooWrapper
    var fooWrapperN: FooWrapper?
    var fooNWrapper: FooNWrapper
    var fooNWrapperN: /*boxed*/ FooNWrapper?
    var nativeFooWrapper: NativeFooWrapper
    var nativeFooWrapperN: NativeFooWrapper?
    var nativeFooNWrapper: NativeFooNWrapper
    var nativeFooNWrapperN: /*boxed*/ NativeFooNWrapper?

    val readOnlyIntWrapper: IntWrapper
    val readOnlyIntWrapperN: IntWrapper?
    val readOnlyIntNWrapper: IntNWrapper
    val readOnlyIntNWrapperN: /*boxed*/ IntNWrapper?
    val readOnlyFooWrapper: FooWrapper
    val readOnlyFooWrapperN: FooWrapper?
    val readOnlyFooNWrapper: FooNWrapper
    val readOnlyFooNWrapperN: /*boxed*/ FooNWrapper?
    val readOnlyNativeFooWrapper: NativeFooWrapper
    val readOnlyNativeFooWrapperN: NativeFooWrapper?
    val readOnlyNativeFooNWrapper: NativeFooNWrapper
    val readOnlyNativeFooNWrapperN: /*boxed*/ NativeFooNWrapper?

    fun getIntWrapper(): IntWrapper
    fun getIntWrapperN(): IntWrapper?
    fun getIntNWrapper(): IntNWrapper
    fun getIntNWrapperN(): /*boxed*/ IntNWrapper?
    fun getFooWrapper(): FooWrapper
    fun getFooWrapperN(): FooWrapper?
    fun getFooNWrapper(): FooNWrapper
    fun getFooNWrapperN(): /*boxed*/ FooNWrapper?
    fun getNativeFooWrapper(): NativeFooWrapper
    fun getNativeFooWrapperN(): NativeFooWrapper?
    fun getNativeFooNWrapper(): NativeFooNWrapper
    fun getNativeFooNWrapperN(): /*boxed*/ NativeFooNWrapper?
}

fun testInterfaceMethodsWithValueClassesInArgs() {
    val o = makeTestInterfaceInstance()

    assertEquals(""42 (number)"", o.describeIntWrapper(IntWrapper(42)))
    assertEquals(""100 (number)"", o.describeIntWrapperN(IntWrapper(100)))
    assertEquals(""null (object)"", o.describeIntWrapperN(null))

    assertEquals(""42 (number)"", o.describeIntNWrapper(IntNWrapper(42)))
    assertEquals(""null (object)"", o.describeIntNWrapper(IntNWrapper(null)))
    assertEquals(""IntNWrapper(value=100) (object)"", o.describeIntNWrapperN(IntNWrapper(100)))
    assertEquals(""IntNWrapper(value=null) (object)"", o.describeIntNWrapperN(IntNWrapper(null)))
    assertEquals(""null (object)"", o.describeIntNWrapperN(null))

    assertEquals(""Foo(s=hello) (object)"", o.describeFooWrapper(FooWrapper(Foo(""hello""))))
    assertEquals(""Foo(s=goodbye) (object)"", o.describeFooWrapperN(FooWrapper(Foo(""goodbye""))))
    assertEquals(""null (object)"", o.describeFooWrapperN(null))

    assertEquals(""Foo(s=hello) (object)"", o.describeFooNWrapper(FooNWrapper(Foo(""hello""))))
    assertEquals(""null (object)"", o.describeFooNWrapper(FooNWrapper(null)))
    assertEquals(""FooNWrapper(fooN=Foo(s=goodbye)) (object)"", o.describeFooNWrapperN(FooNWrapper(Foo(""goodbye""))))
    assertEquals(""FooNWrapper(fooN=null) (object)"", o.describeFooNWrapperN(FooNWrapper(null)))
    assertEquals(""null (object)"", o.describeFooNWrapperN(null))

    assertEquals(""NativeFoo('hello') (object)"", o.describeNativeFooWrapper(NativeFooWrapper(NativeFoo(""hello""))))
    assertEquals(""NativeFoo('goodbye') (object)"", o.describeNativeFooWrapperN(NativeFooWrapper(NativeFoo(""goodbye""))))
    assertEquals(""null (object)"", o.describeNativeFooWrapperN(null))","assertEquals(""NativeFoo('hello') (object)"", o.describeNativeFooNWrapper(NativeFooNWrapper(NativeFoo(""hello""))))"
"return collection as C
    }
}

class ListExternalizer<T>(elementExternalizer: DataExternalizer<T>) :
    CollectionExternalizerV2<T, List<T>>(elementExternalizer, { size -> ArrayList(size) })

class SetExternalizer<T>(elementExternalizer: DataExternalizer<T>) :
    CollectionExternalizerV2<T, Set<T>>(elementExternalizer, { size -> LinkedHashSet(size) })

open class MapExternalizer<K, V, M : Map<K, V>>(
    private val keyExternalizer: DataExternalizer<K>,
    private val valueExternalizer: DataExternalizer<V>,
    private val newMap: (size: Int) -> MutableMap<K, V> = { size -> LinkedHashMap(size) }
) : DataExternalizer<M> {

    override fun save(output: DataOutput, map: M) {
        output.writeInt(map.size)
        for ((key, value) in map) {
            keyExternalizer.save(output, key)
            valueExternalizer.save(output, value)
        }
    }

    override fun read(input: DataInput): M {
        val size = input.readInt()
        val map = newMap(size)
        repeat(size) {
            val key = keyExternalizer.read(input)
            val value = valueExternalizer.read(input)
            map[key] = value
        }
        @Suppress(""UNCHECKED_CAST"")
        return map as M
    }
}

class LinkedHashMapExternalizer<K, V>(
    keyExternalizer: DataExternalizer<K>,
    valueExternalizer: DataExternalizer<V>
) : MapExternalizer<K, V, LinkedHashMap<K, V>>(keyExternalizer, valueExternalizer, { size -> LinkedHashMap(size) })

object JvmMethodSignatureExternalizer : DataExternalizer<JvmMemberSignature.Method> {

    override fun save(output: DataOutput, method: JvmMemberSignature.Method) {
        StringExternalizer.save(output, method.name)
        StringExternalizer.save(output, method.desc)
    }

    override fun read(input: DataInput): JvmMemberSignature.Method {
        return JvmMemberSignature.Method(
            name = StringExternalizer.read(input),
            desc = StringExternalizer.read(input)
        )
    }
}

object InlineFunctionOrAccessorExternalizer : DataExternalizer<InlineFunctionOrAccessor> by DelegateDataExternalizer(
    types = listOf(InlineFunction::class.java, InlinePropertyAccessor::class.java),
    typesExternalizers = listOf(InlineFunctionExternalizer, InlinePropertyAccessorExternalizer)
)

private object InlineFunctionExternalizer : DataExternalizer<InlineFunction> {

    override fun save(output: DataOutput, function: InlineFunction) {","JvmMethodSignatureExternalizer.save(output, function.jvmMethodSignature)"
"// LANGUAGE: +MultiPlatformProjects
// IGNORE_BACKEND_K1: ANY
// TARGET_BACKEND: JVM_IR

// MODULE: common
// FILE: Base.kt
expect interface Base

// MODULE: jvm()()(common)
// FILE: Property.kt
public actual interface Base {
    fun getValue(): PropType // /Base.PropType

    interface PropType {
        val name: String
    }
}

// FILE: Derived.java
public abstract class Derived implements Base {
    @Override
    public Base.PropType getValue() { // /Base/PropType
        return new Base.PropType() {
            @Override",public String getName() {
"}

class TryExpressionExitNode(owner: ControlFlowGraph, override val fir: FirTryExpression, level: Int) : CFGNode<FirTryExpression>(owner, level),
    ExitNodeMarker {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitTryExpressionExitNode(this, data)
    }
}

// ----------------------------------- Boolean operators -----------------------------------

abstract class AbstractBinaryExitNode<T : FirElement>(owner: ControlFlowGraph, level: Int) : CFGNode<T>(owner, level) {
    val leftOperandNode: CFGNode<*> get() = previousNodes[0]
    val rightOperandNode: CFGNode<*> get() = previousNodes[1]
}

class BinaryAndEnterNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : CFGNode<FirBinaryLogicExpression>(owner, level),
    EnterNodeMarker {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryAndEnterNode(this, data)
    }
}
class BinaryAndExitLeftOperandNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : CFGNode<FirBinaryLogicExpression>(owner, level) {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryAndExitLeftOperandNode(this, data)
    }
}
class BinaryAndEnterRightOperandNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : CFGNode<FirBinaryLogicExpression>(owner, level) {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryAndEnterRightOperandNode(this, data)
    }
}
class BinaryAndExitNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : AbstractBinaryExitNode<FirBinaryLogicExpression>(owner, level),
    ExitNodeMarker {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryAndExitNode(this, data)
    }
}

class BinaryOrEnterNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : CFGNode<FirBinaryLogicExpression>(owner, level),
    EnterNodeMarker {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryOrEnterNode(this, data)
    }
}
class BinaryOrExitLeftOperandNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : CFGNode<FirBinaryLogicExpression>(owner, level) {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryOrExitLeftOperandNode(this, data)
    }
}
class BinaryOrEnterRightOperandNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : CFGNode<FirBinaryLogicExpression>(owner, level) {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryOrEnterRightOperandNode(this, data)
    }
}
class BinaryOrExitNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : AbstractBinaryExitNode<FirBinaryLogicExpression>(owner, level),
    ExitNodeMarker {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryOrExitNode(this, data)
    }
}

// ----------------------------------- Operator call -----------------------------------

class TypeOperatorCallNode(owner: ControlFlowGraph, override val fir: FirTypeOperatorCall, level: Int) : CFGNode<FirTypeOperatorCall>(owner, level) {","override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {"
"On the JS platform it represents a plain reference to a JavaScript function.
        
        On the JVM platform it represents a [java.lang.invoke.MethodHandle] constant.
        """""".trimIndent()

        +referencedSymbol(functionSymbolType)
    }
    val containerExpression: Element by element(Expression) {
        parent(expression)
        parent(statementContainer)

        +field(""origin"", statementOriginType, nullable = true)
    }
    val block: Element by element(Expression) {
        needAcceptMethod()

        parent(containerExpression)
    }
    val composite: Element by element(Expression) {
        parent(containerExpression)
    }
    val returnableBlock: Element by element(Expression) {
        parent(block)
        parent(symbolOwner)
        parent(returnTarget)

        +declaredSymbol(returnableBlockSymbolType)
    }
    val inlinedFunctionBlock: Element by element(Expression) {
        parent(block)

        visitorParameterName = ""inlinedBlock""

        +field(""inlineCall"", functionAccessExpression, isChild = false)
        +field(""inlinedElement"", rootElement, isChild = false)
    }
    val syntheticBody: Element by element(Expression) {
        visitorParameterName = ""body""

        parent(body)

        +field(""kind"", type(Packages.exprs, ""IrSyntheticBodyKind""))
    }
    val breakContinue: Element by element(Expression) {
        visitorParameterName = ""jump""

        parent(expression)

        +field(""loop"", loop, isChild = false)
        +field(""label"", string, nullable = true)
    }
    val `break` by element(Expression) {
        visitorParameterName = ""jump""

        parent(breakContinue)
    }
    val `continue` by element(Expression) {
        visitorParameterName = ""jump""

        parent(breakContinue)
    }
    val call: Element by element(Expression) {
        parent(functionAccessExpression)",+referencedSymbol(simpleFunctionSymbolType)
"This associator has two jobs
        1) It will add the output of the 'main' compilation as compile & runtime dependency to the 'auxiliary' compilation
        2) It will add all 'declared dependencies' present on 'main' to 'auxiliary'

        For 1)
        This is necessary so that all symbols that are declared/produced in 'main' are available in 'auxiliary'.
        We use the 'compileOnlyConfiguration' and 'runtimeOnlyConfigurationName' to add the respective classes.
            Note (a): This 'associate' function will be called for 'all' associated compilations (full transitive closure)
            Note (b): It is important that the compiled output of 'main' is prioritised in the compile path order:
                      We therefore ensure that the files are added to the front of the compile path.

                      This is necessary as other binaries might leak into the compile path which contain the same symbols but
                      are not marked as 'friend'. We ensure that associate dependencies are resolved first

        For 2)
        This is an agreed upon convention: 'test' is able to see all dependencies declared for 'main'
        As described in 1b: It needs to be taken care of, that the dependencies are ordered after the output of 'main'
        */
        project.dependencies.add(auxiliary.compileOnlyConfigurationName, main.output.classesDirs)
        project.dependencies.add(auxiliary.runtimeOnlyConfigurationName, main.output.allOutputs)

        // Adding classes that could be produced into non-default destination for JVM target
        // Check KotlinSourceSetProcessor for details
        project.dependencies.add(
            auxiliary.implementationConfigurationName,
            project.filesProvider { main.defaultSourceSet.kotlin.classesDirectory.orNull?.asFile }
        )

        // Adding declared dependencies
        auxiliary.compileDependencyConfigurationName.addAllDependenciesFromOtherConfigurations(
            project,
            main.apiConfigurationName,
            main.implementationConfigurationName,
            main.compileOnlyConfigurationName
        )

        auxiliary.runtimeDependencyConfigurationName?.addAllDependenciesFromOtherConfigurations(
            project,
            main.apiConfigurationName,
            main.implementationConfigurationName,
            main.runtimeOnlyConfigurationName
        )
    }
}

internal object KotlinNativeCompilationAssociator : KotlinCompilationAssociator {
    override fun associate(target: KotlinTarget, auxiliary: InternalKotlinCompilation<*>, main: InternalKotlinCompilation<*>) {
        auxiliary.compileDependencyFiles +=
            main.output.classesDirs + target.project.filesProvider { main.compileDependencyFiles }

        target.project.configurations.named(auxiliary.implementationConfigurationName).configure { configuration ->
            configuration.extendsFrom(target.project.configurations.findByName(main.implementationConfigurationName))
        }
    }
}

internal object KotlinJvmCompilationAssociator : KotlinCompilationAssociator {
    override fun associate(target: KotlinTarget, auxiliary: InternalKotlinCompilation<*>, main: InternalKotlinCompilation<*>) {
        /* Main to Test association handled already by java plugin */
        if (
            ((target is KotlinWithJavaTarget<*, *> && target.platformType == jvm) ||
                    (target is KotlinJvmTarget && target.withJavaEnabled)) &&
            auxiliary.isTest() && main.isMain()
        ) {
            return","} else DefaultKotlinCompilationAssociator.associate(target, auxiliary, main)"
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */


package org.jetbrains.kotlin.gradle.plugin.ide

import org.gradle.api.Project
import org.gradle.api.logging.Logger
import org.gradle.api.logging.Logging
import org.jetbrains.kotlin.gradle.ExternalKotlinTargetApi
import org.jetbrains.kotlin.gradle.dsl.kotlinExtension
import org.jetbrains.kotlin.gradle.dsl.multiplatformExtensionOrNull
import org.jetbrains.kotlin.gradle.idea.serialize.IdeaKotlinExtrasSerializationExtension
import org.jetbrains.kotlin.gradle.idea.serialize.IdeaKotlinExtrasSerializationExtensionBuilder",import org.jetbrains.kotlin.gradle.idea.tcs.IdeaKotlinDependency
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package generators
"/**
         * Exception text, which should be used together with exception object when available.
         */
        val text: String,
        /**
         * Line number of the exception location (0-based).
         */
        val lineNumber: Int,
        /**
         * Column number of the exception location (0-based).
         */
        val columnNumber: Int,
        /**
         * Script ID of the exception location.
         */
        val scriptId: ScriptId? = null,
        /**
         * URL of the exception location, to be used when the script was not reported.
         */
        val url: String? = null,
        /**
         * JavaScript stack trace if available.
         */
        val stackTrace: StackTrace? = null,
        /**
         * Exception object if available.
         */
        val exception: RemoteObject? = null,
        /**
         * Identifier of the context where exception happened.
         */
        val executionContextId: ExecutionContextId? = null,
    )

    /**
     * Description of an isolated world.
     *
     * See [Runtime.ExecutionContextDescription](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-ExecutionContextDescription)
     */
    @Serializable
    class ExecutionContextDescription(
        /**
         * Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed.
         */
        val id: ExecutionContextId,
        /**
         * Execution context origin.
         */
        val origin: String,
        /**
         * Human readable name describing given context.
         */
        val name: String,
    )

    /**
     * An event in the `Runtime` CDP domain.
     */
    @Serializable
    sealed class Event : CDPEvent() {
        /**
         * Issued when new execution context is created.
         *
         * See [Runtime.executionContextCreated](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-executionContextCreated)
         */",@Serializable
"else -> target.transformSingle(transformer, data = null)
        }
    }

    private fun resolveClass(firClass: FirRegularClass) {
        transformer.statusComputationSession.startComputing(firClass)

        if (resolveMode.resolveSupertypes) {
            transformer.forceResolveStatusesOfSupertypes(firClass)
        }

        performCustomResolveUnderLock(firClass) {
            transformer.transformClassStatus(firClass)
            transformer.transformValueClassRepresentation(firClass)
            transformer.storeClass(firClass) {
                resolveClassTypeParameters(firClass)
                firClass
            }
        }

        if (resolveMode.resolveSupertypes) {
            transformer.storeClass(firClass) {
                withContainingDeclaration(firClass) {
                    resolveCallableMembers(firClass)
                }

                firClass
            }

            transformer.statusComputationSession.endComputing(firClass)
        } else {
            transformer.statusComputationSession.computeOnlyClassStatus(firClass)
        }
    }

    private inner class Transformer(
        session: FirSession,
        scopeSession: ScopeSession,
    ) : FirStatusResolveTransformer(session, scopeSession, statusComputationSession) {
        val computationSession: LLStatusComputationSession get() = this@LLFirStatusTargetResolver.statusComputationSession

        override fun FirDeclaration.needResolveMembers(): Boolean = false
        override fun FirDeclaration.needResolveNestedClassifiers(): Boolean = false

        override fun transformClass(klass: FirClass, data: FirResolvedDeclarationStatus?): FirStatement {
            return klass
        }

        override fun forceResolveStatusesOfSupertypes(regularClass: FirClass) {
            computationSession.withClassSession(regularClass) {
                super.forceResolveStatusesOfSupertypes(regularClass)
            }
        }

        override fun superTypeToSymbols(typeRef: FirTypeRef): Collection<FirClassifierSymbol<*>> {
            val type = typeRef.coneType
            return SmartSet.create<FirClassifierSymbol<*>>().apply {
                // Resolution order: from declaration site to use site
                for (useSiteSession in computationSession.useSiteSessions.asReversed()) {
                    type.toSymbol(useSiteSession)?.let(::add)
                }
            }
        }

        override fun resolveClassForSuperType(regularClass: FirRegularClass): Boolean {",val target = regularClass.tryCollectDesignation()?.asResolveTarget() ?: return false
"intWrapper: IntWrapper,
    intWrapperN: IntWrapper?,
    intNWrapper: IntNWrapper,
    intNWrapperN: /*boxed*/ IntNWrapper?,
    fooWrapper: FooWrapper,
    fooWrapperN: FooWrapper?,
    fooNWrapper: FooNWrapper,
    fooNWrapperN: /*boxed*/ FooNWrapper?,
    nativeFooWrapper: NativeFooWrapper,
    nativeFooWrapperN: NativeFooWrapper?,
    nativeFooNWrapper: NativeFooNWrapper,
    nativeFooNWrapperN: /*boxed*/ NativeFooNWrapper?
) {
    fun describeIntWrapper(x: IntWrapper): String
    fun describeIntWrapperN(x: IntWrapper?): String
    fun describeIntNWrapper(x: IntNWrapper): String
    fun describeIntNWrapperN(x: /*boxed*/ IntNWrapper?): String
    fun describeFooWrapper(x: FooWrapper): String
    fun describeFooWrapperN(x: FooWrapper?): String
    fun describeFooNWrapper(x: FooNWrapper): String
    fun describeFooNWrapperN(x: /*boxed*/ FooNWrapper?): String
    fun describeNativeFooWrapper(x: NativeFooWrapper): String
    fun describeNativeFooWrapperN(x: NativeFooWrapper?): String
    fun describeNativeFooNWrapper(x: NativeFooNWrapper): String
    fun describeNativeFooNWrapperN(x: /*boxed*/ NativeFooNWrapper?): String

    var intWrapper: IntWrapper
    var intWrapperN: IntWrapper?
    var intNWrapper: IntNWrapper
    var intNWrapperN: /*boxed*/ IntNWrapper?
    var fooWrapper: FooWrapper
    var fooWrapperN: FooWrapper?
    var fooNWrapper: FooNWrapper
    var fooNWrapperN: /*boxed*/ FooNWrapper?
    var nativeFooWrapper: NativeFooWrapper
    var nativeFooWrapperN: NativeFooWrapper?
    var nativeFooNWrapper: NativeFooNWrapper
    var nativeFooNWrapperN: /*boxed*/ NativeFooNWrapper?

    val readOnlyIntWrapper: IntWrapper
    val readOnlyIntWrapperN: IntWrapper?
    val readOnlyIntNWrapper: IntNWrapper
    val readOnlyIntNWrapperN: /*boxed*/ IntNWrapper?
    val readOnlyFooWrapper: FooWrapper
    val readOnlyFooWrapperN: FooWrapper?
    val readOnlyFooNWrapper: FooNWrapper
    val readOnlyFooNWrapperN: /*boxed*/ FooNWrapper?
    val readOnlyNativeFooWrapper: NativeFooWrapper
    val readOnlyNativeFooWrapperN: NativeFooWrapper?
    val readOnlyNativeFooNWrapper: NativeFooNWrapper
    val readOnlyNativeFooNWrapperN: /*boxed*/ NativeFooNWrapper?

    fun getIntWrapper(): IntWrapper
    fun getIntWrapperN(): IntWrapper?
    fun getIntNWrapper(): IntNWrapper
    fun getIntNWrapperN(): /*boxed*/ IntNWrapper?
    fun getFooWrapper(): FooWrapper
    fun getFooWrapperN(): FooWrapper?
    fun getFooNWrapper(): FooNWrapper
    fun getFooNWrapperN(): /*boxed*/ FooNWrapper?
    fun getNativeFooWrapper(): NativeFooWrapper
    fun getNativeFooWrapperN(): NativeFooWrapper?
    fun getNativeFooNWrapper(): NativeFooNWrapper
    fun getNativeFooNWrapperN(): /*boxed*/ NativeFooNWrapper?",companion object {
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_EXPRESSION -SENSELESS_COMPARISON -UNUSED_PARAMETER

// FILE: J.java

import org.jetbrains.annotations.*;

public class J {
    @NotNull
    public static J staticNN;
    @Nullable
    public static J staticN;
    public static J staticJ;
}

// FILE: k.kt",fun test() {
"if (thisBytes.size != otherBytes.size) {
            return false
        }

        for (index in 0 .. thisBytes.size - 1) {
            if (thisBytes[index] != otherBytes[index]) {
                return false
            }
        }

        return true
    }

    public override fun hashCode(): Int {
        var result = 0
        for (byte in this.getBytes()) {
            result = result * 31 + byte
        }
        return result
    }

    public abstract val size: Int

    public abstract val align: Int

    /**
     * Copy the referenced values to [placement] and return placement pointer.
     */
    public abstract fun place(placement: CPointer<T>): CPointer<T>
}

@ExperimentalForeignApi
public fun <T : CVariable> CValues<T>.placeTo(scope: AutofreeScope): CPointer<T> = this.getPointer(scope)

/**
 * The single immutable C value.
 * It is self-contained and doesn't depend on native memory.
 *
 * TODO: consider providing an adapter instead of subtyping [CValues].
 */
@ExperimentalForeignApi
public abstract class CValue<T : CVariable> : CValues<T>()

/**
 * C pointer.
 */
@ExperimentalForeignApi
public class CPointer<T : CPointed> internal constructor(@PublishedApi internal val value: NonNullNativePtr) : CValuesRef<T>() {

    // TODO: replace by [value].
    @Suppress(""NOTHING_TO_INLINE"")
    public inline val rawValue: NativePtr get() = value.toNativePtr()

    public override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true // fast path
        }

        return (other is CPointer<*>) && (rawValue == other.rawValue)
    }

    public override fun hashCode(): Int {
        return rawValue.hashCode()
    }",public override fun toString(): String = this.cPointerToString()
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.targets.js.npm

import org.gradle.api.tasks.Input
import java.io.Serializable

data class NpmDependencyDeclaration(
    @Input
    val scope: NpmDependency.Scope,
    @Input
    val name: String,
    @Input
    val version: String
) : Serializable

fun NpmDependencyDeclaration.uniqueRepresentation() =
    ""$scope $name:$version""",internal fun NpmDependency.toDeclaration(): NpmDependencyDeclaration =
"annotation(""@OptIn(kotlin.experimental.ExperimentalTypeInference::class)"")
            annotation(""@OverloadResolutionByLambdaReturnType"")
            if (family != ArraysOfUnsigned)
                annotation(""""""@kotlin.jvm.JvmName(""flatMapIndexed$containerClass"")"""""")
            sample(""samples.collections.Collections.Transformations.flatMapIndexed"")
            typeParam(""R"")
            returns(""List<R>"")
            body {
                ""return flatMapIndexedTo(ArrayList<R>(), transform)""
            }
            specialFor(Sequences) {
                inline(Inline.No)
                returns(""Sequence<R>"")
                body {
                    ""return flatMapIndexed(this, transform, $containerClass<R>::iterator)""
                }
            }
        }
    }


    val f_flatMapIndexedTo = listOf(Iterables, Sequences).map { containerFamily ->
        val containerClass = containerFamily.name.dropLast(1)
        fn(""flatMapIndexedTo(destination: C, transform: (index: Int, T) -> $containerClass<R>)"") {
            when (containerFamily) {
                Iterables -> include(Iterables, Sequences, ArraysOfObjects, ArraysOfPrimitives, ArraysOfUnsigned, CharSequences)
                Sequences -> include(Sequences, Iterables, ArraysOfObjects)
                else -> {}
            }
        } builder {
            inlineOnly()

            since(""1.4"")
            doc {
                """"""
                Appends all elements yielded from results of [transform] function being invoked on each ${f.element} 
                and its index in the original ${f.collection}, to the given [destination].
                """"""
            }
            annotation(""@OptIn(kotlin.experimental.ExperimentalTypeInference::class)"")
            annotation(""@OverloadResolutionByLambdaReturnType"")
            if (family != ArraysOfUnsigned)
                annotation(""""""@kotlin.jvm.JvmName(""flatMapIndexed${containerClass}To"")"""""")
            typeParam(""R"")
            typeParam(""C : MutableCollection<in R>"")
            returns(""C"")
            body {
                fun checkOverflow(value: String) = if (f == Sequences || f == Iterables) ""checkIndexOverflow($value)"" else value
                """"""
                var index = 0
                for (element in this) {
                    val list = transform(${checkOverflow(""index++"")}, element)
                    destination.addAll(list)
                }
                return destination
                """"""
            }
        }
    }

    val f_groupBy_key = fn(""groupBy(keySelector: (T) -> K)"") {
        includeDefault()
        include(CharSequences, ArraysOfUnsigned)
    } builder {
        inline()",specialFor(ArraysOfUnsigned) { inlineOnly() }
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.descriptors.types

import org.jetbrains.kotlin.analysis.api.KtAnalysisApiInternals
import org.jetbrains.kotlin.analysis.api.KtTypeProjection
import org.jetbrains.kotlin.analysis.api.base.KtContextReceiver
import org.jetbrains.kotlin.analysis.api.descriptors.Fe10AnalysisContext
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.KtFe10DescNamedClassOrObjectSymbol
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.ktNullability
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.toKtClassSymbol
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.toKtType
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.toKtTypeProjection
import org.jetbrains.kotlin.analysis.api.descriptors.types.base.KtFe10Type
import org.jetbrains.kotlin.analysis.api.descriptors.types.base.asStringForDebugging
import org.jetbrains.kotlin.analysis.api.descriptors.utils.KtFe10JvmTypeMapperContext
import org.jetbrains.kotlin.analysis.api.impl.base.KtContextReceiverImpl
import org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion
import org.jetbrains.kotlin.analysis.api.symbols.KtClassLikeSymbol
import org.jetbrains.kotlin.analysis.api.types.KtClassTypeQualifier
import org.jetbrains.kotlin.analysis.api.types.KtFunctionalType
import org.jetbrains.kotlin.analysis.api.types.KtType
import org.jetbrains.kotlin.analysis.api.types.KtTypeNullability
import org.jetbrains.kotlin.builtins.*
import org.jetbrains.kotlin.builtins.functions.FunctionClassDescriptor
import org.jetbrains.kotlin.builtins.functions.isSuspendOrKSuspendFunction
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.types.SimpleType

internal class KtFe10FunctionalType(
    override val fe10Type: SimpleType,
    private val descriptor: FunctionClassDescriptor,
    override val analysisContext: Fe10AnalysisContext
) : KtFunctionalType(), KtFe10Type {
    override fun asStringForDebugging(): String = withValidityAssertion { fe10Type.asStringForDebugging(analysisContext) }

    override val nullability: KtTypeNullability
        get() = withValidityAssertion { fe10Type.ktNullability }

    override val qualifiers: List<KtClassTypeQualifier.KtResolvedClassTypeQualifier>
        get() = withValidityAssertion {
            KtFe10JvmTypeMapperContext.getNestedType(fe10Type).allInnerTypes.map { innerType ->
                KtClassTypeQualifier.KtResolvedClassTypeQualifier(","innerType.classDescriptor.toKtClassSymbol(analysisContext),"
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.incremental.storage

import com.intellij.util.io.DataExternalizer
import com.intellij.util.io.EnumeratorStringDescriptor
import org.jetbrains.kotlin.incremental.IncrementalCompilationContext
import org.jetbrains.kotlin.name.FqName
import java.io.DataInput
import java.io.DataOutput
import java.io.File

internal open class ClassOneToManyMap(","storageFile: File,"
"// Check that unresolved super type doesn't interfere with unqualified super resolution.

open class Base() {
    open fun foo() {}

    open fun ambiguous() {}

    open val prop: Int
        get() = 1234

    open val ambiguousProp: Int
        get() = 111
}

interface Interface {",fun bar() {}
"private lateinit var generatedSources: File

        @JvmStatic
        @BeforeAll
        fun setUp(@TempDir tmp: File) {
            cache = JavaClassCacheManager(tmp.newCacheFolder())
            generatedSources = tmp.newGeneratedSourcesFolder()
            cache.close()
            val processor = SimpleProcessor().toAggregating()
            val srcFiles = listOf(
                ""MyEnum.java"",
                ""MyNumber.java"",
                ""NumberAnnotation.java"",
                ""NumberException.java"",
                ""NumberHolder.java"",
                ""NumberManager.java"",
                ""GenericNumber.java""
            ).map { File(MY_TEST_DIR, it) }
            runAnnotationProcessing(
                srcFiles,
                listOf(processor),
                generatedSources
            ) { elements, trees -> MentionedTypesTaskListener(cache.javaCache, elements, trees) }
            cache.updateCache(listOf(processor), false)
        }
    }

    @Test
    fun testEnum() {
        val myEnum = cache.javaCache.getStructure(MY_TEST_DIR.resolve(""MyEnum.java""))!! as SourceFileStructure

        assertEquals(setOf(""test.MyEnum""), myEnum.declaredTypes)
        assertEquals(emptySet<String>(), myEnum.getMentionedAnnotations())
        assertEquals(emptySet<String>(), myEnum.getPrivateTypes())
        assertEquals(setOf(""test.MyEnum"", ""test.TypeGeneratedByApt""), myEnum.getMentionedTypes())
    }

    @Test
    fun testMyNumber() {
        val myNumber = cache.javaCache.getStructure(MY_TEST_DIR.resolve(""MyNumber.java""))!! as SourceFileStructure

        assertEquals(
            setOf(
                ""test.MyNumber"",
                ""test.FieldAnnotation"",
                ""test.MethodAnnotation"",
                ""test.ParameterAnnotation"",
                ""test.TypeUseAnnotation"",
                ""test.AnotherTypeUseAnnotation"",
                ""test.ThrowTypeUseAnnotation""
            ), myNumber.declaredTypes
        )
        assertEquals(
            setOf(
                ""java.lang.annotation.Target"",
                ""test.FieldAnnotation"",
                ""test.ParameterAnnotation"",
                ""test.MethodAnnotation"",
                ""test.TypeUseAnnotation"",
                ""test.AnotherTypeUseAnnotation"",
                ""test.ThrowTypeUseAnnotation""
            ), myNumber.getMentionedAnnotations()
        )
        assertEquals(
            setOf(","""test.FieldAnnotation"","
"// FIR_IDENTICAL
// JSPECIFY_STATE: warn

// FILE: IgnoreAnnotations.java
import org.jspecify.annotations.*;

@NullMarked
public class IgnoreAnnotations {
    @Nullable public Derived field = null;

    @Nullable
    public Derived foo(Derived x, @NullnessUnspecified Base y) {
        return null;
    }

    public Derived everythingNotNullable(Derived x) { return null; }

    public @Nullable Derived everythingNullable(@Nullable Derived x) { return null; }

    public @NullnessUnspecified Derived everythingUnknown(@NullnessUnspecified Derived x) { return null; }
}

// FILE: Base.java
public class Base {
    void foo() {}
}

// FILE: Derived.java
public class Derived extends Base { }

// FILE: main.kt
fun main(a: IgnoreAnnotations, x: Derived): Unit {
    // jspecify_nullness_mismatch
    <!RECEIVER_NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS!>a.foo(x, null)<!>.foo()
    // jspecify_nullness_mismatch, jspecify_nullness_mismatch
    <!RECEIVER_NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS!>a.foo(<!NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS!>null<!>, x)<!>.foo()

    // jspecify_nullness_mismatch
    <!RECEIVER_NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS!>a.field<!>.foo()

    // jspecify_nullness_mismatch
    a.everythingNotNullable(<!NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS!>null<!>).foo()
    a.everythingNotNullable(x).foo()

    // jspecify_nullness_mismatch",<!RECEIVER_NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS!>a.everythingNullable(null)<!>.foo()
"import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.FirElement
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.isValueClass
import org.jetbrains.kotlin.fir.analysis.checkers.leastUpperBound
import org.jetbrains.kotlin.fir.analysis.checkers.valOrVarKeyword
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors
import org.jetbrains.kotlin.fir.declarations.FirAnonymousFunction
import org.jetbrains.kotlin.fir.declarations.FirConstructor
import org.jetbrains.kotlin.fir.declarations.FirFunction
import org.jetbrains.kotlin.fir.diagnostics.ConeSimpleDiagnostic
import org.jetbrains.kotlin.fir.diagnostics.DiagnosticKind
import org.jetbrains.kotlin.fir.expressions.FirPropertyAccessExpression
import org.jetbrains.kotlin.fir.expressions.FirQualifiedAccessExpression
import org.jetbrains.kotlin.fir.references.toResolvedValueParameterSymbol
import org.jetbrains.kotlin.fir.resolve.fullyExpandedType
import org.jetbrains.kotlin.fir.types.*
import org.jetbrains.kotlin.fir.visitors.FirVisitorVoid

object FirFunctionParameterChecker : FirFunctionChecker(MppCheckerKind.Common) {
    override fun check(declaration: FirFunction, context: CheckerContext, reporter: DiagnosticReporter) {
        checkVarargParameters(declaration, context, reporter)
        checkParameterTypes(declaration, context, reporter)
        checkUninitializedParameter(declaration, context, reporter)
        checkValOrVarParameter(declaration, context, reporter)
    }

    private fun checkParameterTypes(function: FirFunction, context: CheckerContext, reporter: DiagnosticReporter) {
        if (function is FirAnonymousFunction) return
        for (valueParameter in function.valueParameters) {
            val returnTypeRef = valueParameter.returnTypeRef
            if (returnTypeRef !is FirErrorTypeRef) continue
            // type problems on real source are already reported by ConeDiagnostic.toFirDiagnostics
            if (returnTypeRef.source?.kind == KtRealSourceElementKind) continue

            val diagnostic = returnTypeRef.diagnostic
            if (diagnostic is ConeSimpleDiagnostic && diagnostic.kind == DiagnosticKind.ValueParameterWithNoTypeAnnotation) {
                reporter.reportOn(
                    valueParameter.source, FirErrors.VALUE_PARAMETER_WITH_NO_TYPE_ANNOTATION,
                    context
                )
            }
        }
    }

    private fun checkVarargParameters(function: FirFunction, context: CheckerContext, reporter: DiagnosticReporter) {
        val varargParameters = function.valueParameters.filter { it.isVararg }
        if (varargParameters.size > 1) {
            for (parameter in varargParameters) {
                reporter.reportOn(parameter.source, FirErrors.MULTIPLE_VARARG_PARAMETERS, context)
            }
        }

        for (varargParameter in varargParameters) {
            val coneType = varargParameter.returnTypeRef.coneType
            val varargParameterType = when (function) {
                is FirAnonymousFunction -> coneType
                else -> coneType.arrayElementType()
            }?.fullyExpandedType(context.session) ?: continue
            // LUB is checked to ensure varargParameterType may
            // never be anything except `Nothing` or `Nothing?`
            // in case it is a complex type that quantifies
            // over many other types.",if (varargParameterType.leastUpperBound(context.session).fullyExpandedType(context.session).isNothingOrNullableNothing ||
"if (!mfvc.isKotlinExternalStub()) {
        body = with(context.createJvmIrBuilder(this.symbol)) {
            mfvc.throwWhenNotExternalIsNull(newPrimaryConstructor)
            irExprBody(irCall(newPrimaryConstructor).apply {
                for ((index, parameter) in parameters.withIndex()) {
                    putValueArgument(index, irGet(parameter))
                }
            })
        }
    }
}

private fun makePrimaryConstructorImpl(
    context: JvmBackendContext,
    oldPrimaryConstructor: IrConstructor,
    mfvc: IrClass,
    leaves: List<LeafMfvcNode>,
    subnodes: List<NameableMfvcNode>,
) = context.irFactory.buildFun {
    name = InlineClassAbi.mangledNameFor(context, oldPrimaryConstructor, false, false)
    visibility = oldPrimaryConstructor.visibility
    origin = JvmLoweredDeclarationOrigin.STATIC_MULTI_FIELD_VALUE_CLASS_CONSTRUCTOR
    returnType = context.irBuiltIns.unitType
    modality = Modality.FINAL
}.apply {
    parent = mfvc
    copyTypeParametersFrom(mfvc)
    for (leaf in leaves) {
        addValueParameter(leaf.fullFieldName, leaf.type.substitute(mfvc.typeParameters, typeParameters.map { it.defaultType }))
    }
    for ((index, oldParameter) in oldPrimaryConstructor.valueParameters.withIndex()) {
        val node = subnodes[index]
        val subnodesIndices = subnodes.subnodeIndices
        if (node is LeafMfvcNode) {
            val newIndex = subnodesIndices[node]!!.first
            valueParameters[newIndex].annotations = oldParameter.annotations
        }
    }
    annotations = oldPrimaryConstructor.annotations
    if (oldPrimaryConstructor.metadata != null) {
        metadata = oldPrimaryConstructor.metadata
        oldPrimaryConstructor.metadata = null
    }
    copyAttributes(oldPrimaryConstructor as? IrAttributeContainer)
    // body is added in the Lowering file as it needs to be lowered
}

private fun makeMfvcPrimaryConstructor(
    context: JvmBackendContext,
    oldPrimaryConstructor: IrConstructor,
    mfvc: IrClass,
    leaves: List<LeafMfvcNode>,
    fields: List<IrField>?
) = context.irFactory.buildConstructor {
    updateFrom(oldPrimaryConstructor)
    visibility = DescriptorVisibilities.PRIVATE
    origin = JvmLoweredDeclarationOrigin.SYNTHETIC_MULTI_FIELD_VALUE_CLASS_MEMBER
    returnType = oldPrimaryConstructor.returnType
}.apply {
    require(oldPrimaryConstructor.typeParameters.isEmpty()) { ""Constructors do not support type parameters yet"" }
    this.parent = mfvc
    val parameters = leaves.map { addValueParameter(it.fullFieldName, it.type) }
    val irConstructor = this@apply
    if (!mfvc.isKotlinExternalStub()) {
        body = context.createIrBuilder(irConstructor.symbol).irBlockBody(irConstructor) {",+irDelegatingConstructorCall(context.irBuiltIns.anyClass.owner.constructors.single())
"/**
 * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer]
 * and the default thread-safety mode [LazyThreadSafetyMode.SYNCHRONIZED].
 *
 * If the initialization of a value throws an exception, it will attempt to reinitialize the value at next access.
 *
 * Note that the returned instance uses itself to synchronize on. Do not synchronize from external code on
 * the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.
 */
public actual fun <T> lazy(initializer: () -> T): Lazy<T> = SynchronizedLazyImpl(initializer)

/**
 * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer]
 * and thread-safety [mode].
 *
 * If the initialization of a value throws an exception, it will attempt to reinitialize the value at next access.
 *
 * Note that when the [LazyThreadSafetyMode.SYNCHRONIZED] mode is specified the returned instance uses itself
 * to synchronize on. Do not synchronize from external code on the returned instance as it may cause accidental deadlock.
 * Also this behavior can be changed in the future.
 */
public actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> =
    when (mode) {
        LazyThreadSafetyMode.SYNCHRONIZED -> SynchronizedLazyImpl(initializer)
        LazyThreadSafetyMode.PUBLICATION -> SafePublicationLazyImpl(initializer)
        LazyThreadSafetyMode.NONE -> UnsafeLazyImpl(initializer)
    }

/**
 * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer]
 * and the default thread-safety mode [LazyThreadSafetyMode.SYNCHRONIZED].
 *
 * If the initialization of a value throws an exception, it will attempt to reinitialize the value at next access.
 *
 * The returned instance uses the specified [lock] object to synchronize on.
 * When the [lock] is not specified the instance uses itself to synchronize on,
 * in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock.
 * Also this behavior can be changed in the future.
 */
public actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = SynchronizedLazyImpl(initializer, lock)



private class SynchronizedLazyImpl<out T>(initializer: () -> T, lock: Any? = null) : Lazy<T>, Serializable {
    private var initializer: (() -> T)? = initializer
    @Volatile private var _value: Any? = UNINITIALIZED_VALUE
    // final field is required to enable safe publication of constructed instance
    private val lock = lock ?: this

    override val value: T
        get() {
            val _v1 = _value
            if (_v1 !== UNINITIALIZED_VALUE) {
                @Suppress(""UNCHECKED_CAST"")
                return _v1 as T
            }

            return synchronized(lock) {
                val _v2 = _value
                if (_v2 !== UNINITIALIZED_VALUE) {
                    @Suppress(""UNCHECKED_CAST"") (_v2 as T)
                } else {
                    val typedValue = initializer!!()
                    _value = typedValue",initializer = null
"// TARGET_BACKEND: JVM
// FILE: A.java
public class A {
    public static String o = ""O"";

    public static String k() {
        return ""K"";
    }
}

// FILE: B.kt",open class B : A()
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin

import org.jetbrains.kotlin.test.KotlinTestUtils
import org.junit.Assert
import java.io.File
import java.util.regex.Matcher
import java.util.regex.Pattern

private enum class ExceptionType {
    ANALYZING_EXPRESSION,
    UNKNOWN
}

class TestExceptionsComparator(wholeFile: File) {
    companion object {
        private const val EXCEPTIONS_FILE_PREFIX = ""exceptions""

        private val exceptionMessagePatterns = mapOf(
            ExceptionType.ANALYZING_EXPRESSION to","Pattern.compile(""""""Exception while analyzing expression at \((?<lineNumber>\d+),(?<symbolNumber>\d+)\) in /(?<filename>.*?)$"""""")"
class Foo {,class Bar
"val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }
}

class A7<T> {
    val property: T get() = TODO()
    fun function(value: T): T = value

    class Nested<T> {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }
}

class B1<T : Any> {
    val property: T get() = TODO()
    fun function(value: T): T = value

    class Nested<T : Any> {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }
}

class B2<T : Any> {
    val property: T get() = TODO()
    fun function(value: T): T = value

    class Nested<T : Any> {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }
}

class B3<T : Any> {
    val property: T get() = TODO()
    fun function(value: T): T = value

    class Nested<T : Any> {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {",val property: T get() = TODO()
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.resolve.scopes

import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.incremental.components.LookupLocation
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.utils.Printer
import org.jetbrains.kotlin.utils.addToStdlib.ifNotEmpty

// see utils/ScopeUtils.kt

interface HierarchicalScope : ResolutionScope {
    val parent: HierarchicalScope?

    fun printStructure(p: Printer)
}

interface LexicalScope : HierarchicalScope {
    override val parent: HierarchicalScope

    val ownerDescriptor: DeclarationDescriptor
    val isOwnerDescriptorAccessibleByLabel: Boolean

    val implicitReceiver: ReceiverParameterDescriptor?",val contextReceiversGroup: List<ReceiverParameterDescriptor>
"@EAnno val property = """"

@ExperimentalAPI
@EAnno typealias Typealias = Unit

@ExperimentalAPI
@EAnno class Klass

@ExperimentalAPI
annotation class AnnotationArgument(val p: EAnno)

@ExperimentalAPI
fun insideBody() {
    @EAnno fun local() {}
}

@ExperimentalAPI
fun inDefaultArgument(f: () -> Unit = @EAnno fun() {}) {}

@ExperimentalAPI
val inProperty = @EAnno fun() {}

@ExperimentalAPI
val inPropertyAccessor: () -> Unit
    get() = @EAnno fun() {}

// FILE: usage-use.kt

package usage2

import api.*

@OptIn(ExperimentalAPI::class)
@EAnno fun function() {}

@OptIn(ExperimentalAPI::class)
fun parameter(@EAnno p: String) {}

@OptIn(ExperimentalAPI::class)
fun parameterType(p: <!WRONG_ANNOTATION_TARGET!>@EAnno<!> String) {}

@OptIn(ExperimentalAPI::class)
fun returnType(): <!WRONG_ANNOTATION_TARGET!>@EAnno<!> Unit {}

@OptIn(ExperimentalAPI::class)
@EAnno val property = """"

@OptIn(ExperimentalAPI::class)
@EAnno typealias Typealias = Unit

@OptIn(ExperimentalAPI::class)
@EAnno class Klass

@OptIn(ExperimentalAPI::class)
annotation class AnnotationArgument(val p: EAnno)

fun insideBody() {
    @OptIn(ExperimentalAPI::class) @EAnno fun local() {}
}

fun inDefaultArgument(@OptIn(ExperimentalAPI::class) f: () -> Unit = @EAnno fun() {}) {}

@OptIn(ExperimentalAPI::class)
val inProperty = @EAnno fun() {}",val inPropertyAccessor: () -> Unit
"val inKt = File(depDir, ""Dependency.kt"").apply { writeText(""class Dependency(val v: Int)"") }
        val outStream = ByteArrayOutputStream()
        val compileExitCode = K2JVMCompiler().exec(
            PrintStream(outStream),
            ""-d"", outJar.path, ""-no-stdlib"", ""-cp"", standardJars.joinToString(File.pathSeparator),
            ""-language-version"", if (isK2) ""2.0"" else ""1.9"",
            inKt.path
        )
        assertTrue(
            ""Compilation Failed:\n$outStream"",
            outStream.size() == 0 && compileExitCode == ExitCode.OK && outJar.exists()
        )
        return outJar
    }

    private fun checkWithCache(
        cache: ScriptingCacheWithCounters, script: SourceCode, expectedOutput: List<String>, checkDirectEval: Boolean = true,
        compilationConfiguration: ScriptCompilationConfiguration.Builder.() -> Unit = {},
        evaluationConfiguration: ScriptEvaluationConfiguration.Builder.() -> Unit = {}
    ) {
        val myHostConfiguration = defaultJvmScriptingHostConfiguration.with {
            jvm {
                baseClassLoader.replaceOnlyDefault(null)
                compilationCache(cache)
            }
        }
        val compiler = JvmScriptCompiler(myHostConfiguration)
        val evaluator = BasicJvmScriptEvaluator()
        val host = BasicJvmScriptingHost(compiler = compiler, evaluator = evaluator)

        val scriptCompilationConfiguration = ScriptCompilationConfiguration(body = compilationConfiguration).with {
            updateClasspath(KotlinJars.kotlinScriptStandardJarsWithReflect)
            hostConfiguration.update { myHostConfiguration }
        }

        val scriptEvaluationConfiguration = ScriptEvaluationConfiguration(body = evaluationConfiguration)

        Assert.assertEquals(0, cache.storedScripts)
        var compiledScript: CompiledScript? = null
        val output = captureOut {
            runBlocking {
                compiler(script, scriptCompilationConfiguration).onSuccess {
                    compiledScript = it
                    evaluator(it, scriptEvaluationConfiguration)
                }.throwOnFailure()
            }
        }.lines()
        Assert.assertEquals(expectedOutput, output)
        Assert.assertEquals(1, cache.storedScripts)
        Assert.assertEquals(0, cache.retrievedScripts)

        if (checkDirectEval) {
            val cachedScript = cache.get(script, scriptCompilationConfiguration)
            Assert.assertNotNull(cachedScript)
            Assert.assertEquals(1, cache.retrievedScripts)

            val compiledScriptClassRes = runBlocking { compiledScript!!.getClass(null) }
            val cachedScriptClassRes = runBlocking { cachedScript!!.getClass(null) }

            val compiledScriptClass = compiledScriptClassRes.valueOrThrow()
            val cachedScriptClass = cachedScriptClassRes.valueOrThrow()

            Assert.assertEquals(compiledScriptClass.qualifiedName, cachedScriptClass.qualifiedName)
            Assert.assertEquals(compiledScriptClass.java.supertypes(), cachedScriptClass.java.supertypes())",val output2 = captureOut {
"val jvmNameExpression = jvmNameEntry.valueArguments.firstOrNull()?.getArgumentExpression() as? KtStringTemplateExpression
                ?: continue
            ElementManipulators.handleContentChange(jvmNameExpression, name)
        }

        return this
    }

    override fun getQualifiedName() = facadeClassFqName.asString()

    override fun getNameIdentifier(): PsiIdentifier? = null

    override fun isValid() = files.all { it.isValid && it.hasTopLevelCallables() && facadeClassFqName == it.javaFileFacadeFqName }

    abstract override fun copy(): KtLightClassForFacade

    override fun getNavigationElement() = firstFileInFacade

    override fun isEquivalentTo(another: PsiElement?): Boolean =
        equals(another) ||
                (another is KtLightClassForFacade && another.facadeClassFqName == facadeClassFqName)

    override fun getElementIcon(flags: Int): Icon? = throw UnsupportedOperationException(""This should be done by KotlinIconProvider"")

    override fun isInheritor(baseClass: PsiClass, checkDeep: Boolean): Boolean {
        return baseClass.qualifiedName == CommonClassNames.JAVA_LANG_OBJECT
    }

    override fun getSuperClass(): PsiClass? {
        return JavaPsiFacade.getInstance(project).findClass(CommonClassNames.JAVA_LANG_OBJECT, resolveScope)
    }

    override fun getSupers(): Array<PsiClass> {
        return superClass?.let { arrayOf(it) } ?: arrayOf()
    }

    override fun getSuperTypes(): Array<PsiClassType> {
        return arrayOf(PsiType.getJavaLangObject(manager, resolveScope))
    }

    override fun hashCode() = facadeClassFqName.hashCode()

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || this::class.java != other::class.java) {
            return false
        }

        val lightClass = other as KtLightClassForFacadeBase

        if (facadeClassFqName != lightClass.facadeClassFqName) return false
        if (files != lightClass.files) return false

        return true
    }

    override fun toString() = ""${KtLightClassForFacadeBase::class.java.simpleName}:$facadeClassFqName""

    override val originKind: LightClassOriginKind
        get() = LightClassOriginKind.SOURCE

    override fun getText() = firstFileInFacade.text ?: """"

    override fun getTextRange(): TextRange = firstFileInFacade.textRange ?: TextRange.EMPTY_RANGE",override fun getTextOffset() = firstFileInFacade.textOffset
"/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress(
    ""unused"",
    ""nothing_to_inline"",
    ""useless_cast"",
    ""unchecked_cast"",
    ""extension_shadowed_by_member"",
    ""redundant_projection"",
    ""RemoveRedundantBackticks"",
    ""ObjectPropertyName"",
    ""deprecation""
)
@file:org.gradle.api.Generated

/* ktlint-disable */

package gradle.kotlin.dsl.accessors._c8feb92ae88f9e0cc4f1c07aacfeaaf1


import org.gradle.api.Action
import org.gradle.api.Incubating
import org.gradle.api.NamedDomainObjectProvider
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurablePublishArtifact
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.Dependency
import org.gradle.api.artifacts.DependencyConstraint
import org.gradle.api.artifacts.ExternalModuleDependency",import org.gradle.api.artifacts.ModuleDependency
")
            simpleSingleSourceTarget(
                ""b"", """"""
                interface ABCD
                fun x(): ABCD = null!!
                """"""
            )
            simpleSingleSourceTarget(
                ""c"", """"""
                interface ABCD
                fun x(): ABCD = null!!
                """"""
            )

            simpleSingleSourceTarget(
                ""d"", """"""
                interface ABCD
                fun x(): ABCD = null!!
                """"""
            )
        }

        result.assertCommonized(
            ""(a, b)"", """"""
            expect interface ABCD
            expect fun x(): ABCD
            """"""
        )

        result.assertCommonized(
            ""(c, d)"", """"""
            expect interface ABCD
            expect fun x(): ABCD
            """"""
        )

        result.assertCommonized(
            ""((a,b), (c,d))"", """"""
            expect interface ABCD
            expect fun x(): ABCD
            """"""
        )
    }

    fun `test function with returnType from dependency 1`() {
        val result = commonize {
            outputTarget(""(a, b)"", ""(c, d)"", ""(a, b, c, d)"")
            registerDependency(""a"", ""b"", ""c"", ""d"", ""(a, b)"", ""(c, d)"", ""(a, b, c, d)"") { source(""interface ABCD"") }
            simpleSingleSourceTarget(""a"", ""fun x(): ABCD = null!!"")
            simpleSingleSourceTarget(""b"", ""fun x(): ABCD = null!!"")
            simpleSingleSourceTarget(""c"", ""fun x(): ABCD = null!!"")
            simpleSingleSourceTarget(""d"", ""fun x(): ABCD = null!!"")
        }

        result.assertCommonized(""(c, d)"", ""expect fun x(): ABCD"")
        result.assertCommonized(""(a, b)"", ""expect fun x(): ABCD"")
        result.assertCommonized(""((a,b), (c,d))"", ""expect fun x(): ABCD"")
    }

    fun `test function with returnType from dependency 2`() {
        val result = commonize {
            outputTarget(""(a, b)"", ""(c, d)"", ""(a, b, c, d)"")
            registerDependency(""a"", ""b"", ""c"", ""d"") { source(""interface ABCD"") }
            registerDependency(""(a, b)"") { source(""interface ABCD"") }
            registerDependency(""(c,d)"") { source(""interface ABCD"") }","simpleSingleSourceTarget(""a"", ""fun x(): ABCD = null!!"")"
"/**
     * Adds the specified frameworks in this XCFramework.
     */
    fun from(vararg frameworks: Framework) {
        frameworks.forEach { framework ->
            require(framework.konanTarget.family.isAppleFamily) {
                ""XCFramework supports Apple frameworks only""
            }
            dependsOn(framework.linkTask)
        }
        fromFrameworkDescriptors(frameworks.map { FrameworkDescriptor(it) })
    }

    fun fromFrameworkDescriptors(vararg frameworks: FrameworkDescriptor) = fromFrameworkDescriptors(frameworks.toList())

    fun fromFrameworkDescriptors(frameworks: Iterable<FrameworkDescriptor>) {
        val frameworkName = groupedFrameworkFiles.values.flatten().firstOrNull()?.name

        frameworks.forEach { framework ->
            if (frameworkName != null && framework.name != frameworkName) {
                error(
                    ""All inner frameworks in XCFramework '${baseName.get()}' should have same names. "" +
                            ""But there are two with '$frameworkName' and '${framework.name}' names""
                )
            }
            val group = AppleTarget.values().first { it.targets.contains(framework.target) }
            groupedFrameworkFiles.getOrPut(group, { mutableListOf() }).add(framework)
        }
    }

    @TaskAction
    fun assemble() {
        val frameworks = groupedFrameworkFiles.values.flatten()
        val xcfName = xcFrameworkName.get()
        if (frameworks.isNotEmpty()) {
            val rawXcfName = baseName.get()
            val name = frameworks.first().name
            if (frameworks.any { it.name != name }) {
                error(""All inner frameworks in XCFramework '$rawXcfName' should have same names!"" +
                              frameworks.joinToString(""\n"") { it.file.path })
            }
            if (name != xcfName) {
                toolingDiagnosticsCollector.get().report(this, KotlinToolingDiagnostics.XCFrameworkDifferentInnerFrameworksName(
                    xcFramework = rawXcfName,
                    innerFrameworks = name,
                ))
            }
        }

        val frameworksForXCFramework = groupedFrameworkFiles.entries.mapNotNull { (group, files) ->
            when {
                files.size == 1 -> files.first()
                files.size > 1 -> FrameworkDescriptor(
                    fatFrameworksDir.resolve(group.targetName).resolve(""$xcfName.framework""),
                    files.all { it.isStatic },
                    group.targets.first() //will be not used
                )
                else -> null
            }
        }
        createXCFramework(frameworksForXCFramework, outputXCFrameworkFile)
    }

    private fun createXCFramework(frameworkFiles: List<FrameworkDescriptor>, output: File) {",if (output.exists()) output.deleteRecursively()
"// FIR_IDENTICAL
annotation class Ann
annotation class Second","<!INAPPLICABLE_PARAM_TARGET, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@param:Ann<!>"
"scope: IrParcelerScope?,
        parcelizeType: IrType,
        strict: Boolean = false,
        toplevel: Boolean = false
    ): IrParcelSerializer {
        fun strict() = strict && !irType.hasAnyAnnotation(RAW_VALUE_ANNOTATION_FQ_NAMES)

        scope.getCustomSerializer(irType)?.let { parceler ->
            return IrCustomParcelSerializer(parceler)
        }

        val classifier = irType.erasedUpperBound
        val classifierFqName = classifier.fqNameWhenAvailable?.asString()
        when (classifierFqName) {
            // Built-in parcel serializers
            ""kotlin.String"", ""java.lang.String"" ->
                return stringSerializer
            ""kotlin.CharSequence"", ""java.lang.CharSequence"" ->
                return charSequenceSerializer
            ""android.os.Bundle"" ->
                return IrParcelSerializerWithClassLoader(parcelizeType, symbols.parcelReadBundle, symbols.parcelWriteBundle)
            ""android.os.PersistableBundle"" ->
                return IrParcelSerializerWithClassLoader(
                    parcelizeType,
                    symbols.parcelReadPersistableBundle,
                    symbols.parcelWritePersistableBundle
                )

            // Non-nullable built-in serializers
            ""kotlin.Byte"", ""java.lang.Byte"" ->
                return wrapNullableSerializerIfNeeded(irType, byteSerializer)
            ""kotlin.Boolean"", ""java.lang.Boolean"" ->
                return wrapNullableSerializerIfNeeded(irType, booleanSerializer)
            ""kotlin.Char"", ""java.lang.Character"" ->
                return wrapNullableSerializerIfNeeded(irType, charSerializer)
            ""kotlin.Short"", ""java.lang.Short"" ->
                return wrapNullableSerializerIfNeeded(irType, shortSerializer)
            ""kotlin.Int"", ""java.lang.Integer"" ->
                return wrapNullableSerializerIfNeeded(irType, intSerializer)
            ""kotlin.Long"", ""java.lang.Long"" ->
                return wrapNullableSerializerIfNeeded(irType, longSerializer)
            ""kotlin.Float"", ""java.lang.Float"" ->
                return wrapNullableSerializerIfNeeded(irType, floatSerializer)
            ""kotlin.Double"", ""java.lang.Double"" ->
                return wrapNullableSerializerIfNeeded(irType, doubleSerializer)
            ""java.io.FileDescriptor"" ->
                return wrapNullableSerializerIfNeeded(irType, fileDescriptorSerializer)
            ""android.util.Size"" ->
                return wrapNullableSerializerIfNeeded(irType, sizeSerializer)
            ""android.util.SizeF"" ->
                return wrapNullableSerializerIfNeeded(irType, sizeFSerializer)

            // Unsigned primitive types
            ""kotlin.UByte"" ->
                return wrapNullableSerializerIfNeeded(irType, ubyteSerializer)
            ""kotlin.UShort"" ->
                return wrapNullableSerializerIfNeeded(irType, ushortSerializer)
            ""kotlin.UInt"" ->
                return wrapNullableSerializerIfNeeded(irType, uintSerializer)
            ""kotlin.ULong"" ->
                return wrapNullableSerializerIfNeeded(irType, ulongSerializer)

            // Built-in non-parameterized container types.
            ""kotlin.IntArray"" ->
                if (!scope.hasCustomSerializer(irBuiltIns.intType))",return intArraySerializer
"import org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirInternals
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.*
import org.jetbrains.kotlin.analysis.low.level.api.fir.compile.CodeFragmentCapturedId
import org.jetbrains.kotlin.analysis.low.level.api.fir.compile.CodeFragmentCapturedValueAnalyzer
import org.jetbrains.kotlin.analysis.low.level.api.fir.compile.CompilationPeerCollector
import org.jetbrains.kotlin.analysis.low.level.api.fir.project.structure.llFirModuleData
import org.jetbrains.kotlin.analysis.low.level.api.fir.sessions.LLFirSession
import org.jetbrains.kotlin.analysis.low.level.api.fir.sessions.llFirSession
import org.jetbrains.kotlin.analysis.low.level.api.fir.util.codeFragment
import org.jetbrains.kotlin.analysis.project.structure.KtDanglingFileModule
import org.jetbrains.kotlin.analysis.project.structure.KtModule
import org.jetbrains.kotlin.backend.common.extensions.IrGenerationExtension
import org.jetbrains.kotlin.backend.common.phaser.PhaseConfig
import org.jetbrains.kotlin.backend.jvm.*
import org.jetbrains.kotlin.builtins.DefaultBuiltIns
import org.jetbrains.kotlin.cli.jvm.compiler.NoScopeRecordCliBindingTrace
import org.jetbrains.kotlin.codegen.CodegenFactory
import org.jetbrains.kotlin.codegen.state.GenerationState
import org.jetbrains.kotlin.config.CommonConfigurationKeys
import org.jetbrains.kotlin.config.CompilerConfiguration
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.diagnostics.*
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.analysis.diagnostics.toFirDiagnostics
import org.jetbrains.kotlin.fir.backend.*
import org.jetbrains.kotlin.fir.backend.jvm.FirJvmBackendExtension
import org.jetbrains.kotlin.fir.backend.jvm.FirJvmKotlinMangler
import org.jetbrains.kotlin.fir.backend.jvm.FirJvmVisibilityConverter
import org.jetbrains.kotlin.fir.backend.jvm.JvmFir2IrExtensions
import org.jetbrains.kotlin.fir.backend.jvm.initializeActualDeclarationExtractorIfStdlib
import org.jetbrains.kotlin.fir.backend.utils.CodeFragmentConversionData
import org.jetbrains.kotlin.fir.backend.utils.InjectedValue
import org.jetbrains.kotlin.fir.backend.utils.conversionData
import org.jetbrains.kotlin.fir.declarations.FirDeclaration
import org.jetbrains.kotlin.fir.declarations.FirFile
import org.jetbrains.kotlin.fir.declarations.FirFunction
import org.jetbrains.kotlin.fir.declarations.FirResolvePhase
import org.jetbrains.kotlin.fir.declarations.utils.hasBody
import org.jetbrains.kotlin.fir.diagnostics.ConeSyntaxDiagnostic
import org.jetbrains.kotlin.fir.languageVersionSettings
import org.jetbrains.kotlin.fir.lazy.AbstractFir2IrLazyDeclaration
import org.jetbrains.kotlin.fir.pipeline.*
import org.jetbrains.kotlin.fir.psi
import org.jetbrains.kotlin.fir.references.FirReference
import org.jetbrains.kotlin.fir.references.FirThisReference
import org.jetbrains.kotlin.fir.references.toResolvedSymbol
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.fir.symbols.lazyResolveToPhaseRecursively
import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.PsiIrFileEntry
import org.jetbrains.kotlin.ir.backend.jvm.serialization.JvmIrMangler
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.descriptors.IrBasedDeclarationDescriptor
import org.jetbrains.kotlin.ir.descriptors.IrBasedReceiverParameterDescriptor
import org.jetbrains.kotlin.ir.descriptors.IrBasedValueParameterDescriptor
import org.jetbrains.kotlin.ir.descriptors.IrBasedVariableDescriptor
import org.jetbrains.kotlin.ir.expressions.*
import org.jetbrains.kotlin.ir.symbols.IrClassSymbol
import org.jetbrains.kotlin.ir.symbols.IrSymbol
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.types.IrSimpleType
import org.jetbrains.kotlin.ir.util.IdSignature
import org.jetbrains.kotlin.ir.util.StubGeneratorExtensions
import org.jetbrains.kotlin.ir.util.SymbolTable",import org.jetbrains.kotlin.ir.util.classId
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package org.jetbrains.kotlin.fir.caches
"TLong: Long,
        TFloat: Float,
        TDouble: Double,
        // unsigned integer types
        TUByte: UByte,
        TUShort: UShort,
        TUInt: UInt,
        TULong: ULong,
        // string types
        TString: String,
        // function types
        TFunction: () -> Unit,
        // external types
        TExternalInterface: ExternalInterface,
        TExternalOpenClass: ExternalOpenClass,
        TExternalObject: ExternalObject,
        // correct type parameter
        TCorrectTypeParameter: TExternalInterface
>


// correct JS interop types as property types

// primitive types
external val booleanProperty: Boolean
external val charProperty: Char
external val byteProperty: Byte
external val shortProperty: Short
external val intProperty: Int
external val longProperty: Long
external val floatProperty: Float
external val doubleProperty: Double

// unsigned integer types
external val uByteProperty: UByte
external val uShortProperty: UShort
external val uIntProperty: UInt
external val uLongProperty: ULong

// string types
external val stringProperty: String

// function types
external val functionProperty: () -> Unit

// external types
external val externalInterfaceProperty: ExternalInterface
external val externalOpenClassProperty: ExternalOpenClass
external val externalObjectProperty: ExternalObject


external fun correctJsInteropTypesAsFunctionTypeParameterTypes(
    primitiveTypes: (Boolean, Char, Byte, Short, Int, Long, Float, Double) -> Unit,
    unsignedIntegerTypes: (UByte, UShort, UInt, ULong) -> Unit,
    string: (String) -> Unit,
    function: (() -> Unit) -> Unit,
    externalTypes: (ExternalInterface, ExternalOpenClass, ExternalObject) -> Unit,
)

external fun correctJsInteropTypesAsFunctionTypeReturnTypes(
    // Unit and Nothing
    unit: () -> Unit,
    nothing: () -> Nothing,
    // primitive types
    boolean: () -> Boolean,","char: () -> Char,"
"@Test
    fun testTheThing(): Unit = controlFlow(
        """"""
            @NonRestartableComposable
            @Composable
            fun Simple() {
              // this has a composable call in it, and since we don't know the number of times the
              // lambda will get called, we place a group around the whole call
              run {
                A()
              }
              A()
            }

            @NonRestartableComposable
            @Composable
            fun WithReturn() {
              // this has an early return in it, so it needs to end all of the groups present.
              run {
                A()
                return@WithReturn
              }
              A()
            }

            @NonRestartableComposable
            @Composable
            fun NoCalls() {
              // this has no composable calls in it, so shouldn't cause any groups to get created
              run {
                println(""hello world"")
              }
              A()
            }

            @NonRestartableComposable
            @Composable
            fun NoCallsAfter() {
              // this has a composable call in the lambda, but not after it, which means the
              // group should be able to be coalesced into the group of the function
              run {
                A()
              }
            }
        """"""
    )

    @Test
    fun testLetWithComposableCalls(): Unit = controlFlow(
        """"""
            @Composable
            fun Example(x: Int?) {
              x?.let {
                if (it > 0) {
                  A(a)
                }
                A(b)
              }
              A(c)
            }
        """"""
    )

    @Test",fun testLetWithoutComposableCalls(): Unit = controlFlow(
"// !DIAGNOSTICS: -UNUSED_PARAMETER

fun foo(x: Int, f: () -> Unit, y: Int) {}

fun bar() {",var x: Int?
"public val publicProperty = 1
internal val publicOrInternalProperty = 1
internal val internalProperty = 1
private val internalOrPrivateProperty = 1
private val privateProperty = 1

public fun publicFunction() = 1
internal fun publicOrInternalFunction() = 1
internal fun internalFunction() = 1
private fun internalOrPrivateFunction() = 1
private fun privateFunction() = 1

open class Outer1 {
    public val publicProperty = 1
    internal val publicOrInternalProperty = 1
    internal val internalProperty = 1
    private val internalOrPrivateProperty = 1
    private val privateProperty = 1

    public fun publicFunction() = 1
    internal fun publicOrInternalFunction() = 1
    internal fun internalFunction() = 1
    private fun internalOrPrivateFunction() = 1
    private fun privateFunction() = 1

    open class Inner1 {
        public val publicProperty = 1
        internal val publicOrInternalProperty = 1
        internal val internalProperty = 1
        private val internalOrPrivateProperty = 1
        private val privateProperty = 1

        public fun publicFunction() = 1
        internal fun publicOrInternalFunction() = 1
        internal fun internalFunction() = 1
        private fun internalOrPrivateFunction() = 1
        private fun privateFunction() = 1
    }
}

open class Outer2 {
    public open val publicProperty = 1
    internal open val publicOrInternalProperty = 1
    internal open val internalProperty = 1
    private val internalOrPrivateProperty = 1
    private val privateProperty = 1",public open fun publicFunction() = 1
"@DeprecatedSinceKotlin(warningSince = ""1.5"")
public inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {
    var sum: Double = 0.0
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the array.
 */
@Deprecated(""Use sumOf instead."", ReplaceWith(""this.sumOf(selector)""))
@DeprecatedSinceKotlin(warningSince = ""1.5"")
public inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {
    var sum: Double = 0.0
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the array.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""sumOfDouble"")
@kotlin.internal.InlineOnly
public inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {
    var sum: Double = 0.toDouble()
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the array.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""sumOfDouble"")
@kotlin.internal.InlineOnly
public inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {
    var sum: Double = 0.toDouble()
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the array.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""sumOfDouble"")
@kotlin.internal.InlineOnly
public inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {
    var sum: Double = 0.toDouble()
    for (element in this) {",sum += selector(element)
"fun connectThread(threadNo: Int) = thread(name = ""daemonConnect$threadNo"") {
            try {
                withFlagFile(getTestName(true), "".alive"") { flagFile ->
                    withLogFile(""kotlin-daemon-test"", printLogOnException = false) { logFile ->
                        logFiles[threadNo] = logFile
                        val daemonJVMOptions = makeTestDaemonJvmOptions(logFile)
                        val compileServiceSession =
                                KotlinCompilerClient.connectAndLease(compilerId, flagFile, daemonJVMOptions, daemonOptions,
                                                                     DaemonReportingTargets(out = PrintStream(outStreams[threadNo])), autostart = true,
                                                                     leaseSession = true)
                        daemonInfos[threadNo] = compileServiceSession?.compileService?.getDaemonInfo() to compileServiceSession?.sessionId

                        resultCodes[threadNo] = when {
                            compileServiceSession?.compileService == null -> {
                                ParallelStartParams.connectionFailedErr
                            }
                            ParallelStartParams.performCompilation -> {
                                val jar = testTempDir.absolutePath + File.separator + ""hello.$threadNo.jar""
                                KotlinCompilerClient.compile(
                                    compileServiceSession.compileService,
                                    compileServiceSession.sessionId,
                                    CompileService.TargetPlatform.JVM,
                                    arrayOf(File(getHelloAppBaseDir(), ""hello.kt"").absolutePath, ""-d"", jar),
                                    PrintingMessageCollector(PrintStream(outStreams[threadNo]), MessageRenderer.WITHOUT_PATHS, true))
                            }
                            else -> 0 // compilation skipped, assuming - successful
                        }
                    }
                }
            }
            finally {
                doneLatch.countDown()
            }
        }

        CompilerSystemProperties.COMPILE_DAEMON_VERBOSE_REPORT_PROPERTY.value = ""true""
        CompilerSystemProperties.COMPILE_DAEMON_STARTUP_TIMEOUT_PROPERTY.value = ""100000""

        val succeeded = try {
            (1..ParallelStartParams.threads).forEach { connectThread(it - 1) }
            doneLatch.await(PARALLEL_WAIT_TIMEOUT_S, TimeUnit.SECONDS)
        }
        finally {
            CompilerSystemProperties.COMPILE_DAEMON_STARTUP_TIMEOUT_PROPERTY.clear()
            CompilerSystemProperties.COMPILE_DAEMON_VERBOSE_REPORT_PROPERTY.clear()
        }

        Thread.sleep(100) // Wait for processes to finish and close log files

        val electionLogs = arrayOfNulls<String>(ParallelStartParams.threads)
        val port2logs = arrayOfNulls<Pair<Int?, File?>>(ParallelStartParams.threads)

        for (i in 0..(ParallelStartParams.threads - 1)) {
            val logContents = logFiles[i]?.readLines()
            port2logs[i] = logContents?.find { it.contains(""daemon is listening on port"") }?.split("" "")?.last()?.toIntOrNull() to logFiles[i]
            electionLogs[i] = logContents?.find { it.contains(LOG_PREFIX_ASSUMING_OTHER_DAEMONS_HAVE) }
        }

        val electionsSuccess = electionLogs.any { it != null && (it.contains(""lower prio"") || it.contains(""equal prio"")) }
        val resultsFailures = resultCodes.count { it != null && it == 0 }

        if (!succeeded || !electionsSuccess || resultsFailures > 0) {
            val msg = buildString {
                for (i in 0..ParallelStartParams.threads - 1) {
                    val daemonInfoRes = daemonInfos[i]?.first",val daemonInfo = when (daemonInfoRes) {
"backendContext.testFunsPerFile[fileExports.file]
            ?.let { definitionSet.computeTag(it) }
            ?.let {
                val suiteFunctionTag = definitionSet.computeTag(backendContext.suiteFun!!.owner) ?: error(""Expect suite function tag exists"")
                result.testEnvironment = JsIrProgramTestEnvironment(it, suiteFunctionTag)
            }

        result.computeAndSaveNameBindings(definitionSet, nameGenerator)
        result.computeAndSaveImports(definitionSet, nameGenerator)
        result.computeAndSaveDefinitions(definitionSet, fileExports)

        if (optimizeGeneratedJs) {
            optimizeFragmentByJsAst(result, staticContext)
        }

        return JsIrProgramFragments(result, exportFragment)
    }

    private fun Set<IrDeclaration>.computeTag(declaration: IrDeclaration): String? {
        // Use LEGACY here because the declaration may come from an old klib, in which its `IdSignature.CommonSignature`
        // doesn't have `description`, but only `id`. Hence, we always render the signature with `id` instead of `description`,
        // because otherwise there may be a mismatch when we're computing the tag first for the IrDeclaration deserialized from klib,
        // and then for the same declaration but constructed from a descriptor.
        //
        // The former won't have `description` in its `IdSignature`, the latter will have it,
        // which will result in different renders unless we use the LEGACY renderer.
        val tag = (backendContext.irFactory as IdSignatureRetriever).declarationSignature(declaration)?.render(IdSignatureRenderer.LEGACY)

        if (tag == null && !contains(declaration)) {
            error(""signature for ${declaration.render()} not found"")
        }

        return tag
    }

    private fun JsIrProgramFragment.computeAndSaveNameBindings(
        definitions: Set<IrDeclaration>,
        nameGenerator: JsNameLinkingNamer
    ) {
        nameGenerator.nameMap.entries.forEach { (declaration, name) ->
            definitions.computeTag(declaration)?.let { tag ->
                nameBindings[tag] = name
                if (isBuiltInClass(declaration) || checkIsFunctionInterface(declaration.symbol.signature)) {
                    optionalCrossModuleImports += tag
                }
            }
        }
    }

    private fun JsIrProgramFragment.computeAndSaveImports(
        definitions: Set<IrDeclaration>,
        nameGenerator: JsNameLinkingNamer
    ) {
        nameGenerator.imports.entries.forEach { (declaration, importExpression) ->
            val tag = definitions.computeTag(declaration) ?: error(""No tag for imported declaration ${declaration.render()}"")
            imports[tag] = importExpression
            optionalCrossModuleImports += tag
        }
    }

    private fun JsIrProgramFragment.computeAndSaveDefinitions(
        definitions: Set<IrDeclaration>,
        fileExports: IrFileExports,
    ) {",fileExports.file.declarations.forEach {
"/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.js.backend.ast

import java.io.Reader

data class JsLocation @JvmOverloads constructor(","override val file: String,"
"// !DIAGNOSTICS: -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_VARIABLE -UNUSED_PARAMETER -FINAL_UPPER_BOUND
// SKIP_TXT

/*
 * KOTLIN DIAGNOSTICS SPEC TEST (NEGATIVE)
 *
 * SPEC VERSION: 0.1-296
 * MAIN LINK: expressions, try-expression -> paragraph 8 -> sentence 1
 * PRIMARY LINKS: expressions, try-expression -> paragraph 9 -> sentence 1
 * NUMBER: 1
 * DESCRIPTION: The type of the try-expression is the least upper bound of the types of the last expressions of the try body and the last expressions of all the catch blocks
 */

// FILE: TestCase1.kt
// TESTCASE NUMBER: 1
package testPackCase1

fun throwExceptionA(b: Boolean) = run { if (b) throw ExcA() }

class ExcA() : Exception()
class ExcB() : Exception()

open class A<T>(var data: T) {
    fun foo(d: A<T>) {}
}

class B<T>(data: T) : A<T>(data)

fun case1() {
    val tryVal: B<String> =
    <!INITIALIZER_TYPE_MISMATCH!>try {
        throwExceptionA(false)
        A("""")
    } catch (e: Exception) {
        B("""")
    }<!>
}

// FILE: TestCase2.kt
// TESTCASE NUMBER: 2
package testPackCase2

fun throwExceptionA(b: Boolean) = run { if (b) throw ExcA() }

class ExcA() : Exception()
class ExcB() : Exception()

open class A<T>(var data: T) {
    fun foo(d: A<T>) {}
}

class B<T>(data: T) : A<T>(data)



fun case2() {",val tryVal: A<String> =
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer

import java.io.File
import java.security.MessageDigest
import java.util.*

public object CommonizerOutputFileLayout {",internal const val maxFileNameLength = 150
"@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.ULongArray.max(): kotlin.ULong

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UShortArray.max(): kotlin.UShort

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxOrThrow"")
public fun <T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.max(): T

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxOrThrow"")
public fun kotlin.collections.Iterable<kotlin.Double>.max(): kotlin.Double

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxOrThrow"")
public fun kotlin.collections.Iterable<kotlin.Float>.max(): kotlin.Float

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <T, R : kotlin.Comparable<R>> kotlin.Array<out T>.maxBy(selector: (T) -> R): T

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.BooleanArray.maxBy(selector: (kotlin.Boolean) -> R): kotlin.Boolean

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.ByteArray.maxBy(selector: (kotlin.Byte) -> R): kotlin.Byte

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.CharArray.maxBy(selector: (kotlin.Char) -> R): kotlin.Char

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.DoubleArray.maxBy(selector: (kotlin.Double) -> R): kotlin.Double

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.FloatArray.maxBy(selector: (kotlin.Float) -> R): kotlin.Float

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.IntArray.maxBy(selector: (kotlin.Int) -> R): kotlin.Int

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.LongArray.maxBy(selector: (kotlin.Long) -> R): kotlin.Long

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.ShortArray.maxBy(selector: (kotlin.Short) -> R): kotlin.Short

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun <R : kotlin.Comparable<R>> kotlin.UByteArray.maxBy(selector: (kotlin.UByte) -> R): kotlin.UByte

@kotlin.SinceKotlin(version = ""1.7"")","@kotlin.jvm.JvmName(name = ""maxByOrThrow-U"")"
"// TARGET_BACKEND: JVM
// WITH_STDLIB
// JVM_ABI_K1_K2_DIFF: KT-63914

// FILE: J.java

import java.util.*;

public interface J<T extends Number> {
    T foo(List<T> p0, Map<T, ? extends Set<T>> p1);
}

// FILE: K.kt

import kotlin.test.assertEquals

object O : J<Long> {
    override fun foo(p0: List<Long>, p1: Map<Long, out Set<Long>>): Long = 42L
}

class A : J<Long> by O

fun box(): String {
    val m = A::class.java.getDeclaredMethod(""foo"", List::class.java, Map::class.java)",assertEquals(
"// WITH_STDLIB
// CHECK_CASES_COUNT: function=bar1 count=3
// CHECK_IF_COUNT: function=bar1 count=0
// CHECK_CASES_COUNT: function=bar2 count=4
// CHECK_IF_COUNT: function=bar2 count=0

import kotlin.test.assertEquals

enum class Season {
    WINTER,
    SPRING,
    SUMMER,
    AUTUMN
}

fun bar1(x : Season) : String {
    return when (x) {
        Season.WINTER, Season.SPRING -> ""winter_spring""
        Season.SUMMER -> ""summer""
        else -> ""autumn""
    }
}

fun bar2(x : Season) : String {
    return when (x) {
        Season.WINTER, Season.SPRING -> ""winter_spring""
        Season.SUMMER -> ""summer""
        Season.AUTUMN -> ""autumn""
    }
}

fun box() : String {
    assertEquals(""winter_spring"", bar1(Season.WINTER))
    assertEquals(""winter_spring"", bar1(Season.SPRING))
    assertEquals(""summer"", bar1(Season.SUMMER))
    assertEquals(""autumn"", bar1(Season.AUTUMN))","assertEquals(""winter_spring"", bar2(Season.WINTER))"
"override fun isApplicable(subjectType: KotlinType): Boolean {
        return DescriptorUtils.isSealedClass(TypeUtils.getClassDescriptor(subjectType))
    }
}


object WhenChecker {

    private val exhaustivenessCheckers = listOf(
        WhenOnBooleanExhaustivenessChecker,
        WhenOnEnumExhaustivenessChecker,
        WhenOnSealedExhaustivenessChecker
    )

    @JvmStatic
    fun getClassIdForEnumSubject(expression: KtWhenExpression, context: BindingContext) =
        getClassIdForTypeIfEnum(whenSubjectType(expression, context))

    @JvmStatic
    fun getClassIdForTypeIfEnum(type: KotlinType?) =
        getClassDescriptorOfTypeIfEnum(type)?.classId

    @JvmStatic
    fun getClassDescriptorOfTypeIfEnum(type: KotlinType?): ClassDescriptor? {
        if (type == null) return null
        val classDescriptor = TypeUtils.getClassDescriptor(type) ?: return null
        if (classDescriptor.kind != ClassKind.ENUM_CLASS) return null

        return classDescriptor
    }

    @JvmStatic
    fun getClassDescriptorOfTypeIfSealed(type: KotlinType?): ClassDescriptor? =
        type?.let { TypeUtils.getClassDescriptor(it) }?.takeIf { DescriptorUtils.isSealedClass(it) }


    @JvmStatic
    fun whenSubjectType(expression: KtWhenExpression, context: BindingContext): KotlinType? {
        val subjectVariable = expression.subjectVariable
        val subjectExpression = expression.subjectExpression
        return when {
            subjectVariable != null -> context.get(VARIABLE, subjectVariable)?.type
            subjectExpression != null -> context.get(SMARTCAST, subjectExpression)?.defaultType ?: context.getType(subjectExpression)
            else -> null
        }
    }

    fun whenSubjectTypeWithoutSmartCasts(expression: KtWhenExpression, context: BindingContext): KotlinType? {
        val subjectVariable = expression.subjectVariable
        val subjectExpression = expression.subjectExpression
        return when {
            subjectVariable != null -> context.get(VARIABLE, subjectVariable)?.type
            subjectExpression != null -> context.getType(subjectExpression)
            else -> null
        }
    }

    @JvmStatic
    fun getEnumMissingCases(
        expression: KtWhenExpression,
        context: BindingContext,
        enumClassDescriptor: ClassDescriptor
    ) = WhenOnEnumExhaustivenessChecker.getMissingCases(expression, context, enumClassDescriptor, false)",@JvmStatic
"package hello

open class A {

    internal val z: String = ""A_O""","internal fun test() = ""A_K"""
"val `OrgGradlePluginGroup`.`groovy-gradle-plugin`: PluginDependencySpec
    get() = plugins.id(""org.gradle.groovy-gradle-plugin"")


/**
 * The `org.gradle.help-tasks` plugin implemented by [org.gradle.api.plugins.HelpTasksPlugin].
 */
internal
val `OrgGradlePluginGroup`.`help-tasks`: PluginDependencySpec
    get() = plugins.id(""org.gradle.help-tasks"")


/**
 * The `org.gradle.idea` plugin implemented by [org.gradle.plugins.ide.idea.IdeaPlugin].
 */
internal
val `OrgGradlePluginGroup`.`idea`: PluginDependencySpec
    get() = plugins.id(""org.gradle.idea"")


/**
 * The `org.gradle.ivy-publish` plugin implemented by [org.gradle.api.publish.ivy.plugins.IvyPublishPlugin].
 */
internal
val `OrgGradlePluginGroup`.`ivy-publish`: PluginDependencySpec
    get() = plugins.id(""org.gradle.ivy-publish"")


/**
 * The `org.gradle.jacoco` plugin implemented by [org.gradle.testing.jacoco.plugins.JacocoPlugin].
 */
internal
val `OrgGradlePluginGroup`.`jacoco`: PluginDependencySpec
    get() = plugins.id(""org.gradle.jacoco"")


/**
 * The `org.gradle.jacoco-report-aggregation` plugin implemented by [org.gradle.testing.jacoco.plugins.JacocoReportAggregationPlugin].
 */
internal
val `OrgGradlePluginGroup`.`jacoco-report-aggregation`: PluginDependencySpec
    get() = plugins.id(""org.gradle.jacoco-report-aggregation"")


/**
 * The `org.gradle.java` plugin implemented by [org.gradle.api.plugins.JavaPlugin].
 */
internal
val `OrgGradlePluginGroup`.`java`: PluginDependencySpec
    get() = plugins.id(""org.gradle.java"")


/**
 * The `org.gradle.java-base` plugin implemented by [org.gradle.api.plugins.JavaBasePlugin].
 */
internal
val `OrgGradlePluginGroup`.`java-base`: PluginDependencySpec
    get() = plugins.id(""org.gradle.java-base"")


/**
 * The `org.gradle.java-gradle-plugin` plugin implemented by [org.gradle.plugin.devel.plugins.JavaGradlePluginPlugin].
 */
internal
val `OrgGradlePluginGroup`.`java-gradle-plugin`: PluginDependencySpec","get() = plugins.id(""org.gradle.java-gradle-plugin"")"
"// j.u.List in JDK 8 from Kotlin POV has a supertype kotlin.collections.MutableCollection
                    // that actually has JavaAnalogue, but since JDK 21 it has j.u.SequencedCollection as a supertype
                    // so `getJavaAnalogue()` might return null, but we still should continue traversing the supertypes
                    superClassDescriptor.getJavaAnalogue() ?: superClassDescriptor
                }
            },
            object : DFS.AbstractNodeHandler<ClassDescriptor, JDKMemberStatus>() {
                override fun beforeChildren(javaClassDescriptor: ClassDescriptor): Boolean {
                    val signature = SignatureBuildingComponents.signature(javaClassDescriptor, jvmDescriptor)
                    when (signature) {
                        in HIDDEN_METHOD_SIGNATURES -> result = JDKMemberStatus.HIDDEN
                        in VISIBLE_METHOD_SIGNATURES -> result = JDKMemberStatus.VISIBLE
                        in DEPRECATED_LIST_METHODS -> result = JDKMemberStatus.DEPRECATED_LIST_METHODS
                        in DROP_LIST_METHOD_SIGNATURES -> result = JDKMemberStatus.DROP
                    }

                    return result == null
                }

                override fun result() = result ?: JDKMemberStatus.NOT_CONSIDERED
            })
    }

    private enum class JDKMemberStatus {
        HIDDEN, VISIBLE, DEPRECATED_LIST_METHODS, NOT_CONSIDERED, DROP
    }

    private fun ClassDescriptor.getJavaAnalogue(): LazyJavaClassDescriptor? {
        // Prevents recursive dependency: memberScope(Any) -> memberScope(Object) -> memberScope(Any)
        // No additional members should be added to Any
        if (KotlinBuiltIns.isAny(this)) return null

        // Optimization: only classes under kotlin.* can have Java analogues
        if (!KotlinBuiltIns.isUnderKotlinPackage(this)) return null

        val fqName = fqNameUnsafe
        if (!fqName.isSafe) return null
        val javaAnalogueFqName = JavaToKotlinClassMap.mapKotlinToJava(fqName)?.asSingleFqName() ?: return null

        return settings.ownerModuleDescriptor.resolveClassByFqName(javaAnalogueFqName, NoLookupLocation.FROM_BUILTINS) as? LazyJavaClassDescriptor
    }

    override fun getConstructors(classDescriptor: ClassDescriptor): Collection<ClassConstructorDescriptor> {
        if (classDescriptor.kind != ClassKind.CLASS || !settings.isAdditionalBuiltInsFeatureSupported) return emptyList()

        val javaAnalogueDescriptor = classDescriptor.getJavaAnalogue() ?: return emptyList()

        val defaultKotlinVersion =
            j2kClassMapper.mapJavaToKotlin(javaAnalogueDescriptor.fqNameSafe, FallbackBuiltIns.Instance) ?: return emptyList()

        val substitutor = createMappedTypeParametersSubstitution(defaultKotlinVersion, javaAnalogueDescriptor).buildSubstitutor()

        fun ConstructorDescriptor.isEffectivelyTheSameAs(javaConstructor: ConstructorDescriptor) =
            OverridingUtil.getBothWaysOverridability(this, javaConstructor.substitute(substitutor)) ==
                    OverridingUtil.OverrideCompatibilityInfo.Result.OVERRIDABLE

        return javaAnalogueDescriptor.constructors.filter { javaConstructor ->
            javaConstructor.visibility.isPublicAPI &&
                    defaultKotlinVersion.constructors.none { it.isEffectivelyTheSameAs(javaConstructor) } &&
                    !javaConstructor.isTrivialCopyConstructorFor(classDescriptor) &&
                    !KotlinBuiltIns.isDeprecated(javaConstructor) &&
                    SignatureBuildingComponents.signature(
                        javaAnalogueDescriptor,
                        javaConstructor.computeJvmDescriptor()
                    ) !in HIDDEN_CONSTRUCTOR_SIGNATURES",}.map { javaConstructor ->
"@NullableApi
        public String foobar(String x, @Nullable CharSequence y) {
            return """";
        }

        public String bar() {
            return """";
        }

        @Nullable
        public java.util.List<String> baz() {
            return null;
        }
    }
}

// FILE: main.kt
fun main(a: A, b: A.B, c: A.C) {
    a.foo("""", null)<!UNNECESSARY_SAFE_CALL!>?.<!>length
    a.foo("""", null).length
    a.foo(<!NULL_FOR_NONNULL_TYPE!>null<!>, """").length

    a.foobar(null, """")<!UNSAFE_CALL!>.<!>length
    a.foobar("""", <!NULL_FOR_NONNULL_TYPE!>null<!>)?.length

    a.bar().length
    a.bar()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.length

    a.field<!UNNECESSARY_SAFE_CALL!>?.<!>length
    a.field.length

    a.baz()<!UNSAFE_CALL!>.<!>get(0)
    a.baz()!!.get(0).get(0)
    a.baz()!!.get(0)?.get(0)

    // b
    b.foo("""", <!NULL_FOR_NONNULL_TYPE!>null<!>)?.length
    b.foo("""", <!NULL_FOR_NONNULL_TYPE!>null<!>)<!UNSAFE_CALL!>.<!>length
    b.foo(null, """")<!UNSAFE_CALL!>.<!>length

    b.foobar(<!NULL_FOR_NONNULL_TYPE!>null<!>, """").length
    b.foobar("""", null)<!UNNECESSARY_SAFE_CALL!>?.<!>length

    b.bar()<!UNSAFE_CALL!>.<!>length
    b.bar()!!.length

    b.field?.length
    b.field<!UNSAFE_CALL!>.<!>length

    b.baz()<!UNSAFE_CALL!>.<!>get(0)
    b.baz()!!.get(0).get(0)
    b.baz()!!.get(0)?.get(0)

    // c
    c.foo("""", null)<!UNNECESSARY_SAFE_CALL!>?.<!>length
    c.foo("""", null).length
    c.foo(<!NULL_FOR_NONNULL_TYPE!>null<!>, """").length

    c.foobar(null, """")<!UNSAFE_CALL!>.<!>length
    c.foobar("""", null)?.length

    c.bar().length
    c.bar()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.length",c.field?.length
"typeParameters = listOfNotNull(visitorResultType as? TypeVariable, dataTP),
        modality = modality,
        override = override,
    )
}

private fun transformChildrenMethodKDoc(transformerParameter: FunctionParameter, dataParameter: FunctionParameter?, returnType: TypeRef) =
    buildString {
        append(""Recursively transforms this node's children *in place* using ["")
        append(transformerParameter.name)
        append(""].\n\n"")
        append(""Basically, executes `this.child = this.child.transform("")
        append(transformerParameter.name)
        if (dataParameter != null) {
            append("", "")
            append(dataParameter.name)
        }
        append("")` for each child of this node.\n\n"")
        append(""Does **not** run ["")
        append(transformerParameter.name)
        append(""] on this node itself.\n\n"")
        append(""@param "")
        append(transformerParameter.name)
        append("" The transformer to use for transforming the children."")
        if (dataParameter != null) {
            append(""\n@param "")
            append(dataParameter.name)
            append("" An arbitrary context to pass to each invocation of ["")
            append(transformerParameter.name)
            append(""]'s methods."")
        }
        if (returnType != StandardTypes.unit) {
            append(""\n@return `this`"")
        }
    }

fun ImportCollectingPrinter.printTransformChildrenMethod(
    element: FieldContainer<*>,
    transformerClass: ClassRef<PositionTypeParameterRef>,
    returnType: TypeRef,
    modality: Modality? = null,
    override: Boolean = false,
) {
    if (!element.hasTransformChildrenMethod) return
    println()
    val transformerParameter = FunctionParameter(""transformer"", transformerClass.withArgs(dataTP))
    if (!override) {
        printKDoc(transformChildrenMethodKDoc(transformerParameter, dataParameter, returnType))
    }
    printFunctionDeclaration(
        name = ""transformChildren"",
        parameters = listOf(transformerParameter, dataParameter),
        returnType = returnType,
        typeParameters = listOf(dataTP),
        modality = modality,
        override = override,
    )
}

fun ImportCollectingPrinter.printAcceptVoidMethod(visitorType: ClassRef<*>, treeName: String) {
    val visitorParameter = FunctionParameter(""visitor"", visitorType)
    val returnType = StandardTypes.unit
    printKDoc(acceptMethodKDoc(visitorParameter, null, returnType, treeName))
    printFunctionDeclaration(""accept"", listOf(visitorParameter), returnType)
    printBlock {","println(""accept("", visitorParameter.name, "", null)"")"
"builder.reified = typeParameter.isReified
        }

        val variance = variance(typeParameter.variance)
        if (variance != builder.variance) {
            builder.variance = variance
        }
        extension.serializeTypeParameter(typeParameter, builder)

        val upperBounds = typeParameter.upperBounds
        if (upperBounds.size == 1 && KotlinBuiltIns.isDefaultBound(upperBounds.single())) return builder

        for (upperBound in upperBounds) {
            if (useTypeTable()) {
                builder.addUpperBoundId(typeId(upperBound))
            } else {
                builder.addUpperBound(type(upperBound))
            }
        }

        return builder
    }

    fun typeId(type: KotlinType): Int = typeTable[type(type)]

    internal fun type(type: KotlinType): ProtoBuf.Type.Builder {
        val builder = ProtoBuf.Type.newBuilder()

        if (type.isError) {
            extension.serializeErrorType(type, builder)
            return builder
        }

        if (type.isFlexible()) {
            val flexibleType = type.asFlexibleType()

            val lowerBound = type(flexibleType.lowerBound)
            val upperBound = type(flexibleType.upperBound)
            extension.serializeFlexibleType(flexibleType, lowerBound, upperBound)
            if (useTypeTable()) {
                lowerBound.flexibleUpperBoundId = typeTable[upperBound]
            } else {
                lowerBound.setFlexibleUpperBound(upperBound)
            }
            return lowerBound
        }

        if (type.isSuspendFunctionType) {
            val functionType = type(transformSuspendFunctionToRuntimeFunctionType(type))
            functionType.flags = Flags.getTypeFlags(true, false)
            return functionType
        }

        when (val descriptor = type.constructor.declarationDescriptor) {
            is ClassDescriptor, is TypeAliasDescriptor -> {
                val possiblyInnerType = type.buildPossiblyInnerType() ?: error(""possiblyInnerType should not be null: $type"")
                fillFromPossiblyInnerType(builder, possiblyInnerType)
            }
            is TypeParameterDescriptor -> {
                if (descriptor.containingDeclaration === containingDeclaration) {
                    builder.typeParameterName = getSimpleNameIndex(descriptor.name)
                } else {
                    builder.typeParameter = getTypeParameterId(descriptor)
                }",if (type.unwrap() is DefinitelyNotNullType) {
"// -----------------------------------------------------------------------
    // internal implementation stuff

    // TODO: consider matching compilerId coming from outside with actual one
    //    private val selfCompilerId by lazy {
    //        CompilerId(
    //                compilerClasspath = System.getProperty(""java.class.path"")
    //                                            ?.split(File.pathSeparator)
    //                                            ?.map { File(it) }
    //                                            ?.filter { it.exists() }
    //                                            ?.map { it.absolutePath }
    //                                    ?: listOf(),
    //                compilerVersion = loadKotlinVersionFromResource()
    //        )
    //    }

    fun startDaemonElections() {
        timer.schedule(10) {
            exceptionLoggingTimerThread { initiateElections() }
        }
    }

    fun configurePeriodicActivities() {
        timer.schedule(delay = DAEMON_PERIODIC_CHECK_INTERVAL_MS, period = DAEMON_PERIODIC_CHECK_INTERVAL_MS) {
            exceptionLoggingTimerThread { periodicAndAfterSessionCheck() }
        }
        timer.schedule(delay = DAEMON_PERIODIC_SELDOM_CHECK_INTERVAL_MS + 100, period = DAEMON_PERIODIC_SELDOM_CHECK_INTERVAL_MS) {
            exceptionLoggingTimerThread { periodicSeldomCheck() }
        }
    }


    protected inline fun <R> ifAliveChecksImpl(
        minAliveness: Aliveness = Aliveness.LastSession,
        body: () -> CompileService.CallResult<R>,
    ): CompileService.CallResult<R> {
        val curState = state.alive.get()
        return when {
            curState < minAliveness.ordinal -> {
                log.info(""Cannot perform operation, requested state: ${minAliveness.name} > actual: ${curState.toAlivenessName()}"")
                CompileService.CallResult.Dying()
            }
            else -> {
                try {
                    body()
                } catch (e: Throwable) {
                    log.log(Level.SEVERE, ""Exception"", e)
                    CompileService.CallResult.Error(e)
                }
            }
        }
    }

    protected inline fun <R> withValidClientOrSessionProxy(
        sessionId: Int,
        body: (ClientOrSessionProxy<Any>?) -> CompileService.CallResult<R>,
    ): CompileService.CallResult<R> {
        val session: ClientOrSessionProxy<Any>? =
            if (sessionId == CompileService.NO_SESSION) null
            else state.sessions[sessionId] ?: return CompileService.CallResult.Error(""Unknown or invalid session $sessionId"")
        try {
            compilationsCounter.incrementAndGet()
            return body(session)",} finally {
"// Test depends on macOS-specific AppKit
// DISABLE_NATIVE: isAppleTarget=false
// DISABLE_NATIVE: targetFamily=IOS
// DISABLE_NATIVE: targetFamily=TVOS
// DISABLE_NATIVE: targetFamily=WATCHOS
import kotlinx.cinterop.alloc
import kotlinx.cinterop.memScoped
import kotlinx.cinterop.readValue
import platform.AppKit.NSEvent
import platform.AppKit.NSOpenGLPixelFormat
import platform.AppKit.NSOpenGLView
import platform.Foundation.NSRect

val sb = StringBuilder()

@OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)
class MyNSOpenGLView(
        frame: kotlinx.cinterop.CValue<NSRect>,
        pixelFormat: platform.AppKit.NSOpenGLPixelFormat?
) : NSOpenGLView(frame, pixelFormat) {

    init {
        this.resetCursorRects()
    }

    override fun acceptsFirstResponder(): Boolean = true
    override fun becomeFirstResponder(): Boolean = true

    override fun resetCursorRects() {
       sb.append(""OK"")
    }


    override fun flagsChanged(event: NSEvent) {

    }

    override fun magnifyWithEvent(event: NSEvent) {

    }

    override fun rotateWithEvent(event: NSEvent) {

    }

    override fun swipeWithEvent(event: NSEvent) {

    }

    override fun smartMagnifyWithEvent(event: NSEvent) {

    }

    override fun scrollWheel(event: NSEvent) {

    }

    override fun mouseUp(event: NSEvent): Unit = TODO()
    override fun rightMouseUp(event: NSEvent): Unit = TODO()
    override fun otherMouseUp(event: NSEvent): Unit = TODO()

    override fun mouseDown(event: NSEvent): Unit = TODO()
    override fun rightMouseDown(event: NSEvent): Unit = TODO()
    override fun otherMouseDown(event: NSEvent): Unit = TODO()",override fun mouseDragged(event: NSEvent): Unit = TODO()
"// WITH_STDLIB

@file:JvmName(""TestKt"")

package test

import kotlinx.parcelize.*
import android.os.Parcel
import android.os.Parcelable
import kotlinx.collections.immutable.*

@Parcelize
data class Test(val a: PersistentList<String>) : Parcelable

fun box() = parcelTest { parcel ->
    val first = Test(persistentListOf(""A"", ""B""))

    first.writeToParcel(parcel, 0)

    val bytes = parcel.marshall()
    parcel.unmarshall(bytes, 0, bytes.size)
    parcel.setDataPosition(0)

    val first2 = parcelableCreator<Test>().createFromParcel(parcel)",assert(first == first2)
"): List<ConeClassLikeType> {
    return SmartList<ConeClassLikeType>().also {
        klass.symbol.collectSuperTypes(it, SmartSet.create(), deep, lookupInterfaces, substituteTypes, useSiteSession, supertypeSupplier)
    }
}

fun FirClassSymbol<*>.isSubclassOf(
    ownerLookupTag: ConeClassLikeLookupTag,
    session: FirSession,
    isStrict: Boolean,
    lookupInterfaces: Boolean
): Boolean {
    lazyResolveToPhase(FirResolvePhase.SUPER_TYPES)
    return fir.isSubclassOf(ownerLookupTag, session, isStrict, SupertypeSupplier.Default, lookupInterfaces)
}

fun FirClass.isSubclassOf(
    ownerLookupTag: ConeClassLikeLookupTag,
    session: FirSession,
    isStrict: Boolean,
    supertypeSupplier: SupertypeSupplier = SupertypeSupplier.Default,
    lookupInterfaces: Boolean = true,
): Boolean {
    if (symbol.toLookupTag() == ownerLookupTag) {
        return !isStrict
    }

    return lookupSuperTypes(
        this,
        lookupInterfaces = lookupInterfaces,
        deep = true,
        session,
        substituteTypes = false,
        supertypeSupplier
    ).any { superType ->
        // Note: We just check lookupTag here, so type substitution isn't needed
        superType.lookupTag == ownerLookupTag
    }
}

fun FirClass.isThereLoopInSupertypes(session: FirSession): Boolean {
    val visitedSymbols: MutableSet<FirClassifierSymbol<*>> = SmartSet.create()
    val inProcess: MutableSet<FirClassifierSymbol<*>> = mutableSetOf()

    var isThereLoop = false

    fun dfs(current: FirClassifierSymbol<*>) {
        if (current in visitedSymbols) return
        if (!inProcess.add(current)) {
            isThereLoop = true
            return
        }

        when (val fir = current.fir) {
            is FirClass -> {
                fir.superConeTypes.forEach {
                    it.lookupTag.toSymbol(session)?.let(::dfs)
                }
            }
            is FirTypeAlias -> {
                fir.expandedConeType?.lookupTag?.toSymbol(session)?.let(::dfs)
            }
            else -> {}
        }",visitedSymbols.add(current)
"// FILE: rootPackage.kt
class Klass {
    class Nested
}",class NotImported
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_PARAMETER
// ISSUE: KT-35896

interface B<E, SC>

class Inv<T>","class Foo<T>(x: Int): B<T, Inv<T>>"
"// Object.
interface Codeable {
    fun asCode(): Int
}

val an_object = object : Codeable {
    override fun asCode() = 42
}

object Singleton {
    override fun toString() = ""I am single""
}

class Child : Base() {
    override fun fooParam(arg0: String, arg1: Int, arg2: String?) =
            println(""Child.fooParam: $arg0 $arg1 ${arg2 ?: ""null""}"")

    val roProperty: Int
        get() = 42

    var rwProperty: Int = 0
        get() = field
        set(value) { field = value + 1 }
}

// Interface.
interface I {
    fun foo(arg0: String, arg1: Int, arg2: I)
    fun fooImpl() = foo(""Hi"", 239, this)
}

open class Impl1: I {
    override fun foo(arg0: String, arg1: Int, arg2: I) {
        println(""Impl1.I: $arg0 $arg1 ${arg2::class.qualifiedName}"")
    }
}

class Impl2 : Impl1() {
    override fun foo(arg0: String, arg1: Int, arg2: I) {
        println(""Impl2.I: $arg0 $arg1 ${arg2::class.qualifiedName}"")
    }
}

inline class IC1(val value: Int)
inline class IC2(val value: String)
inline class IC3(val value: Base?)

fun useInlineClasses(ic1: IC1, ic2: IC2, ic3: IC3) {
    assert(ic1.value == 42)
    assert(ic2.value == ""bar"")
    assert(ic3.value is Base)
}

fun testNullableWithNulls(arg1: Int?, arg2: Unit?) {
    assert(arg1 == null)
    assert(arg2 == null)
}

fun setCErrorHandler(callback: CPointer<CFunction<(CPointer<ByteVar>) -> Unit>>?) {
    setUnhandledExceptionHook({
        throwable: Throwable ->
        memScoped {
            callback!!(throwable.toString().cstr.ptr)
        }",kotlin.system.exitProcess(0)
"/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")
@DeprecatedSinceKotlin(warningSince = ""1.6"")
@kotlin.internal.InlineOnly
public inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {
    nativeSort(comparison)
}

/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")
@DeprecatedSinceKotlin(warningSince = ""1.6"")
@kotlin.internal.InlineOnly
public inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {
    nativeSort(comparison)
}

/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")
@DeprecatedSinceKotlin(warningSince = ""1.6"")
@kotlin.internal.InlineOnly
public inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {
    nativeSort(comparison)
}

/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")
@DeprecatedSinceKotlin(warningSince = ""1.6"")
@kotlin.internal.InlineOnly
public inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {
    nativeSort(comparison)
}

/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")
@DeprecatedSinceKotlin(warningSince = ""1.6"")
@kotlin.internal.InlineOnly
public inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {
    nativeSort(comparison)
}

/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")
@DeprecatedSinceKotlin(warningSince = ""1.6"")
@kotlin.internal.InlineOnly
public inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {
    nativeSort(comparison)
}

/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")","@DeprecatedSinceKotlin(warningSince = ""1.6"")"
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.resolve.transformers.body.resolve

import org.jetbrains.kotlin.fir.FirCallResolver
import org.jetbrains.kotlin.fir.FirElement
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.util.PrivateForInline
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.expressions.FirLazyBlock
import org.jetbrains.kotlin.fir.expressions.FirLazyExpression
import org.jetbrains.kotlin.fir.expressions.FirStatement
import org.jetbrains.kotlin.fir.resolve.*
import org.jetbrains.kotlin.fir.resolve.calls.ResolutionContext
import org.jetbrains.kotlin.fir.resolve.calls.ResolutionStageRunner
import org.jetbrains.kotlin.fir.resolve.dfa.FirDataFlowAnalyzer
import org.jetbrains.kotlin.fir.resolve.inference.FirCallCompleter
import org.jetbrains.kotlin.fir.resolve.inference.InferenceComponents
import org.jetbrains.kotlin.fir.resolve.inference.inferenceComponents
import org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider
import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider
import org.jetbrains.kotlin.fir.resolve.transformers.*
import org.jetbrains.kotlin.fir.scopes.FirScope",import org.jetbrains.kotlin.fir.scopes.impl.FirLocalScope
"import org.junit.jupiter.api.Tag
import org.junit.jupiter.api.TestFactory
import org.jetbrains.kotlin.konan.test.blackbox.support.group.PredefinedTestCase as TC

@Tag(""stdlib"")
@PredefinedTestCases(
    TC(
        name = ""default"",
        runnerType = TestRunnerType.DEFAULT,
        freeCompilerArgs = [
            ENABLE_MPP, STDLIB_IS_A_FRIEND, ENABLE_X_STDLIB_API, ENABLE_X_ENCODING_API, ENABLE_RANGE_UNTIL,
            ENABLE_X_FOREIGN_API, ENABLE_X_NATIVE_API, ENABLE_OBSOLETE_NATIVE_API, ENABLE_NATIVE_RUNTIME_API,
            ENABLE_OBSOLETE_WORKERS_API, ENABLE_INTERNAL_FOR_KOTLIN_NATIVE,
            ""-language-version"", ""1.9"",
            ""-api-version"", ""2.0"",
            ""-Xsuppress-api-version-greater-than-language-version-error""
        ],
        sourceLocations = [
            ""libraries/stdlib/test/**.kt"",
            ""libraries/stdlib/common/test/**.kt"",
            ""libraries/stdlib/native-wasm/test/**.kt"",
            ""kotlin-native/runtime/test/**.kt""
        ],
        ignoredTests = [DISABLED_STDLIB_TEST]
    )
)
@EnforcedProperty(property = ClassLevelProperty.EXECUTION_TIMEOUT, propertyValue = ""2m"")
@UsePartialLinkage(UsePartialLinkage.Mode.DISABLED)
class StdlibTest : AbstractNativeBlackBoxTest() {
    @TestFactory
    fun default() = dynamicTestCase(TestCaseId.Named(""default""))
}

@Tag(""stdlib"")
@Tag(""frontend-fir"")
@PredefinedTestCases(
    TC(
        name = ""default"",
        runnerType = TestRunnerType.DEFAULT,
        freeCompilerArgs = [
            ENABLE_MPP, STDLIB_IS_A_FRIEND, ENABLE_X_STDLIB_API, ENABLE_X_ENCODING_API, ENABLE_RANGE_UNTIL,
            ENABLE_X_FOREIGN_API, ENABLE_X_NATIVE_API, ENABLE_OBSOLETE_NATIVE_API, ENABLE_NATIVE_RUNTIME_API,
            ENABLE_OBSOLETE_WORKERS_API, ENABLE_INTERNAL_FOR_KOTLIN_NATIVE,
            ""-Xcommon-sources=libraries/stdlib/common/test/jsCollectionFactories.kt"",
            ""-Xcommon-sources=libraries/stdlib/common/test/testUtils.kt"",
            ""-Xcommon-sources=libraries/stdlib/test/testUtils.kt"",
            ""-Xcommon-sources=libraries/stdlib/test/text/StringEncodingTest.kt"",
        ],
        sourceLocations = [
            ""libraries/stdlib/test/**.kt"",
            ""libraries/stdlib/common/test/**.kt"",
            ""libraries/stdlib/native-wasm/test/**.kt"",
            ""kotlin-native/runtime/test/**.kt""
        ],
        ignoredTests = [DISABLED_STDLIB_TEST]
    )
)
@EnforcedProperty(property = ClassLevelProperty.EXECUTION_TIMEOUT, propertyValue = ""2m"")
@FirPipeline
@UsePartialLinkage(UsePartialLinkage.Mode.DISABLED)
class FirStdlibTest : AbstractNativeBlackBoxTest() {
    @TestFactory
    fun default() = dynamicTestCase(TestCaseId.Named(""default""))
}","private const val ENABLE_MPP = ""-Xmulti-platform"""
"val removedFqNames = removedClasses.toSet()

        for (removedClass in removedFqNames) {
            for (affectedClass in withSubtypes(removedClass, thisWithDependentCaches)) {
                changesCollector.collectSignature(affectedClass, areSubclassesAffected = false)
            }
        }

        for (cache in thisWithDependentCaches) {
            val parentsFqNames = hashSetOf<FqName>()
            val childrenFqNames = hashSetOf<FqName>()

            for (removedFqName in removedFqNames) {
                parentsFqNames.addAll(cache.supertypesMap[removedFqName].orEmpty())
                childrenFqNames.addAll(cache.subtypesMap[removedFqName].orEmpty())

                cache.supertypesMap.remove(removedFqName)
                cache.subtypesMap.remove(removedFqName)
            }

            for (child in childrenFqNames) {
                cache.supertypesMap.removeValues(child, removedFqNames)
            }

            for (parent in parentsFqNames) {
                cache.subtypesMap.removeValues(parent, removedFqNames)
            }
        }

        removedFqNames.forEach {
            classFqNameToSourceMap.remove(it)
            classAttributesMap.remove(it)
        }
    }

    protected class ClassFqNameToSourceMap(
        storageFile: File,
        icContext: IncrementalCompilationContext,
    ) : AbstractBasicMap<FqName, File>(
        storageFile,
        FqNameExternalizer.toDescriptor(),
        icContext.fileDescriptorForSourceFiles,
        icContext
    )

    override fun getComplementaryFilesRecursive(dirtyFiles: Collection<File>): Collection<File> {
        val complementaryFiles = HashSet<File>()
        val filesQueue = ArrayDeque(dirtyFiles)

        val processedClasses = HashSet<FqName>()
        val processedFiles = HashSet<File>()

        while (filesQueue.isNotEmpty()) {
            val file = filesQueue.pollFirst()
            if (processedFiles.contains(file)) {
                continue
            }
            processedFiles.add(file)
            complementaryFilesMap[file]?.forEach {
                if (complementaryFiles.add(it) && !processedFiles.contains(it)) filesQueue.add(it)
            }
            val classes2recompile = sourceToClassesMap.getFqNames(file).orEmpty()
            classes2recompile.filter { !processedClasses.contains(it) }.forEach { class2recompile ->
                processedClasses.add(class2recompile)","val sealedClasses = findSealedSupertypes(class2recompile, listOf(this))"
"/*
 * KOTLIN DIAGNOSTICS SPEC TEST (POSITIVE)
 *
 * SPEC VERSION: 0.1-100
 * MAIN LINK: expressions, constant-literals, real-literals -> paragraph 4 -> sentence 1
 * NUMBER: 4
 * DESCRIPTION: Real literals with an omitted whole-number part and underscores in a whole-number part, a fraction part and an exponent part.
 */

// TESTCASE NUMBER: 1
val value_1 = .0_0

// TESTCASE NUMBER: 2
val value_2 = .0_0f

// TESTCASE NUMBER: 3
val value_3 = .0_0e-0_0

// TESTCASE NUMBER: 4
val value_4 = .0_0e0_0F

// TESTCASE NUMBER: 5
val value_5 = .0__0F

// TESTCASE NUMBER: 6
val value_6 = .0_0E+0__0_0F

// TESTCASE NUMBER: 7
val value_7 = .0e0f

// TESTCASE NUMBER: 8
val value_8 = .0_0E0_0

// TESTCASE NUMBER: 9
val value_9 = .0e1_0F

// TESTCASE NUMBER: 10
val value_10 = .0e10__0

// TESTCASE NUMBER: 11
val value_11 = .00______00F

// TESTCASE NUMBER: 12
val value_12 = .0___9

// TESTCASE NUMBER: 13",val value_13 = .0__________________________________________________12___________________________________________________________________0F
"// EXPECTED_REACHABLE_NODES: 1284
class C {
    fun foo() {}
}

fun box(): String {
    val a: C? = C()
    val b: C? = null

    if (a?.foo() != Unit) return ""fail1: ${a?.foo()}""","if (b?.foo() != null) return ""fail2: ${b?.foo()}"""
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.klib.reader.testUtils

import org.jetbrains.kotlin.native.analysis.api.*

fun Iterable<KlibDeclarationAddress>.render() = joinToString(System.lineSeparator().repeat(2)) { it.render() }",fun KlibDeclarationAddress.render(): String {
"fun data() = arrayOf<Any>(
            arrayOf(false, false),
            arrayOf(false, true),
            arrayOf(true, false),
            arrayOf(true, true)
        )
    }

    override fun CompilerConfiguration.updateConfiguration() {
        put(
            ComposeConfiguration.FEATURE_FLAGS,
            listOf(
                FeatureFlag.StrongSkipping.featureName,
                FeatureFlag.OptimizeNonSkippingGroups.featureName,
                FeatureFlag.IntrinsicRemember.name(intrinsicRememberEnabled)
            )
        )
    }

    @Test
    fun testSingleStableParam(): Unit = verifyMemoization(
        """"""
            class Foo(val value: Int = 0)
            @Composable fun A(x: Foo) {}
        """""",
        """"""
            @Composable
            fun Test(x: Foo) {
                A(x)
            }
        """"""
    )

    @Test
    fun testSingleUnstableParam(): Unit = verifyMemoization(
        """"""
            @Composable fun A(x: Foo) {}
            class Foo(var value: Int = 0)
        """""",
        """"""
            @Composable
            fun Test(x: Foo) {
                A(x)
            }
        """"""
    )

    @Test
    fun testSingleNullableUnstableParam(): Unit = verifyMemoization(
        """"""
            @Composable fun A(x: Foo?) {}
            class Foo(var value: Int = 0)
        """""",
        """"""
            @Composable
            fun Test(x: Foo?) {
                A(x)
            }
        """"""
    )

    @Test
    fun testSingleOptionalUnstableParam(): Unit = verifyMemoization(
        """"""
            @Composable fun A(x: Foo?) {}",class Foo(var value: Int = 0)
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"", ""unused"")

package org.jetbrains.kotlin.fir.expressions.builder

import kotlin.contracts.*
import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.FirExpressionRef
import org.jetbrains.kotlin.fir.builder.FirAnnotationContainerBuilder
import org.jetbrains.kotlin.fir.builder.FirBuilderDsl
import org.jetbrains.kotlin.fir.builder.toMutableOrEmpty
import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.expressions.FirCheckedSafeCallSubject
import org.jetbrains.kotlin.fir.expressions.FirExpression
import org.jetbrains.kotlin.fir.expressions.impl.FirCheckedSafeCallSubjectImpl
import org.jetbrains.kotlin.fir.types.ConeKotlinType

@FirBuilderDsl
class FirCheckedSafeCallSubjectBuilder : FirAnnotationContainerBuilder, FirExpressionBuilder {
    override var source: KtSourceElement? = null
    override var coneTypeOrNull: ConeKotlinType? = null
    override val annotations: MutableList<FirAnnotation> = mutableListOf()
    lateinit var originalReceiverRef: FirExpressionRef<FirExpression>",override fun build(): FirCheckedSafeCallSubject {
"val project = compilation.target.project

        val processResourcesTask = target.project.tasks.named(compilation.processResourcesTaskName)

        val assembleTaskProvider = project.tasks.named(LifecycleBasePlugin.ASSEMBLE_TASK_NAME)

        compilation.binaries
            .matching { it is Executable }
            .all { binary ->
                binary as Executable

                val mode = binary.mode
                val archivesName = project.archivesName

                val webpackTask = registerSubTargetTask<KotlinWebpack>(
                    disambiguateCamelCased(
                        binary.executeTaskBaseName,
                        WEBPACK_TASK_NAME
                    ),
                    listOf(compilation)
                ) { task ->
                    task.description = ""build webpack ${mode.name.toLowerCaseAsciiOnly()} bundle""
                    val buildDirectory = project.layout.buildDirectory
                    val targetName = target.name
                    task.outputDirectory.convention(
                        binary.distribution.distributionName.flatMap {
                            buildDirectory.dir(""kotlin-webpack/$targetName/$it"")
                        }
                    ).finalizeValueOnRead()

                    task.dependsOn(binary.linkSyncTask)

                    task.commonConfigure(
                        binary = binary,
                        mode = mode,
                        inputFilesDirectory = task.project.objects.directoryProperty().fileProvider(
                            task.project.provider { binary.linkSyncTask.get().destinationDirectory.get() },
                        ),
                        entryModuleName = binary.linkTask.flatMap { it.compilerOptions.moduleName },
                        configurationActions = webpackTaskConfigurations,
                        nodeJs = nodeJs,
                        defaultArchivesName = archivesName,
                    )
                }

                val distributionTask = registerSubTargetTask<Copy>(
                    disambiguateCamelCased(
                        if (binary.mode == KotlinJsBinaryMode.PRODUCTION) """" else binary.name,
                        DISTRIBUTION_TASK_NAME
                    )
                ) { copy ->
                    copy.from(processResourcesTask)
                    copy.from(webpackTask.flatMap { it.outputDirectory })

                    if (binary.compilation.platformType == KotlinPlatformType.wasm) {
                        copy.from(
                            binary.linkSyncTask.zip(binary.linkTask) { linkSyncTask, linkTask ->
                                val moduleNameProvider = linkTask.compilerOptions.moduleName
                                linkSyncTask.destinationDirectory.zip(moduleNameProvider) { destDir, moduleName ->
                                    destDir.resolve(""$moduleName.wasm"")
                                }
                            }
                        )
                    }",copy.into(binary.distribution.outputDirectory)
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.light.classes.symbol.source

import org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators.AnalysisApiFirSourceTestConfigurator
import org.jetbrains.kotlin.light.classes.symbol.base.AbstractSymbolLightClassesEqualityByPsiTest

abstract class AbstractSymbolLightClassesEqualityByPsiForSourceTest :
    AbstractSymbolLightClassesEqualityByPsiTest(","AnalysisApiFirSourceTestConfigurator(analyseInDependentSession = false),"
"toNullableT = true
        body {
            """"""
            return filterNotNullTo(ArrayList<T>())
            """"""
        }

        specialFor(Sequences) {
            doc { ""Returns a sequence containing all elements that are not `null`."" }
            returns(""Sequence<T>"")
        }
        body(Sequences) {
            """"""
            @Suppress(""UNCHECKED_CAST"")
            return filterNot { it == null } as Sequence<T>
            """"""
        }
    }

    val f_filterNotNullTo = fn(""filterNotNullTo(destination: C)"") {
        include(Iterables, Sequences, ArraysOfObjects)
    } builder {
        doc { ""Appends all elements that are not `null` to the given [destination]."" }
        sample(""samples.collections.Collections.Filtering.filterNotNullTo"")
        returns(""C"")
        typeParam(""C : TCollection"")
        typeParam(""T : Any"")
        toNullableT = true
        body {
            """"""
            for (element in this) if (element != null) destination.add(element)
            return destination
            """"""
        }
    }

    val f_filterIsInstanceTo = fn(""filterIsInstanceTo(destination: C)"") {
        include(Iterables, Sequences, ArraysOfObjects)
    } builder {
        doc { ""Appends all elements that are instances of specified type parameter R to the given [destination]."" }
        sample(""samples.collections.Collections.Filtering.filterIsInstanceTo"")
        typeParam(""reified R"")
        typeParam(""C : MutableCollection<in R>"")
        inline()
        genericStarProjection = true
        returns(""C"")
        body {
            """"""
            for (element in this) if (element is R) destination.add(element)
            return destination
            """"""
        }
    }

    val f_filterIsInstance = fn(""filterIsInstance()"") {
        include(Iterables, Sequences, ArraysOfObjects)
    } builder {
        doc { ""Returns a list containing all elements that are instances of specified type parameter R."" }
        sample(""samples.collections.Collections.Filtering.filterIsInstance"")
        typeParam(""reified R"")
        returns(""List<@kotlin.internal.NoInfer R>"")
        inline()
        genericStarProjection = true
        body {
            """"""",return filterIsInstanceTo(ArrayList<R>())
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.lower.calls

import org.jetbrains.kotlin.ir.backend.js.JsIrBackendContext
import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder
import org.jetbrains.kotlin.ir.expressions.IrConstructorCall
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.expressions.IrFunctionAccessExpression
import org.jetbrains.kotlin.ir.util.irConstructorCall


class BuiltInConstructorCalls(val context: JsIrBackendContext) : CallsTransformer {
    val intrinsics = context.intrinsics

    override fun transformFunctionAccess(call: IrFunctionAccessExpression, doNotIntrinsify: Boolean): IrExpression =
        if (call is IrConstructorCall) {
            // Do not transform Delegation calls
            when (call.symbol) {","intrinsics.stringConstructorSymbol -> JsIrBuilder.buildString(context.irBuiltIns.stringType, """")"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.internal.properties

import org.gradle.api.Project
import org.gradle.api.plugins.ExtraPropertiesExtension
import org.gradle.api.provider.MapProperty
import org.gradle.api.provider.Property",import org.gradle.api.provider.Provider
") {
        this.candidate = candidate
        setAnalyzedResults(subResolvedAtoms)
    }

}

class EagerCallableReferenceAtom(
    atom: CallableReferenceKotlinCallArgument,
    expectedType: UnwrappedType?
) : ResolvedCallableReferenceArgumentAtom(atom, expectedType) {
    override val inputTypes: Collection<UnwrappedType> get() = emptyList()
    override val outputType: UnwrappedType? get() = null

    fun transformToPostponed(): PostponedCallableReferenceAtom = PostponedCallableReferenceAtom(this)
}

sealed class AbstractPostponedCallableReferenceAtom(
    atom: CallableReferenceKotlinCallArgument,
    expectedType: UnwrappedType?
) : ResolvedCallableReferenceArgumentAtom(atom, expectedType) {
    override val inputTypes: Collection<UnwrappedType>
        get() = extractInputOutputTypesFromCallableReferenceExpectedType(expectedType)?.inputTypes ?: listOfNotNull(expectedType)

    override val outputType: UnwrappedType?
        get() = extractInputOutputTypesFromCallableReferenceExpectedType(expectedType)?.outputType
}

class CallableReferenceWithRevisedExpectedTypeAtom(
    atom: CallableReferenceKotlinCallArgument,
    expectedType: UnwrappedType?,
) : AbstractPostponedCallableReferenceAtom(atom, expectedType)

class PostponedCallableReferenceAtom(
    eagerCallableReferenceAtom: EagerCallableReferenceAtom
) : AbstractPostponedCallableReferenceAtom(eagerCallableReferenceAtom.atom, eagerCallableReferenceAtom.expectedType),
    PostponedCallableReferenceMarker {
    override var revisedExpectedType: UnwrappedType? = null
        private set

    override fun reviseExpectedType(expectedType: KotlinTypeMarker) {
        require(expectedType is UnwrappedType)
        revisedExpectedType = expectedType
    }
}

class ResolvedCollectionLiteralAtom(
    override val atom: CollectionLiteralKotlinCallArgument,
    val expectedType: UnwrappedType?
) : ResolvedAtom() {
    init {
        setAnalyzedResults(listOf())
    }
}

sealed class CallResolutionResult(
    resultCallAtom: ResolvedCallAtom?,
    val diagnostics: List<KotlinCallDiagnostic>,
    val constraintSystem: NewConstraintSystem
) : ResolvedAtom() {
    init {
        setAnalyzedResults(listOfNotNull(resultCallAtom))
    }

    final override fun setAnalyzedResults(subResolvedAtoms: List<ResolvedAtom>) {",super.setAnalyzedResults(subResolvedAtoms)
"// TARGET_BACKEND: JVM
// WITH_REFLECT
// FILE: 1.kt",@file:JvmMultifileClass
"val factory = when {
                            isReportExpansionError && argumentTypeRef == null -> additionalUpperBoundsProvider.diagnosticForTypeAlias
                            else -> additionalUpperBoundsProvider.diagnostic
                        }
                        reporter.reportOn(argumentSource, factory, upperBound, argumentType.type, context)
                    }
                }
            }

            if (argumentType is ConeClassLikeType) {
                checkUpperBoundViolated(argumentTypeRef, argumentType, context, reporter, isIgnoreTypeParameters)
            }
        }
    }
}

fun ConeClassLikeType.fullyExpandedTypeWithSource(
    typeRef: FirTypeRef,
    useSiteSession: FirSession,
): ConeClassLikeType? {
    val typeRefAndSourcesForArguments = extractArgumentsTypeRefAndSource(typeRef) ?: return null

    // Add source information to arguments of non-expanded type, which is preserved during expansion.
    val typeArguments = typeArguments.mapIndexed { i, projection ->
        // typeRefAndSourcesForArguments can have fewer elements than there are type arguments
        // because in FIR, inner types of generic outer types have the generic arguments of the outer type added to the end of their list
        // of type arguments but there is no source for them.
        val source = typeRefAndSourcesForArguments.elementAtOrNull(i) ?: return@mapIndexed projection
        projection.withSource(source)
    }.toTypedArray()

    return withArguments(typeArguments).fullyExpandedType(useSiteSession)
}

private class SourceAttribute(private val data: FirTypeRefSource) : ConeAttribute<SourceAttribute>() {
    val source: KtSourceElement? get() = data.source
    val typeRef: FirTypeRef? get() = data.typeRef

    override fun union(other: SourceAttribute?): SourceAttribute = other ?: this
    override fun intersect(other: SourceAttribute?): SourceAttribute = other ?: this
    override fun add(other: SourceAttribute?): SourceAttribute = other ?: this

    override fun isSubtypeOf(other: SourceAttribute?): Boolean = true

    override fun toString() = ""SourceAttribute: $data""

    override val key: KClass<out SourceAttribute>
        get() = SourceAttribute::class
    override val keepInInferredDeclarationType: Boolean
        get() = false
}

private val ConeAttributes.sourceAttribute: SourceAttribute? by ConeAttributes.attributeAccessor()

fun ConeTypeProjection.withSource(source: FirTypeRefSource?): ConeTypeProjection {
    return when {
        source == null || this !is ConeKotlinTypeProjection -> this
        else -> {
            // Prefer existing source information.
            val attributes = ConeAttributes.create(listOf(SourceAttribute(source))).add(type.attributes)
            replaceType(type.withAttributes(attributes))
        }
    }
}",interface FirPlatformUpperBoundsProvider : FirSessionComponent {
"//KT-1290 Method property in constructor causes NPE

class Foo<T>(val filter: (T) -> Boolean) {
    public fun bar(tee: T) : Boolean {
        return filter(tee);
    }
}

fun foo() = Foo({ i: Int -> i < 5 }).bar(2)

fun box() : String {
    if (!foo()) return ""fail""","return ""OK"""
"fun testReleaseCompilerAgainstPreReleaseLibrarySkipPrereleaseCheck() {
        doTestPreReleaseKotlinLibrary(K2JVMCompiler(), ""library"", tmpdir, ""-Xskip-prerelease-check"")
    }

    fun testReleaseCompilerAgainstPreReleaseLibraryJsSkipPrereleaseCheck() {
        doTestPreReleaseKotlinLibrary(K2JSCompiler(), ""library"", File(tmpdir, ""usage.js""), ""-Xskip-prerelease-check"")
    }

    fun testReleaseCompilerAgainstPreReleaseLibrarySkipMetadataVersionCheck() {
        doTestPreReleaseKotlinLibrary(K2JVMCompiler(), ""library"", tmpdir, ""-Xskip-metadata-version-check"")
    }

    fun testPreReleaseCompilerAgainstPreReleaseLibraryStableLanguageVersion() {
        withPreRelease {
            val library = compileLibrary(""library"")
            val someStableReleasedVersion = LanguageVersion.entries.first { it.isStable && it >= LanguageVersion.FIRST_NON_DEPRECATED }
            compileKotlin(
                ""source.kt"", tmpdir, listOf(library), K2JVMCompiler(),
                listOf(""-language-version"", someStableReleasedVersion.versionString)
            )

            checkPreReleaseness(File(tmpdir, ""usage/SourceKt.class""), shouldBePreRelease = false)
        }
    }

    fun testPreReleaseCompilerAgainstPreReleaseLibraryLatestStable() {
        withPreRelease {
            val library = compileLibrary(""library"")
            compileKotlin(
                ""source.kt"", tmpdir, listOf(library), K2JVMCompiler(),
                listOf(""-language-version"", LanguageVersion.LATEST_STABLE.versionString)
            )

            checkPreReleaseness(File(tmpdir, ""usage/SourceKt.class""), shouldBePreRelease = true)
        }
    }

    fun testReleaseCompilerAgainstPreReleaseLibrarySkipPrereleaseCheckAllowUnstableDependencies() {
        doTestPreReleaseKotlinLibrary(K2JVMCompiler(), ""library"", tmpdir, ""-Xallow-unstable-dependencies"", ""-Xskip-prerelease-check"")
    }

    // KT-61051 K1/K2 difference on extension functions with specific extension receiver types when compiling code that has itself as a dependency
    fun testDependencyOnItself() {
        val compiledLibrary = compileLibrary(""library"")
        compileKotlin(
            ""library/sample.kt"",
            output = tmpdir,
            classpath = listOf(compiledLibrary),
        )
    }

    fun testWrongMetadataVersion() {
        doTestKotlinLibraryWithWrongMetadataVersion(""library"", null)
    }

    // This test compiles a library with a ""future"" metadata version, then intentionally inserts some gibberish to the metadata, and tries
    // to compile something against this library. It emulates the scenario when a future Kotlin version has a completely different metadata
    // format -- so different that reading it as if it's the current (protobuf-based) format would most likely result in an exception.
    // Expected result is that the compiler does NOT try to read it, and instead reports incompatible version & unresolved reference errors.
    fun testWrongMetadataVersionBadMetadata() {
        doTestKotlinLibraryWithWrongMetadataVersion(""library"", { name, value ->
            if (JvmAnnotationNames.METADATA_DATA_FIELD_NAME == name) {
                @Suppress(""UNCHECKED_CAST"")
                val strings = value as Array<String>
                strings.map { string ->",String(string.toByteArray().map { x -> x xor 42 }.toTypedArray().toByteArray())
"* will use `ObjCFoo` instead of the class name `Foo`
 *
 */
context(KtAnalysisSession, KtObjCExportSession)
fun KtClassLikeSymbol.getObjCClassOrProtocolName(): ObjCExportClassOrProtocolName {
    val resolvedObjCNameAnnotation = resolveObjCNameAnnotation()

    return ObjCExportClassOrProtocolName(
        objCName = getObjCName(resolvedObjCNameAnnotation),
        swiftName = getSwiftName(resolvedObjCNameAnnotation)
    )
}

context(KtAnalysisSession, KtObjCExportSession)
private fun KtClassLikeSymbol.getObjCName(
    resolvedObjCNameAnnotation: KtResolvedObjCNameAnnotation? = resolveObjCNameAnnotation(),
): String {
    val objCName = (resolvedObjCNameAnnotation?.objCName ?: nameOrAnonymous.asString()).toValidObjCSwiftIdentifier()

    if (resolvedObjCNameAnnotation != null && resolvedObjCNameAnnotation.isExact) {
        return objCName
    }

    getContainingSymbol()?.let { it as? KtClassLikeSymbol }?.let { containingClass ->
        return containingClass.getObjCName() + objCName.capitalizeAsciiOnly()
    }

    return buildString {
        configuration.frameworkName?.let(::append)
        getObjCModuleNamePrefix()?.let(::append)
        append(objCName)
    }
}

context(KtAnalysisSession, KtObjCExportSession)
private fun KtClassLikeSymbol.getSwiftName(
    resolvedObjCNameAnnotation: KtResolvedObjCNameAnnotation? = resolveObjCNameAnnotation(),
): String {
    val swiftName = (resolvedObjCNameAnnotation?.swiftName ?: nameOrAnonymous.asString()).toValidObjCSwiftIdentifier()
    if (resolvedObjCNameAnnotation != null && resolvedObjCNameAnnotation.isExact) {
        return swiftName
    }

    getContainingSymbol()?.let { it as? KtClassLikeSymbol }?.let { containingClass ->
        val containingClassSwiftName = containingClass.getSwiftName()
        return buildString {
            if (canBeInnerSwift()) {
                append(containingClassSwiftName)
                if (""."" !in this && containingClass.canBeOuterSwift()) {
                    // AB -> AB.C
                    append(""."")
                    append(mangleSwiftNestedClassName(swiftName))
                } else {
                    // AB -> ABC
                    // A.B -> A.BC
                    append(swiftName.capitalizeAsciiOnly())
                }
            } else {
                append(containingClassSwiftName.replaceFirst(""."", """"))
                append(swiftName.capitalizeAsciiOnly())
            }
        }
    }

    return buildString {",getObjCModuleNamePrefix()?.let(::append)
"// !DIAGNOSTICS: -UNUSED_EXPRESSION
// SKIP_TXT

/*
 * KOTLIN DIAGNOSTICS SPEC TEST (NEGATIVE)
 *
 * SPEC VERSION: 0.1-435
 * MAIN LINK: expressions, when-expression, exhaustive-when-expressions -> paragraph 2 -> sentence 11
 * NUMBER: 3
 * DESCRIPTION: Non-exhaustive when using nullable enum values.
 * HELPERS: enumClasses
 */

// TESTCASE NUMBER: 1
fun case_1(value_1: EnumClass?): String = <!NO_ELSE_IN_WHEN!>when<!>(value_1) {
    EnumClass.EAST -> """"
    EnumClass.SOUTH -> """"
    EnumClass.NORTH -> """"
    EnumClass.WEST -> """"
}

// TESTCASE NUMBER: 2
fun case_2(value_1: EnumClass?): String = <!NO_ELSE_IN_WHEN!>when<!>(value_1) {
    EnumClass.EAST -> """"
    EnumClass.SOUTH -> """"
    EnumClass.NORTH -> """"
    null -> """"
}

// TESTCASE NUMBER: 3
fun case_3(value_1: EnumClass?): String = <!NO_ELSE_IN_WHEN!>when<!>(value_1) {
    EnumClass.EAST, null, EnumClass.SOUTH, EnumClass.NORTH -> """"
}

// TESTCASE NUMBER: 4
fun case_4(value_1: EnumClassSingle): Int = <!TYPE_MISMATCH!><!NO_ELSE_IN_WHEN!>when<!>(value_1) {}<!>

// TESTCASE NUMBER: 5
fun case_5(value_1: EnumClassSingle?): String = <!NO_ELSE_IN_WHEN!>when<!>(value_1) {
    EnumClassSingle.EVERYTHING -> """"
}

// TESTCASE NUMBER: 6
fun case_6(value_1: EnumClassSingle?): String = <!NO_ELSE_IN_WHEN!>when<!>(value_1) {","null -> """""
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.importsDumper

import com.intellij.openapi.project.Project
import kotlinx.serialization.internal.LinkedHashMapSerializer
import kotlinx.serialization.internal.StringSerializer
import kotlinx.serialization.json.Json",import kotlinx.serialization.json.JsonConfiguration
"// LAMBDAS: INDY
// TARGET_BACKEND: JVM_IR
// JVM_TARGET: 1.8
// WITH_STDLIB

// CHECK_BYTECODE_TEXT
// JVM_IR_TEMPLATES
// 14 java/lang/invoke/LambdaMetafactory


fun box(): String {
    var captureMe = 0

    fun () {} // 1
    fun (a: Any, b: Any, c: Any, d: Any, e: Any, f: Any, g: Any, h: Any, i: Any, j: Any, k: Any, l: Any, m: Any, n: Any, o: Any,
         p: Any, q: Any, r: Any, s: Any, t: Any, u: Any, v: Any) = ""just enough"" // 2
    fun () = ++captureMe // 3
    fun (vararg x: Int) = x // 4

    fun Any.() {} // 5
    fun Any.(a: Any, b: Any, c: Any, d: Any, e: Any, f: Any, g: Any, h: Any, i: Any, j: Any, k: Any, l: Any, m: Any, n: Any, o: Any,
             p: Any, q: Any, r: Any, s: Any, t: Any, u: Any) = ""just enough"" // 6
    fun () = ++captureMe // 7
    fun Any.(vararg x: Int) = x // 8


    {} // 9
    { a: Any, b: Any, c: Any, d: Any, e: Any, f: Any, g: Any, h: Any, i: Any, j: Any, k: Any, l: Any, m: Any, n: Any, o: Any,
      p: Any, q: Any, r: Any, s: Any, t: Any, u: Any, v: Any -> ""just enough"" } // 10
    { ++captureMe } // 11


    fun local1() {}
    { local1() } // 12","fun local2(a: Any, b: Any, c: Any, d: Any, e: Any, f: Any, g: Any, h: Any, i: Any, j: Any, k: Any, l: Any, m: Any, n: Any, o: Any,"
"// TARGET_BACKEND: WASM
// USE_NEW_EXCEPTION_HANDLING_PROPOSAL
// TODO: remove the test when KT-66906 will be resolved
class MyString {
    var s = """"
    operator fun plus(x : String) : MyString {
        s += x
        return this
    }

    override fun toString(): String {
        return s
    }
}


fun test1() : MyString {
    var r = MyString()
    try {
        r + ""Try1""

        try {
            r + ""Try2""
            if (true)
                return r
        } finally {
            r + ""Finally2""
            if (true) {",return r
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir

import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.resolve.calls.AbstractCallInfo
import org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol
import org.jetbrains.kotlin.fir.types.*
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.name.SpecialNames.DEFAULT_NAME_FOR_COMPANION_OBJECT
import org.jetbrains.kotlin.name.StandardClassIds
import org.jetbrains.kotlin.utils.SmartList

abstract class FirLookupTrackerComponent : FirSessionComponent {

    abstract fun recordLookup(name: String, inScopes: Iterable<String>, source: KtSourceElement?, fileSource: KtSourceElement?)

    abstract fun recordLookup(name: String, inScope: String, source: KtSourceElement?, fileSource: KtSourceElement?)
}

fun FirLookupTrackerComponent.recordCallLookup(callInfo: AbstractCallInfo, inType: ConeKotlinType) {
    val classId = inType.classId ?: return
    if (classId.isLocal) return",val scopes = SmartList(classId.asFqNameString())
"when (this) {
                is List -> return if (size == 1) this[0] else null
                else -> {
                    val iterator = iterator()
                    if (!iterator.hasNext())
                        return null
                    val single = iterator.next()
                    if (iterator.hasNext())
                        return null
                    return single
                }
            }
            """"""
        }
        body(Sequences) {
            """"""
            val iterator = iterator()
            if (!iterator.hasNext())
                return null
            val single = iterator.next()
            if (iterator.hasNext())
                return null
            return single
            """"""
        }
        body(CharSequences) {
            """"""
            return if (length == 1) this[0] else null
            """"""
        }
        body(Lists, ArraysOfObjects, ArraysOfPrimitives, ArraysOfUnsigned) {
            """"""
            return if (size == 1) this[0] else null
            """"""
        }
    }

    val f_single_predicate = fn(""single(predicate: (T) -> Boolean)"") {
        includeDefault()
        include(CharSequences, ArraysOfUnsigned)
    } builder {
        inline()
        specialFor(ArraysOfUnsigned) { inlineOnly() }

        doc { ""Returns the single ${f.element} matching the given [predicate], or throws exception if there is no or more than one matching ${f.element}."" }
        returns(""T"")

        body {
            """"""
            var single: T? = null
            var found = false
            for (element in this) {
                if (predicate(element)) {
                    if (found) throw IllegalArgumentException(""${f.doc.collection.capitalize()} contains more than one matching element."")
                    single = element
                    found = true
                }
            }
            if (!found) throw NoSuchElementException(""${f.doc.collection.capitalize()} contains no ${f.doc.element} matching the predicate."")
            @Suppress(""UNCHECKED_CAST"")
            return single as T
            """"""
        }
    }","val f_singleOrNull_predicate = fn(""singleOrNull(predicate: (T) -> Boolean)"") {"
"fun Leaf() {}

            fun Example(foo: Foo) {
                foo.setContent { Leaf() }
            }
        """"""
        )
    }

    @Test
    fun testComposableReporting024x() {
        check(
            """"""
            import androidx.compose.runtime.*

            var x: (@Composable () -> Unit)? = null

            fun <!COMPOSABLE_EXPECTED!>Example<!>(content: @Composable () -> Unit) {
                x = content
                <!COMPOSABLE_INVOCATION!>content<!>()
            }
        """"""
        )
    }

    @Test
    fun testComposableReporting025() {
        check(
            """"""
            import androidx.compose.runtime.*;

            @Composable
            fun Leaf() {}

            @Composable
            fun foo() {
                listOf(1,2,3,4,5).forEach { Leaf() }
            }
        """"""
        )
    }

    @Test
    fun testComposableReporting026() {
        check(
            """"""
            import androidx.compose.runtime.*;

            @Composable
            fun Leaf() {}

            @Composable
            fun Group(content: @Composable () -> Unit) { content() }

            @Composable
            fun foo() {
                Group {
                    Leaf()
                }
            }
        """"""
        )
    }

    @Test",fun testComposableReporting027() {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin.mpp.compilationImpl

import org.jetbrains.kotlin.gradle.plugin.Kotlin2JvmSourceSetProcessor
import org.jetbrains.kotlin.gradle.plugin.KotlinCommonSourceSetProcessor
import org.jetbrains.kotlin.gradle.plugin.KotlinCompilationInfo
import org.jetbrains.kotlin.gradle.plugin.KotlinJsIrSourceSetProcessor
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinCommonCompilation
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinJvmCompilation
import org.jetbrains.kotlin.gradle.targets.js.ir.KotlinJsIrCompilation
import org.jetbrains.kotlin.gradle.tasks.KotlinTasksProvider

internal val KotlinCompilationProcessorSideEffect = KotlinCompilationSideEffect { compilation ->
    val processor = when (compilation) {","is KotlinCommonCompilation -> KotlinCommonSourceSetProcessor(KotlinCompilationInfo(compilation), KotlinTasksProvider())"
"* If enabled - the evaluator will try to get imported script from a shared container
 * only create/evaluate instances if not found, and evaluator will put newly created instances into the container
 * This allows to have a single instance of the script if it is imported several times via different import paths.
 */
val ScriptEvaluationConfigurationKeys.scriptsInstancesSharing by PropertiesCollection.key<Boolean>(false)

/**
 * Scripting host configuration
 */
val ScriptEvaluationConfigurationKeys.hostConfiguration by PropertiesCollection.key<ScriptingHostConfiguration>(isTransient = true)

/**
 * The callback that will be called on the script compilation immediately before starting the compilation
 */
val ScriptEvaluationConfigurationKeys.refineConfigurationBeforeEvaluate by PropertiesCollection.key<List<RefineEvaluationConfigurationData>>(isTransient = true)

interface ScriptExecutionWrapper<T> {
    fun invoke(block: () -> T): T
}

/**
 *  An optional user-defined wrapper which is called with the code that actually executes script body
 */
val ScriptEvaluationConfigurationKeys.scriptExecutionWrapper by PropertiesCollection.key<ScriptExecutionWrapper<*>>(isTransient = true)

/**
 * A helper to enable passing lambda directly to the scriptExecutionWrapper ""keyword""
 */
fun <T> ScriptEvaluationConfiguration.Builder.scriptExecutionWrapper(wrapper: (() -> T) -> T) {
    ScriptEvaluationConfiguration.scriptExecutionWrapper.put(object : ScriptExecutionWrapper<T> {
        override fun invoke(block: () -> T): T = wrapper(block)
    })
}

/**
 * A helper to enable scriptsInstancesSharingMap with default implementation
 */
fun ScriptEvaluationConfiguration.Builder.enableScriptsInstancesSharing() {
    this {
        scriptsInstancesSharing(true)
    }
}

/**
 * A helper to enable passing lambda directly to the refinement ""keyword""
 */
fun ScriptEvaluationConfiguration.Builder.refineConfigurationBeforeEvaluate(handler: RefineScriptEvaluationConfigurationHandler) {
    ScriptEvaluationConfiguration.refineConfigurationBeforeEvaluate.append(RefineEvaluationConfigurationData(handler))
}

/**
 * The refinement callback function signature
 */
typealias RefineScriptEvaluationConfigurationHandler =
            (ScriptEvaluationConfigurationRefinementContext) -> ResultWithDiagnostics<ScriptEvaluationConfiguration>

data class RefineEvaluationConfigurationData(
    val handler: RefineScriptEvaluationConfigurationHandler
) : Serializable {
    companion object { private const val serialVersionUID: Long = 1L }
}

fun ScriptEvaluationConfiguration.refineBeforeEvaluation(
    script: CompiledScript,
    contextData: ScriptEvaluationContextData? = null",): ResultWithDiagnostics<ScriptEvaluationConfiguration> {
"// !LANGUAGE: -ProhibitTypeParametersInClassLiteralsInAnnotationArguments

import kotlin.reflect.KClass

annotation class Ann(vararg val k: KClass<*>)

inline val <reified T> T.test",get() = @Ann(
"// WITH_STDLIB
// WORKS_WHEN_VALUE_CLASS
// LANGUAGE: +ValueClasses

OPTIONAL_JVM_INLINE_ANNOTATION
value class A(val x: String)

fun isNullVacuousLeft(s: A) = s == null
fun isNullVacuousRight(s: A) = null == s",fun isNullLeft(s: A?) = s == null
"if (<!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.equals(null)
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.propT
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.propAny
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.propNullableT
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.propNullableAny
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.funT()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.funAny()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.funNullableT()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.funNullableAny()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.equals(null)
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.propT
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.propAny
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>.propNullableT
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>.propNullableAny
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.funT()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.funAny()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>.funNullableT()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>.funNullableAny()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>

        w = if (<!SENSELESS_COMPARISON!>null != null<!>) 10 else null
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.equals(null)
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propT
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propAny
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableT
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableAny
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funT()
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funAny()
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableT()
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableAny()
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.equals(null)
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propT
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propAny
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableT
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableAny
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funT()
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funAny()
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableT()
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableAny()
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.equals(null)
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propT
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propAny
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableT
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableAny
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funT()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funAny()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableT()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableAny()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!>this.w<!>.equals(null)
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!>this.w<!>.propT
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!>this.w<!>.propAny
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>this.w<!>.propNullableT
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>this.w<!>.propNullableAny
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!>this.w<!>.funT()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!>this.w<!>.funAny()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>this.w<!>.funNullableT()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>this.w<!>.funNullableAny()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>this.w<!>

        s = null","<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Nothing?"")!>s<!>.hashCode()"
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.cfg.pseudocode

import org.jetbrains.kotlin.cfg.pseudocode.instructions.Instruction
import org.jetbrains.kotlin.cfg.pseudocode.instructions.KtElementInstruction
import org.jetbrains.kotlin.cfg.pseudocode.instructions.special.LocalFunctionDeclarationInstruction
import org.jetbrains.kotlin.cfg.pseudocode.instructions.special.SubroutineEnterInstruction
import org.jetbrains.kotlin.cfg.pseudocode.instructions.special.SubroutineExitInstruction
import org.jetbrains.kotlin.cfg.pseudocode.instructions.special.SubroutineSinkInstruction
import org.jetbrains.kotlin.psi.KtElement

interface Pseudocode {
    val correspondingElement: KtElement

    val parent: Pseudocode?

    val localDeclarations: Set<LocalFunctionDeclarationInstruction>

    val instructions: List<Instruction>

    val reversedInstructions: List<Instruction>

    val instructionsIncludingDeadCode: List<Instruction>

    val exitInstruction: SubroutineExitInstruction

    val errorInstruction: SubroutineExitInstruction",val sinkInstruction: SubroutineSinkInstruction
"enum class EnumerationBCB constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    ENTRY;
}

enum class EnumerationBCC constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    ENTRY1,
    ENTRY2;
}

enum class EnumerationBCD constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    ENTRY1,
    ENTRY2();
}

enum class EnumerationBCE constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    ENTRY1 { override fun abstractFunc() { TODO(""Not yet implemented"") } },
    ENTRY2() { override fun abstractFunc() { TODO(""Not yet implemented"") } };
    abstract fun abstractFunc()
}

enum class EnumerationBDA constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY;<!>
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
}

enum class EnumerationBDB constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY1,<!>
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY2;<!>
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
}

enum class EnumerationBDC constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY1,<!>
    ENTRY2();
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
}

enum class EnumerationBDD constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY1 { override fun abstractFunc() { TODO(""Not yet implemented"") } },<!>
    ENTRY2() { override fun abstractFunc() { TODO(""Not yet implemented"") } };
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
    abstract fun abstractFunc()
}

enum class EnumerationBEA constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY;<!>
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
    constructor() : this(UserKlass(), UserKlass())
}

enum class EnumerationBEB constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY1,<!>
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY2;<!>
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
    constructor() : this(UserKlass(), UserKlass())
}

enum class EnumerationBEC constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY1,<!>
    ENTRY2();
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
    constructor() : this(UserKlass(), UserKlass())
}","enum class EnumerationBED constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {"
"* DESCRIPTION: Raw data flow analysis test
 * HELPERS: classes, objects, typealiases, functions, enumClasses, interfaces, sealedClasses
 */

/*
 * TESTCASE NUMBER: 1
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-24901
 */
fun case_1(x: String?) {
    when {
        x == null -> return
    }
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>.length
}

// TESTCASE NUMBER: 2
fun case_2(x: String?) {
    when {
        x == null -> return
        else -> println(1)
    }
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>.length
}

/*
 * TESTCASE NUMBER: 3
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-24901
 */
fun case_3(x: String?) {
    when (x) {
        null -> return
    }
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>.length
}

// TESTCASE NUMBER: 4
fun case_4(x: String?) {
    when (x) {
        null -> return
        else -> println(1)
    }
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>.length
}

// TESTCASE NUMBER: 5
fun case_5(x: String?) {
    when (x) {
        null -> throw Exception()
        else -> println(1)
    }
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>.length
}

/*
 * TESTCASE NUMBER: 6
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-24901
 */",fun case_6(x: String?) {
"// MEMBER_CLASS_FILTER: org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol
package second",@Target(AnnotationTarget.TYPE)
"// Super calls to Throwable properties are not supported
// IGNORE_BACKEND: JS_IR
// IGNORE_BACKEND: JS_IR_ES6

open class Base(message: String? = null, cause: Throwable? = null) : Throwable(message, cause)

open class Base2(message: String? = null, cause: Throwable? = null): Base(message, cause)","open class Override(message: String? = null, cause: Throwable? = null) : Base2(message, cause) {"
"if (isDebugEnabled) messageCollector else MessageCollector.NONE
        val connection =
            metrics.measure(GradleBuildTime.CONNECT_TO_DAEMON) {
                GradleCompilerRunner.getDaemonConnectionImpl(
                    config.projectFiles.clientIsAliveFlagFile,
                    config.projectFiles.sessionFlagFile,
                    config.compilerFullClasspath,
                    daemonMessageCollector,
                    isDebugEnabled = isDebugEnabled,
                    daemonJvmArgs = config.compilerExecutionSettings.daemonJvmArgs
                )
            } ?: throw RuntimeException(COULD_NOT_CONNECT_TO_DAEMON_MESSAGE) // TODO: Add root cause

        val (daemon, sessionId) = connection

        if (log.isDebugEnabled) {
            daemon.getDaemonJVMOptions().takeIf { it.isGood }?.let { jvmOpts ->
                log.debug(""Kotlin compile daemon JVM options: ${jvmOpts.get().mappers.flatMap { it.toArgs(""-"") }}"")
            }
        }

        val memoryUsageBeforeBuild = daemon.getUsedMemory(withGC = false).takeIf { it.isGood }?.get()

        val targetPlatform = when (config.compilerClassName) {
            KotlinCompilerClass.JVM -> CompileService.TargetPlatform.JVM
            KotlinCompilerClass.JS -> CompileService.TargetPlatform.JS
            KotlinCompilerClass.METADATA -> CompileService.TargetPlatform.METADATA
            else -> throw IllegalArgumentException(""Unknown compiler type ${config.compilerClassName}"")
        }
        val bufferingMessageCollector = GradleBufferingMessageCollector()
        val exitCode = try {
            val res = if (isIncremental) {
                incrementalCompilationWithDaemon(daemon, sessionId, targetPlatform, bufferingMessageCollector)
            } else {
                nonIncrementalCompilationWithDaemon(daemon, sessionId, targetPlatform, bufferingMessageCollector)
            }
            bufferingMessageCollector.flush(messageCollector)
            exitCodeFromProcessExitCode(log, res.get())
        } catch (e: Throwable) {
            bufferingMessageCollector.flush(messageCollector)
            wrapAndRethrowCompilationException(KotlinCompilerExecutionStrategy.DAEMON, e)
        } finally {
            val memoryUsageAfterBuild = runCatching { daemon.getUsedMemory(withGC = false).takeIf { it.isGood }?.get() }.getOrNull()

            if (memoryUsageAfterBuild == null || memoryUsageBeforeBuild == null) {
                log.debug(""Unable to calculate memory usage"")
            } else {
                metrics.addMetric(GradleBuildPerformanceMetric.DAEMON_INCREASED_MEMORY, memoryUsageAfterBuild - memoryUsageBeforeBuild)
                metrics.addMetric(GradleBuildPerformanceMetric.DAEMON_MEMORY_USAGE, memoryUsageAfterBuild)
            }


            // todo: can we clear cache on the end of session?
            // often source of the NoSuchObjectException and UnmarshalException, probably caused by the failed/crashed/exited daemon
            // TODO: implement a proper logic to avoid remote calls in such cases
            try {
                metrics.measure(GradleBuildTime.CLEAR_JAR_CACHE) {
                    // releasing compile session implies clearing the jar cache
                    daemon.releaseCompileSession(sessionId)
                }
            } catch (e: RemoteException) {
                log.warn(""Unable to release compile session, maybe daemon is already down: $e"")
            }
        }
        log.logFinish(KotlinCompilerExecutionStrategy.DAEMON)",return exitCode
"private fun copyDefaultArgumentsFromExpectToActual(declaration: IrDeclaration) {
        declaration.acceptVoid(object : IrElementVisitorVoid {
            override fun visitElement(element: IrElement) {
                element.acceptChildrenVoid(this)
            }

            override fun visitValueParameter(declaration: IrValueParameter) {
                super.visitValueParameter(declaration)

                val defaultValue = declaration.defaultValue ?: return
                val function = declaration.parent as IrFunction

                val index = declaration.index
                assert(function.valueParameters[index] == declaration)

                if (function is IrConstructor && OptionalAnnotationUtil.isOptionalAnnotationClass(function.descriptor.constructedClass)) {
                    return
                }

                val actualForExpected = function.findActualForExpected()
                actualForExpected.valueParameters[index].defaultValue =
                        irModule.irBuiltins.irFactory.createExpressionBody(
                                defaultValue.startOffset, defaultValue.endOffset,
                                defaultValue.expression.remapExpectValueSymbols().patchDeclarationParents(actualForExpected)
                        )
            }
        })
    }

    private inline fun <reified T : IrFunction> T.findActualForExpected(): T =
            moduleIndex.functions[descriptor.findActualForExpect()] as T

    private fun IrProperty.findActualForExpected(): IrProperty =
            moduleIndex.properties[descriptor.findActualForExpect()]!!

    private fun IrClass.findActualForExpected(): IrClass =
            moduleIndex.classes[descriptor.findActualForExpect()]!!

    private fun IrEnumEntry.findActualForExpected(): IrEnumEntry =
            moduleIndex.enumEntries[descriptor.findActualForExpect()]!!

    private inline fun <reified T : MemberDescriptor> T.findActualForExpect(): T {
        if (!this.isExpect) error(this)
        return (findCompatibleActualsForExpected(module).singleOrNull() ?: error(this)) as T
    }

    private fun IrExpression.remapExpectValueSymbols(): IrExpression {
        class SymbolRemapper : DeepCopySymbolRemapper() {
            override fun getReferencedClass(symbol: IrClassSymbol) =
                    if (symbol.descriptor.isExpect)
                        symbol.owner.findActualForExpected().symbol
                    else super.getReferencedClass(symbol)

            override fun getReferencedClassifier(symbol: IrClassifierSymbol): IrClassifierSymbol = when (symbol) {
                is IrClassSymbol -> getReferencedClass(symbol)
                is IrTypeParameterSymbol -> remapExpectTypeParameter(symbol).symbol
                is IrScriptSymbol -> symbol.unexpectedSymbolKind<IrClassifierSymbol>()
            }

            override fun getReferencedConstructor(symbol: IrConstructorSymbol) =
                    if (symbol.descriptor.isExpect)
                        symbol.owner.findActualForExpected().symbol
                    else super.getReferencedConstructor(symbol)",override fun getReferencedFunction(symbol: IrFunctionSymbol): IrFunctionSymbol = when (symbol) {
"fun testEarlyReturnFromCrossInlinedLambda() = verifyGoldenComposeIrTransform(
        source = """"""
            import androidx.compose.runtime.*

            @Composable
            private fun Test(param: String?) {
                Dialog {
                    if (false) Test(param)
                }
            }
        """""",
        extra = """"""
            import androidx.compose.runtime.*

            @Composable
            internal inline fun Dialog(crossinline block: @Composable () -> Unit) {}
        """""".trimIndent(),
    )

    @Test
    fun testEarlyReturnFromWhenStatement() = verifyGoldenComposeIrTransform(
        source = """"""
            import androidx.compose.runtime.*

            @Composable
            private fun Test(param: String?) {
                val state = remember { mutableStateOf(false) }
                when (state.value) {
                    true -> return Text(text = ""true"")
                    else -> Text(text = ""false"")
                }
            }
        """""",
        extra = """"""
            import androidx.compose.runtime.*

            @Composable fun Text(text: String) {}
        """"""
    )

    @Test
    fun testComposableInAnonymousObjectDelegate() = verifyGoldenComposeIrTransform(
        """"""
            import androidx.compose.runtime.Composable

                interface A

                interface B {
                    val property: A @Composable get() = TODO()
                }

                @Composable fun Test(b: B) {
                    val a = object : A by b.property {}
                    println(a)
                }
        """"""
    )

    @Test
    fun testReturnNull() = verifyGoldenComposeIrTransform(
        source = """"""
            import androidx.compose.runtime.*

            @Composable
            fun Test(): String? {",return null
"private fun IrAnnotationContainer.hasNoLiveLiteralsAnnotation(): Boolean = annotations.any {
        it.symbol.owner == NoLiveLiteralsAnnotation.owner.primaryConstructor
    }

    private fun <T> enter(key: String, block: () -> T) = keyVisitor.enter(key, block)
    private fun <T> siblings(key: String, block: () -> T) = keyVisitor.siblings(key, block)
    private fun <T> siblings(block: () -> T) = keyVisitor.siblings(block)
    private var liveLiteralsClass: IrClass? = null
    private var liveLiteralsEnabledSymbol: IrSimpleFunctionSymbol? = null
    private var currentFile: IrFile? = null

    private fun irGetLiveLiteralsClass(startOffset: Int, endOffset: Int): IrExpression {
        return IrGetObjectValueImpl(
            startOffset = startOffset,
            endOffset = endOffset,
            type = liveLiteralsClass!!.defaultType,
            symbol = liveLiteralsClass!!.symbol
        )
    }

    private fun Name.asJvmFriendlyString(): String {
        return if (!isSpecial) identifier
        else asString().replace('<', '$').replace('>', '$').replace(' ', '-')
    }

    private fun irLiveLiteralInfoAnnotation(
        key: String,
        offset: Int
    ): IrConstructorCall = IrConstructorCallImpl(
        UNDEFINED_OFFSET,
        UNDEFINED_OFFSET,
        liveLiteralInfoAnnotation.defaultType,
        liveLiteralInfoAnnotation.constructors.single(),
        0,
        0,
        2
    ).apply {
        putValueArgument(0, irConst(key))
        putValueArgument(1, irConst(offset))
    }

    private fun irLiveLiteralFileInfoAnnotation(
        file: String
    ): IrConstructorCall = IrConstructorCallImpl(
        UNDEFINED_OFFSET,
        UNDEFINED_OFFSET,
        liveLiteralFileInfoAnnotation.defaultType,
        liveLiteralFileInfoAnnotation.constructors.single(),
        0,
        0,
        1
    ).apply {
        putValueArgument(0, irConst(file))
    }

    @OptIn(IrImplementationDetail::class)
    private fun irLiveLiteralGetter(
        key: String,
        literalValue: IrExpression,
        literalType: IrType,
        startOffset: Int
    ): IrSimpleFunction {
        val clazz = liveLiteralsClass!!
        val stateType = stateInterface.owner.typeWith(literalType).makeNullable()","val stateGetValue = stateInterface.getPropertyGetter(""value"")!!"
"name: Name,
    internal val scriptInfo: KtScriptInfo
) : ScriptDescriptor, LazyClassDescriptor(
    resolveSession,
    containingDeclaration,
    name,
    scriptInfo,
    /* isExternal = */ false
) {
    init {
        resolveSession.trace.record(BindingContext.SCRIPT, scriptInfo.script, this)
    }

    private val _resultValue: () -> ReplResultPropertyDescriptor? = resolveSession.storageManager.createNullableLazyValue {
        val expression = scriptInfo.script
            .getChildOfType<KtBlockExpression>()
            ?.getChildrenOfType<KtScriptInitializer>()?.lastOrNull()
            ?.getChildOfType<KtExpression>()

        val type = expression?.let {
            resolveSession.trace.bindingContext.getType(it)
        }

        if (type != null && !type.isUnit() && !type.isNothing()) {
            resultFieldName()?.let {
                ReplResultPropertyDescriptor(
                    it,
                    type,
                    this.thisAsReceiverParameter,
                    this,
                    expression.toSourceElement()
                )
            }
        } else null
    }

    override fun getResultValue(): ReplResultPropertyDescriptor? = _resultValue()

    fun resultFieldName(): Name? {
        // TODO: implement robust REPL/script selection
        val replSnippetId =
            scriptInfo.script.getUserData(ScriptPriorities.PRIORITY_KEY)?.toString()
        val identifier = if (replSnippetId != null) {
            // assuming repl
            scriptCompilationConfiguration()[ScriptCompilationConfiguration.repl.resultFieldPrefix]?.takeIf { it.isNotBlank() }?.let {
                ""$it$replSnippetId""
            }
        } else {
            scriptCompilationConfiguration()[ScriptCompilationConfiguration.resultField]?.takeIf { it.isNotBlank() }
        }
        return identifier?.let { Name.identifier(it) }
    }

    private val sourceElement = scriptInfo.script.toSourceElement()

    override fun getSource() = sourceElement

    private val priority: Int = ScriptPriorities.getScriptPriority(scriptInfo.script)
    private val isReplScript: Boolean = ScriptPriorities.isReplScript(scriptInfo.script)

    override fun getPriority() = priority

    val scriptCompilationConfiguration: () -> ScriptCompilationConfiguration = resolveSession.storageManager.createLazyValue {
        run {
            val containingFile = scriptInfo.script.containingKtFile",val provider = ScriptDependenciesProvider.getInstance(containingFile.project)
"}

        if (!isLocalDelegatedProperty) {
            generateAccessors()
        }
    }

    private fun generateConstructor() {
        generateMethod(""property reference init"", 0, constructor) {
            val shouldHaveBoundReferenceReceiver = closure.isForBoundCallableReference()
            val receiverIndexAndFieldInfo = generateClosureFieldsInitializationFromParameters(closure, constructorArgs)

            load(0, OBJECT_TYPE)
            val superCtorArgTypes = mutableListOf<Type>()
            if (receiverIndexAndFieldInfo != null) {
                val (receiverIndex, receiverFieldInfo) = receiverIndexAndFieldInfo
                loadBoundReferenceReceiverParameter(receiverIndex, receiverFieldInfo.fieldType, receiverFieldInfo.fieldKotlinType)
                superCtorArgTypes.add(OBJECT_TYPE)
            } else {
                assert(!shouldHaveBoundReferenceReceiver) { ""No bound reference receiver in constructor parameters: $constructorArgs"" }
            }

            if (isOptimizedPropertyReferenceSupertype(superAsmType)) {
                generateCallableReferenceDeclarationContainerClass(this, target, state)
                aconst(target.name.asString())
                generatePropertyReferenceSignature(this, target, state)
                aconst(getCallableReferenceTopLevelFlag(target))
                superCtorArgTypes.add(JAVA_CLASS_TYPE)
                superCtorArgTypes.add(JAVA_STRING_TYPE)
                superCtorArgTypes.add(JAVA_STRING_TYPE)
                superCtorArgTypes.add(Type.INT_TYPE)
            }

            invokespecial(
                superAsmType.internalName, ""<init>"",
                Type.getMethodDescriptor(Type.VOID_TYPE, *superCtorArgTypes.toTypedArray()), false
            )
        }
    }

    private fun generateAccessors() {
        val getFunction = findGetFunction(localVariableDescriptorForReference)
        val getImpl = createFakeOpenDescriptor(getFunction, classDescriptor)
        functionCodegen.generateMethod(
            JvmDeclarationOrigin.NO_ORIGIN,
            getImpl,
            PropertyReferenceGenerationStrategy(
                true,
                getFunction,
                target,
                asmType,
                boundReceiverJvmKotlinType,
                element,
                state,
                false
            )
        )

        if (!ReflectionTypes.isNumberedKMutablePropertyType(localVariableDescriptorForReference.type)) return
        val setFunction = localVariableDescriptorForReference.type.memberScope.getContributedFunctions(
            OperatorNameConventions.SET,
            NoLookupLocation.FROM_BACKEND
        ).single()
        val setImpl = createFakeOpenDescriptor(setFunction, classDescriptor)
        functionCodegen.generateMethod(","JvmDeclarationOrigin.NO_ORIGIN,"
"/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.native.interop.gen

import org.jetbrains.kotlin.konan.library.KonanLibrary
import org.jetbrains.kotlin.native.interop.indexer.*

interface Imports {
    fun getPackage(location: Location): String?

    fun isImported(headerId: HeaderId): Boolean
}


class PackageInfo(val name: String, val library: KonanLibrary)

class ImportsImpl(internal val headerIdToPackage: Map<HeaderId, PackageInfo>) : Imports {

    override fun getPackage(location: Location): String? {
        val packageInfo = headerIdToPackage[location.headerId]
                ?: return null
        accessedLibraries += packageInfo.library
        return packageInfo.name
    }

    override fun isImported(headerId: HeaderId) =
            headerId in headerIdToPackage

    private val accessedLibraries = mutableSetOf<KonanLibrary>()

    val requiredLibraries: Set<KonanLibrary>
        get() = accessedLibraries.toSet()
}

class HeaderInclusionPolicyImpl(
        private val nameGlobs: List<String>,
        private val excludeGlobs: List<String>,",) : HeaderInclusionPolicy {
"}

    protected abstract fun buildParametersForList(): List<PsiParameter>

    private val typeParamsList: PsiTypeParameterList? by lazyPub { buildTypeParameterList() }

    protected abstract fun buildTypeParameterList(): PsiTypeParameterList?

    override fun accept(visitor: PsiElementVisitor) {
        if (visitor is JavaElementVisitor) {
            visitor.visitMethod(this)
        } else {
            visitor.visitElement(this)
        }
    }

    override val isMangled: Boolean get() = checkIsMangled()

    override fun setName(name: String): PsiElement? {
        val jvmNameAnnotation = modifierList.findAnnotation(JvmFileClassUtil.JVM_NAME.asString())?.unwrapped as? KtAnnotationEntry
        val demangledName = (if (isMangled) demangleInternalName(name) else null) ?: name
        val newNameForOrigin = propertyNameByAccessor(demangledName, this) ?: demangledName
        if (newNameForOrigin == kotlinOrigin?.name) {
            jvmNameAnnotation?.delete()
            return this
        }

        val nameExpression = jvmNameAnnotation?.let { JvmFileClassUtil.getLiteralStringEntryFromAnnotation(it) }
        if (nameExpression != null) {
            nameExpression.replace(KtPsiFactory(project).createLiteralStringTemplateEntry(name))
        } else {
            val toRename = kotlinOrigin as? PsiNamedElement ?: cannotModify()
            toRename.setName(newNameForOrigin)
        }

        return this
    }

    override fun delete() {
        kotlinOrigin?.let {
            if (it.isValid) {
                it.delete()
            }
        } ?: cannotModify()
    }

    abstract override fun getModifierList(): PsiModifierList

    override fun getParameterList() = paramsList

    override fun getTypeParameterList() = typeParamsList

    override fun getTypeParameters(): Array<PsiTypeParameter> =
        typeParameterList?.typeParameters ?: PsiTypeParameter.EMPTY_ARRAY

    override fun hasTypeParameters() = typeParameters.isNotEmpty()

    abstract override fun getSignature(substitutor: PsiSubstitutor): MethodSignature

    override fun processDeclarations(
        processor: PsiScopeProcessor,
        state: ResolveState,
        lastParent: PsiElement?,
        place: PsiElement
    ): Boolean {","return typeParameters.all { processor.execute(it, state) }"
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.checkers.type

import org.jetbrains.kotlin.config.LanguageFeature
import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget
import org.jetbrains.kotlin.descriptors.annotations.KotlinTarget
import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.getAllowedAnnotationTargets
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors
import org.jetbrains.kotlin.fir.declarations.toAnnotationClassId
import org.jetbrains.kotlin.fir.types.FirResolvedTypeRef
import org.jetbrains.kotlin.fir.types.FirTypeRef
import org.jetbrains.kotlin.fir.types.isSomeFunctionType
import org.jetbrains.kotlin.name.StandardClassIds

object FirTypeAnnotationChecker : FirTypeRefChecker(MppCheckerKind.Common) {
    override fun check(typeRef: FirTypeRef, context: CheckerContext, reporter: DiagnosticReporter) {
        if (typeRef !is FirResolvedTypeRef) return

        for (annotation in typeRef.annotations) {
            if (annotation.source == null) continue
            val useSiteTarget = annotation.useSiteTarget
            val annotationTargets = annotation.getAllowedAnnotationTargets(context.session)

            // Annotations like `@receiver:` go
            // into FirReceiverParameter, not FirTypeRef
            if (useSiteTarget != null) {
                reporter.reportOn(
                    annotation.source, FirErrors.WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET,
                    ""type usage"", useSiteTarget.renderName, context
                )
            } else if (KotlinTarget.TYPE !in annotationTargets) {
                reporter.reportOn(annotation.source, FirErrors.WRONG_ANNOTATION_TARGET, ""type usage"", context)
            }
            if (annotation.toAnnotationClassId(context.session) == StandardClassIds.Annotations.ExtensionFunctionType) {
                if (!typeRef.type.isSomeFunctionType(context.session)) {
                    if (context.languageVersionSettings.supportsFeature(LanguageFeature.ForbidExtensionFunctionTypeOnNonFunctionTypes)) {
                        reporter.reportOn(annotation.source, FirErrors.WRONG_EXTENSION_FUNCTION_TYPE, context)
                    } else {
                        reporter.reportOn(annotation.source, FirErrors.WRONG_EXTENSION_FUNCTION_TYPE_WARNING, context)
                    }

                } else if (typeRef.type.typeArguments.size <= 1) {","reporter.reportOn(annotation.source, FirErrors.WRONG_EXTENSION_FUNCTION_TYPE, context)"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.resolve.transformers.plugin

import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.containingClassLookupTag
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.expressions.FirAnnotationCall
import org.jetbrains.kotlin.fir.expressions.FirErrorAnnotationCall
import org.jetbrains.kotlin.fir.expressions.FirPropertyAccessExpression
import org.jetbrains.kotlin.fir.expressions.FirQualifiedAccessExpression
import org.jetbrains.kotlin.fir.expressions.FirResolvedQualifier
import org.jetbrains.kotlin.fir.expressions.FirStatement
import org.jetbrains.kotlin.fir.expressions.builder.buildPropertyAccessExpression
import org.jetbrains.kotlin.fir.references.FirResolvedNamedReference
import org.jetbrains.kotlin.fir.references.builder.buildErrorNamedReference
import org.jetbrains.kotlin.fir.references.builder.buildSimpleNamedReference
import org.jetbrains.kotlin.fir.references.toResolvedBaseSymbol
import org.jetbrains.kotlin.fir.resolve.ResolutionMode
import org.jetbrains.kotlin.fir.resolve.ScopeSession
import org.jetbrains.kotlin.fir.resolve.diagnostics.ConeAmbiguouslyResolvedAnnotationArgument
import org.jetbrains.kotlin.fir.resolve.transformers.ReturnTypeCalculator
import org.jetbrains.kotlin.fir.resolve.transformers.ReturnTypeCalculatorForFullBodyResolve
import org.jetbrains.kotlin.fir.resolve.transformers.body.resolve.*
import org.jetbrains.kotlin.fir.symbols.impl.FirEnumEntrySymbol
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.StandardClassIds
import org.jetbrains.kotlin.util.PrivateForInline

open class FirAnnotationArgumentsTransformer(
    session: FirSession,
    scopeSession: ScopeSession,
    resolvePhase: FirResolvePhase,
    outerBodyResolveContext: BodyResolveContext? = null,
    returnTypeCalculator: ReturnTypeCalculator = ReturnTypeCalculatorForFullBodyResolve.Default,
) : FirAbstractBodyResolveTransformerDispatcher(
    session,
    resolvePhase,
    implicitTypeOnly = false,
    scopeSession,
    outerBodyResolveContext = outerBodyResolveContext,
    returnTypeCalculator = returnTypeCalculator,
) {
    final override val expressionsTransformer: FirExpressionsResolveTransformer = FirExpressionTransformerForAnnotationArguments(this)

    private val declarationsResolveTransformerForAnnotationArguments = FirDeclarationsResolveTransformerForAnnotationArguments(this)

    private val usualDeclarationTransformer = FirDeclarationsResolveTransformer(this)

    @PrivateForInline",var isInsideAnnotationArgument: Boolean = false
"): Boolean {
    if (arguments.useJavac) {
        configuration.put(JVMConfigurationKeys.USE_JAVAC, true)
        if (arguments.compileJava) {
            configuration.put(JVMConfigurationKeys.COMPILE_JAVA, true)
        }
        return registerJavac(arguments = arguments.javacArguments)
    }

    return true
}

fun CompilerConfiguration.configureAdvancedJvmOptions(arguments: K2JVMCompilerArguments) {

    put(JVMConfigurationKeys.PARAMETERS_METADATA, arguments.javaParameters)

    val useOldBackend = arguments.useOldBackend
    val useIR = arguments.useK2 || languageVersionSettings.languageVersion.usesK2 || !useOldBackend

    messageCollector.report(LOGGING, ""Using ${if (useIR) ""JVM IR"" else ""old JVM""} backend"")

    put(JVMConfigurationKeys.IR, useIR)

    val abiStability = JvmAbiStability.fromStringOrNull(arguments.abiStability)
    if (arguments.abiStability != null) {
        if (abiStability == null) {
            messageCollector.report(
                ERROR,
                ""Unknown ABI stability mode: ${arguments.abiStability}, supported modes: ${JvmAbiStability.entries.map { it.description }}""
            )
        } else if (!useIR && abiStability == JvmAbiStability.UNSTABLE) {
            messageCollector.report(ERROR, ""-Xabi-stability=unstable is not supported in the old JVM backend"")
        } else {
            put(JVMConfigurationKeys.ABI_STABILITY, abiStability)
        }
    }

    put(JVMConfigurationKeys.DO_NOT_CLEAR_BINDING_CONTEXT, arguments.doNotClearBindingContext)
    put(JVMConfigurationKeys.DISABLE_CALL_ASSERTIONS, arguments.noCallAssertions)
    put(JVMConfigurationKeys.DISABLE_RECEIVER_ASSERTIONS, arguments.noReceiverAssertions)
    put(JVMConfigurationKeys.DISABLE_PARAM_ASSERTIONS, arguments.noParamAssertions)
    put(JVMConfigurationKeys.DISABLE_OPTIMIZATION, arguments.noOptimize)
    put(JVMConfigurationKeys.EMIT_JVM_TYPE_ANNOTATIONS, arguments.emitJvmTypeAnnotations)
    put(JVMConfigurationKeys.NO_OPTIMIZED_CALLABLE_REFERENCES, arguments.noOptimizedCallableReferences)
    put(JVMConfigurationKeys.NO_KOTLIN_NOTHING_VALUE_EXCEPTION, arguments.noKotlinNothingValueException)
    put(JVMConfigurationKeys.NO_RESET_JAR_TIMESTAMPS, arguments.noResetJarTimestamps)
    put(JVMConfigurationKeys.NO_UNIFIED_NULL_CHECKS, arguments.noUnifiedNullChecks)
    put(JVMConfigurationKeys.NO_SOURCE_DEBUG_EXTENSION, arguments.noSourceDebugExtension)

    put(JVMConfigurationKeys.SERIALIZE_IR, JvmSerializeIrMode.fromString(arguments.serializeIr))

    put(JVMConfigurationKeys.VALIDATE_IR, arguments.validateIr)
    put(JVMConfigurationKeys.VALIDATE_BYTECODE, arguments.validateBytecode)

    put(JVMConfigurationKeys.LINK_VIA_SIGNATURES, arguments.linkViaSignatures)

    put(JVMConfigurationKeys.ENABLE_DEBUG_MODE, arguments.enableDebugMode)
    put(JVMConfigurationKeys.NO_NEW_JAVA_ANNOTATION_TARGETS, arguments.noNewJavaAnnotationTargets)
    put(JVMConfigurationKeys.OLD_INNER_CLASSES_LOGIC, arguments.oldInnerClassesLogic)
    put(JVMConfigurationKeys.ENABLE_IR_INLINER, arguments.enableIrInliner)
    put(JVMConfigurationKeys.USE_INLINE_SCOPES_NUMBERS, arguments.useInlineScopesNumbers)

    val assertionsMode =
        JVMAssertionsMode.fromStringOrNull(arguments.assertionsMode)
    if (assertionsMode == null) {",messageCollector.report(
"// FIR_IDENTICAL
interface X {
    fun foo(a : Int = 1)
}

interface Y {
    fun foo(a : Int)
}

class Z : X, Y {",override fun foo(a : Int) {}
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin.mpp.external

import org.gradle.api.artifacts.ModuleVersionIdentifier
import org.gradle.api.artifacts.PublishArtifact
import org.gradle.api.component.ComponentWithCoordinates
import org.gradle.api.publish.maven.MavenPublication
import org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension
import org.jetbrains.kotlin.gradle.plugin.KotlinCompilation
import org.jetbrains.kotlin.gradle.plugin.mpp.*
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinUsageContext.MavenScope.COMPILE
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinUsageContext.MavenScope.RUNTIME
import org.jetbrains.kotlin.gradle.plugin.mpp.external.ExternalKotlinTargetComponent.TargetProvider
import org.jetbrains.kotlin.gradle.utils.dashSeparatedName
import org.jetbrains.kotlin.util.capitalizeDecapitalize.toLowerCaseAsciiOnly

internal class ExternalKotlinTargetComponent(","val targetProvider: TargetProvider,"
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.interpreter.state

import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.interpreter.IrInterpreterEnvironment
import org.jetbrains.kotlin.ir.interpreter.getOriginalPropertyByName
import org.jetbrains.kotlin.ir.interpreter.stack.Field
import org.jetbrains.kotlin.ir.interpreter.stack.Fields
import org.jetbrains.kotlin.ir.interpreter.stack.Variable
import org.jetbrains.kotlin.ir.symbols.IrSymbol
import org.jetbrains.kotlin.ir.util.isSubclassOf",import kotlin.math.min
"/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.testFramework

import java.lang.instrument.Instrumentation

@Suppress(""unused"")",object TestInstrumentationAgent {
"override fun findPrimaryConstructor(clazz: IrClassSymbol) = clazz.descriptor.unsubstitutedPrimaryConstructor?.let { symbolTable.descriptorExtension.referenceConstructor(it) }
    override fun findNoParametersConstructor(clazz: IrClassSymbol) = clazz.descriptor.constructors.singleOrNull { it.valueParameters.size == 0 }?.let { symbolTable.descriptorExtension.referenceConstructor(it) }

    override fun findNestedClass(clazz: IrClassSymbol, name: Name): IrClassSymbol? {
        val classDescriptor = clazz.descriptor.defaultType.memberScope.getContributedClassifier(name, NoLookupLocation.FROM_BUILTINS) as? ClassDescriptor
        return classDescriptor?.let {
            symbolTable.descriptorExtension.referenceClass(it)
        }
    }

    override fun getValueParameterPrimitiveBinaryType(function: IrFunctionSymbol, index: Int): PrimitiveBinaryType? {
        return function.descriptor.valueParameters[0].type.computePrimitiveBinaryTypeOrNull()
    }
}

internal class SymbolOverIrLookupUtils() : SymbolLookupUtils {
    override fun findMemberFunction(clazz: IrClassSymbol, name: Name): IrSimpleFunctionSymbol? =
            clazz.owner.findDeclaration<IrSimpleFunction> { it.name == name }?.symbol

    override fun findMemberProperty(clazz: IrClassSymbol, name: Name): IrPropertySymbol? =
            clazz.owner.findDeclaration<IrProperty> { it.name == name }?.symbol

    override fun findMemberPropertyGetter(clazz: IrClassSymbol, name: Name): IrSimpleFunctionSymbol? =
            clazz.owner.findDeclaration<IrProperty> { it.name == name }?.getter?.symbol

    override fun findPrimaryConstructor(clazz: IrClassSymbol): IrConstructorSymbol? = clazz.owner.primaryConstructor?.symbol
    override fun findNoParametersConstructor(clazz: IrClassSymbol): IrConstructorSymbol? = clazz.owner.constructors.singleOrNull { it.valueParameters.isEmpty() }?.symbol

    override fun findNestedClass(clazz: IrClassSymbol, name: Name): IrClassSymbol? {
        return clazz.owner.declarations.filterIsInstance<IrClass>().singleOrNull { it.name == name }?.symbol
    }

    override fun getName(clazz: IrClassSymbol): Name = clazz.owner.name

    override fun isExtensionReceiverClass(property: IrPropertySymbol, expected: IrClassSymbol?): Boolean {
        return property.owner.getter?.extensionReceiverParameter?.type?.classOrNull == expected
    }

    override fun isExtensionReceiverClass(function: IrFunctionSymbol, expected: IrClassSymbol?): Boolean {
        return function.owner.extensionReceiverParameter?.type?.classOrNull == expected
    }

    override fun findGetter(property: IrPropertySymbol): IrSimpleFunctionSymbol? = property.owner.getter?.symbol

    override fun isExtensionReceiverNullable(function: IrFunctionSymbol): Boolean? {
        return function.owner.extensionReceiverParameter?.type?.isMarkedNullable()
    }

    override fun getValueParametersCount(function: IrFunctionSymbol): Int = function.owner.valueParameters.size

    override fun getTypeParametersCount(function: IrFunctionSymbol): Int = function.owner.typeParameters.size

    override fun isTypeParameterUpperBoundClass(property: IrPropertySymbol, index: Int, expected: IrClassSymbol): Boolean {
        return property.owner.getter?.typeParameters?.getOrNull(index)?.superTypes?.any { it.classOrNull == expected } ?: false
    }

    override fun isValueParameterClass(function: IrFunctionSymbol, index: Int, expected: IrClassSymbol?): Boolean {
        return function.owner.valueParameters.getOrNull(index)?.type?.classOrNull == expected
    }

    override fun isReturnClass(function: IrFunctionSymbol, expected: IrClassSymbol): Boolean {
        return function.owner.returnType.classOrNull == expected
    }","override fun isValueParameterTypeArgumentClass(function: IrFunctionSymbol, index: Int, argumentIndex: Int, expected: IrClassSymbol?): Boolean {"
"// IGNORE_BACKEND: JS_IR
// IGNORE_BACKEND: JS_IR_ES6
// TODO: muted automatically, investigate should it be ran for JS or not
// IGNORE_BACKEND: JS

// WITH_STDLIB
// This is a big, ugly, semi-auto generated test.
// Use corresponding 'Small' test for debug.

import kotlin.test.*

fun fn0() {}
fun fn1(x0: Any) {}
fun fn2(x0: Any, x1: Any) {}
fun fn3(x0: Any, x1: Any, x2: Any) {}
fun fn4(x0: Any, x1: Any, x2: Any, x3: Any) {}
fun fn5(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any) {}
fun fn6(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any, x5: Any) {}
fun fn7(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any, x5: Any, x6: Any) {}
fun fn8(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any, x5: Any, x6: Any, x7: Any) {}
fun fn9(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any, x5: Any, x6: Any, x7: Any, x8: Any) {}
fun fn10(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any, x5: Any, x6: Any, x7: Any, x8: Any, x9: Any) {}","fun fn11(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any, x5: Any, x6: Any, x7: Any, x8: Any, x9: Any, x10: Any) {}"
"// !DIAGNOSTICS: -UNUSED_PARAMETER

fun <K> id(x: K) = x

class A1 {
    fun <T> a1(t: T): Unit {}
    fun test1(): (String) -> Unit = A1()::a1
    fun test2(): (String) -> Unit = id(A1()::a1)
}

class A2 {
    fun <K, V> a2(key: K): V = TODO()

    fun test1(): (String) -> Unit = A2()::a2
    fun <T3> test2(): (T3) -> T3 = A2()::a2
}

class A3<T> {
    fun <V> a3(key: T): V = TODO()

    fun test1(): (T) -> Int = this::a3",fun test2(): (T) -> Unit = A3<T>()::a3
"is Float -> buildLiteralExpression(
            null, ConstantValueKind.Float, this, setType = true
        )
        is Double -> buildLiteralExpression(
            null, ConstantValueKind.Double, this, setType = true
        )
        is Boolean -> buildLiteralExpression(
            null, ConstantValueKind.Boolean, this, setType = true
        )
        is String -> buildLiteralExpression(
            null, ConstantValueKind.String, this, setType = true
        )
        is ByteArray -> toList().createArrayLiteral(session, ConstantValueKind.Byte)
        is ShortArray -> toList().createArrayLiteral(session, ConstantValueKind.Short)
        is IntArray -> toList().createArrayLiteral(session, ConstantValueKind.Int)
        is LongArray -> toList().createArrayLiteral(session, ConstantValueKind.Long)
        is CharArray -> toList().createArrayLiteral(session, ConstantValueKind.Char)
        is FloatArray -> toList().createArrayLiteral(session, ConstantValueKind.Float)
        is DoubleArray -> toList().createArrayLiteral(session, ConstantValueKind.Double)
        is BooleanArray -> toList().createArrayLiteral(session, ConstantValueKind.Boolean)
        null -> buildLiteralExpression(
            null, ConstantValueKind.Null, null, setType = true
        )

        else -> null
    }
}

private fun <T> List<T>.createArrayLiteral(session: FirSession, kind: ConstantValueKind): FirArrayLiteral {
    return buildArrayLiteral {
        argumentList = buildArgumentList {
            for (element in this@createArrayLiteral) {
                arguments += element.createConstantOrError(session)
            }
        }
        coneTypeOrNull = kind.expectedConeType(session).createArrayType()
    }
}

// For now, it's supported only for RxJava3 annotations, see KT-53041
fun extractNullabilityAnnotationOnBoundedWildcard(wildcardType: JavaWildcardType): JavaAnnotation? {
    require(wildcardType.bound != null) { ""Nullability annotations on unbounded wildcards aren't supported"" }
    return wildcardType.annotations.find { annotation -> RXJAVA3_ANNOTATIONS.any { annotation.classId?.asSingleFqName() == it } }
}

fun FirProperty.hasJvmFieldAnnotation(session: FirSession): Boolean =
    backingField?.annotations?.any { it.isJvmFieldAnnotation(session) } == true

fun FirAnnotation.isJvmFieldAnnotation(session: FirSession): Boolean =
    toAnnotationClassId(session) == JvmStandardClassIds.Annotations.JvmField

// The implementation is different from `FirAnnotationContainer.getAnnotationsByClassId` because it doesn't expand typealiases
// The reason is that some usesites do not have access to the session. For the intended use for main function detection it seems fine
// for now, but we may need to reimplement it in the future. See KT-67634
// See also the comment in the body, relevant for the use in the const evaluator.
private fun FirDeclaration.findAnnotationByClassId(classId: ClassId): FirAnnotation? {
    return annotations.firstOrNull {
        // Access to type must be through `coneTypeOrNull`.
        // Even if `JvmName` is in the list of annotations that must be resoled for compilation, we still could try to access some user
        // annotations that could be not resolved.
        it.annotationTypeRef.coneTypeOrNull?.classId == classId
    }
}

fun FirDeclaration.findJvmNameAnnotation(): FirAnnotation? = findAnnotationByClassId(JvmStandardClassIds.Annotations.JvmName)",fun FirDeclaration.findJvmStaticAnnotation(): FirAnnotation? = findAnnotationByClassId(JvmStandardClassIds.Annotations.JvmStatic)
"// SKIP_WHEN_OUT_OF_CONTENT_ROOT
// MEMBER_NAME_FILTER: something
// IS_GETTER: true
// FILE: Derived.kt",class Der<caret>ived : Base() {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.checkers.generator.diagnostics

import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.fir.checkers.generator.diagnostics.model.DiagnosticList
import org.jetbrains.kotlin.fir.checkers.generator.diagnostics.model.PositioningStrategy
import org.jetbrains.kotlin.fir.types.ConeKotlinType
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.util.PrivateForInline

@Suppress(""ClassName"", ""unused"")
@OptIn(PrivateForInline::class)
object WASM_DIAGNOSTICS_LIST : DiagnosticList(""FirWasmErrors"") {
    val ANNOTATIONS by object : DiagnosticGroup(""Annotations"") {
        val JS_MODULE_PROHIBITED_ON_VAR by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT)
        val JS_MODULE_PROHIBITED_ON_NON_EXTERNAL by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT)
        val NESTED_JS_MODULE_PROHIBITED by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT)
    }

    val EXTERNALS by object : DiagnosticGroup(""Externals"") {
        val NON_EXTERNAL_TYPE_EXTENDS_EXTERNAL_TYPE by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT) {
            parameter<ConeKotlinType>(""superType"")
        }",val EXTERNAL_TYPE_EXTENDS_NON_EXTERNAL_TYPE by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT) {
"}

                if (!compileModulesUsingFrontendIrAndLightTree(
                        projectEnvironment, configuration, messageCollector, buildFile, chunk.single(), targetDescription,
                        checkSourceFiles = !arguments.allowNoSourceFiles,
                        isPrintingVersion = arguments.version,
                    )
                ) return COMPILATION_ERROR
            } else {
                val environment = createCoreEnvironment(
                    rootDisposable, configuration, messageCollector,
                    targetDescription
                ) ?: return COMPILATION_ERROR
                environment.registerJavacIfNeeded(arguments).let {
                    if (!it) return COMPILATION_ERROR
                }

                if (environment.getSourceFiles().isEmpty() && !arguments.allowNoSourceFiles && buildFile == null) {
                    if (arguments.version) return OK

                    messageCollector.report(ERROR, ""No source files"")
                    return COMPILATION_ERROR
                }

                if (!KotlinToJVMBytecodeCompiler.compileModules(environment, buildFile, chunk)) return COMPILATION_ERROR
            }
            return OK
        } catch (e: CompilationException) {
            messageCollector.report(
                EXCEPTION,
                OutputMessageUtil.renderException(e),
                MessageUtil.psiElementToMessageLocation(e.element)
            )
            return INTERNAL_ERROR
        }
    }

    override fun MutableList<String>.addPlatformOptions(arguments: K2JVMCompilerArguments) {
        if (arguments.scriptTemplates?.isNotEmpty() == true) {
            add(""plugin:kotlin.scripting:script-templates=${arguments.scriptTemplates!!.joinToString("","")}"")
        }
        if (arguments.scriptResolverEnvironment?.isNotEmpty() == true) {
            add(
                ""plugin:kotlin.scripting:script-resolver-environment=${arguments.scriptResolverEnvironment!!.joinToString(
                    "",""
                )}""
            )
        }
    }

    private fun createCoreEnvironment(
        rootDisposable: Disposable,
        configuration: CompilerConfiguration,
        messageCollector: MessageCollector,
        targetDescription: String
    ): KotlinCoreEnvironment? {
        if (messageCollector.hasErrors()) return null

        val environment = KotlinCoreEnvironment.createForProduction(rootDisposable, configuration, EnvironmentConfigFiles.JVM_CONFIG_FILES)

        val sourceFiles = environment.getSourceFiles()
        configuration[CLIConfigurationKeys.PERF_MANAGER]?.notifyCompilerInitialized(
            sourceFiles.size, environment.countLinesOfCode(sourceFiles), targetDescription
        )",return if (messageCollector.hasErrors()) null else environment
"}

internal class KtUltraLightParameterForSource(
    name: String,
    override val kotlinOrigin: KtParameter,
    support: KtUltraLightSupport,
    method: KtUltraLightMethod,
    containingDeclaration: KtCallableDeclaration
) : KtAbstractUltraLightParameterForDeclaration(name, kotlinOrigin, support, method, containingDeclaration) {

    override fun tryGetKotlinType(): KotlinType? = kotlinOrigin.getKotlinType()

    override fun isVarArgs(): Boolean = kotlinOrigin.isVarArg && method.parameterList.parameters.last() == this

    override fun setName(@NonNls name: String): PsiElement {
        kotlinOrigin.setName(name)
        return this
    }

    override val givenAnnotations: List<KtLightAbstractAnnotation>?
        get() {
            return if (kotlinOrigin.hasValOrVar()) {
                val entriesWithoutJvmField = kotlinOrigin.annotationEntries.filter { it.shortName?.identifier != ""JvmField"" }
                entriesWithoutJvmField.toLightAnnotations(this, null) +
                        entriesWithoutJvmField.toLightAnnotations(this, AnnotationUseSiteTarget.CONSTRUCTOR_PARAMETER)
            } else {
                kotlinOrigin.annotationEntries.toLightAnnotations(this, null)
            }
        }

    override fun getStartOffsetInParent(): Int = kotlinOrigin.startOffsetInParent
    override fun isWritable(): Boolean = kotlinOrigin.isWritable
    override fun getNavigationElement(): PsiElement = kotlinOrigin.navigationElement
    override fun getContainingFile(): PsiFile = parent.containingFile
    override fun getPresentation(): ItemPresentation? = kotlinOrigin.let { ItemPresentationProviders.getItemPresentation(it) }
    override fun findElementAt(offset: Int): PsiElement? = kotlinOrigin.findElementAt(offset)
}

internal class KtUltraLightParameterForSetterParameter(
    name: String,
    // KtProperty or KtParameter from primary constructor
    private val property: KtDeclaration,
    support: KtUltraLightSupport,
    method: KtUltraLightMethod,
    containingDeclaration: KtCallableDeclaration
) : KtAbstractUltraLightParameterForDeclaration(name, null, support, method, containingDeclaration) {

    override fun tryGetKotlinType(): KotlinType? = property.getKotlinType()

    override val givenAnnotations: List<KtLightAbstractAnnotation>?
        get() = property.annotationEntries.toLightAnnotations(this, AnnotationUseSiteTarget.SETTER_PARAMETER)

    override fun isVarArgs(): Boolean = false

    override fun equals(other: Any?): Boolean = other === this ||
            other is KtUltraLightParameterForSetterParameter &&
            other.name == this.name &&
            other.property == this.property

    override fun hashCode(): Int = name.hashCode()
}

internal class KtUltraLightReceiverParameter(
    containingDeclaration: KtCallableDeclaration,
    support: KtUltraLightSupport,",method: KtUltraLightMethod
"private val fileToDebugInfoMap = mutableMapOf<Int, IrArrayFileReader?>()
    override fun debugInfo(index: Int, fileIndex: Int): ByteArray? {
        val dataReader = fileToDebugInfoMap.getOrPut(fileIndex) {
            val fileDirectory = directories[fileIndex]
            access.realFiles {
                it.irDebugInfo(fileDirectory).let { diFile ->
                    if (diFile.exists) {
                        IrArrayFileReader(diFile)
                    } else null
                }
            }

        }
        return dataReader?.tableItemBytes(index)
    }

    override fun file(index: Int): ByteArray {
        return access.realFiles {
            it.irFile(directories[index]).readBytes()
        }
    }

    override fun fileCount(): Int {
        return directories.size
    }

    override fun types(fileIndex: Int): ByteArray {
        TODO(""Not yet implemented"")
    }

    override fun signatures(fileIndex: Int): ByteArray {
        TODO(""Not yet implemented"")
    }

    override fun strings(fileIndex: Int): ByteArray {
        TODO(""Not yet implemented"")
    }

    override fun declarations(fileIndex: Int): ByteArray {
        TODO(""Not yet implemented"")
    }

    override fun bodies(fileIndex: Int): ByteArray {
        TODO(""Not yet implemented"")
    }
}

class KotlinLibraryImpl(
    val base: BaseKotlinLibraryImpl,
    val metadata: MetadataLibraryImpl,
    val ir: IrLibraryImpl
) : KotlinLibrary,
    BaseKotlinLibrary by base,
    MetadataLibrary by metadata,
    IrLibrary by ir {
    override fun toString(): String = buildString {
        append(""name "")
        append(base.libraryName)
        append("", "")
        append(""file: "")
        append(base.libraryFile.path)
        append("", "")
        append(""version: "")
        append(base.versions)
        if (isInterop) {","append("", interop: true, "")"
"var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }
    return maxValue
}

/**
 * Returns the largest value among all values produced by [selector] function
 * applied to each element in the array or `null` if there are no elements.
 * 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.internal.InlineOnly
public inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {
    if (isEmpty()) return null
    var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }
    return maxValue
}

/**
 * Returns the largest value among all values produced by [selector] function
 * applied to each element in the array or `null` if there are no elements.
 * 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.internal.InlineOnly
public inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {
    if (isEmpty()) return null
    var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }
    return maxValue
}

/**
 * Returns the largest value among all values produced by [selector] function
 * applied to each element in the array or `null` if there are no elements.
 * 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.internal.InlineOnly
public inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {
    if (isEmpty()) return null
    var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }",return maxValue
"// LANGUAGE: +MultiPlatformProjects
// IGNORE_BACKEND_K1: JVM, JVM_IR, JS, JS_IR, JS_IR_ES6, WASM
// DUMP_IR

// MODULE: common
// FILE: common.kt

open class A {
    internal open fun foo1() = ""A::foo1""
    internal open fun foo2() = ""A::foo2""
    internal open fun foo3() = ""A::foo3""
}

expect open class B() : A {
    internal override fun foo1(): String
    internal override fun foo2(): String
}

open class C : B() {
    internal override fun foo1() = ""C::foo1""
}


// MODULE: main()()(common)
// FILE: main.kt

actual open class B actual constructor() : A() {
    internal actual override fun foo1() = ""B::foo1""
    internal actual override fun foo2() = ""B::foo2""
}",fun box() : String {
"// IGNORE_FIR
// DONT_TARGET_EXACT_BACKEND: JS
// EXPECTED_REACHABLE_NODES: 1283
// RUN_PLAIN_BOX_FUNCTION
// INFER_MAIN_MODULE

// MODULE: lib1
// FILE: lib1.kt",@JsExport
"val classLoader = URLClassLoader(classpath.map { it.toURI().toURL() }.toTypedArray(), parentClassLoader)
        this.annotationProcessingClassLoader = classLoader

        val processors = if (options.processors.isNotEmpty()) {
            logger.info(""Annotation processor class names are set, skip AP discovery"")
            options.processors.mapNotNull { tryLoadProcessor(it, classLoader) }
        } else {
            logger.info(""Need to discovery annotation processors in the AP classpath"")
            doLoadProcessors(classpath, classLoader)
        }

        if (processors.isEmpty()) {
            logger.info(""No annotation processors available, aborting"")
        } else {
            logger.info { ""Annotation processors: "" + processors.joinToString { it::class.java.canonicalName } }
        }

        return LoadedProcessors(wrapInIncrementalProcessor(processors, classpath), classLoader)
    }

    private fun wrapInIncrementalProcessor(processors: List<Processor>, classpath: Iterable<File>): List<IncrementalProcessor> {
        if (options.incrementalCache == null) {
            return processors.map { IncrementalProcessor(it, DeclaredProcType.NON_INCREMENTAL, logger) }
        }

        val processorNames = processors.map {it.javaClass.name}.toSet()

        val processorsInfo: Map<String, DeclaredProcType> = getIncrementalProcessorsFromClasspath(processorNames, classpath)

        val nonIncremental = processorNames.filter { !processorsInfo.containsKey(it) }
        return processors.map {
            val procType = processorsInfo[it.javaClass.name]?.let {
                if (nonIncremental.isEmpty()) {
                    it
                } else {
                    DeclaredProcType.INCREMENTAL_BUT_OTHER_APS_ARE_NOT
                }
            } ?: DeclaredProcType.NON_INCREMENTAL
            IncrementalProcessor(it, procType, logger)
        }
    }

    open fun doLoadProcessors(classpath: LinkedHashSet<File>, classLoader: ClassLoader): List<Processor> {
        val processorNames = mutableSetOf<String>()

        fun processSingleInput(input: InputStream) {
            val lines = input.bufferedReader().lineSequence()
            lines.forEach { line ->
                val processedLine = line.substringBefore(""#"").trim()
                if (processedLine.isNotEmpty()) {
                    processorNames.add(processedLine)
                }
            }
        }
        // Do not use ServiceLoader as it uses JarFileFactory cache which is not cleared
        // properly. This may cause issues on Windows.
        // Previously, JarFileFactory caches were manually cleaned, but that caused race conditions,
        // as JarFileFactory was shared between concurrent runs in the same class loader.
        // See https://youtrack.jetbrains.com/issue/KT-34604 for more details. Similar issue
        // is also https://youtrack.jetbrains.com/issue/KT-22513.
        val serviceFile = ""META-INF/services/javax.annotation.processing.Processor""
        for (file in classpath) {
            when {
                file.isDirectory -> {
                    file.resolve(serviceFile).takeIf { it.isFile }?.let {",processSingleInput(it.inputStream())
"object C {
  var myIntProp: Int = 1
  var myByteProp: Byte = 2
  var myLongProp: Long = 3L
  var myShortProp: Short = 4
  var myDoubleProp: Double = 5.6
  var myFloatProp: Float = 7.8f
  var myBooleanProp: Boolean = true
  var myCharProp: Char = '9'

  init {
    myIntProp = 0
    myByteProp = 0
    myLongProp = 0L
    myShortProp = 0
    myDoubleProp = 0.0
    myFloatProp = 0.0f
    myBooleanProp = false
    myCharProp = '\u0000'
  }
}

fun box(): String {
  if (C.myIntProp != 0) return ""fail Int""
  if (C.myByteProp != 0.toByte()) return ""fail Byte""
  if (C.myLongProp != 0L) return ""fail Long""
  if (C.myShortProp != 0.toShort()) return ""fail Short""
  if (C.myDoubleProp != 0.0) return ""fail Double""
  if (C.myFloatProp != 0.0f) return ""fail Float""
  if (C.myBooleanProp != false) return ""fail Boolean""
  if (C.myCharProp != '\u0000') return ""fail Char""","return ""OK"""
"// No termination is going on here. But that's the closest location to other unhandled exception hook tests.
// KIND: REGULAR
// OUTPUT_REGEX: .*an error.*
import kotlin.test.*

import kotlin.native.concurrent.*

@Test",fun testExecuteStart() {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.load.java.structure.impl.source

import com.intellij.openapi.project.Project
import com.intellij.psi.*

abstract class JavaElementSourceFactory {
    abstract fun <PSI : PsiElement> createPsiSource(psi: PSI): JavaElementPsiSource<PSI>
    abstract fun <TYPE : PsiType> createTypeSource(type: TYPE): JavaElementTypeSource<TYPE>
    abstract fun <TYPE : PsiType> createVariableReturnTypeSource(psiVariableSource: JavaElementPsiSource<out PsiVariable>): JavaElementTypeSource<TYPE>
    abstract fun <TYPE : PsiType> createMethodReturnTypeSource(psiMethodSource: JavaElementPsiSource<out PsiMethod>): JavaElementTypeSource<TYPE>

    abstract fun <TYPE : PsiType> createTypeParameterUpperBoundTypeSource(
        psiTypeParameterSource: JavaElementPsiSource<out PsiTypeParameter>,
        boundIndex: Int,
    ): JavaElementTypeSource<TYPE>

    abstract fun createSuperTypeSource(
        psiTypeParameterSource: JavaElementPsiSource<out PsiClass>,
        superTypeIndex: Int,
    ): JavaElementTypeSource<PsiClassType>

    abstract fun <TYPE : PsiType> createExpressionTypeSource(psiExpressionSource: JavaElementPsiSource<out PsiExpression>): JavaElementTypeSource<TYPE>

    /**
     * @see com.intellij.psi.PsiClass.getPermitsListTypes
     */
    abstract fun createPermittedTypeSource(
        psiTypeParameterSource: JavaElementPsiSource<out PsiClass>,
        permittedTypeIndex: Int,
    ): JavaElementTypeSource<PsiClassType>

    companion object {
        @JvmStatic
        fun getInstance(project: Project): JavaElementSourceFactory {
            return project.getService(JavaElementSourceFactory::class.java)
        }
    }
}

class JavaFixedElementSourceFactory : JavaElementSourceFactory() {
    override fun <PSI : PsiElement> createPsiSource(psi: PSI): JavaElementPsiSource<PSI> {
        return JavaElementPsiSourceWithFixedPsi(psi)
    }",override fun <TYPE : PsiType> createTypeSource(type: TYPE): JavaElementTypeSource<TYPE> {
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.renderer

import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.isCatchParameter
import org.jetbrains.kotlin.util.capitalizeDecapitalize.toLowerCaseAsciiOnly

open class FirDeclarationRenderer(
    private val localVariablePrefix: String = ""l"",
) {

    internal lateinit var components: FirRendererComponents
    protected val printer: FirPrinter get() = components.printer
    private val resolvePhaseRenderer: FirResolvePhaseRenderer? get() = components.resolvePhaseRenderer
    private val typeRenderer: ConeTypeRenderer get() = components.typeRenderer

    fun render(declaration: FirDeclaration) {
        renderPhaseAndAttributes(declaration)
        if (declaration is FirConstructor) {
            declaration.dispatchReceiverType?.let {
                typeRenderer.render(it)
                printer.print(""."")
            }
            if (declaration is FirErrorPrimaryConstructor) {
                printer.print(""error_"")
            }
            printer.print(""constructor"")
            return
        }
        printer.print(
            when (declaration) {","is FirRegularClass -> declaration.classKind.name.toLowerCaseAsciiOnly().replace(""_"", "" "")"
"}
            // TODO what should the default message be?
            roots.size == 1 && original.getValueArgument(0)!!.type.isBoolean() -> irString(""Assertion failed"")
            else -> null
        }
    }

    private fun findDelegates(function: IrFunction): List<FunctionDelegate> {
        val values = function.valueParameters
        if (values.isEmpty()) return emptyList()

        // Java static functions require searching by class
        val parentClassFunctions = (
                function.parentClassId
                    ?.let { context.referenceClass(it) }
                    ?.functions ?: emptySequence()
                )
            .filter { it.owner.kotlinFqName == function.kotlinFqName }
            .toList()
        val possible = (context.referenceFunctions(function.callableId) + parentClassFunctions)
            .distinct()

        return possible.mapNotNull { overload ->
            // Dispatch receivers must always match exactly
            if (function.dispatchReceiverParameter?.type != overload.owner.dispatchReceiverParameter?.type) {
                return@mapNotNull null
            }

            // Extension receiver may only be assignable
            if (!function.extensionReceiverParameter?.type.isAssignableTo(overload.owner.extensionReceiverParameter?.type)) {
                return@mapNotNull null
            }

            val parameters = overload.owner.valueParameters
            if (parameters.size !in values.size..values.size + 1) return@mapNotNull null
            if (!parameters.zip(values).all { (param, value) -> value.type.isAssignableTo(param.type) }) {
                return@mapNotNull null
            }

            val messageParameter = parameters.last()
            return@mapNotNull when {
                isStringSupertype(messageParameter.type) -> SimpleFunctionDelegate(overload, messageParameter)
                isStringFunction(messageParameter.type) -> LambdaFunctionDelegate(overload, messageParameter)
                isStringJavaSupplierFunction(messageParameter.type) ->
                    SamConversionLambdaFunctionDelegate(overload, messageParameter)
                else -> null
            }
        }
    }

    private fun isStringFunction(type: IrType): Boolean =
        type.isFunctionOrKFunction() && type is IrSimpleType && (type.arguments.size == 1 && isStringSupertype(type.arguments.first()))

    private fun isStringJavaSupplierFunction(type: IrType): Boolean {
        val javaSupplier = context.referenceClass(ClassId.topLevel(FqName(""java.util.function.Supplier"")))
        return javaSupplier != null && type.isSubtypeOfClass(javaSupplier) &&
                type is IrSimpleType && (type.arguments.size == 1 && isStringSupertype(type.arguments.first()))
    }

    private fun isStringSupertype(argument: IrTypeArgument): Boolean =
        argument is IrTypeProjection && isStringSupertype(argument.type)

    private fun isStringSupertype(type: IrType): Boolean =
        context.irBuiltIns.stringType.isSubtypeOf(type, irTypeSystemContext)",private fun IrType?.isAssignableTo(type: IrType?): Boolean {
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.test.framework.services

import com.intellij.openapi.util.Key",import org.jetbrains.kotlin.analysis.providers.ForeignValueProviderService
"// DONT_TARGET_EXACT_BACKEND: JS
// ES_MODULES
// SPLIT_PER_MODULE
// EXPECTED_REACHABLE_NODES: 1287
// MODULE: lib
// FILE: lib.kt

package lib

fun foo() = 23

external fun bar(): Int = definedExternally

inline fun baz() = 99

inline fun callFoo() = foo()

inline fun buzz(): Int {
    val o = object {
        fun f() = 111
    }
    return o.f()
}

// FILE: lib.js

function bar() {
    return 42;
}

// MODULE: main(lib)
// FILE: main.kt

package main

fun box(): String {
    val a = lib.foo()
    if (a != 23) return ""fail: simple function: $a""

    val b = lib.bar()
    if (b != 42) return ""fail: native function: $b""

    val c = lib.baz()
    if (c != 99) return ""fail: inline function: $c""

    val d = lib.buzz()
    if (d != 111) return ""fail: inline function with object expression: $d""",val e = lib.callFoo()
"fun collectErrorCandidatesForFunction(
    scopeTower: ImplicitScopeTower,
    name: Name,
    explicitReceiver: DetailedReceiver?
): Collection<ErrorCandidate<*>> {
    val context = ErrorCandidateContext(scopeTower, name, explicitReceiver)
    context.asClassifierCall(asFunction = true)
    return context.result
}

fun collectErrorCandidatesForVariable(
    scopeTower: ImplicitScopeTower,
    name: Name,
    explicitReceiver: DetailedReceiver?
): Collection<ErrorCandidate<*>> {
    val context = ErrorCandidateContext(scopeTower, name, explicitReceiver)
    context.asClassifierCall(asFunction = false)
    return context.result
}

private class ErrorCandidateContext(
    val scopeTower: ImplicitScopeTower,
    val name: Name,
    val explicitReceiver: DetailedReceiver?
) {
    val result = SmartList<ErrorCandidate<*>>()

    fun add(errorCandidate: ErrorCandidate<*>) {
        result.add(errorCandidate)
    }
}

private fun ErrorCandidateContext.asClassifierCall(asFunction: Boolean) {
    val classifier =
        when (explicitReceiver) {
            is ReceiverValueWithSmartCastInfo -> {
                explicitReceiver.receiverValue.type.memberScope.getContributedClassifier(name, scopeTower.location)
            }
            is QualifierReceiver -> {
                explicitReceiver.staticScope.getContributedClassifier(name, scopeTower.location)
            }
            else -> scopeTower.lexicalScope.findClassifier(name, scopeTower.location)
        } ?: return

    val kind = getWrongResolutionToClassifier(classifier, asFunction) ?: return

    add(ErrorCandidate.Classifier(classifier, kind))
}

private fun ErrorCandidateContext.getWrongResolutionToClassifier(
    classifier: ClassifierDescriptor,
    asFunction: Boolean
): WrongResolutionToClassifier? =
    when (classifier) {
        is TypeAliasDescriptor -> classifier.classDescriptor?.let { getWrongResolutionToClassifier(it, asFunction) }

        is TypeParameterDescriptor -> if (asFunction) TYPE_PARAMETER_AS_FUNCTION else TYPE_PARAMETER_AS_VALUE

        is ClassDescriptor -> {
            when (classifier.kind) {
                ClassKind.INTERFACE -> if (asFunction) INTERFACE_AS_FUNCTION else INTERFACE_AS_VALUE

                ClassKind.OBJECT -> if (asFunction) OBJECT_AS_FUNCTION else null",ClassKind.CLASS -> when {
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.fir.components

import org.jetbrains.kotlin.analysis.api.components.KtDiagnosticCheckerFilter
import org.jetbrains.kotlin.analysis.api.components.KtDiagnosticProvider
import org.jetbrains.kotlin.analysis.api.diagnostics.KtDiagnosticWithPsi
import org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession
import org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken
import org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.DiagnosticCheckerFilter
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.collectDiagnosticsForFile
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.getDiagnostics
import org.jetbrains.kotlin.psi.KtElement
import org.jetbrains.kotlin.psi.KtFile

internal class KtFirDiagnosticProvider(
    override val analysisSession: KtFirAnalysisSession,
    override val token: KtLifetimeToken,
) : KtDiagnosticProvider(), KtFirAnalysisSessionComponent {

    override fun getDiagnosticsForElement(
        element: KtElement,
        filter: KtDiagnosticCheckerFilter
    ): Collection<KtDiagnosticWithPsi<*>> {
        return element.getDiagnostics(firResolveSession, filter.asLLFilter()).map { it.asKtDiagnostic() }
    }

    override fun collectDiagnosticsForFile(ktFile: KtFile, filter: KtDiagnosticCheckerFilter): Collection<KtDiagnosticWithPsi<*>> =
        ktFile.collectDiagnosticsForFile(firResolveSession, filter.asLLFilter()).map { it.asKtDiagnostic() }",private fun KtDiagnosticCheckerFilter.asLLFilter() = when (this) {
"// IGNORE_BACKEND: JS

fun jsNullUndefinedHashCode() {","assertEquals(js(""null"").unsafeCast<Any>().hashCode(), js(""null"").unsafeCast<Any>().hashCode())"
"check(::x5.getter, annotationExists = true)
        check(::x6.getter, annotationExists = true)

        check(::x7.getter, annotationExists = false)

        check(::x8.getter, annotationExists = true)
        check(::x8.setter, annotationExists = false)

        check(::x9.getter, annotationExists = true)
        check(::x9.setter, annotationExists = true)
    }
}

private class EffetivelyPrivate private constructor(
    @get:Ann val x0: Int,
    @get:Ann protected val x1: Int,
    @get:Ann internal val x2: Int
) {
    companion object {
        fun test() {
            EffetivelyPrivate(0, 0, 0).test()
        }
    }

    private class Nested {
        @get:Ann
        val fofo = 0
    }

    fun test() {
        check(::x0.getter, annotationExists = true)
        check(::x1.getter, annotationExists = true)
        check(::x2.getter, annotationExists = true)

        check(Nested::fofo.getter, annotationExists = true)
    }
}

class Statics {
    companion object {
        @JvmField
        @get:Ann
        val x0 = """"

        @get:Ann
        const val x1 = """"

        @JvmStatic
        @AnnRepeat
        @get:Ann
        @set:Ann
        @setparam:Ann
        var x2 = """"

        @JvmStatic
        @get:Ann
        private val x3 = """"

        @get:Ann
        val x4 = """"
    }

    fun test() {
        check(::x0.getter, annotationExists = false)","check(::x1.getter, annotationExists = false)"
"""extension_shadowed_by_member"",
    ""redundant_projection"",
    ""RemoveRedundantBackticks"",
    ""ObjectPropertyName"",
    ""deprecation""
)
@file:org.gradle.api.Generated

/* ktlint-disable */

package gradle.kotlin.dsl.accessors._c8feb92ae88f9e0cc4f1c07aacfeaaf1


import org.gradle.api.Action
import org.gradle.api.Incubating
import org.gradle.api.NamedDomainObjectProvider
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurablePublishArtifact
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.Dependency
import org.gradle.api.artifacts.DependencyConstraint
import org.gradle.api.artifacts.ExternalModuleDependency
import org.gradle.api.artifacts.ModuleDependency
import org.gradle.api.artifacts.PublishArtifact
import org.gradle.api.artifacts.dsl.ArtifactHandler
import org.gradle.api.artifacts.dsl.DependencyConstraintHandler
import org.gradle.api.artifacts.dsl.DependencyHandler
import org.gradle.api.provider.Provider
import org.gradle.api.provider.ProviderConvertible
import org.gradle.api.tasks.TaskContainer
import org.gradle.api.tasks.TaskProvider

import org.gradle.kotlin.dsl.*
import org.gradle.kotlin.dsl.accessors.runtime.*


/**
 * Adds a dependency to the 'kotlinCompilerClasspath' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`kotlinCompilerClasspath`(dependencyNotation: Any): Dependency? =
    add(""kotlinCompilerClasspath"", dependencyNotation)

/**
 * Adds a dependency to the 'kotlinCompilerClasspath' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`kotlinCompilerClasspath`(
    dependencyNotation: String,
    dependencyConfiguration: Action<ExternalModuleDependency>
): ExternalModuleDependency = addDependencyTo(
    this, ""kotlinCompilerClasspath"", dependencyNotation, dependencyConfiguration",) as ExternalModuleDependency
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package org.jetbrains.kotlin.fir.plugin.generators
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.load.java

import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.util.capitalizeDecapitalize.capitalizeAsciiOnly

object JvmAbi {
    const val DEFAULT_IMPLS_CLASS_NAME = ""DefaultImpls""
    const val ERASED_INLINE_CONSTRUCTOR_NAME = ""constructor""

    @JvmField
    val JVM_FIELD_ANNOTATION_FQ_NAME = FqName(""kotlin.jvm.JvmField"")
    @JvmField
    val JVM_FIELD_ANNOTATION_CLASS_ID = ClassId.topLevel(JVM_FIELD_ANNOTATION_FQ_NAME)

    /**
     * Warning: use DEFAULT_IMPLS_CLASS_NAME and TypeMappingConfiguration.innerClassNameFactory when possible.
     * This is false for KAPT3 mode.
     */
    const val DEFAULT_IMPLS_SUFFIX = ""$$DEFAULT_IMPLS_CLASS_NAME""

    const val DEFAULT_PARAMS_IMPL_SUFFIX = ""\$default""

    private const val GET_PREFIX = ""get""
    private const val IS_PREFIX = ""is""
    private const val SET_PREFIX = ""set""

    const val DELEGATED_PROPERTY_NAME_SUFFIX = ""\$delegate""
    const val DELEGATED_PROPERTIES_ARRAY_NAME = ""$\$delegatedProperties""
    const val DELEGATE_SUPER_FIELD_PREFIX = ""$\$delegate_""
    private const val ANNOTATIONS_SUFFIX = ""\$annotations""
    const val ANNOTATED_PROPERTY_METHOD_NAME_SUFFIX = ANNOTATIONS_SUFFIX
    private const val ANNOTATED_TYPEALIAS_METHOD_NAME_SUFFIX = ANNOTATIONS_SUFFIX

    const val INSTANCE_FIELD = ""INSTANCE""
    const val HIDDEN_INSTANCE_FIELD = ""$$$INSTANCE_FIELD""

    val REFLECTION_FACTORY_IMPL = ClassId.topLevel(FqName(""kotlin.reflect.jvm.internal.ReflectionFactoryImpl""))

    const val LOCAL_VARIABLE_NAME_PREFIX_INLINE_ARGUMENT = ""\$i\$a$""
    const val LOCAL_VARIABLE_NAME_PREFIX_INLINE_FUNCTION = ""\$i\$f$""

    const val IMPL_SUFFIX_FOR_INLINE_CLASS_MEMBERS = ""-impl""

    const val REPEATABLE_ANNOTATION_CONTAINER_NAME = ""Container""
    val REPEATABLE_ANNOTATION_CONTAINER_META_ANNOTATION = ClassId.fromString(""kotlin/jvm/internal/RepeatableContainer"")

    /**
     * @param baseName JVM name of the property getter since Kotlin 1.4, or Kotlin name of the property otherwise.
     */",@JvmStatic
"build(""assemble"") {
                assertTasksUpToDate("":app:kaptGenerateStubsKotlin"")
                assertTasksExecuted(
                    "":lib:compileKotlin"",
                    "":app:kaptKotlin""
                )
            }

            // enable discovery
            subProject(""app"").buildGradle.modify {
                it.replace(
                    ""kapt.includeCompileClasspath = true"",
                    ""kapt.includeCompileClasspath = false""
                )
            }
            build(""assemble"") {
                assertTasksUpToDate("":lib:compileKotlin"")
                assertTasksExecuted(
                    "":app:kaptGenerateStubsKotlin"",
                    "":app:kaptKotlin""
                )
            }

            libClassKt.modify { it.checkedReplace(replacement1, replacement2) }
            build(""assemble"") {
                assertTasksExecuted("":lib:compileKotlin"")
                assertTasksUpToDate("":app:kaptKotlin"", "":app:kaptGenerateStubsKotlin"")
            }
        }
    }

    @DisplayName(""KT19179 and KT37241: kapt is not skipped and does not generate stubs for non-existent entries"")
    @GradleTest
    open fun testKt19179andKt37241(gradleVersion: GradleVersion) {
        project(""kt19179"".withPrefix, gradleVersion) {

            build(""build"") {
                val processorSubproject = subProject(""processor"")
                processorSubproject
                    .assertFileInProjectExists(""build/tmp/kapt3/classes/main/META-INF/services/javax.annotation.processing.Processor"")

                val processorJar = processorSubproject.projectPath.resolve(""build/libs/processor.jar"")
                assertFileExists(processorJar)

                val zip = ZipFile(processorJar.toFile())
                @Suppress(""ConvertTryFinallyToUseCall"")
                try {
                    assert(zip.getEntry(""META-INF/services/javax.annotation.processing.Processor"") != null) {
                        ""Generated annotation processor jar file does not contain processor service entry!""
                    }
                } finally {
                    zip.close()
                }

                assertTasksExecuted(
                    "":processor:kaptGenerateStubsKotlin"",
                    "":processor:kaptKotlin"",
                    "":app:kaptGenerateStubsKotlin"",
                    "":app:kaptKotlin""
                )

                // Test for KT-37241, check the that non-existent classpath entry is filtered out:
                assertOutputDoesNotContain(""Classpath entry points to a non-existent location"")
            }","val testKt = subProject(""app"").kotlinSourcesDir().resolve(""Test.kt"")"
"): Boolean {
        // KT-13934: reference to companion object member via class name
        if (candidate.containingDeclaration.isCompanionObject() && kotlinCall.lhsResult is LHSResult.Type) return true

        if (callableReferenceAdaptation == null) return false

        return hasNonTrivialAdaptation(callableReferenceAdaptation)
    }

    private fun hasNonTrivialAdaptation(callableReferenceAdaptation: CallableReferenceAdaptation) =
        callableReferenceAdaptation.defaults != 0 ||
                callableReferenceAdaptation.suspendConversionStrategy != SuspendConversionStrategy.NO_CONVERSION ||
                callableReferenceAdaptation.coercionStrategy != CoercionStrategy.NO_COERCION ||
                callableReferenceAdaptation.mappedArguments.values.any { it is ResolvedCallArgument.VarargArgument }

    private fun getCallableReferenceAdaptation(
        descriptor: FunctionDescriptor,
        expectedType: UnwrappedType?,
        unboundReceiverCount: Int,
        builtins: KotlinBuiltIns
    ): CallableReferenceAdaptation? {
        if (expectedType == null || TypeUtils.noExpectedType(expectedType)) return null

        // Do not adapt references against KCallable type as it's impossible to map defaults/vararg to absent parameters of KCallable
        if (ReflectionTypes.hasKCallableTypeFqName(expectedType)) return null

        val inputOutputTypes = extractInputOutputTypesFromCallableReferenceExpectedType(expectedType) ?: return null

        val expectedArgumentCount = inputOutputTypes.inputTypes.size - unboundReceiverCount
        if (expectedArgumentCount < 0) return null

        val fakeArguments = createFakeArgumentsForReference(descriptor, expectedArgumentCount, inputOutputTypes, unboundReceiverCount)
        val argumentMapping =
            callComponents.argumentsToParametersMapper.mapArguments(fakeArguments, externalArgument = null, descriptor = descriptor)

        @OptIn(ApplicabilityDetail::class)
        if (argumentMapping.diagnostics.any { !it.candidateApplicability.isSuccess }) return null

        /**
         * (A, B, C) -> Unit
         * fun foo(a: A, b: B = B(), vararg c: C)
         */
        var defaults = 0
        var varargMappingState = VarargMappingState.UNMAPPED
        val mappedArguments = linkedMapOf<ValueParameterDescriptor, ResolvedCallArgument>()
        val mappedVarargElements = linkedMapOf<ValueParameterDescriptor, MutableList<KotlinCallArgument>>()
        val mappedArgumentTypes = arrayOfNulls<KotlinType?>(fakeArguments.size)

        for ((valueParameter, resolvedArgument) in argumentMapping.parameterToCallArgumentMap) {
            for (fakeArgument in resolvedArgument.arguments) {
                val index = (fakeArgument as FakeKotlinCallArgumentForCallableReference).index
                val substitutedParameter = descriptor.valueParameters.getOrNull(valueParameter.index) ?: continue

                val mappedArgument: KotlinType?
                if (substitutedParameter.isVararg) {
                    val (varargType, newVarargMappingState) = varargParameterTypeByExpectedParameter(
                        inputOutputTypes.inputTypes[index + unboundReceiverCount],
                        substitutedParameter,
                        varargMappingState,
                        builtins
                    )
                    varargMappingState = newVarargMappingState
                    mappedArgument = varargType

                    when (newVarargMappingState) {",VarargMappingState.MAPPED_WITH_ARRAY -> {
"// FIR_IDENTICAL
// FILE: a/x.java
package a;

public class x {

    public static final int I = 42;
    public static final int I1 = 42;
    public static final int I2 = I + I1;

}

// FILE: b/y.java
package b;

import static a.x.I;

public class y {
    public static final int O = I;
}

// FILE: b/z.java
package b;

import static a.x.*;",public class z {
"@Test
    fun code() {
        val codes = listOf(48, 65, 122, 946, '+'.code, ''.code, 0xFFFC)
        val chars = ""0Az+\uFFFC""
        assertEquals(codes, chars.map { it.code })
        assertEquals(0, Char.MIN_VALUE.code)
        assertEquals(0xFFFF, Char.MAX_VALUE.code)
    }

    @Test
    fun digitToInt() {
        fun testEquals(expected: Int, receiver: Char, radix: Int) {
            if (radix == 10) {
                assertEquals(expected, receiver.digitToInt())
                assertEquals(expected, receiver.digitToIntOrNull())
            }
            assertEquals(expected, receiver.digitToInt(radix))
            assertEquals(expected, receiver.digitToIntOrNull(radix))
        }

        fun testFails(receiver: Char, radix: Int) {
            if (radix == 10) {
                assertFails { receiver.digitToInt() }
                assertEquals(null, receiver.digitToIntOrNull())
            }
            assertFails { receiver.digitToInt(radix) }
            assertEquals(null, receiver.digitToIntOrNull(radix))
        }

        for (char in '0'..'9') {
            val digit = char - '0'

            for (radix in (digit + 1).coerceAtLeast(2)..36) {
                testEquals(digit, char, radix)
            }
            for (radix in 2..digit) {
                testFails(char, radix)
            }
        }

        val letterRanges = listOf('A'..'Z', '\uFF21'..'\uFF3A')

        for (range in letterRanges) {
            for (char in range) {
                val digit = 10 + (char - range.first)
                val lower = char.lowercaseChar()

                for (radix in digit + 1..36) {
                    testEquals(digit, char, radix)
                    testEquals(digit, lower, radix)
                }
                for (radix in 2..digit) {
                    testFails(char, radix)
                    testFails(lower, radix)
                }
            }
        }

        assertFails { '0'.digitToInt(radix = 37) }
        assertFails { '0'.digitToIntOrNull(radix = 37) }
        assertFails { '0'.digitToInt(radix = 1) }
        assertFails { '0'.digitToIntOrNull(radix = 1) }

        testFails('0' - 1, radix = 10)","testFails('9' + 1, radix = 10)"
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.lower

import org.jetbrains.kotlin.backend.common.lower.optimizations.PropertyAccessorInlineLowering
import org.jetbrains.kotlin.ir.backend.js.JsIrBackendContext
import org.jetbrains.kotlin.ir.declarations.IrDeclaration
import org.jetbrains.kotlin.ir.declarations.IrProperty
import org.jetbrains.kotlin.ir.util.fileOrNull
import org.jetbrains.kotlin.ir.util.isTopLevel

class JsPropertyAccessorInlineLowering(
    val context: JsIrBackendContext
) : PropertyAccessorInlineLowering(context) {
    override fun IrProperty.isSafeToInline(accessContainer: IrDeclaration): Boolean {
        if (!isSafeToInlineInClosedWorld())
            return false

        // Member properties could be safely inlined, because initialization processed via parent declaration
        if (!isTopLevel && !context.incrementalCacheEnabled)
            return true

        // Just undefined value
        if (symbol == context.intrinsics.void) {
            return true
        }

        // TODO: teach the deserializer to load constant property initializers
        val accessFile = accessContainer.fileOrNull ?: return false
        val file = fileOrNull ?: return false",return accessFile == file
"import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.expressions.FirExpression
import org.jetbrains.kotlin.fir.expressions.builder.buildExpressionStub
import org.jetbrains.kotlin.fir.resolve.defaultType
import org.jetbrains.kotlin.fir.resolve.transformers.setLazyPublishedVisibility
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.fir.symbols.impl.*
import org.jetbrains.kotlin.fir.toEffectiveVisibility
import org.jetbrains.kotlin.fir.types.*
import org.jetbrains.kotlin.fir.types.builder.buildResolvedTypeRef
import org.jetbrains.kotlin.fir.types.impl.ConeClassLikeTypeImpl
import org.jetbrains.kotlin.fir.types.impl.ConeTypeParameterTypeImpl
import org.jetbrains.kotlin.fir.types.impl.FirImplicitUnitTypeRef
import org.jetbrains.kotlin.metadata.ProtoBuf
import org.jetbrains.kotlin.metadata.deserialization.*
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.StandardClassIds
import org.jetbrains.kotlin.protobuf.MessageLite
import org.jetbrains.kotlin.serialization.deserialization.ProtoEnumFlags
import org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedContainerSource
import org.jetbrains.kotlin.serialization.deserialization.getName

class FirDeserializationContext(
    val nameResolver: NameResolver,
    val typeTable: TypeTable,
    val versionRequirementTable: VersionRequirementTable,
    val moduleData: FirModuleData,
    val packageFqName: FqName,
    val relativeClassName: FqName?,
    val typeDeserializer: FirTypeDeserializer,
    val annotationDeserializer: AbstractAnnotationDeserializer,
    val constDeserializer: FirConstDeserializer,
    val containerSource: DeserializedContainerSource?,
    val outerClassSymbol: FirRegularClassSymbol?,
    val outerTypeParameters: List<FirTypeParameterSymbol>
) {
    val session: FirSession = moduleData.session

    val allTypeParameters: List<FirTypeParameterSymbol> =
        typeDeserializer.ownTypeParameters + outerTypeParameters

    fun childContext(
        typeParameterProtos: List<ProtoBuf.TypeParameter>,
        containingDeclarationSymbol: FirBasedSymbol<*>,
        nameResolver: NameResolver = this.nameResolver,
        typeTable: TypeTable = this.typeTable,
        relativeClassName: FqName? = this.relativeClassName,
        containerSource: DeserializedContainerSource? = this.containerSource,
        outerClassSymbol: FirRegularClassSymbol? = this.outerClassSymbol,
        annotationDeserializer: AbstractAnnotationDeserializer = this.annotationDeserializer,
        constDeserializer: FirConstDeserializer = this.constDeserializer,
        capturesTypeParameters: Boolean = true,
    ): FirDeserializationContext = FirDeserializationContext(
        nameResolver,
        typeTable,
        versionRequirementTable,
        moduleData,
        packageFqName,
        relativeClassName,
        typeDeserializer.forChildContext(
            typeParameterProtos, containingDeclarationSymbol, nameResolver, typeTable, annotationDeserializer
        ),
        annotationDeserializer,","constDeserializer,"
"//      {   // SAFE_CALL
            //          val tmp = <safe_receiver>
            //          when {
            //              tmp == null -> null
            //              else -> <safe_call_result>
            //          }
            //      }
            val safeCallBlock = safeCallInfo.block
            val startOffset = safeCallBlock.startOffset
            val endOffset = safeCallBlock.endOffset
            val safeCallType = safeCallBlock.type
            val safeCallTmpVal = safeCallInfo.tmpVal

            val tmpValInitializer = safeCallTmpVal.initializer
            if (tmpValInitializer is IrBlock && tmpValInitializer.origin == JvmLoweredStatementOrigin.FOLDED_SAFE_CALL) {
                // Chained safe call.
                // If <safe_receiver> is a FOLDED_SAFE_CALL form, rewrite safe call to:
                //      {   // FOLDED_SAFE_CALL
                //          when {
                //              <safe_receiver_condition> && { val tmp = <safe_receiver_result>; tmp != null } ->
                //                  <safe_call_result>
                //              else ->
                //                  null
                //          }
                //      }
                //    where
                //      <safe_receiver> =
                //          {   // FOLDED_SAFE_CALL
                //              when {
                //                  <safe_receiver_condition> -> <safe_receiver_result>
                //                  else -> null
                //              }
                //          }
                val foldedBlock: IrBlock = tmpValInitializer
                val foldedWhen = foldedBlock.statements[0] as IrWhen
                val safeReceiverCondition = foldedWhen.branches[0].condition
                val safeReceiverResult = foldedWhen.branches[0].result
                safeCallTmpVal.initializer = safeReceiverResult
                safeCallTmpVal.type = safeReceiverResult.type
                val foldedConditionPart =
                    IrCompositeImpl(
                        startOffset, endOffset, context.irBuiltIns.booleanType, null,
                        listOf<IrStatement>(
                            safeCallTmpVal,
                            irValNotNull(startOffset, endOffset, safeCallTmpVal)
                        )
                    )
                foldedBlock.type = safeCallType
                foldedWhen.type = safeCallType
                foldedWhen.branches[0].condition = irAndAnd(safeReceiverCondition, foldedConditionPart)
                foldedWhen.branches[0].result = safeCallInfo.ifNotNullBranch.result
                return foldedBlock
            } else {
                // Simple safe call.
                // If <safe_receiver> itself is not a FOLDED_SAFE_CALL form, rewrite safe call to:
                //      {   // FOLDED_SAFE_CALL
                //          when {
                //              { val tmp = <safe_receiver>; tmp != null } ->
                //                  <safe_call_result>
                //              else ->
                //                  null
                //          }
                //      }

                val foldedCondition =",IrCompositeImpl(
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See native/swift/sir/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"", ""unused"")

package org.jetbrains.kotlin.sir.builder

import kotlin.contracts.*
import org.jetbrains.kotlin.sir.*
import org.jetbrains.kotlin.sir.impl.SirInitImpl",@SirBuilderDsl
"// FIR_IDENTICAL
// !LANGUAGE: -RepeatableAnnotations
// FULL_JDK
// FILE: Runtime.java",import java.lang.annotation.*;
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package org.jetbrains.kotlin.fir.resolve
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.light.classes.symbol.annotations

import com.intellij.psi.*
import com.intellij.psi.impl.light.LightIdentifier
import org.jetbrains.kotlin.asJava.classes.cannotModify
import org.jetbrains.kotlin.asJava.classes.lazyPub
import org.jetbrains.kotlin.asJava.elements.KtLightElementBase
import org.jetbrains.kotlin.light.classes.symbol.toAnnotationMemberValue
import org.jetbrains.kotlin.psi.KtElement

internal class SymbolNameValuePairForAnnotationArgument(
    private val constantValue: AnnotationArgument,
    parent: PsiAnnotationParameterList,
) : KtLightElementBase(parent), PsiNameValuePair {

    override val kotlinOrigin: KtElement? get() = constantValue.value.sourcePsi

    private val _value by lazyPub {
        constantValue.value.toAnnotationMemberValue(this)
    }

    override fun setValue(newValue: PsiAnnotationMemberValue) = cannotModify()

    private val _nameIdentifier: PsiIdentifier by lazyPub {
        LightIdentifier(manager, constantValue.name.asString())
    }

    override fun getNameIdentifier(): PsiIdentifier = _nameIdentifier

    override fun getValue(): PsiAnnotationMemberValue? = _value

    override fun getLiteralValue(): String? = (value as? PsiLiteralExpression)?.value?.toString()

    override fun getName(): String = constantValue.name.asString()",override fun accept(visitor: PsiElementVisitor) {
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.interpreter.intrinsics

import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.interpreter.*
import org.jetbrains.kotlin.ir.interpreter.exceptions.handleUserException
import org.jetbrains.kotlin.ir.interpreter.exceptions.stop
import org.jetbrains.kotlin.ir.interpreter.exceptions.withExceptionHandler
import org.jetbrains.kotlin.ir.interpreter.state.*
import org.jetbrains.kotlin.ir.interpreter.state.reflection.KFunctionState
import org.jetbrains.kotlin.ir.interpreter.state.reflection.KPropertyState
import org.jetbrains.kotlin.ir.interpreter.state.reflection.KTypeState
import org.jetbrains.kotlin.ir.types.*
import org.jetbrains.kotlin.ir.types.impl.buildSimpleType
import org.jetbrains.kotlin.ir.types.impl.makeTypeProjection
import org.jetbrains.kotlin.ir.util.toIrConst
import org.jetbrains.kotlin.types.Variance
import java.util.*

internal sealed class IntrinsicBase {
    abstract fun getListOfAcceptableFunctions(): List<String>","abstract fun evaluate(irFunction: IrFunction, environment: IrInterpreterEnvironment)"
"// DIAGNOSTICS: -UNUSED_EXPRESSION

fun ifExpr() = try {
    if (true) 2
    <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 2
} catch (e: Exception) {
    if (true) 3
    <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 3
} catch (e: Throwable) {
    if (true) 4
    <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 4
} finally {
    if (true) 5
    if (true) 5
}

fun ifBlock() = try {
    if (true) {
        2
    }
    <!INVALID_IF_AS_EXPRESSION!>if<!> (true) {
        2
    }
} catch (e: Exception) {
    if (true) {
        3
    }
    <!INVALID_IF_AS_EXPRESSION!>if<!> (true) {
        3
    }
} catch (e: Throwable) {
    if (true) {
        4
    }
    <!INVALID_IF_AS_EXPRESSION!>if<!> (true) {
        4
    }
} finally {
    if (true) {
        5
    }
    if (true) {
        5
    }
}

fun whenExpr() = try {
    when {
        true -> 2
    }
    <!NO_ELSE_IN_WHEN!>when<!> {
        true -> 2
    }
} catch (e: Exception) {
    when {
        true -> 3
    }
    <!NO_ELSE_IN_WHEN!>when<!> {
        true -> 3
    }
} catch (e: Throwable) {
    when {
        true -> 4
    }
    <!NO_ELSE_IN_WHEN!>when<!> {",true -> 4
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.calls.checkers

import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.descriptors.PropertyDescriptor",import org.jetbrains.kotlin.diagnostics.Errors
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin.mpp.compilationImpl

import org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet
import org.jetbrains.kotlin.gradle.plugin.sources.internal
import org.jetbrains.kotlin.gradle.utils.MutableObservableSet
import org.jetbrains.kotlin.gradle.utils.MutableObservableSetImpl
import org.jetbrains.kotlin.gradle.utils.ObservableSet

internal fun KotlinCompilationSourceSetsContainer(
    defaultSourceSet: KotlinSourceSet
): KotlinCompilationSourceSetsContainer {
    return DefaultKotlinCompilationSourceSetsContainer(defaultSourceSet)
}

internal interface KotlinCompilationSourceSetsContainer {
    val defaultSourceSet: KotlinSourceSet
    val kotlinSourceSets: ObservableSet<KotlinSourceSet>
    val allKotlinSourceSets: ObservableSet<KotlinSourceSet>",fun source(sourceSet: KotlinSourceSet)
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.targets.js.yarn

import org.gradle.api.Plugin
import org.gradle.api.Project
import org.jetbrains.kotlin.gradle.targets.js.MultiplePluginDeclarationDetector
import org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootPlugin
import org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootPlugin.Companion.kotlinNodeJsExtension
import org.jetbrains.kotlin.gradle.targets.js.npm.LockCopyTask
import org.jetbrains.kotlin.gradle.targets.js.npm.tasks.KotlinNpmInstallTask
import org.jetbrains.kotlin.gradle.tasks.CleanDataTask
import org.jetbrains.kotlin.gradle.tasks.registerTask
import org.jetbrains.kotlin.gradle.utils.detachedResolvable

open class YarnPlugin : Plugin<Project> {
    override fun apply(project: Project): Unit = project.run {
        MultiplePluginDeclarationDetector.detect(project)

        check(project == project.rootProject) {
            ""YarnPlugin can be applied only to root project""
        }

        val yarnRootExtension = this.extensions.create(YarnRootExtension.YARN, YarnRootExtension::class.java, this)
        NodeJsRootPlugin.apply(project)
        val nodeJs = this.kotlinNodeJsExtension
        val nodeJsTaskProviders = this.kotlinNodeJsExtension

        yarnRootExtension.platform.value(nodeJs.platform)
            .disallowChanges()

        nodeJs.packageManagerExtension.set(
            yarnRootExtension
        )

        val setupTask = registerTask<YarnSetupTask>(YarnSetupTask.NAME) {
            it.dependsOn(nodeJsTaskProviders.nodeJsSetupTaskProvider)

            it.group = NodeJsRootPlugin.TASKS_GROUP_NAME
            it.description = ""Download and install a local yarn version""

            it.configuration = provider {
                this.project.configurations.detachedResolvable(this.project.dependencies.create(it.ivyDependency))
                    .also { conf -> conf.isTransitive = false }
            }
        }

        val kotlinNpmInstall = tasks.named(KotlinNpmInstallTask.NAME)",kotlinNpmInstall.configure {
"// FIR_IDENTICAL
// WITH_STDLIB
// MODULE: m1-common
// FILE: common.kt
import kotlin.reflect.KClass

annotation class Ann(val clazz: KClass<*>)

@Ann(LinkToExpectInnerClass.Inner::class)
expect class LinkToExpectInnerClass {
    object Inner
}

expect class WillBeTypealiased

@Ann(WillBeTypealiased::class)
expect fun linkToExpectClassWhichWillBeTypealiased()

@Ann(WillBeTypealiased::class)
expect fun linkToExpectClassWhichWillBeTypealiased2()

// MODULE: m1-jvm()()(m1-common)
// FILE: jvm.kt
@Ann(LinkToExpectInnerClass.Inner::class)
actual class LinkToExpectInnerClass {
    actual object Inner
}

actual typealias WillBeTypealiased = Any

@Ann(WillBeTypealiased::class)
actual fun linkToExpectClassWhichWillBeTypealiased() {}

@Ann(Any::class)",actual fun linkToExpectClassWhichWillBeTypealiased2() {}
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.konan.test.blackbox.support.compilation

import org.jetbrains.kotlin.cli.common.ExitCode",import org.jetbrains.kotlin.konan.properties.resolvablePropertyList
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.components

import com.intellij.psi.PsiElement
import com.intellij.psi.PsiType
import org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion
import org.jetbrains.kotlin.analysis.api.types.KtType
import org.jetbrains.kotlin.analysis.api.types.KtTypeMappingMode

public abstract class KtPsiTypeProvider : KtAnalysisSessionComponent() {
    public abstract fun asPsiType(
        type: KtType,
        useSitePosition: PsiElement,
        allowErrorTypes: Boolean,
        mode: KtTypeMappingMode,
        isAnnotationMethod: Boolean,
        suppressWildcards: Boolean?,
        preserveAnnotations: Boolean,
    ): PsiType?

    public abstract fun asKtType(
        psiType: PsiType,
        useSitePosition: PsiElement,",): KtType?
"var modifier = PsiModifier.FINAL
            project.applyCompilerPlugins {
                modifier = it.interceptModalityBuilding(declaration, descriptor, modifier)
            }
            return modifier == PsiModifier.FINAL
        }

        private fun hasModifier(name: String): Boolean {
            if (name == PsiModifier.PUBLIC || name == PsiModifier.PROTECTED || name == PsiModifier.PRIVATE) {
                if (forcePrivate || declaration.isPrivate() || accessedProperty?.isPrivate() == true) {
                    return name == PsiModifier.PRIVATE
                }
                if (declaration.hasModifier(PROTECTED_KEYWORD) ||
                    accessedProperty?.hasModifier(PROTECTED_KEYWORD) == true ||
                    (declaration is KtConstructor<*> && containingClassIsSealed)
                ) {
                    return name == PsiModifier.PROTECTED
                }

                if (outerDeclaration.hasModifier(OVERRIDE_KEYWORD)) {
                    when ((outerDeclaration.resolve() as? CallableDescriptor)?.visibility) {
                        DescriptorVisibilities.PUBLIC -> return name == PsiModifier.PUBLIC
                        DescriptorVisibilities.PRIVATE -> return name == PsiModifier.PRIVATE
                        DescriptorVisibilities.PROTECTED -> return name == PsiModifier.PROTECTED
                    }
                }

                return name == PsiModifier.PUBLIC
            }

            return when (name) {
                PsiModifier.FINAL ->
                    !forceNonFinal && !containingClass.isInterface && outerDeclaration !is KtConstructor<*> && isFinal(outerDeclaration)

                PsiModifier.ABSTRACT -> containingClass.isInterface || outerDeclaration.hasModifier(ABSTRACT_KEYWORD)
                PsiModifier.STATIC ->
                    forceStatic || containingClassIsNamedObject && (outerDeclaration.isJvmStatic(support) || declaration.isJvmStatic(support))

                PsiModifier.STRICTFP -> declaration is KtFunction && declaration.hasAnnotation(STRICTFP_ANNOTATION_FQ_NAME)
                PsiModifier.SYNCHRONIZED -> declaration is KtFunction && declaration.hasAnnotation(SYNCHRONIZED_ANNOTATION_FQ_NAME)
                PsiModifier.NATIVE -> declaration is KtFunction && declaration.hasModifier(EXTERNAL_KEYWORD)
                else -> false
            }
        }

        private fun KtDeclaration.isPrivate() =
            hasModifier(PRIVATE_KEYWORD) || isInlineOnly()

        private fun KtDeclaration.isInlineOnly(): Boolean {
            if (this !is KtCallableDeclaration || !hasModifier(INLINE_KEYWORD)) return false
            if (annotationEntries.isEmpty()) return false

            val descriptor = resolve() as? CallableMemberDescriptor ?: return false

            return descriptor.isInlineOnly()
        }
    }

    private fun lightMethod(
        name: String,
        declaration: KtDeclaration,
        forceStatic: Boolean,
        forcePrivate: Boolean = false,
        forceNonFinal: Boolean = false,
    ): LightMethodBuilder {",val accessedProperty = if (declaration is KtPropertyAccessor) declaration.property else null
"// IGNORE_BACKEND_K2: JVM_IR, JS_IR, JS_IR_ES6, NATIVE, WASM
// FIR status: expect/actual in the same module (ACTUAL_WITHOUT_EXPECT)
// !LANGUAGE: +MultiPlatformProjects
// !OPT_IN: kotlin.ExperimentalMultiplatform
// WITH_STDLIB
// MODULE: library
// FILE: expected.kt

package a

@OptionalExpectation
expect annotation class A(val x: Int)

@OptionalExpectation
expect annotation class B(val s: String) {
    @OptionalExpectation
    annotation class C(val a: Boolean)
}

// FILE: actual.kt

package a

actual annotation class A(actual val x: Int)

// MODULE: main(library)
// FILE: main.kt

@file:Suppress(""OPTIONAL_DECLARATION_USAGE_IN_NON_COMMON_SOURCE"") // TODO: support common sources in the test infrastructure",package usage
"print("": "")
        val type = declaration.backingField?.type
            ?: declaration.getter?.returnType
            ?: error(""Couldn't find return type"")
        print(type.renderSrc())
        declaration.backingField?.let { field ->
            field.initializer?.let { initializer ->
                print("" = "")
                initializer.print()
            }
        }
        indented {
            declaration.getter?.scoped {
                if (it.origin != IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR) {
                    println()
                    it.printAnnotations()
                    println()
                    println(""get() {"")
                    indented {
                        it.body?.accept(this, null)
                    }
                    println()
                    println(""}"")
                }
            }
            declaration.setter?.scoped {
                if (it.origin != IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR) {
                    println()
                    it.printAnnotations()
                    println(""set(value) {"")
                    indented {
                        it.body?.accept(this, null)
                    }
                    println()
                    println(""}"")
                }
            }
        }
    }

    private var printIntsAsBinary = false
    fun <T> withIntsAsBinaryLiterals(block: () -> T): T {
        val prev = printIntsAsBinary
        try {
            printIntsAsBinary = true
            return block()
        } finally {
            printIntsAsBinary = prev
        }
    }

    private fun intAsBinaryString(value: Int): String {
        if (value == 0) return ""0""
        var current = if (value >= 0) value else value.inv()
        var result = """"
        while (current != 0 || result.length % 4 != 0) {
            val nextBit = current and 1 != 0
            current = current ushr 1
            result = ""${if (nextBit) ""1"" else ""0""}$result""
        }
        return ""0b$result"" + if (value < 0) "".inv()"" else """"
    }

    override fun visitConst(expression: IrConst<*>) {
        val result = when (expression.kind) {","is IrConstKind.Null -> ""${expression.value}"""
"// JSPECIFY_STATE: warn
// LANGUAGE: +JavaTypeParameterDefaultRepresentationWithDNN
// DIAGNOSTICS: -UNUSED_PARAMETER

// FILE: NullMarkedType.java

import org.jspecify.annotations.*;

@NullMarked
public class NullMarkedType {",public static class TargetType<
"@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedIterable"")
@kotlin.internal.InlineOnly
public inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {
    return flatMapIndexedTo(ArrayList<R>(), transform)
}

/**
 * Returns a single list of all elements yielded from results of [transform] function being invoked on each element
 * and its index in the original array.
 * 
 * @sample samples.collections.Collections.Transformations.flatMapIndexed
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedIterable"")
@kotlin.internal.InlineOnly
public inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {
    return flatMapIndexedTo(ArrayList<R>(), transform)
}

/**
 * Returns a single list of all elements yielded from results of [transform] function being invoked on each element
 * and its index in the original array.
 * 
 * @sample samples.collections.Collections.Transformations.flatMapIndexed
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedIterable"")
@kotlin.internal.InlineOnly
public inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {
    return flatMapIndexedTo(ArrayList<R>(), transform)
}

/**
 * Returns a single list of all elements yielded from results of [transform] function being invoked on each element
 * and its index in the original array.
 * 
 * @sample samples.collections.Collections.Transformations.flatMapIndexed
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedSequence"")
@kotlin.internal.InlineOnly
public inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {
    return flatMapIndexedTo(ArrayList<R>(), transform)
}

/**
 * Appends all elements yielded from results of [transform] function being invoked on each element
 * and its index in the original array, to the given [destination].
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedIterableTo"")
@kotlin.internal.InlineOnly
public inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {
    var index = 0
    for (element in this) {","val list = transform(index++, element)"
"public <T> void foo2(@Nullable T a) {}

    public <T> @Nullable T bar2() { return null; }

    public <T> void foo3(@Nullable JavaBox<T> a) {}

    public <T> @Nullable JavaBox<T> bar3() { return null; }

    public <T> void foo4(@NotNull JavaBox<T> a) {}

    public <T> @NotNull JavaBox<T> bar4() { return null; }

    public <T> void foo5(@Nullable JavaBox<@Nullable T> a) {}

    public <T> @Nullable JavaBox<@Nullable T> bar5() { return null; }

    public <T> void foo6(@NotNull JavaBox<@NotNull T> a) {}

    public <T> @NotNull JavaBox<@NotNull T> bar6() { return null; }

    public <T extends @NotNull Object> void foo7(T a) {}

    public <T extends @NotNull Object> T bar7() { return null; }

    public <T extends @Nullable Object> void foo8(T a) {}

    public <T extends @Nullable Object> T bar8() { return null; }

    public <T extends @Nullable Object> void foo9(JavaBox<T> a) {}

    public <T extends @Nullable Object> JavaBox<T> bar9() { return null; }

    public <T extends @NotNull Object> void foo10(JavaBox<T> a) {}

    public <T extends @NotNull Object> JavaBox<T> bar10() { return null; }
}

// FILE: JavaBox.java
public class JavaBox<T> {
    public JavaBox(T b) {
        a = b;
    }
    public T a;
}

// FILE: Test.kt
fun genericFunWithAnnotations(x: GenericFunWithAnnotation) {
    x.foo("""")
    x.foo(<!NULL_FOR_NONNULL_TYPE!>null<!>)
    takeString(x.bar())

    x.foo2("""")
    x.foo2(null)
    takeString(<!TYPE_MISMATCH!>x.bar2()<!>)

    x.<!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo3<!>(null)
    x.foo3<String>(null)
    x.foo3<String?>(null)
    x.foo3(JavaBox(null))
    x.foo3<String>(JavaBox(null))
    x.foo3<String?>(JavaBox(null))
    x.foo3(JavaBox(""""))
    takeString(x.<!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar3<!>()?.<!DEBUG_INFO_MISSING_UNRESOLVED!>a<!>)",x.foo4(JavaBox(null))
"// !LANGUAGE: +OverloadResolutionByLambdaReturnType
// ALLOW_KOTLIN_PACKAGE
// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -UNUSED_EXPRESSION
// ISSUE: KT-11265

// FILE: OverloadResolutionByLambdaReturnType.kt

package kotlin

annotation class OverloadResolutionByLambdaReturnType

// FILE: main.kt

import kotlin.OverloadResolutionByLambdaReturnType

@OverloadResolutionByLambdaReturnType
fun create(f: (Int) -> Int): Int = 1
fun create(f: (Int) -> String): String = """"

fun takeString(s: String) {}
fun takeInt(s: Int) {}

fun test_1() {
    val x = create { """" }
    takeString(x)
}

fun test_2() {
    val x = create { 1 }
    takeInt(x)
}

fun test_3() {
    val x = create { <!ARGUMENT_TYPE_MISMATCH!>1.0<!> }
}

@OverloadResolutionByLambdaReturnType","fun <K> create(x: K, f: (K) -> Int): Int = 1"
"+isFakeOverrideField()
        +referencedSymbolList(""overriddenSymbols"", s) {
            skipInIrFactory()
        }
    }
    val memberWithContainerSource: Element by element(Declaration) {
        parent(declarationWithName)

        +field(""containerSource"", type<DeserializedContainerSource>(), nullable = true, mutable = false) {
            useFieldInIrFactory(defaultValue = ""null"")
        }
    }
    val valueDeclaration: Element by element(Declaration) {
        parent(declarationWithName)
        parent(symbolOwner)

        +descriptor(""ValueDescriptor"")
        +declaredSymbol(valueSymbolType)
        +field(""type"", irTypeType)
    }
    val valueParameter: Element by element(Declaration) {
        needTransformMethod()

        parent(declarationBase)
        parent(valueDeclaration)

        +descriptor(""ParameterDescriptor"")
        +field(""isAssignable"", boolean, mutable = false)
        +declaredSymbol(valueParameterSymbolType)
        +field(""index"", int)
        +field(""varargElementType"", irTypeType, nullable = true)
        +field(""isCrossinline"", boolean)
        +field(""isNoinline"", boolean)
        +field(""isHidden"", boolean) {
            kDoc = """"""
            If `true`, the value parameter does not participate in [${idSignatureType.render()}] computation.

            This is a workaround that is needed for better support of compiler plugins.
            Suppose you have the following code and some IR plugin that adds a value parameter to functions
            marked with the `@PluginMarker` annotation.
            ```kotlin
            @PluginMarker
            fun foo(defined: Int) { /* ... */ }
            ```

            Suppose that after applying the plugin the function is changed to:
            ```kotlin
            @PluginMarker
            fun foo(defined: Int, ${'$'}extra: String) { /* ... */ }
            ```

            If a compiler plugin adds parameters to an [${function.render()}],
            the representations of the function in the frontend and in the backend may diverge, potentially causing signature mismatch and
            linkage errors (see [KT-40980](https://youtrack.jetbrains.com/issue/KT-40980)).
            We wouldn't want IR plugins to affect the frontend representation, since in an IDE you'd want to be able to see those
            declarations in their original form (without the `${'$'}extra` parameter).

            To fix this problem, [$name] was introduced.
            
            TODO: consider dropping [$name] if it isn't used by any known plugin.
            """""".trimIndent()
        }
        +field(""defaultValue"", expressionBody, nullable = true)
    }
    val `class`: Element by element(Declaration) {",parent(declarationBase)
"/**
 * Returns the last element matching the given [predicate].
 * 
 * @throws NoSuchElementException if no such element is found.
 * 
 * @sample samples.collections.Collections.Elements.last
 */
public inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {
    for (index in this.indices.reversed()) {
        val element = this[index]
        if (predicate(element)) return element
    }
    throw NoSuchElementException(""Array contains no element matching the predicate."")
}

/**
 * Returns the last element matching the given [predicate].
 * 
 * @throws NoSuchElementException if no such element is found.
 * 
 * @sample samples.collections.Collections.Elements.last
 */
public inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {
    for (index in this.indices.reversed()) {
        val element = this[index]
        if (predicate(element)) return element
    }
    throw NoSuchElementException(""Array contains no element matching the predicate."")
}

/**
 * Returns the last element matching the given [predicate].
 * 
 * @throws NoSuchElementException if no such element is found.
 * 
 * @sample samples.collections.Collections.Elements.last
 */
public inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {
    for (index in this.indices.reversed()) {
        val element = this[index]
        if (predicate(element)) return element
    }
    throw NoSuchElementException(""Array contains no element matching the predicate."")
}

/**
 * Returns the last element matching the given [predicate].
 * 
 * @throws NoSuchElementException if no such element is found.
 * 
 * @sample samples.collections.Collections.Elements.last
 */
public inline fun CharArray.last(predicate: (Char) -> Boolean): Char {
    for (index in this.indices.reversed()) {
        val element = this[index]
        if (predicate(element)) return element
    }
    throw NoSuchElementException(""Array contains no element matching the predicate."")
}

/**
 * Returns last index of [element], or -1 if the array does not contain element.
 */
public fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {
    if (element == null) {",for (index in indices.reversed()) {
"infix fun UserKlass.testDifferencesInInfixModifierPresenceReverse(arg: UserKlass) {}
    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) fun UserKlass.testDifferencesInInfixModifierPresenceReverse(arg: UserKlass) {}


    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) operator fun UserKlassA.unaryPlus() {}
    operator fun UserKlassA.unaryPlus() {}

    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) operator fun UserKlassB.unaryPlus() {}
    fun UserKlassB.unaryPlus() {}

    operator fun UserKlassB.unaryMinus() {}
    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) fun UserKlassB.unaryMinus() {}


    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) tailrec fun testIdenticalPresenceOfTailrecModifier() {}
    tailrec fun testIdenticalPresenceOfTailrecModifier() {}

    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) tailrec fun testDifferencesInTailrecModifierPresence() {}
    fun testDifferencesInTailrecModifierPresence() {}

    tailrec fun testDifferencesInTailrecModifierPresenceReverse() {}
    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) fun testDifferencesInTailrecModifierPresenceReverse() {}


    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) private fun testIdenticalPrivateVisibility() {}
    private fun testIdenticalPrivateVisibility() {}

    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) internal fun testIdenticalInternalVisibility() {}
    internal fun testIdenticalInternalVisibility() {}

    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) private fun testDifferencesInPrivateAndPublicVisibilities() {}
    public fun testDifferencesInPrivateAndPublicVisibilities() {}

    private fun testDifferencesInPrivateAndPublicVisibilitiesReverse() {}
    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) public fun testDifferencesInPrivateAndPublicVisibilitiesReverse() {}

    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) internal fun testDifferencesInInternalAndPublicVisibilities() {}
    public fun testDifferencesInInternalAndPublicVisibilities() {}

    internal fun testDifferencesInInternalAndPublicVisibilitiesReverse() {}
    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) public fun testDifferencesInInternalAndPublicVisibilitiesReverse() {}

    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) private fun testDifferencesInPrivateAndInternalVisibilities() {}
    internal fun testDifferencesInPrivateAndInternalVisibilities() {}

    private fun testDifferencesInPrivateAndInternalVisibilitiesReverse() {}
    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) internal fun testDifferencesInPrivateAndInternalVisibilitiesReverse() {}


}


open class Invariant<T>


class UserKlass
class UserKlassA
class UserKlassB
typealias SameUserKlass = UserKlass
typealias SameUserKlassA = UserKlassA
typealias SameUserKlassB = UserKlassB


val defaultArgument = UserKlass()",val defaultArgumentA = UserKlass()
"// TARGET_BACKEND: JVM
// This test checks that JVM-specific static initialization behavior is preserved in JVM_IR.

var testObjectInit = false
var testClassCompanionInit = false
var testInterfaceCompanionInit = false

fun use(x: Int) {}

object TestObject {
    init {
        testObjectInit = true
    }
    const val x = 42
}

fun getTestObject() = TestObject

class TestClassCompanion {
    companion object {
        init {
            testClassCompanionInit = true
        }
        const val x = 42
    }
}

fun getTestClassCompanion() = TestClassCompanion

class TestInterfaceCompanion {
    companion object {
        init {
            testInterfaceCompanionInit = true
        }
        const val x = 42
    }
}

fun getInterfaceCompanion() = TestInterfaceCompanion

fun box(): String {
    use(TestObject.x)
    if (testObjectInit)
        throw Exception(""use(TestObject.x)"")

    use((TestObject).x)
    if (testObjectInit)
        throw Exception(""use((TestObject).x)"")

    use(getTestObject().x)
    if (!testObjectInit)
        throw Exception(""use(getTestObject().x)"")

    use(TestClassCompanion.x)
    if (testClassCompanionInit)
        throw Exception(""use(TestClassCompanion.x)"")

    use((TestClassCompanion).x)
    if (testClassCompanionInit)
        throw Exception(""use((TestClassCompanion).x)"")",use(getTestClassCompanion().x)
"package org.jetbrains.ring

import kotlin.native.concurrent.*
import kotlin.concurrent.*
import org.jetbrains.benchmarksLauncher.Blackhole
import org.jetbrains.benchmarksLauncher.Random

data class Pos(val i: Int, val j: Int)

data class Cell(val isAlive: Boolean = false)

class Generation(private val width: Int, private val height: Int) {
    val cells = Array(height) { _ -> Array(width) { _ -> Cell() } }

    fun evolve(): Generation {
        val newGen = Generation(width, height)

        for (i in 0 until height) {
            for (j in 0 until width) {
                val neighborhood = mutableListOf<Pos>()
                for (di in -1..1) {",for (dj in -1..1) {
"select({ x, y -> x.inv() + y.toByte() }, id { x: Int, y -> y.toByte() }, id { x, y: Number -> x.inv() })

    // Inferring lambda parameter types by other specified lambda parameters; expected type is a functional type with type variables in parameter types
    takeLambdas({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Nothing"")!>it<!> }, { x: Int -> }, { x: Nothing -> x })
    takeLambdas({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Nothing"")!>it<!> }, { } as (Int) -> Unit, { x: Nothing -> x })
    takeLambdas({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Nothing"")!>it<!> }, { } as (Nothing) -> Unit, { x: Int -> x })
    takeLambdas({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Nothing"")!>it<!> }, { } as (Int) -> Unit, { } as (Nothing) -> Unit)

    // Inferring lambda parameter types by other specified lambda parameters; expected type is a functional type with type variables in parameter types; dependent type parameters
    takeLambdasWithDirectlyDependentTypeParameters({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> }, { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> }, { x: Int -> x })
    takeLambdasWithDirectlyDependentTypeParameters({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> }, { x: Number -> x }, { x: Int -> x })
    takeLambdasWithInverselyDependentTypeParameters({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> }, { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> }, { x: Int -> x })
    /*
     * Interesting test case: variable can be fixed to different types randomly (`Int` or `Number`; it depends on variable fixation order)
     * if in `TypeVariableDependencyInformationProvider` `hashSet` instead of `linkedSet` for `deepTypeVariableDependencies` and `shallowTypeVariableDependencies` will be used
     */
    takeLambdasWithInverselyDependentTypeParameters({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>it<!> }, { x: Number -> x }, { x: Int -> x })

    // Inferring lambda parameter types by subtypes of functional type
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int, kotlin.String, kotlin.Float) -> kotlin.Float"")!>select(A2(), { a, b, c -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>a<!>; <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String"")!>b<!>; <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float"")!>c<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Number) -> java.io.Serializable"")!>select(A3(), { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>it<!> }, { a -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>a<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction<kotlin.Any>"")!>select(A3(), <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>)<!>
    // Should be error as `A3::foo1` is `KFunction2`, but the remaining arguments are `KFuncion1` or `Function1`
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(A3(), <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>, { <!CANNOT_INFER_PARAMETER_TYPE!>a<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>a<!> }, { <!CANNOT_INFER_PARAMETER_TYPE!>it<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>it<!> })<!>
    // It's OK because `A3::foo2` is from companion of `A3`
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int) -> kotlin.Any"")!>select(A3(), <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction1<kotlin.Int, kotlin.Unit>"")!>A3::foo2<!>, { a -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>a<!> }, { it -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int) -> {Comparable<*> & java.io.Serializable}"")!>select(A4(), { x: Number -> """" })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int, kotlin.Int) -> {Comparable<*> & java.io.Serializable}"")!>select(A5<Int, Int>(), { x: Number, y: Int -> """" })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int, kotlin.String, kotlin.Float) -> kotlin.Float"")!>select(A2(), id { a, b, c -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>a<!>; <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String"")!>b<!>; <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float"")!>c<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Number) -> java.io.Serializable"")!>select(id(A3()), { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>it<!> }, { a -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>a<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction<kotlin.Any>"")!>select(A3(), id(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>))<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(A3(), <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>, id { <!CANNOT_INFER_PARAMETER_TYPE!>a<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>a<!> }, { <!CANNOT_INFER_PARAMETER_TYPE!>it<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>it<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(A3(), <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>, { <!CANNOT_INFER_PARAMETER_TYPE!>a<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>a<!> }, id { <!CANNOT_INFER_PARAMETER_TYPE!>it<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>it<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(id(A3()), id(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>), { <!CANNOT_INFER_PARAMETER_TYPE!>a<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>a<!> }, { <!CANNOT_INFER_PARAMETER_TYPE!>it<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>it<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(id(A3()), id(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>), { <!CANNOT_INFER_PARAMETER_TYPE!>a<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>a<!> }, id { <!CANNOT_INFER_PARAMETER_TYPE!>it<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>it<!> })<!>
    // If lambdas' parameters are specified explicitly, we don't report an error, because there is proper CST  Function<Unit>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(id(A3()), id(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>), { a: Number -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>a<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(id(A3()), id(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>), id { a: Number -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>a<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int) -> kotlin.Number"")!>select(A4(), id { x: Number -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>x<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int, kotlin.Int) -> {Comparable<*> & Number}"")!>select(id(A5<Int, Int>()), id { x: Number, y: Int -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>x<!>;<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>y<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int, kotlin.Int) -> {Comparable<*> & Number}"")!>select(id(A5<Int, Int>()), id { x, y -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>x<!>;<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>y<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Number, kotlin.Int) -> {Comparable<*> & Number}"")!>select(id(<!DEBUG_INFO_EXPRESSION_TYPE(""A5<kotlin.Number, kotlin.Int>"")!>A5()<!>), id { x: Number, y: Int -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>x<!>;<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>y<!> })<!>
    val x55: Function2<Number, Int, Float> = select(id(A5()), id { x, y -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>x<!>;<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>y<!>; 1f })

    // Diffrerent lambda's parameters with proper CST
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function1<*, kotlin.Unit>"")!>select({ x: Int -> }, { x: String -> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Unit>"")!>select({ x: Int -> }, { x: Int, y: Number -> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function1<*, kotlin.Unit>"")!>select(id { x: Int -> }, { x: String -> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Unit>"")!>select({ x: Int -> }, id { x: Int, y: Number -> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function1<*, kotlin.Unit>"")!>select(id { x: Int -> }, id { x: String -> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Unit>"")!>select(id { x: Int -> }, id { x: Int, y: Number -> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function1<*, {Comparable<*> & java.io.Serializable}>"")!>select({ x: Int -> 1 }, { x: String -> """" })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<{Comparable<*> & Number}>"")!>select({ x: Int -> 1 }, { x: Int, y: Number -> 1f })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function1<*, Inv<out {Comparable<*> & java.io.Serializable}>>"")!>select(id { x: Int -> Inv(10) }, { x: String -> Inv("""") })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select({ x: Int -> TODO() }, id { x: Int, y: Number -> Any() })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function1<*, kotlin.String?>"")!>select(id { x: Int -> null }, id { x: String -> """" })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Int>"")!>select(id { x: Int -> 10 }, id { x: Int, y: Number -> TODO() })<!>
    val x68: String.(String) -> String = select(id { x: String, y: String -> ""10"" }, id { x: String, y: String -> ""TODO()"" })

    // Anonymous functions
    val x69: (C) -> Unit = selectB({ it }, { }, id(fun (x) { <!DEBUG_INFO_EXPRESSION_TYPE(""A"")!>x<!> }))
    select(id1(fun(it) { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!>.inv() }), id1 { x: Number -> TODO() }, id1(id2(::takeInt)))
    select(id(fun (it) { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> }), id(id<(Int) -> Unit> { x: Number -> Unit }))
    select(id(fun (it) { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!>.inv() }), id<(Int) -> Unit> { })
    val x70: (Int) -> Unit = selectNumber(id(fun (it) { }), id {}, id {})","val x71: String.() -> Unit = select(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String.() -> kotlin.Unit"")!>id(fun String.() { })<!>, <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.String) -> kotlin.Unit"")!>id(fun(x: String) {})<!>)"
"private val codegen: ExpressionCodegen,
    override val callElement: KtElement,
    private val functionDescriptor: FunctionDescriptor
) : SourceCompilerForInline {
    override val state
        get() = codegen.state

    private val additionalInnerClasses = mutableListOf<ClassDescriptor>()

    val context = getContext(
        functionDescriptor,
        functionDescriptor,
        codegen.state,
        DescriptorToSourceUtils.descriptorToDeclaration(functionDescriptor)?.containingFile as? KtFile,
        additionalInnerClasses
    ) as MethodContext

    override val callElementText: String by lazy { callElement.text }

    override val inlineCallSiteInfo: InlineCallSiteInfo
        get() {
            var context = codegen.getContext()
            var parentCodegen = codegen.parentCodegen
            while (context is InlineLambdaContext) {
                val closureContext = context.getParentContext()
                assert(closureContext is ClosureContext) { ""Parent context of inline lambda should be closure context"" }
                assert(closureContext.parentContext is MethodContext) { ""Closure context should appear in method context"" }
                context = closureContext.parentContext as MethodContext
                assert(parentCodegen is FakeMemberCodegen) { ""Parent codegen of inlined lambda should be FakeMemberCodegen"" }
                parentCodegen = (parentCodegen as FakeMemberCodegen).delegate
            }

            val signature = codegen.state.typeMapper.mapSignatureSkipGeneric(context.functionDescriptor, context.contextKind)
            return InlineCallSiteInfo(
                parentCodegen.className,
                signature.asmMethod,
                context.functionDescriptor.getInlineCallSiteVisibility(),
                callElement.containingFile?.virtualFile?.let { File(it.path) },
                CodegenUtil.getLineNumberForElement(callElement, false) ?: 0
            )
        }

    override val sourceMapper
        get() = codegen.parentCodegen.orCreateSourceMapper

    override fun generateLambdaBody(lambdaInfo: ExpressionLambda, reifiedTypeParameters: ReifiedTypeParametersUsages): SMAPAndMethodNode {
        require(lambdaInfo is PsiExpressionLambda)
        val invokeMethodDescriptor = lambdaInfo.invokeMethodDescriptor
        val jvmMethodSignature = state.typeMapper.mapSignatureSkipGeneric(invokeMethodDescriptor)
        val asmMethod = jvmMethodSignature.asmMethod
        val methodNode = MethodNode(
            Opcodes.API_VERSION, DescriptorAsmUtil.getMethodAsmFlags(invokeMethodDescriptor, OwnerKind.IMPLEMENTATION, state),
            asmMethod.name, asmMethod.descriptor, null, null
        )
        val adapter = wrapWithMaxLocalCalc(methodNode)
        val closureContext = when {
            lambdaInfo.isPropertyReference ->
                codegen.getContext().intoAnonymousClass(lambdaInfo.classDescriptor, codegen, OwnerKind.IMPLEMENTATION)
            invokeMethodDescriptor.isSuspend ->
                codegen.getContext().intoCoroutineClosure(
                    getOrCreateJvmSuspendFunctionView(invokeMethodDescriptor, state), invokeMethodDescriptor, codegen, state.typeMapper
                )
            else -> codegen.getContext().intoClosure(invokeMethodDescriptor, codegen, state.typeMapper)
        }
        val context = closureContext.intoInlinedLambda(invokeMethodDescriptor, lambdaInfo.isCrossInline, lambdaInfo.isPropertyReference)",val smap = generateMethodBody(
"// SKIP_WHEN_OUT_OF_CONTENT_ROOT
// MODULE: topmost
// MODULE_KIND: LibraryBinary
// FILE: topmost.kt",package org.example
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package kotlin.metadata.jvm

import kotlin.metadata.*
import kotlin.metadata.jvm.internal.JvmReadUtils.readModuleMetadataImpl
import kotlin.metadata.jvm.internal.JvmReadUtils.throwIfNotCompatible
import kotlin.metadata.jvm.internal.wrapIntoMetadataExceptionWhenNeeded
import org.jetbrains.kotlin.metadata.jvm.JvmModuleProtoBuf
import org.jetbrains.kotlin.metadata.jvm.deserialization.ModuleMapping
import org.jetbrains.kotlin.metadata.jvm.deserialization.PackageParts
import org.jetbrains.kotlin.metadata.jvm.deserialization.serializeToByteArray
import org.jetbrains.kotlin.metadata.jvm.deserialization.JvmMetadataVersion as CompilerMetadataVersion

/**
 * Represents the parsed metadata of a Kotlin JVM module file.
 *
 * To create an instance of [KotlinModuleMetadata], load the contents of the `.kotlin_module` file into a byte array
 * and call [KotlinModuleMetadata.read]. Then it is possible to get the result in the form of [KmModule] with [KotlinModuleMetadata.kmModule].
 *
 * `.kotlin_module` file is produced per Kotlin compilation, and contains auxiliary information, such as a map of all single- and multi-file facades ([KmModule.packageParts]),
 *  and `@OptionalExpectation` declarations ([KmModule.optionalAnnotationClasses]).
 */
@UnstableMetadataApi
public class KotlinModuleMetadata public constructor(
    /**
     * [KmModule] representation of this metadata.
     *
     * Returns the same (mutable) [KmModule] instance every time.
     */
    public var kmModule: KmModule,

    /**
     * Version of this metadata.
     */
    public var version: JvmMetadataVersion,
) {
    /**
     * Encodes and writes this metadata of the Kotlin module file.
     *
     * This method encodes all available data, including [version].
     *
     * @throws IllegalArgumentException if [kmModule] is not correct and cannot be written or if [version] is not supported for writing.
     */
    public fun write(): ByteArray {
        val b = JvmModuleProtoBuf.Module.newBuilder()
        kmModule.packageParts.forEach { (fqName, packageParts) ->",PackageParts(fqName).apply {
"/**
 * Returns `true` if given function is *static* as defined in [staticCFunction].
 */
private fun isStatic(function: Function<*>): Boolean {
    // TODO: revise
    try {
        with(function.javaClass.getDeclaredField(""INSTANCE"")) {
            if (!java.lang.reflect.Modifier.isStatic(modifiers) || !java.lang.reflect.Modifier.isFinal(modifiers)) {
                return false
            }

            isAccessible = true // TODO: undo

            return get(null) == function

            // If the class has static final ""INSTANCE"" field, and only the value of this field is accepted,
            // then each class is handled at most once, so these checks prevent memory leaks.
        }
    } catch (e: NoSuchFieldException) {
        return false
    }
}

internal data class FunctionSpec(val functionClass: Class<*>, val returnType: KType, val parameterTypes: List<KType>)

@Suppress(""UNCHECKED_CAST"")
@PublishedApi
internal fun <F : Function<*>> staticCFunctionImpl(function: F, returnType: KType, vararg parameterTypes: KType): CPointer<CFunction<F>> {
    val spec = FunctionSpec(function.javaClass, returnType, parameterTypes.asList())
    return caches.createdStaticFunctions.computeIfAbsent(spec) {
        createStaticCFunction(function, spec)
    } as CPointer<CFunction<F>>
}

private val invokeMethods = (0 .. 22).map { arity ->
    Class.forName(""kotlin.jvm.functions.Function$arity"").getMethod(""invoke"",
            *Array<Class<*>>(arity) { java.lang.Object::class.java })
}

private fun createStaticCFunctionImpl(
        returnType: CType<Any?>,
        paramTypes: List<CType<*>>,
        function: Function<*>
): NativePtr {
    val ffiCif = ffiCreateCif(returnType.ffiType, paramTypes.map { it.ffiType })

    val arity = paramTypes.size
    val pt = paramTypes.toTypedArray()

    @Suppress(""UNCHECKED_CAST"")
    val impl: FfiClosureImpl = when (arity) {
        0 -> {
            val f = function as () -> Any?
            ffiClosureImpl(returnType) { _ ->
                f()
            }
        }
        1 -> {
            val f = function as (Any?) -> Any?
            ffiClosureImpl(returnType) { args ->
                f(pt.read(args, 0))
            }
        }
        2 -> {","val f = function as (Any?, Any?) -> Any?"
"open class Base() {
    val plain = 239
    public val read : Int
      get() = 239

    public var readwrite : Int = 0
      get() = field + 1
      set(n : Int) {
        field = n
      }
}

interface Abstract {}

class Derived1() : Base(), Abstract {}
class Derived2() : Abstract, Base() {}

fun code(s : Base) : Int {
    if (s.plain != 239) return 1
    if (s.read != 239) return 2
    s.readwrite = 238
    if (s.readwrite != 239) return 3
    return 0
}

fun test(s : Base) : Boolean = code(s) == 0

fun box() : String {
    if (!test(Base())) return ""Fail #1""
    if (!test(Derived1())) return ""Fail #2""
    if (!test(Derived2())) return ""Fail #3""","return ""OK"""
"// EXPECTED_REACHABLE_NODES: 1286
package foo

// CHECK_NOT_CALLED: abs

inline fun abs(a: Int): Int {
    if (a < 0) {
        return a * -1
    } else {
        return a
    }
}

val r1 = abs(1)
val r2 = abs(-2)
val r3 = abs(3)
val r4 = abs(-4)

fun box(): String {
    assertEquals(1, r1)","assertEquals(2, r2)"
"loadedInProjectPath = projectPath

            val ext = project.rootProject.extensions.getByType(ExtraPropertiesExtension::class.java)

            if (!ext.has(loadedInProjectsPropertyName)) {
                ext.set(loadedInProjectsPropertyName, projectPath)
                onRegister()
            } else {
                ext.set(loadedInProjectsPropertyName, (ext.get(loadedInProjectsPropertyName) as String) + "";"" + loadedInProjectPath)
            }
        }
    }

    fun isInMultipleProjects(
        project: Project,
        kotlinPluginVersion: String? = null
    ): Boolean {
        require(trackPluginVersionsSeparately == (kotlinPluginVersion != null))
        return getAffectedProjects(project, kotlinPluginVersion)?.let {
            it.size > 1
        } ?: false
    }

    fun getAffectedProjects(
        project: Project,
        kotlinPluginVersion: String? = null
    ): List<String>? {
        require(trackPluginVersionsSeparately == (kotlinPluginVersion != null))

        val ext = getExt(project)

        val propertyName = getPropertyName(kotlinPluginVersion)

        if (!ext.has(propertyName)) {
            return null
        }

        return (ext.get(propertyName) as String).split("";"")
    }

    private fun getExt(project: Project): ExtraPropertiesExtension {
        return project.rootProject.extensions.getByType(ExtraPropertiesExtension::class.java)
    }

    private fun getPropertyName(version: String?): String {
        return listOfNotNull(
            ""kotlin"",
            ""plugin"",
            ""loaded"",
            ""in"",
            ""projects"",
            version
        )
            .joinToString(""."")
    }
}

const val MULTIPLE_KOTLIN_PLUGINS_LOADED_WARNING: String =
    ""The Kotlin Gradle plugin was loaded multiple times in different subprojects, which is not supported and may break the build. \n"" +

            ""This might happen in subprojects that apply the Kotlin plugins with the Gradle 'plugins { ... }' DSL if they specify "" +
            ""explicit versions, even if the versions are equal.\n"" +

            ""Please add the Kotlin plugin to the common parent project or the root project, then remove the versions in the subprojects.\n"" +","""If the parent project does not need the plugin, add 'apply false' to the plugin line.\n"" +"
"val analysisResult = if (doErrorCheck) {
                val codeLineForErrorCheck = nextCodeLine(code, lineCounter)

                var res: ReplAnalyzerResult?
                val timeMillis = measureTimeMillis {
                    res = compiler.analyze(codeLineForErrorCheck, SourceCode.Position(0, 0), newCompilationConfiguration).valueOrNull()
                }

                loggingInfo?.analyze?.writeValue(timeMillis)

                res
            } else {
                null
            } ?: ReplAnalyzerResult()

            val errorsSequence = analysisResult[ReplAnalyzerResult.analysisDiagnostics]!!
            val resultType = analysisResult[ReplAnalyzerResult.renderedResultType]

            if (doCompile) {
                val codeLineForCompilation = nextCodeLine(code, lineCounter)
                val compilationResult: ResultWithDiagnostics<LinkedSnippet<KJvmCompiledScript>>
                val timeMillis = measureTimeMillis {
                    compilationResult = compiler.compile(codeLineForCompilation, newCompilationConfiguration)
                }
                if (compilationResult is ResultWithDiagnostics.Failure) {
                    System.err.println(compilationResult.reports.joinToString(""\n"", ""Compilation failed:\n"") { it.toString() })
                }

                loggingInfo?.compile?.writeValue(timeMillis)
            }

            ActualResult(completionRes, errorsSequence.toList(), resultType).asSuccess()
        }
    }
}

private fun <T> checkLists(index: Int, checkName: String, expected: List<T>, actual: List<T>, options: ExpectedOptions<T>) {
    when (options.mode) {
        ComparisonType.EQUALS -> Assert.assertEquals(
            ""#$index ($checkName): Expected $expected, got $actual"",
            expected,
            actual
        )
        ComparisonType.INCLUDES -> Assert.assertTrue(
            ""#$index ($checkName): Expected $actual to include $expected"",
            actual.containsAll(expected)
        )
        ComparisonType.COMPARE_SIZE -> Assert.assertEquals(
            ""#$index ($checkName): Expected list size to be equal to ${options.size}, but was ${actual.size}"",
            options.size,
            actual.size
        )
        ComparisonType.CUSTOM -> options.checkFunction!!(actual)
        ComparisonType.DONT_CHECK -> {
        }
    }
}

private suspend fun checkEvaluateInRepl(
    compilationConfiguration: ScriptCompilationConfiguration,
    testData: List<Pair<RunRequest, ExpectedResult>>
) {
    val (snippets, expected) = testData.unzip()
    val expectedIter = expected.iterator()","evaluateInRepl(compilationConfiguration, snippets, AtomicInteger()).forEachIndexed { index, res ->"
"}
            storage.maxTypeDepthFromInitialConstraints = beforeMaxTypeDepthFromInitialConstraints
            storage.errors.trimToSize(beforeErrorsCount)
            storage.missedConstraints.trimToSize(beforeMissedConstraintsCount)
            storage.constraintsFromAllForkPoints.trimToSize(beforeConstraintsFromAllForks)

            val addedInitialConstraints = storage.initialConstraints.subList(
                beforeInitialConstraintCount,
                storage.initialConstraints.size
            )

            for (variableWithConstraint in storage.notFixedTypeVariables.values) {
                val sinceIndexToRemoveConstraints =
                    beforeConstraintCountByVariables[variableWithConstraint.typeVariable.freshTypeConstructor()]
                if (sinceIndexToRemoveConstraints != null) {
                    variableWithConstraint.removeLastConstraints(sinceIndexToRemoveConstraints)
                }
            }

            addedInitialConstraints.clear() // remove constraint from storage.initialConstraints
            closeTransaction(beforeState, beforeTypeVariablesTransactionSize)
        }
    }

    override fun prepareTransaction(): ConstraintSystemTransaction {
        checkState(State.BUILDING, State.COMPLETION, State.TRANSACTION)
        return TransactionState(
            beforeState = state,
            beforeInitialConstraintCount = storage.initialConstraints.size,
            beforeErrorsCount = storage.errors.size,
            beforeMaxTypeDepthFromInitialConstraints = storage.maxTypeDepthFromInitialConstraints,
            beforeTypeVariablesTransactionSize = typeVariablesTransaction.size,
            beforeMissedConstraintsCount = storage.missedConstraints.size,
            beforeConstraintCountByVariables = storage.notFixedTypeVariables.mapValues { it.value.rawConstraintsCount },
            beforeConstraintsFromAllForks = storage.constraintsFromAllForkPoints.size,
        ).also {
            state = State.TRANSACTION
        }
    }

    // ConstraintSystemBuilder, KotlinConstraintSystemCompleter.Context
    override val hasContradiction: Boolean
        get() = storage.hasContradiction.also {
            checkState(
                State.FREEZED,
                State.BUILDING,
                State.COMPLETION,
                State.TRANSACTION
            )
        }

    fun addOuterSystem(outerSystem: ConstraintStorage) {
        require(!storage.usesOuterCs)

        storage.usesOuterCs = true
        storage.outerSystemVariablesPrefixSize = outerSystem.allTypeVariables.size
        @OptIn(AssertionsOnly::class)
        storage.outerCS = outerSystem

        addOtherSystem(outerSystem, isAddingOuter = true)
    }

    @K2Only
    fun setBaseSystem(baseSystem: ConstraintStorage) {
        require(storage.allTypeVariables.isEmpty())",storage.usesOuterCs = baseSystem.usesOuterCs
"import org.jetbrains.kotlin.test.frontend.classic.ClassicFrontend2ClassicBackendConverter
import org.jetbrains.kotlin.test.frontend.classic.ClassicFrontend2IrConverter
import org.jetbrains.kotlin.test.frontend.classic.ClassicFrontendFacade
import org.jetbrains.kotlin.test.frontend.classic.ClassicFrontendOutputArtifact
import org.jetbrains.kotlin.test.frontend.fir.Fir2IrResultsConverter
import org.jetbrains.kotlin.test.frontend.fir.FirFrontendFacade
import org.jetbrains.kotlin.test.frontend.fir.FirOutputArtifact
import org.jetbrains.kotlin.test.model.*
import org.jetbrains.kotlin.test.runners.AbstractKotlinCompilerWithTargetBackendTest
import org.jetbrains.kotlin.test.services.SplittingModuleTransformerForBoxTests
import org.jetbrains.kotlin.utils.bind


@OptIn(TestInfrastructureInternals::class)
abstract class AbstractCompileKotlinAgainstInlineKotlinTestBase<R : ResultingArtifact.FrontendOutput<R>, I : ResultingArtifact.BackendInput<I>>(
    val targetFrontend: FrontendKind<R>,
    targetBackend: TargetBackend
) : AbstractKotlinCompilerWithTargetBackendTest(targetBackend) {
    abstract val frontendFacade: Constructor<FrontendFacade<R>>
    abstract val frontendToBackendConverter: Constructor<Frontend2BackendConverter<R, I>>
    abstract val backendFacade: Constructor<BackendFacade<I, BinaryArtifacts.Jvm>>
    open val directiveToSuppressTest: ValueDirective<TargetBackend> = IGNORE_BACKEND_MULTI_MODULE

    override fun TestConfigurationBuilder.configuration() {
        commonConfigurationForTest(targetFrontend, frontendFacade, frontendToBackendConverter, backendFacade)
        useInlineHandlers()
        configureCommonHandlersForBoxTest()
        useModuleStructureTransformers(
            SplittingModuleTransformerForBoxTests()
        )
        useAfterAnalysisCheckers(::BlackBoxCodegenSuppressor.bind(directiveToSuppressTest))
    }
}

open class AbstractCompileKotlinAgainstInlineKotlinTest :
    AbstractCompileKotlinAgainstInlineKotlinTestBase<ClassicFrontendOutputArtifact, ClassicBackendInput>(
        FrontendKinds.ClassicFrontend,
        TargetBackend.JVM
    ) {
    override val frontendFacade: Constructor<FrontendFacade<ClassicFrontendOutputArtifact>>
        get() = ::ClassicFrontendFacade

    override val frontendToBackendConverter: Constructor<Frontend2BackendConverter<ClassicFrontendOutputArtifact, ClassicBackendInput>>
        get() = ::ClassicFrontend2ClassicBackendConverter

    override val backendFacade: Constructor<BackendFacade<ClassicBackendInput, BinaryArtifacts.Jvm>>
        get() = ::ClassicJvmBackendFacade
}

open class AbstractIrCompileKotlinAgainstInlineKotlinTest(targetBackend: TargetBackend = TargetBackend.JVM_IR) :
    AbstractCompileKotlinAgainstInlineKotlinTestBase<ClassicFrontendOutputArtifact, IrBackendInput>(
        FrontendKinds.ClassicFrontend,
        targetBackend
    ) {
    override val frontendFacade: Constructor<FrontendFacade<ClassicFrontendOutputArtifact>>
        get() = ::ClassicFrontendFacade

    override val frontendToBackendConverter: Constructor<Frontend2BackendConverter<ClassicFrontendOutputArtifact, IrBackendInput>>
        get() = ::ClassicFrontend2IrConverter

    override val backendFacade: Constructor<BackendFacade<IrBackendInput, BinaryArtifacts.Jvm>>
        get() = ::JvmIrBackendFacade
}

private fun TestConfigurationBuilder.configureForSerialization() {",defaultDirectives {
"reporter,
                    when (context.session.languageVersionSettings.supportsFeature(LanguageFeature.ProhibitUseSiteGetTargetAnnotations)) {
                        true -> FirErrors.INAPPLICABLE_TARGET_ON_PROPERTY
                        false -> FirErrors.INAPPLICABLE_TARGET_ON_PROPERTY_WARNING
                    }
                )
            }
            FIELD -> {
                if (annotated is FirBackingField) {
                    val propertySymbol = annotated.propertySymbol
                    if (propertySymbol.delegateFieldSymbol != null && !propertySymbol.hasBackingField) {
                        reporter.reportOn(annotation.source, FirErrors.INAPPLICABLE_TARGET_PROPERTY_HAS_NO_BACKING_FIELD, context)
                    }
                }
            }
            PROPERTY_DELEGATE_FIELD -> {
                if (annotated is FirBackingField && annotated.propertySymbol.delegateFieldSymbol == null) {
                    reporter.reportOn(annotation.source, FirErrors.INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE, context)
                }
            }
            PROPERTY_SETTER,
            SETTER_PARAMETER -> {
                if (!checkPropertyGetter(annotated, annotation, target, context, reporter, FirErrors.INAPPLICABLE_TARGET_ON_PROPERTY) &&
                    !annotated.isVar
                ) {
                    reporter.reportOn(annotation.source, FirErrors.INAPPLICABLE_TARGET_PROPERTY_IMMUTABLE, target.renderName, context)
                }
            }
            CONSTRUCTOR_PARAMETER -> when {
                annotated is FirValueParameter -> {
                    val container = context.containingDeclarations.lastOrNull()
                    if (container is FirConstructor && container.isPrimary) {
                        if (annotated.source?.hasValOrVar() != true) {
                            reporter.reportOn(annotation.source, FirErrors.REDUNDANT_ANNOTATION_TARGET, target.renderName, context)
                        }
                    } else {
                        reporter.reportOn(annotation.source, FirErrors.INAPPLICABLE_PARAM_TARGET, context)
                    }
                }
                else -> reporter.reportOn(annotation.source, FirErrors.INAPPLICABLE_PARAM_TARGET, context)
            }
            FILE -> {
                // NB: report once?
                if (annotated !is FirFile) {
                    reporter.reportOn(annotation.source, FirErrors.INAPPLICABLE_FILE_TARGET, context)
                }
            }
            RECEIVER -> {
                // NB: report once?
                // annotation with use-site target `receiver` can be only on type reference, but not on declaration
                reporter.reportOn(
                    annotation.source, FirErrors.WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET, ""declaration"", target.renderName, context
                )
            }
        }
    }

    @OptIn(ExperimentalContracts::class)
    private fun checkPropertyGetter(
        annotated: FirAnnotationContainer,
        annotation: FirAnnotation,
        target: AnnotationUseSiteTarget,
        context: CheckerContext,
        reporter: DiagnosticReporter,
        diagnostic: KtDiagnosticFactory1<String>",): Boolean {
"""""""
                        dependencies {
                            implementation(""org.jetbrains.kotlin:kotlin-stdlib-js"")
                        }
                        """""".trimIndent().also { added = it }
            }

            build(""assemble"") {
                assertTasksUpToDate("":compileKotlinJs"")
            }

            buildGradleKts.modify {
                val replaced = it.replace(added!!, """")
                replaced + ""\n"" +
                        """"""
                        dependencies {
                            implementation(""org.jetbrains.kotlin:kotlin-dom-api-compat"")
                        }
                        """""".trimIndent().also { added = it }
            }

            build(""assemble"") {
                assertTasksUpToDate("":compileKotlinJs"")
            }

            buildGradleKts.modify {
                val replaced = it.replace(added!!, """")
                replaced + ""\n"" +
                        """"""
                        dependencies {
                            implementation(""org.jetbrains.kotlin:kotlin-stdlib-js"")
                            implementation(""org.jetbrains.kotlin:kotlin-dom-api-compat"")
                        }
                        """""".trimIndent().also { added = it }
            }

            build(""assemble"") {
                assertTasksUpToDate("":compileKotlinJs"")
            }
        }
    }

    @DisplayName(""Kotlin/JS DOM API automatically not added as dependency with disabled adding of stdlib"")
    @GradleTest
    fun testJsDomApiCompatWithDisabledAddingStdlib(gradleVersion: GradleVersion) {
        project(""kotlin-js-dom-api-compat"", gradleVersion) {
            var added: String? = null

            gradleProperties.modify {
                it + ""\n"" +
                        """"""
                        kotlin.stdlib.default.dependency=false
                        """""".trimIndent()
            }

            build(""assemble"") {
                assertTasksExecuted("":compileKotlinJs"")
            }

            buildGradleKts.modify {
                it + ""\n"" +
                        """"""
                        dependencies {
                            implementation(""org.jetbrains.kotlin:kotlin-stdlib-js"")
                        }",""""""".trimIndent().also { added = it }"
"// if the rhs is 0, that means that none of the parameters ended up getting used
                // in the body of the function which means we can simplify the expression quite a
                // bit. In this case we just care about if the low bit is non-zero
                if (rhs == 0) {
                    irNotEqual(
                        irAnd(
                            irGet(param),
                            irConst(1)
                        ),
                        irConst(0)
                    )
                } else {
                    // $dirty and (0b 101 ... 101 1) != (0b 001 ... 001 0)
                    irNotEqual(
                        irAnd(
                            irGet(param),
                            irConst(lhs or 0b1)
                        ),
                        irConst(rhs or 0b0)
                    )
                }
            }
            return if (expressions.size == 1)
                expressions.single()
            else
                expressions.reduce { lhs, rhs -> irOrOr(lhs, rhs) }
        }

        override fun irCopyToTemporary(
            nameHint: String?,
            isVar: Boolean,
            exactName: Boolean
        ): IrChangedBitMaskVariable {
            used = true
            val temps = params.mapIndexed { index, param ->
                IrVariableImpl(
                    UNDEFINED_OFFSET,
                    UNDEFINED_OFFSET,
                    // We label ""dirty"" as a defined variable instead of a temporary, so that it
                    // is properly stored in the locals table and discoverable by debuggers. The
                    // dirty variable encodes information that could be useful for tooling to
                    // interpret.
                    IrDeclarationOrigin.DEFINED,
                    IrVariableSymbolImpl(),
                    Name.identifier(if (index == 0) ""\$dirty"" else ""\$dirty$index""),
                    param.type,
                    isVar,
                    isConst = false,
                    isLateinit = false
                ).apply {
                    parent = currentFunctionScope.function.parent
                    initializer = irGet(param)
                }
            }
            return IrChangedBitMaskVariableImpl(temps, count)
        }

        override fun putAsValueArgumentInWithLowBit(
            fn: IrFunctionAccessExpression,
            startIndex: Int,
            lowBit: Boolean
        ) {
            used = true
            params.fastForEachIndexed { index, param ->",fn.putValueArgument(
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.psi2ir.generators

import org.jetbrains.kotlin.backend.common.CodegenUtil
import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.UNDEFINED_OFFSET
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.descriptors.IrImplementingDelegateDescriptorImpl
import org.jetbrains.kotlin.ir.expressions.IrBlockBody
import org.jetbrains.kotlin.ir.expressions.impl.IrCallImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrGetFieldImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrGetValueImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrReturnImpl
import org.jetbrains.kotlin.ir.expressions.typeParametersCount
import org.jetbrains.kotlin.ir.symbols.IrClassSymbol
import org.jetbrains.kotlin.ir.symbols.impl.IrFieldSymbolImpl
import org.jetbrains.kotlin.ir.types.IrSimpleType
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.psi.KtClassOrObject
import org.jetbrains.kotlin.psi.KtDelegatedSuperTypeEntry
import org.jetbrains.kotlin.psi.KtEnumEntry
import org.jetbrains.kotlin.psi.KtPureClassOrObject
import org.jetbrains.kotlin.psi.psiUtil.endOffset
import org.jetbrains.kotlin.psi.psiUtil.pureEndOffset
import org.jetbrains.kotlin.psi.psiUtil.pureStartOffset
import org.jetbrains.kotlin.psi.psiUtil.startOffsetSkippingComments
import org.jetbrains.kotlin.psi.synthetics.SyntheticClassOrObjectDescriptor
import org.jetbrains.kotlin.psi.synthetics.findClassDescriptor
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.DelegationResolver
import org.jetbrains.kotlin.resolve.DescriptorUtils
import org.jetbrains.kotlin.resolve.descriptorUtil.propertyIfAccessor
import org.jetbrains.kotlin.resolve.descriptorUtil.setSingleOverridden
import org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter
import org.jetbrains.kotlin.resolve.scopes.MemberScope
import org.jetbrains.kotlin.types.KotlinType
import org.jetbrains.kotlin.types.TypeProjectionImpl
import org.jetbrains.kotlin.types.TypeSubstitutor
import org.jetbrains.kotlin.types.error.ErrorTypeKind
import org.jetbrains.kotlin.types.error.ErrorUtils.createErrorType
import org.jetbrains.kotlin.utils.newHashMapWithExpectedSize

@ObsoleteDescriptorBasedAPI
internal class ClassGenerator(
    declarationGenerator: DeclarationGenerator
) : DeclarationGeneratorExtension(declarationGenerator) {","fun generateClass(ktClassOrObject: KtPureClassOrObject, visibility_: DescriptorVisibility? = null): IrClass {"
"expect(1, { listOf(1).minOrNull() })
        expect(2, { listOf(2, 3).minOrNull() })
        expect(2000000000000, { listOf(3000000000000, 2000000000000).minOrNull() })
        expect('a', { listOf('a', 'b').minOrNull() })
        expect(""a"", { listOf(""a"", ""b"").minOrNull() })
        expect(null, { listOf<Int>().asSequence().minOrNull() })
        expect(2, { listOf(2, 3).asSequence().minOrNull() })

        assertIsNegativeZero(listOf(0.0, -0.0).shuffled().minOrNull()!!)
        assertIsNegativeZero(listOf(0.0F, -0.0F).shuffled().minOrNull()!!.toDouble())
    }

    @Test fun max() {
        expect(null, { listOf<Int>().maxOrNull() })
        expect(1, { listOf(1).maxOrNull() })
        expect(3, { listOf(2, 3).maxOrNull() })
        expect(3000000000000, { listOf(3000000000000, 2000000000000).maxOrNull() })
        expect('b', { listOf('a', 'b').maxOrNull() })
        expect(""b"", { listOf(""a"", ""b"").maxOrNull() })
        expect(null, { listOf<Int>().asSequence().maxOrNull() })
        expect(3, { listOf(2, 3).asSequence().maxOrNull() })

        assertIsPositiveZero(listOf(0.0, -0.0).shuffled().maxOrNull()!!)
        assertIsPositiveZero(listOf(0.0F, -0.0F).shuffled().maxOrNull()!!.toDouble())
    }

    @Test fun minWithOrNull() {
        expect(null, { listOf<Int>().minWithOrNull(naturalOrder()) })
        expect(1, { listOf(1).minWithOrNull(naturalOrder()) })
        expect(""a"", { listOf(""a"", ""B"").minWithOrNull(STRING_CASE_INSENSITIVE_ORDER) })
        expect(""a"", { listOf(""a"", ""B"").asSequence().minWithOrNull(STRING_CASE_INSENSITIVE_ORDER) })
    }

    @Test fun maxWithOrNull() {
        expect(null, { listOf<Int>().maxWithOrNull(naturalOrder()) })
        expect(1, { listOf(1).maxWithOrNull(naturalOrder()) })
        expect(""B"", { listOf(""a"", ""B"").maxWithOrNull(STRING_CASE_INSENSITIVE_ORDER) })
        expect(""B"", { listOf(""a"", ""B"").asSequence().maxWithOrNull(STRING_CASE_INSENSITIVE_ORDER) })
    }

    @Test fun minByOrNull() {
        expect(null, { listOf<Int>().minByOrNull { it } })
        expect(1, { listOf(1).minByOrNull { it } })
        expect(3, { listOf(2, 3).minByOrNull { -it } })
        expect('a', { listOf('a', 'b').minByOrNull { ""x$it"" } })
        expect(""b"", { listOf(""b"", ""abc"").minByOrNull { it.length } })
        expect(null, { listOf<Int>().asSequence().minByOrNull { it } })
        expect(3, { listOf(2, 3).asSequence().minByOrNull { -it } })
    }

    @Test fun maxByOrNull() {
        expect(null, { listOf<Int>().maxByOrNull { it } })
        expect(1, { listOf(1).maxByOrNull { it } })
        expect(2, { listOf(2, 3).maxByOrNull { -it } })
        expect('b', { listOf('a', 'b').maxByOrNull { ""x$it"" } })
        expect(""abc"", { listOf(""b"", ""abc"").maxByOrNull { it.length } })
        expect(null, { listOf<Int>().asSequence().maxByOrNull { it } })
        expect(2, { listOf(2, 3).asSequence().maxByOrNull { -it } })
    }

    @Test fun minByOrNullEvaluateOnce() {
        var c = 0
        expect(1, { listOf(5, 4, 3, 2, 1).minByOrNull { c++; it * it } })
        assertEquals(5, c)
        c = 0","expect(1, { listOf(5, 4, 3, 2, 1).asSequence().minByOrNull { c++; it * it } })"
"}
        copy.excludeFromJsExport(session)
        return listOf(copy.symbol)
    }

    private fun generateSerializerFactoryVararg(
        owner: FirClassSymbol<*>,
        callableId: CallableId,
        original: FirSimpleFunction
    ): FirNamedFunctionSymbol =
        createMemberFunction(owner, SerializationPluginKey, callableId.callableName, original.returnTypeRef.coneType) {
            val vpo = original.valueParameters.single()
            valueParameter(vpo.name, vpo.returnTypeRef.coneType, vpo.isCrossinline, vpo.isNoinline, vpo.isVararg, vpo.defaultValue != null)
        }.apply {
            excludeFromJsExport(session)
        }.symbol

    private fun generateSerializerGetterInCompanion(
        owner: FirClassSymbol<*>,
        serializableClassSymbol: FirClassSymbol<*>,
        callableId: CallableId
    ): FirNamedFunctionSymbol {
        val function = createMemberFunction(
            owner,
            SerializationPluginKey,
            callableId.callableName,
            returnTypeProvider = { typeParameters ->
                val parametersAsArguments = typeParameters.map { it.toConeType() }.toTypedArray<ConeTypeProjection>()
                kSerializerId.constructClassLikeType(
                    arrayOf(serializableClassSymbol.constructType(parametersAsArguments, false)),
                    isNullable = false
                )
            }
        ) {
            serializableClassSymbol.typeParameterSymbols.forEachIndexed { i, typeParameterSymbol ->
                typeParameter(typeParameterSymbol.name)
                valueParameter(
                    Name.identifier(""${SerialEntityNames.typeArgPrefix}$i""),
                    { typeParameters ->
                        kSerializerId.constructClassLikeType(arrayOf(typeParameters[i].toConeType()), false)
                    }
                )
            }
        }

        function.excludeFromJsExport(session)

        return function.symbol
    }

    override fun generateProperties(callableId: CallableId, context: MemberGenerationContext?): List<FirPropertySymbol> {
        val owner = context?.owner ?: return emptyList()
        if (!owner.isSerializer) return emptyList()
        if (callableId.callableName != SerialEntityNames.SERIAL_DESC_FIELD_NAME) return emptyList()

        val target = getFromSupertype(callableId, owner) { it.getProperties(callableId.callableName).filterIsInstance<FirPropertySymbol>() }
        val property = createMemberProperty(
            owner,
            SerializationPluginKey,
            callableId.callableName,
            target.resolvedReturnType
        )

        property.excludeFromJsExport(session)",return listOf(property.symbol)
"// SPLIT_PER_MODULE
// EXPECTED_REACHABLE_NODES: 1287
// MODULE: lib
// FILE: lib.kt
package lib

val foo = 23

val boo: Int
    get() = 42

external val bar: Int = definedExternally

external val far: Int
    get() = definedExternally

// TODO: annotations like this are not serialized properly. Uncomment after KT-14529 gets fixed
/*
val fuzz: Int
    @JsName(""getBuzz"") get() = 55
    */

inline fun fetchFoo() = foo

@JsName(""fee"")
val tee = 2525

// FILE: lib.js

var bar = 99",var far = 111
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.asJava.elements

import com.intellij.psi.PsiAnnotation
import com.intellij.psi.PsiElement
import com.intellij.psi.PsiModifierList
import com.intellij.psi.PsiModifierListOwner
import com.intellij.util.IncorrectOperationException
import org.jetbrains.kotlin.asJava.classes.lazyPub
import org.jetbrains.kotlin.psi.KtModifierList
import org.jetbrains.kotlin.psi.KtModifierListOwner

abstract class KtLightModifierList<out T : KtLightElement<KtModifierListOwner, PsiModifierListOwner>>(
    protected val owner: T
) : KtLightElementBase(owner), PsiModifierList, KtLightElement<KtModifierList, PsiModifierList> {
    private val _annotations by lazyPub {
        val annotations = computeAnnotations()
        annotationsFilter?.let(annotations::filter) ?: annotations
    }

    protected open val annotationsFilter: ((KtLightAbstractAnnotation) -> Boolean)? = null

    override val kotlinOrigin: KtModifierList?
        get() = owner.kotlinOrigin?.modifierList

    override fun getParent() = owner

    override fun hasExplicitModifier(name: String) = hasModifierProperty(name)

    private fun throwInvalidOperation(): Nothing = throw IncorrectOperationException()

    override fun setModifierProperty(name: String, value: Boolean): Unit = throwInvalidOperation()

    override fun checkSetModifierProperty(name: String, value: Boolean): Unit = throwInvalidOperation()

    override fun addAnnotation(qualifiedName: String): PsiAnnotation = throwInvalidOperation()

    override fun getApplicableAnnotations(): Array<out PsiAnnotation> = annotations

    override fun getAnnotations(): Array<out PsiAnnotation> = _annotations.toTypedArray()",override fun findAnnotation(qualifiedName: String) = _annotations.firstOrNull { it.fqNameMatches(qualifiedName) }
"fun test5(): String {
    val foo: (Any) -> String = ({ b: Any ->
        val a: (Any) -> String = ::baz
        a(b)
    })::cux
    return foo(3)
}

inline fun <reified T, K, reified S> bak(value1: T, value2: K, value3: S): String = ""OK"" + value1 + value2 + value3

fun test6(): String {
    val f: (Any, Int, String) -> String = ::bak
    return f(1, 37, ""joo"")
}

inline fun <reified T, K> bal(value1: Array<K>, value2: Array<T>): String = ""OK"" + value1.joinToString() + value2.joinToString()

fun test7(): String {
    val f: (Array<Any>, Array<Int>) -> String = ::bal
    return f(arrayOf(""mer"", ""nas""), arrayOf(73, 37))
}

class E<T>
public inline fun <reified T> E<T>.foo(value: T): String = ""OK"" + value

class F<T1> {
    inline fun <reified T2> foo(x: T1, y: T2): Any? = ""OK"" + x + y
}

inline fun <reified T, K> bam(value1: K?, value2: T?): String = ""OK"" + value1.toString() + value2.toString()

fun <T> test10(): String {
    val f: (T?, String?) -> String = ::bam
    return f(null, ""abc"")
}

inline fun <T> test11Impl() : String {
    val f: (T?, String?) -> String = ::bam
    return f(null, ""def"")
}

fun <T> test11() = test11Impl<T>()


fun box(): String {
    val test1 = test()
    if (test1 != ""OK1"") return ""fail1: $test1""
    val test2 = test2()
    if (test2 != ""123OK"") return ""fail2: $test2""
    val test3 = test3()
    if (test3 != ""321OK"") return ""fail3: $test3""
    val test4 = test4()
    if (test4 != ""OK456"") return ""fail4: $test4""
    val test5 = test5()
    if (test5 != ""OK3"") return ""fail5: $test5""
    val test6 = test6()
    if (test6 != ""OK137joo"") return ""fail6: $test6""
    val test7 = test7()
    if (test7 != ""OKmer, nas73, 37"") return ""fail7: $test7""
    val test8 = E<Int>().foo(56)
    if (test8 != ""OK56"") return ""fail8: $test8""
    val test9 = F<Int>().foo(65, ""hello"")
    if (test9 != ""OK65hello"") return ""fail9: $test9""
    val test10 = test10<Int>()
    if (test10 != ""OKnullabc"") return ""fail10: $test10""",val test11 = test11<Int>()
"private inner class ProjectStepsExecutor(
        private val projectInfo: ProjectInfo,
        private val moduleInfos: Map<String, ModuleInfo>,
        private val testDir: File,
        private val sourceDir: File,
        private val buildDir: File,
        private val jsDir: File,
    ) {
        private inner class TestStepInfo(
            val moduleName: String,
            val modulePath: String,
            val friends: List<String>,
            val expectedFileStats: Map<String, Set<String>>,
            val expectedDTS: ExpectedFile?,
        )

        private inner class ExpectedFile(val name: String, val content: String)

        private fun setupTestStep(projStep: ProjectInfo.ProjectBuildStep, module: String): TestStepInfo {
            val projStepId = projStep.id
            val moduleTestDir = File(testDir, module)
            val moduleSourceDir = File(sourceDir, module)
            val moduleInfo = moduleInfos[module] ?: error(""No module info found for $module"")
            val moduleStep = moduleInfo.steps.getValue(projStepId)
            for (modification in moduleStep.modifications) {
                modification.execute(moduleTestDir, moduleSourceDir) {}
            }

            val outputKlibFile = resolveModuleArtifact(module, buildDir)

            val friends = mutableListOf<File>()
            if (moduleStep.rebuildKlib) {
                val dependencies = mutableListOf(File(STDLIB_KLIB), File(KOTLIN_TEST_KLIB))
                for (dep in moduleStep.dependencies) {
                    val klibFile = resolveModuleArtifact(dep.moduleName, buildDir)
                    dependencies += klibFile
                    if (dep.isFriend) {
                        friends += klibFile
                    }
                }
                val configuration = createConfiguration(module, projStep.language, projectInfo.moduleKind)
                configuration.enableKlibRelativePaths(moduleSourceDir)
                outputKlibFile.delete()
                buildKlib(configuration, module, moduleSourceDir, dependencies, friends, outputKlibFile)
            }

            val dtsFile = moduleStep.expectedDTS.ifNotEmpty {
                moduleTestDir.resolve(singleOrNull() ?: error(""$module module may generate only one d.ts at step $projStepId""))
            }
            return TestStepInfo(
                module.safeModuleName,
                outputKlibFile.canonicalPath,
                friends.map { it.canonicalPath },
                moduleStep.expectedFileStats,
                dtsFile?.let { ExpectedFile(moduleStep.expectedDTS.single(), it.readText()) }
            )
        }

        private fun verifyCacheUpdateStats(stepId: Int, stats: KotlinSourceFileMap<EnumSet<DirtyFileState>>, testInfo: List<TestStepInfo>) {
            val gotStats = stats.filter { it.key.path != STDLIB_KLIB && it.key.path != KOTLIN_TEST_KLIB }

            val checkedLibs = mutableSetOf<KotlinLibraryFile>()

            for (info in testInfo) {
                val libFile = KotlinLibraryFile(info.modulePath)",val updateStatus = gotStats[libFile] ?: emptyMap()
"// WITH_STDLIB
// WORKS_WHEN_VALUE_CLASS
// LANGUAGE: +ValueClasses

OPTIONAL_JVM_INLINE_ANNOTATION",value class UInt(private val u: Int) {
"* 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.internal.InlineOnly
public inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {
    if (isEmpty()) return null
    var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }
    return maxValue
}

/**
 * Returns the largest value among all values produced by [selector] function
 * applied to each element in the array or `null` if there are no elements.
 * 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.internal.InlineOnly
public inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {
    if (isEmpty()) return null
    var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }
    return maxValue
}

/**
 * Returns the largest value among all values produced by [selector] function
 * applied to each element in the array or `null` if there are no elements.
 * 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.internal.InlineOnly
public inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {
    if (isEmpty()) return null
    var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }
    return maxValue
}

/**
 * Returns the largest value among all values produced by [selector] function
 * applied to each element in the array or `null` if there are no elements.
 * 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)",@OverloadResolutionByLambdaReturnType
"fun main(args: Array<<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Anno<!> String>) {}

annotation class Anno

fun Int.train(args: Array<<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Anno<!> String>) {}

fun Int.plane(<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Anno<!> args: Array<String>) {}

fun vein(args: Array<<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@file:Anno<!> String>) {}

fun rain(args: Array<<!WRONG_ANNOTATION_TARGET!>@Anno<!> String>) {}

fun <!WRONG_ANNOTATION_TARGET!>@Anno<!> Int.strain() {}

fun @receiver:Anno Int.drain() {}",fun <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@file:Anno<!> Int.brain() {}
"synthetic = true
                        callee.name?.let { sideEffects = it.sideEffects }
                    }
                    qualifier = fqn.extractToTemporary()
                    qualifier = Namer.getFunctionCallRef(qualifier)
                    arguments.add(0, receiverTmp)
                    matchedIndices = matchedIndices.map { it + 1 }
                }
                else {
                    qualifier = qualifier.extractToTemporary()
                }
            }
        }

        processByIndices(arguments, matchedIndices)
    }

    private fun processByIndices(elements: MutableList<JsExpression>, matchedIndices: List<Int>) {
        var prev = 0
        for (curr in matchedIndices) {
            for (i in prev..curr-1) {
                val arg = elements[i]
                if (arg !in containsNodeWithSideEffect) continue

                elements[i] = arg.extractToTemporary()
            }

            elements[curr] = accept(elements[curr])
            prev = curr
        }
    }

    inline
    private fun <T> withNewAdditionalStatements(fn: ()->T): T {
        val backup = additionalStatements
        additionalStatements = SmartList<JsStatement>()
        val result = fn()
        additionalStatements = backup
        return result
    }

    private fun addStatement(statement: JsStatement) =
            additionalStatements.add(statement)

    private fun addStatements(statements: List<JsStatement>) =
            additionalStatements.addAll(statements)

    private fun addStatements(index: Int, statements: List<JsStatement>) =
            additionalStatements.addAll(index, statements)

    private fun JsExpression.extractToTemporary(): JsExpression {
        val tmp = Temporary(this)
        addStatement(tmp.variable)
        return tmp.nameRef
    }

    private inner class Temporary(val value: JsExpression? = null, val sourceInfo: Any? = null) {
        val name: JsName = JsScope.declareTemporary()

        val variable: JsVars = newVar(name, value).apply {
            synthetic = true
            name.staticRef = value
            source = sourceInfo ?: value?.source
        }",val nameRef: JsExpression
"// WITH_STDLIB

@file:JvmName(""TestKt"")
package test

import kotlinx.parcelize.*
import android.os.Parcel
import android.os.Parcelable

enum class Color {
    BLACK, WHITE
}

@Parcelize
data class Test(val name: String, val color: Color) : Parcelable

fun box() = parcelTest { parcel ->
    val test = Test(""John"", Color.WHITE)
    test.writeToParcel(parcel, 0)

    val bytes = parcel.marshall()
    parcel.unmarshall(bytes, 0, bytes.size)
    parcel.setDataPosition(0)

    val test2 = parcelableCreator<Test>().createFromParcel(parcel)",assert(test == test2)
"eliminateDeadDeclarations(allModules, backendContext, dceDumpNameCache)
            }

            dumpDeclarationIrSizesIfNeed(arguments.irDceDumpDeclarationIrSizesToFile, allModules, dceDumpNameCache)

            val res = compileWasm(
                allModules = allModules,
                backendContext = backendContext,
                typeScriptFragment = typeScriptFragment,
                baseFileName = outputName,
                emitNameSection = arguments.wasmDebug,
                allowIncompleteImplementations = arguments.irDce,
                    generateWat = configuration.get(WasmConfigurationKeys.WASM_GENERATE_WAT, false),
                generateSourceMaps = generateSourceMaps,
            )
            performanceManager?.notifyIRGenerationFinished()
            performanceManager?.notifyGenerationFinished()

            writeCompilationResult(
                result = res,
                dir = outputDir,
                fileNameBase = outputName,
            )

            return OK
        } else {
            if (arguments.irDceDumpReachabilityInfoToFile != null) {
                messageCollector.report(STRONG_WARNING, ""Dumping the reachability info to file is supported only for Kotlin/Wasm."")
            }
            if (arguments.irDceDumpDeclarationIrSizesToFile != null) {
                messageCollector.report(STRONG_WARNING, ""Dumping the size of declarations to file is supported only for Kotlin/Wasm."")
            }
        }

        val start = System.currentTimeMillis()

        try {
            val ir2JsTransformer = Ir2JsTransformer(arguments, module, phaseConfig, messageCollector, mainCallArguments)
            val outputs = ir2JsTransformer.compileAndTransformIrNew()

            messageCollector.report(INFO, ""Executable production duration: ${System.currentTimeMillis() - start}ms"")

            outputs.writeAll(outputDir, outputName, arguments.dtsStrategy, moduleName, moduleKind)
        } catch (e: CompilationException) {
            messageCollector.report(
                ERROR,
                e.stackTraceToString(),
                CompilerMessageLocation.create(
                    path = e.path,
                    line = e.line,
                    column = e.column,
                    lineContent = e.content
                )
            )
            return INTERNAL_ERROR
        }

        return OK
    }

    private fun produceSourceModule(
        configuration: CompilerConfiguration,
        environmentForJS: KotlinCoreEnvironment,
        libraries: List<String>,
        friendLibraries: List<String>,","arguments: K2JSCompilerArguments,"
"// Auto-generated by GenerateInRangeExpressionTestData. Do not edit!
// WITH_STDLIB



val range0 = 1L until 3L
val range1 = 3L until 1L

val element0 = (-1).toByte()
val element1 = (-1).toShort()
val element2 = -1
val element3 = -1L
val element4 = 0.toByte()
val element5 = 0.toShort()
val element6 = 0
val element7 = 0L
val element8 = 1.toByte()
val element9 = 1.toShort()
val element10 = 1
val element11 = 1L
val element12 = 2.toByte()
val element13 = 2.toShort()
val element14 = 2",val element15 = 2L
"// !LANGUAGE: +ProhibitAssigningSingleElementsToVarargsInNamedForm

annotation class Ann1(vararg val a: String = [])
annotation class Ann2(vararg val a: Int = [1, 2])
annotation class Ann3(vararg val a: Float = [1f])
annotation class Ann4(vararg val a: String = [""/""])

annotation class Ann5(vararg val a: Ann4 = [])
annotation class Ann6(vararg val a: Ann4 = [Ann4(*[""a"", ""b""])])","annotation class Ann7(vararg val a: Long = [1L, <!NULL_FOR_NONNULL_TYPE!>null<!>, <!ARGUMENT_TYPE_MISMATCH!>""""<!>])"
"@Test
    fun testInnerClass() = checkApi(
        """"""
            interface A {
                fun b() {}
            }
            class C {
                val foo = 1
                inner class D : A {
                    override fun b() {
                        print(foo)
                    }
                }
            }
        """""",
    )

    @Test
    fun testFunInterfaces() = checkApi(
        """"""
            fun interface A {
                fun compute(value: Int): Unit
            }
            fun Example(a: A) {
                a.compute(123)
            }
            fun Usage() {
                Example { it -> it + 1 }
            }
        """""",
    )

    @Test
    fun testComposableFunInterfaces() = checkApi(
        """"""
            fun interface A {
                @Composable fun compute(value: Int): Unit
            }
            fun Example(a: A) {
                Example { it -> a.compute(it) }
            }
        """""",
    )

    @Test
    fun testFunInterfacesInComposableCall() = checkApi(
        """"""
            fun interface MeasurePolicy {
                fun compute(value: Int): Unit
            }

            @NonRestartableComposable
            @Composable fun Text() {
                Layout { value ->
                    println(value)
                }
            }

            @Composable inline fun Layout(policy: MeasurePolicy) {
                policy.compute(0)
            }
        """""",
    )",@Test
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.kapt3.base.incremental

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import java.io.File
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

class IncrementalProcessorDiscoveryTest {

    private val markerFileContent = """"""
                    Input1Processor1,AGGREGATING
                    Input1Processor2,ISOLATING
                    Input1Processor3,DYNAMIC
                    Input1Processor4,UNKNOWN
                    Input1Processor5 this is malformed input
            """""".trimIndent()

    @Test
    fun locateInJars(@TempDir tmp: File) {
        val inputJar = tmp.resolve(""inputJar.jar"")",ZipOutputStream(inputJar.outputStream()).use {
"package properties

@Target(
    AnnotationTarget.TYPE,
    AnnotationTarget.PROPERTY,
    AnnotationTarget.VALUE_PARAMETER,
    AnnotationTarget.FIELD,
    AnnotationTarget.PROPERTY_SETTER,
    AnnotationTarget.PROPERTY_GETTER,
)
annotation class Anno(val position: String)
const val constant = 0

class MyClass(
    @property:Anno(""property $constant"")
    @get:Anno(""get $constant"")
    @set:Anno(""set $constant"")
    @setparam:Anno(""set $constant"")
    @field:Anno(""field $constant"")
    @param:Anno(""param $constant"")","var pr<caret>operty: @Anno(""parameter type: $constant"") List<@Anno(""nested parameter type: $constant"") List<@Anno(""nested nested parameter type: $constant"") Int>>,"
