Context,Completion
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.builder

import com.intellij.psi.tree.IElementType
import org.jetbrains.kotlin.KtFakeSourceElementKind
import org.jetbrains.kotlin.KtRealSourceElementKind
import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.contracts.description.LogicOperationKind
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.descriptors.Visibilities
import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget
import org.jetbrains.kotlin.fakeElement
import org.jetbrains.kotlin.fir.*",import org.jetbrains.kotlin.fir.contracts.FirContractDescription
"package test

class A {
    companion object {
        annotation class Anno1",class B {
")

                // Native:
                assertFileExists(""build/classes/kotlin/linux64/integrationTest/klib/new-mpp-associate-compilations_integrationTest.klib"")
            }
        }
    }

    @Test
    fun testTestRunsApi() = with(Project(""new-mpp-associate-compilations"")) {
        setupWorkingDir()
        gradleBuildScript().modify(::transformBuildScriptWithPluginsDsl)

        // TOOD: add Kotlin/JS tests once they can be tested without much performance overhead
        val targetsToTest = listOf(""jvm"", nativeHostTargetName) + when (HostManager.host) {
            KonanTarget.MACOS_X64 -> listOf(""iosX64"")
            KonanTarget.MACOS_ARM64 -> listOf(""iosSimulatorArm64"")
            else -> emptyList()
        }
        val testTasks = targetsToTest.flatMap { listOf("":${it}Test"", "":${it}IntegrationTest"") }.toTypedArray()

        build(*testTasks) {
            assertSuccessful()

            assertTasksExecuted(
                *testTasks,
                "":compileIntegrationTestKotlinJvm"",
                "":linkIntegrationDebugTest${nativeHostTargetName.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() }}""
            )

            fun checkUnitTestOutput(targetName: String) {
                val classReportHtml = projectDir
                    .resolve(""build/reports/tests/${targetName}Test/classes/com.example.HelloTest.html"")
                    .readText()

                assertTrue(""secondTest"" !in classReportHtml, ""Test report should not contain 'secondTest':\n$classReportHtml"")
            }
            targetsToTest.forEach {
                checkUnitTestOutput(it)
            }

            fun checkIntegrationTestOutput(targetName: String) {
                val classReportHtml = projectDir
                    .resolve(""build/reports/tests/${targetName}IntegrationTest/classes/com.example.HelloIntegrationTest.html"")
                    .readText()

                assertTrue(""test[$targetName]"" in classReportHtml, ""Test report should contain 'test[$targetName]':\n$classReportHtml"")
                assertTrue(""secondTest"" !in classReportHtml, ""Test report should not contain 'secondTest':\n$classReportHtml"")
                assertTrue(""thirdTest"" !in classReportHtml, ""Test report should not contain 'thirdTest':\n$classReportHtml"")
            }
            targetsToTest.forEach {
                checkIntegrationTestOutput(it)
            }
        }
    }

    @Test
    fun testKlibsWithTheSameProjectName() = with(transformProjectWithPluginsDsl(""new-mpp-klibs-with-same-name"")) {
        // KT-36721.
        build(""assemble"") {
            assertSuccessful()
            assertTasksExecuted(
                "":foo:foo:compileKotlinJs"",
                "":foo:foo:compileKotlinLinux"",
                "":foo:compileKotlinJs"",",""":foo:compileKotlinLinux"","
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.references.fe10

import com.intellij.util.SmartList
import org.jetbrains.kotlin.references.fe10.base.KtFe10Reference
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.idea.references.SyntheticPropertyAccessorReference",import org.jetbrains.kotlin.psi.KtImportAlias
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.checkers

import org.jetbrains.kotlin.KtFakeSourceElementKind
import org.jetbrains.kotlin.builtins.StandardNames
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.*
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.declaration.FirNameConflictsTracker
import org.jetbrains.kotlin.fir.analysis.checkers.declaration.isEffectivelyFinal
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.declarations.impl.FirResolvedDeclarationStatusImpl.Companion.DEFAULT_STATUS_FOR_STATUSLESS_DECLARATIONS
import org.jetbrains.kotlin.fir.declarations.impl.FirResolvedDeclarationStatusImpl.Companion.DEFAULT_STATUS_FOR_SUSPEND_MAIN_FUNCTION
import org.jetbrains.kotlin.fir.declarations.impl.modifiersRepresentation
import org.jetbrains.kotlin.fir.declarations.utils.nameOrSpecialName
import org.jetbrains.kotlin.fir.expressions.FirBlock
import org.jetbrains.kotlin.fir.expressions.FirComponentCall
import org.jetbrains.kotlin.fir.expressions.FirPropertyAccessExpression
import org.jetbrains.kotlin.fir.references.FirResolvedNamedReference
import org.jetbrains.kotlin.fir.resolve.fullyExpandedType
import org.jetbrains.kotlin.fir.resolve.outerType
import org.jetbrains.kotlin.fir.resolve.providers.firProvider
import org.jetbrains.kotlin.fir.resolve.scope
import org.jetbrains.kotlin.fir.scopes.*
import org.jetbrains.kotlin.fir.scopes.impl.FirPackageMemberScope
import org.jetbrains.kotlin.fir.scopes.impl.TypeAliasConstructorsSubstitutingScope
import org.jetbrains.kotlin.fir.scopes.impl.toConeType
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.fir.symbols.SymbolInternals
import org.jetbrains.kotlin.fir.symbols.impl.*
import org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase
import org.jetbrains.kotlin.fir.types.*
import org.jetbrains.kotlin.fir.util.ListMultimap
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId",import org.jetbrains.kotlin.name.Name
"import org.jetbrains.kotlin.ir.BuiltInOperatorNames
import org.jetbrains.kotlin.ir.IrBuiltIns
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.interpreter.CallInterceptor
import org.jetbrains.kotlin.ir.interpreter.fqName
import org.jetbrains.kotlin.ir.interpreter.isPrimitiveArray
import org.jetbrains.kotlin.ir.interpreter.proxy.CommonProxy.Companion.asProxy
import org.jetbrains.kotlin.ir.interpreter.proxy.reflection.ReflectionProxy.Companion.asProxy
import org.jetbrains.kotlin.ir.interpreter.state.*
import org.jetbrains.kotlin.ir.interpreter.state.reflection.ReflectionState
import org.jetbrains.kotlin.ir.types.isArray
import org.jetbrains.kotlin.ir.types.isFloat
import org.jetbrains.kotlin.name.Name
import java.lang.invoke.MethodType

internal interface Proxy {
    val state: State
    val callInterceptor: CallInterceptor
    val environment
        get() = callInterceptor.environment

    override fun equals(other: Any?): Boolean
    override fun hashCode(): Int
    override fun toString(): String
}

internal fun State.wrap(callInterceptor: CallInterceptor, remainArraysAsIs: Boolean, extendFrom: Class<*>? = null): Any? {
    return when (this) {
        is ExceptionState -> this
        is Wrapper -> this.value
        is Primitive<*> -> when {
            this.isNull() -> null
            this.type.isArray() || this.type.isPrimitiveArray() -> if (remainArraysAsIs) this else this.value
            else -> this.value
        }
        is Common -> this.asProxy(callInterceptor, extendFrom)
        is ReflectionState -> this.asProxy(callInterceptor)
        else -> throw AssertionError(""${this::class} is unsupported as argument for wrap function"")
    }
}

private val eqeqName = IrBuiltIns.KOTLIN_INTERNAL_IR_FQN.child(Name.identifier(BuiltInOperatorNames.EQEQ)).asString()
private val checkNotNullName = IrBuiltIns.KOTLIN_INTERNAL_IR_FQN.child(Name.identifier(BuiltInOperatorNames.CHECK_NOT_NULL)).asString()

/**
 * Prepare state object to be passed in outer world
 */
internal fun List<State>.wrap(callInterceptor: CallInterceptor, irFunction: IrFunction, methodType: MethodType? = null): List<Any?> {
    val name = irFunction.fqName
    if (name == eqeqName && this.any { it is Common }) {
        // in case of custom `equals` it is important not to lose information obout type
        // so all states remain as is, only common will be converted to Proxy
        return mapIndexed { index, state ->
            if (state !is Common) return@mapIndexed state
            state.wrap(callInterceptor, remainArraysAsIs = true, methodType?.parameterType(index))
        }
    }
    return this.mapIndexed { index, state ->
        // don't get arrays from Primitive in case of ""set"" and ""Pair.<init>""; information about type will be lost
        val unwrapArrays = (name == ""kotlin.Array.set"" && index != 0) || name == ""kotlin.Pair.<init>"" || name == checkNotNullName
        state.wrap(callInterceptor, unwrapArrays, methodType?.parameterType(index))
    }
}",internal fun Class<*>.isObject(): Boolean {
fun box(): String {,"return if (call(10, ::calc) == 5) ""OK"" else ""fail"""
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""PackageDirectoryMismatch"") // Old package for compatibility
package org.jetbrains.kotlin.gradle.plugin.mpp

import org.gradle.api.Project
import org.jetbrains.kotlin.gradle.DeprecatedTargetPresetApi
import org.jetbrains.kotlin.gradle.plugin.AbstractKotlinTargetConfigurator
import org.jetbrains.kotlin.gradle.plugin.KotlinPlatformType
import org.jetbrains.kotlin.gradle.targets.jvm.KotlinJvmTarget
import org.jetbrains.kotlin.gradle.targets.jvm.KotlinJvmTargetConfigurator

@DeprecatedTargetPresetApi
class KotlinJvmTargetPreset(
    project: Project",") : KotlinOnlyTargetPreset<KotlinJvmTarget, KotlinJvmCompilation>("
"equals(null)
            propT
            propAny
            propNullableT
            propNullableAny
            funT()
            funAny()
            funNullableT()
            funNullableAny()
            get()
            ip1test1()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.get()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.ip1test1()
        }
        also {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.get()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.ip1test1()
        }
    }
}

// TESTCASE NUMBER: 52
fun <T> T?.case_52() where T : Inv<in T>, T: InterfaceWithTypeParameter1<T>? {
    if (this != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.get()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.ip1test1()

        equals(this)
        get()
        ip1test1()
        apply {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>
            equals(null)
            propT
            propAny
            propNullableT",propNullableAny
"// !RENDER_DIAGNOSTICS_FULL_TEXT
fun <T> flowOf(value: T): Flow<T> = TODO()

interface FlowCollector<in T> {}

interface Flow<out T>

fun <T, R> Flow<T>.transform(transform: FlowCollector<R>.(T) -> Unit): Flow<R> = TODO()

fun f() {
    fun <T> doEmit(collector: FlowCollector<T>) {}",flowOf(1).<!INFERRED_INTO_DECLARED_UPPER_BOUNDS!>transform<!> { doEmit(this) }
"generateCompareTo()

        generateBinaryOperators()
        generateUnaryOperators()
        generateRangeTo()
        generateRangeUntil()

        if (type == UnsignedType.UINT || type == UnsignedType.ULONG) {
            generateBitShiftOperators()
        }

        generateBitwiseOperators()

        generateMemberConversions()
        generateFloatingConversions()

        generateToStringHashCode()

        out.println(""}"")
        out.println()


        generateExtensionConversions()
    }


    private fun generateCompareTo() {
        for (otherType in UnsignedType.entries) {
            out.println(""""""
    /**
     * Compares this value with the specified value for order.
     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,
     * or a positive number if it's greater than other.
     */"""""")
            out.println(""    @kotlin.internal.InlineOnly"")
            if (otherType == type)
                out.println(""""""    @Suppress(""OVERRIDE_BY_INLINE"")"""""")
            out.print(""    public "")
            if (otherType == type) out.print(""override "")
            out.print(""inline operator fun compareTo(other: ${otherType.capitalized}): Int = "")
            if (otherType == type && maxByDomainCapacity(type, UnsignedType.UINT) == type) {
                out.println(""${className.lowercase()}Compare(this.data, other.data)"")
            } else {
                if (maxOf(type, otherType) < UnsignedType.UINT) {
                    out.println(""this.toInt().compareTo(other.toInt())"")
                } else {
                    val ctype = maxByDomainCapacity(type, otherType)
                    out.println(""${convert(""this"", type, ctype)}.compareTo(${convert(""other"", otherType, ctype)})"")
                }
            }
        }
        out.println()
    }

    private fun generateBinaryOperators() {
        for (name in BasePrimitivesGenerator.binaryOperators) {
            generateOperator(name)
        }
        generateFloorDivMod(""floorDiv"")
        generateFloorDivMod(""mod"")
    }

    private fun generateOperator(name: String) {
        for (otherType in UnsignedType.entries) {","val returnType = getOperatorReturnType(type, otherType)"
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.codegen.optimization

import org.jetbrains.kotlin.codegen.TransformationMethodVisitor
import org.jetbrains.kotlin.codegen.coroutines.UninitializedStoresProcessor
import org.jetbrains.kotlin.codegen.inline.InplaceArgumentsMethodTransformer
import org.jetbrains.kotlin.codegen.optimization.boxing.PopBackwardPropagationTransformer
import org.jetbrains.kotlin.codegen.optimization.boxing.RedundantBoxingMethodTransformer
import org.jetbrains.kotlin.codegen.optimization.boxing.StackPeepholeOptimizationsTransformer
import org.jetbrains.kotlin.codegen.optimization.common.prepareForEmitting
import org.jetbrains.kotlin.codegen.optimization.common.nodeType
import org.jetbrains.kotlin.codegen.optimization.nullCheck.RedundantNullCheckMethodTransformer
import org.jetbrains.kotlin.codegen.optimization.temporaryVals.TemporaryVariablesEliminationTransformer
import org.jetbrains.kotlin.codegen.optimization.transformer.CompositeMethodTransformer
import org.jetbrains.kotlin.codegen.state.GenerationState
import org.jetbrains.org.objectweb.asm.MethodVisitor
import org.jetbrains.org.objectweb.asm.Opcodes
import org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode
import org.jetbrains.org.objectweb.asm.tree.MethodNode

class OptimizationMethodVisitor(
    delegate: MethodVisitor,
    private val mandatoryTransformationsOnly: Boolean,
    private val generationState: GenerationState,
    access: Int,
    name: String,
    desc: String,
    signature: String?,
    exceptions: Array<out String>?
) : TransformationMethodVisitor(delegate, access, name, desc, signature, exceptions) {
    val normalizationMethodTransformer = CompositeMethodTransformer(
        InplaceArgumentsMethodTransformer(),
        FixStackWithLabelNormalizationMethodTransformer(),
        MethodVerifier(""AFTER mandatory stack transformations"", generationState)
    )

    val optimizationTransformer = CompositeMethodTransformer(
        CapturedVarsOptimizationMethodTransformer(),
        RedundantNullCheckMethodTransformer(generationState),
        RedundantCheckCastEliminationMethodTransformer(),
        ConstantConditionEliminationMethodTransformer(),
        RedundantBoxingMethodTransformer(generationState),
        TemporaryVariablesEliminationTransformer(generationState),
        StackPeepholeOptimizationsTransformer(),
        PopBackwardPropagationTransformer(),
        DeadCodeEliminationMethodTransformer(),
        RedundantGotoMethodTransformer(),
        RedundantNopsCleanupMethodTransformer(),
        NegatedJumpsMethodTransformer(),
        RedundantCheckcastsBeforeAastoreMethodTransformer,","MethodVerifier(""AFTER optimizations"", generationState)"
"): FirSimpleFunction {
        // TODO: consider using here some light-weight functions instead of pseudo-real FirMemberFunctionImpl
        // As second alternative, we can invent some light-weight kind of FirRegularClass
        return createCopyForFirFunction(
            fakeOverrideSymbol,
            baseFunction,
            derivedClassLookupTag = derivedClassLookupTag,
            session,
            origin,
            isExpect,
            newDispatchReceiverType,
            newParameterTypes,
            newTypeParameters,
            newReceiverType,
            newContextReceiverTypes,
            newReturnType,
            deferredReturnTypeCalculation = callableCopySubstitutionForTypeUpdater
        ).apply {
            originalForSubstitutionOverrideAttr = baseFunction
        }
    }

    fun createCopyForFirFunction(
        newSymbol: FirNamedFunctionSymbol,
        baseFunction: FirSimpleFunction,
        derivedClassLookupTag: ConeClassLikeLookupTag?,
        session: FirSession,
        origin: FirDeclarationOrigin,
        isExpect: Boolean = baseFunction.isExpect,
        newDispatchReceiverType: ConeSimpleKotlinType?,
        newParameterTypes: List<ConeKotlinType?>? = null,
        newTypeParameters: List<FirTypeParameter>? = null,
        newReceiverType: ConeKotlinType? = null,
        newContextReceiverTypes: List<ConeKotlinType?>? = null,
        newReturnType: ConeKotlinType? = null,
        newModality: Modality? = null,
        newVisibility: Visibility? = null,
        deferredReturnTypeCalculation: DeferredCallableCopyReturnType? = null,
        newSource: KtSourceElement? = derivedClassLookupTag?.toSymbol(session)?.source ?: baseFunction.source,
    ): FirSimpleFunction = buildSimpleFunction {
        source = newSource
        moduleData = session.nullableModuleData ?: baseFunction.moduleData
        this.origin = origin
        name = baseFunction.name
        status = baseFunction.status.copy(newVisibility, newModality, isExpect = isExpect, isOverride = true)
        symbol = newSymbol
        resolvePhase = origin.resolvePhaseForCopy

        dispatchReceiverType = newDispatchReceiverType
        attributes = baseFunction.attributes.copy()
        typeParameters += configureAnnotationsTypeParametersAndSignature(
            session, baseFunction, newParameterTypes, newTypeParameters,
            newReceiverType, newContextReceiverTypes, newReturnType, deferredReturnTypeCalculation, newSymbol,
            copyDefaultValues = false,
        ).filterIsInstance<FirTypeParameter>()
        deprecationsProvider = baseFunction.deprecationsProvider
    }.apply {
        containingClassForStaticMemberAttr = derivedClassLookupTag.takeIf { shouldOverrideSetContainingClass(baseFunction) }
    }

    fun createCopyForFirConstructor(
        fakeOverrideSymbol: FirConstructorSymbol,
        session: FirSession,
        baseConstructor: FirConstructor,
        derivedClassLookupTag: ConeClassLikeLookupTag?,","origin: FirDeclarationOrigin,"
"// !LANGUAGE: -ProhibitVisibilityOfNestedClassifiersFromSupertypesOfCompanion
// !DIAGNOSTICS: -UNUSED_VARIABLE

// FILE: J.java
public class J {
    public static void foo() {}
}

// FILE: test.kt
open class A<T> : J() {
    init {
        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>
        bar()
        val a: Int = <!TYPE_MISMATCH!><!DEBUG_INFO_LEAKING_THIS!>baz<!>()<!>
        val b: T = <!DEBUG_INFO_LEAKING_THIS!>baz<!>()
    }

    fun test1() {
        <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>
        bar()
        val a: Int = <!TYPE_MISMATCH!>baz()<!>
        val b: T = baz()
    }

    fun baz(): T = null!!

    object O {
        fun test() {
            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>
            bar()
            val a: Int = baz()
            val b: <!UNRESOLVED_REFERENCE!>T<!> = baz()
        }
    }

    companion object : A<Int>() {
        init {
            <!DEPRECATED_ACCESS_BY_SHORT_NAME!>foo()<!>
            bar()
            val a: Int = baz()
            val b: <!UNRESOLVED_REFERENCE!>T<!> = baz()
        }",fun test() {
"internal companion object {
            private const val serialVersionUID = 0L
        }
    }

    /* Not implemented as data class to ensure more controllable binary compatibility */
    class Key<T> @PublishedApi internal constructor(
        val type: Type<T>,
        val name: String? = null,
    ) : Serializable {

        val stableString: String
            get() {
                return if (name == null) type.signature
                else ""${type.signature};$name""
            }

        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other !is Key<*>) return false
            if (name != other.name) return false
            if (type != other.type) return false
            return true
        }

        override fun hashCode(): Int {
            var result = name?.hashCode() ?: 0
            result = 31 * result + type.hashCode()
            return result
        }

        override fun toString(): String = stableString

        companion object {
            fun fromString(stableString: String): Key<*> {
                @OptIn(UnsafeApi::class) return if (stableString.contains(';')) {
                    val split = stableString.split(';', limit = 2)
                    Key<Any?>(Type(split[0]), split[1])
                } else Key<Any?>(Type(stableString))
            }

            private const val serialVersionUID = 0L
        }
    }

    /* Not implemented as data class to ensure more controllable binary compatibility */
    class Entry<T>(val key: Key<T>, val value: T) : Serializable {
        override fun equals(other: Any?): Boolean {
            if (this === other) return true
            if (other !is Entry<*>) return false
            if (other.key != key) return false
            if (other.value != value) return false
            return true
        }

        override fun hashCode(): Int {
            var result = key.hashCode()
            result = 31 * result + value.hashCode()
            return result
        }

        override fun toString(): String = ""$key=$value""

        operator fun component1() = key",operator fun component2() = value
"// TARGET_BACKEND: JVM
// JVM_TARGET: 1.8
// SAM_CONVERSIONS: INDY
// WITH_STDLIB

// CHECK_BYTECODE_TEXT
// JVM_IR_TEMPLATES
// 0 java/lang/invoke/LambdaMetafactory
// 19 final synthetic class BoundAdaptedFunctionReferenceKt\$box\$[0-9]*
// 1 final synthetic class FromOtherFileKt\$target1FromOtherFile\$[0-9]*
// 1 final synthetic class FromOtherFileKt\$adapted1FromOtherFile\$[0-9]*
// 1 final synthetic class FromOtherFileKt\$adapted2FromOtherFile\$[0-9]*

// FILE: boundAdaptedFunctionReference.kt

fun checkEqual(x: Any, y: Any) {
    if (x != y || y != x) throw AssertionError(""$x and $y should be equal"")
    if (x.hashCode() != y.hashCode()) throw AssertionError(""$x and $y should have the same hash code"")
}

fun checkNotEqual(x: Any, y: Any) {
    if (x == y || y == x) throw AssertionError(""$x and $y should NOT be equal"")
}

fun interface FunInterface {
    fun invoke()
}

private fun id(f: FunInterface): Any = f

class C {",fun target1() {}
"public constructor StringBuilder()

    public constructor StringBuilder(content: kotlin.CharSequence)

    public constructor StringBuilder(capacity: kotlin.Int)

    public constructor StringBuilder(content: kotlin.String)

    public open override val length: kotlin.Int { get; }

    public final fun append(value: kotlin.Any?): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.3"")
    public final fun append(value: kotlin.Boolean): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.9"")
    public final fun append(value: kotlin.Byte): kotlin.text.StringBuilder

    public open override fun append(value: kotlin.Char): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.4"")
    public final fun append(value: kotlin.CharArray): kotlin.text.StringBuilder

    public open override fun append(value: kotlin.CharSequence?): kotlin.text.StringBuilder

    public open override fun append(value: kotlin.CharSequence?, startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.9"")
    public final fun append(value: kotlin.Double): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.9"")
    public final fun append(value: kotlin.Float): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.9"")
    public final fun append(value: kotlin.Int): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.9"")
    public final fun append(value: kotlin.Long): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.9"")
    public final fun append(value: kotlin.Short): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.3"")
    public final fun append(value: kotlin.String?): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.4"")
    public final fun appendRange(value: kotlin.CharArray, startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.4"")
    public final fun appendRange(value: kotlin.CharSequence, startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.3"")
    @kotlin.Deprecated(level = DeprecationLevel.WARNING, message = ""Obtaining StringBuilder capacity is not supported in JS and common code."")
    public final fun capacity(): kotlin.Int

    @kotlin.SinceKotlin(version = ""1.3"")
    public final fun clear(): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.4"")
    public final fun deleteAt(index: kotlin.Int): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.4"")
    public final fun deleteRange(startIndex: kotlin.Int, endIndex: kotlin.Int): kotlin.text.StringBuilder

    @kotlin.SinceKotlin(version = ""1.4"")",public final fun ensureCapacity(minimumCapacity: kotlin.Int): kotlin.Unit
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.lower.coroutines

import org.jetbrains.kotlin.backend.common.BodyLoweringPass
import org.jetbrains.kotlin.ir.backend.js.JsIrBackendContext
import org.jetbrains.kotlin.ir.backend.js.utils.compileSuspendAsJsGenerator
import org.jetbrains.kotlin.ir.declarations.IrDeclaration
import org.jetbrains.kotlin.ir.expressions.IrBody
import org.jetbrains.kotlin.ir.expressions.IrCall
import org.jetbrains.kotlin.ir.expressions.IrCallableReference
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.symbols.IrSimpleFunctionSymbol
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
import org.jetbrains.kotlin.ir.visitors.transformChildrenVoid

class ReplaceSuspendIntrinsicLowering(private val context: JsIrBackendContext) : BodyLoweringPass {
    private val valueParamSizeToItsCreateCoroutineUnintercepted =
        context.intrinsics.createCoroutineUninterceptedGeneratorVersion.groupPerValueParamSize()
    private val valueParamSizeToItsStartCoroutineUninterceptedOrReturn =
        context.intrinsics.startCoroutineUninterceptedOrReturnGeneratorVersion.groupPerValueParamSize()

    private fun Set<IrSimpleFunctionSymbol>.groupPerValueParamSize(): Map<Int, IrSimpleFunctionSymbol> {
        return associateBy { it.owner.valueParameters.size }
    }

    override fun lower(irBody: IrBody, container: IrDeclaration) {
        if (!context.compileSuspendAsJsGenerator) return
        irBody.transformChildrenVoid(object : IrElementTransformerVoid() {
            override fun visitCallableReference(expression: IrCallableReference<*>): IrExpression {
                if (expression.symbol !is IrSimpleFunctionSymbol) return super.visitCallableReference(expression)

                @Suppress(""UNCHECKED_CAST"")
                val reference = expression as IrCallableReference<IrSimpleFunctionSymbol>

                when (val symbol = reference.symbol) {
                    in context.intrinsics.createCoroutineUnintercepted ->
                        reference.symbol = valueParamSizeToItsCreateCoroutineUnintercepted.getValue(symbol.owner.valueParameters.size)
                    in context.intrinsics.startCoroutineUninterceptedOrReturn ->
                        reference.symbol = valueParamSizeToItsStartCoroutineUninterceptedOrReturn.getValue(symbol.owner.valueParameters.size)
                }

                return super.visitCallableReference(reference)
            }

            override fun visitCall(expression: IrCall): IrExpression {
                when (val symbol = expression.symbol) {
                    in context.intrinsics.createCoroutineUnintercepted ->
                        expression.symbol = valueParamSizeToItsCreateCoroutineUnintercepted.getValue(symbol.owner.valueParameters.size)
                    in context.intrinsics.startCoroutineUninterceptedOrReturn ->",expression.symbol = valueParamSizeToItsStartCoroutineUninterceptedOrReturn.getValue(symbol.owner.valueParameters.size)
"internal fun IrClass.hasSerializableOrMetaAnnotationWithoutArgs(): Boolean = checkSerializableOrMetaAnnotationArgs(mustDoNotHaveArgs = true)

fun IrClass.hasSerializableOrMetaAnnotation() = checkSerializableOrMetaAnnotationArgs(mustDoNotHaveArgs = false)

private fun IrClass.hasSerializableAnnotationWithArgs(): Boolean {
    val annot = getAnnotation(SerializationAnnotations.serializableAnnotationFqName)
    return annot?.getValueArgument(0) != null
}

private fun IrClass.checkSerializableOrMetaAnnotationArgs(mustDoNotHaveArgs: Boolean): Boolean {
    val annot = getAnnotation(SerializationAnnotations.serializableAnnotationFqName)
    if (annot != null) { // @Serializable have higher priority
        if (!mustDoNotHaveArgs) return true
        if (annot.getValueArgument(0) != null) return false
        return true
    }
    return annotations
        .map { it.constructedClass.annotations }
        .any { it.hasAnnotation(SerializationAnnotations.metaSerializableAnnotationFqName) }
}

internal val IrClass.isSerialInfoAnnotation: Boolean
    get() = annotations.hasAnnotation(SerializationAnnotations.serialInfoFqName)
            || annotations.hasAnnotation(SerializationAnnotations.inheritableSerialInfoFqName)
            || annotations.hasAnnotation(SerializationAnnotations.metaSerializableAnnotationFqName)

internal val IrClass.isInheritableSerialInfoAnnotation: Boolean
    get() = annotations.hasAnnotation(SerializationAnnotations.inheritableSerialInfoFqName)

internal fun IrClass.shouldHaveGeneratedSerializer(): Boolean =
    (isInternalSerializable && (modality == Modality.FINAL || modality == Modality.OPEN))
            || isEnumWithLegacyGeneratedSerializer()
            // enum factory must be used for enums
            || (shouldHaveGeneratedMethods() && kind != ClassKind.ENUM_CLASS)

internal val IrClass.shouldHaveGeneratedMethodsInCompanion: Boolean
    get() = this.isSerializableObject || this.isSerializableEnum() || (this.kind == ClassKind.CLASS && hasSerializableOrMetaAnnotation()) || this.isSealedSerializableInterface || this.isSerializableInterfaceWithCustom

internal fun IrClass.isSerializableEnum(): Boolean = kind == ClassKind.ENUM_CLASS && hasSerializableOrMetaAnnotation()

internal val IrType.genericIndex: Int?
    get() = (this.classifierOrNull as? IrTypeParameterSymbol)?.owner?.index

fun IrType.serialName(): String = this.classOrUpperBound()!!.owner.serialName()

fun IrClass.serialName(): String {
    return annotations.serialNameValue ?: fqNameWhenAvailable?.asString() ?: error(""${this.render()} does not have fqName"")
}

fun IrClass.findEnumValuesMethod() = this.functions.singleOrNull { f ->
    f.name == Name.identifier(""values"") && f.valueParameters.isEmpty() && f.extensionReceiverParameter == null && f.dispatchReceiverParameter == null
} ?: error(""Enum class does not have single .values() function"")

internal fun IrClass.enumEntries(): List<IrEnumEntry> {
    check(this.kind == ClassKind.ENUM_CLASS)
    return declarations.filterIsInstance<IrEnumEntry>().toList()
}

internal fun IrClass.isEnumWithSerialInfoAnnotation(): Boolean {
    if (kind != ClassKind.ENUM_CLASS) return false
    if (annotations.hasAnySerialAnnotation) return true
    return enumEntries().any { (it.annotations.hasAnySerialAnnotation) }
}

fun IrClass.findWriteSelfMethod(): IrSimpleFunction? =",functions.singleOrNull { it.name == SerialEntityNames.WRITE_SELF_NAME && !it.isFakeOverride }
"// Auto-generated by GenerateSteppedRangesCodegenTestData. Do not edit!
// WITH_STDLIB
import kotlin.test.*

fun box(): String {
    val intList = mutableListOf<Int>()
    for (i in 1 until 8 step 3 step 2) {
        intList += i
    }
    assertEquals(listOf(1, 3, 5, 7), intList)

    val longList = mutableListOf<Long>()
    for (i in 1L until 8L step 3L step 2L) {
        longList += i
    }","assertEquals(listOf(1L, 3L, 5L, 7L), longList)"
"}

    override fun visitBlock(block: FirBlock) {
        if (block !is FirContractCallBlock) {
            super.visitBlock(block)
        }
    }

    override fun visitContractDescription(contractDescription: FirContractDescription) {
        // Skip contract description.
        // Contract blocks are skipped in BE, so we would never need to inline contract DSL calls.
    }

    override fun visitConstructor(constructor: FirConstructor) {
        constructor.lazyResolveToPhase(FirResolvePhase.BODY_RESOLVE)

        super.visitConstructor(constructor)
    }

    override fun visitSimpleFunction(simpleFunction: FirSimpleFunction) {
        simpleFunction.lazyResolveToPhase(FirResolvePhase.BODY_RESOLVE)

        val oldIsInlineFunctionContext = isInlineFunctionContext
        try {
            isInlineFunctionContext = simpleFunction.isInline
            super.visitFunction(simpleFunction)
        } finally {
            isInlineFunctionContext = oldIsInlineFunctionContext
        }
    }

    override fun visitProperty(property: FirProperty) {
        property.lazyResolveToPhase(FirResolvePhase.BODY_RESOLVE)

        super.visitProperty(property)
    }

    override fun visitClass(klass: FirClass) {
        super.visitClass(klass)

        if (isInlineFunctionContext) {
            collectedInlinedClasses.addIfNotNull(klass.psi as? KtClassOrObject)
        }
    }

    @OptIn(SymbolInternals::class)
    private fun processResolvable(element: FirResolvable) {
        fun addToQueue(function: FirFunction?) {
            val original = function?.unwrapSubstitutionOverrides() ?: return
            if (original.isInline && original.hasBody) {
                queue.add(function)
            }
        }

        val reference = element.calleeReference
        if (reference !is FirResolvedNamedReference) {
            return
        }

        val symbol = reference.resolvedSymbol
        if (symbol is FirCallableSymbol<*>) {
            when (val fir = symbol.fir) {
                is FirFunction -> {
                    addToQueue(fir)
                }",is FirProperty -> {
"import kotlin.reflect.KProperty

class Delegate {
    var inner = 1
    operator fun getValue(t: Any?, p: KProperty<*>): Int = inner
    operator fun setValue(t: Any?, p: KProperty<*>, i: Int) { inner = i }
}

fun foo() = Delegate()

class A {
    var prop: Int by foo()
}",fun box(): String {
"import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.declaration.FirAbstractOverrideChecker
import org.jetbrains.kotlin.fir.analysis.checkers.unsubstitutedScope
import org.jetbrains.kotlin.fir.analysis.diagnostics.jvm.FirJvmErrors
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.declarations.utils.isExpect
import org.jetbrains.kotlin.fir.java.enhancement.EnhancedForWarningConeSubstitutor
import org.jetbrains.kotlin.fir.scopes.*
import org.jetbrains.kotlin.fir.scopes.impl.FirFakeOverrideGenerator
import org.jetbrains.kotlin.fir.symbols.SymbolInternals
import org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol
import org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase
import org.jetbrains.kotlin.fir.types.coneType
import org.jetbrains.kotlin.fir.types.typeContext
import org.jetbrains.kotlin.utils.addToStdlib.runIf

sealed class FirOverrideJavaNullabilityWarningChecker(mppKind: MppCheckerKind) : FirAbstractOverrideChecker(mppKind) {
    object Regular : FirOverrideJavaNullabilityWarningChecker(MppCheckerKind.Platform) {
        override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {
            if (declaration.isExpect) return
            super.check(declaration, context, reporter)
        }
    }

    object ForExpectClass : FirOverrideJavaNullabilityWarningChecker(MppCheckerKind.Common) {
        override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {
            if (!declaration.isExpect) return
            super.check(declaration, context, reporter)
        }
    }

    override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {
        val substitutor = EnhancedForWarningConeSubstitutor(context.session.typeContext)
        val scope = declaration.unsubstitutedScope(context)
        val typeCheckerState = context.session.typeContext.newTypeCheckerState(
            errorTypesEqualToAnything = false,
            stubTypesEqualToAnything = false
        )

        for (member in declaration.declarations) {
            var anyBaseEnhanced = false
            var anyReported = false

            if (member is FirSimpleFunction) {
                val enhancedOverrides = scope
                    .getDirectOverriddenFunctions(member.symbol)
                    .map {
                        val substitutedBase = it.substituteOrNull(substitutor, context) ?: return@map it
                        anyBaseEnhanced = true

                        if (!anyReported && !context.session.firOverrideChecker.isOverriddenFunction(member.symbol, substitutedBase)) {
                            anyReported = true
                            reporter.reportOn(
                                member.source,
                                FirJvmErrors.WRONG_NULLABILITY_FOR_JAVA_OVERRIDE,
                                member.symbol,
                                substitutedBase,
                                context
                            )
                        }

                        substitutedBase
                    }",if (anyBaseEnhanced && !anyReported) {
"for (projStep in projectInfo.steps) {
                val testInfo = projStep.order.map { setupTestStep(projStep, it) }

                val mainModuleInfo = testInfo.last()
                testInfo.find { it != mainModuleInfo && it.friends.isNotEmpty() }?.let {
                    error(""module ${it.moduleName} has friends, but only main module may have the friends"")
                }

                val configuration = createConfiguration(projStep.order.last(), projStep.language, projectInfo.moduleKind)

                val dirtyData = when (granularity) {
                    JsGenerationGranularity.PER_FILE -> projStep.dirtyJsFiles
                    else -> projStep.dirtyJsModules
                }

                val cacheUpdater = CacheUpdater(
                    mainModule = mainModuleInfo.modulePath,
                    allModules = testInfo.mapTo(mutableListOf(STDLIB_KLIB, KOTLIN_TEST_KLIB)) { it.modulePath },
                    mainModuleFriends = mainModuleInfo.friends,
                    cacheDir = buildDir.resolve(""incremental-cache"").absolutePath,
                    compilerConfiguration = configuration,
                    irFactory = { IrFactoryImplForJsIC(WholeWorldStageController()) },
                    compilerInterfaceFactory = { mainModule, cfg ->
                        JsIrCompilerWithIC(
                            mainModule,
                            mainArguments,
                            cfg,
                            granularity,
                            getPhaseConfig(projStep.id),
                            setOf(FqName(BOX_FUNCTION_NAME)),
                        )
                    }
                )

                val removedModulesInfo = (projectInfo.modules - projStep.order.toSet()).map { setupTestStep(projStep, it) }

                val icCaches = cacheUpdater.actualizeCaches()
                verifyCacheUpdateStats(projStep.id, cacheUpdater.getDirtyFileLastStats(), testInfo + removedModulesInfo)

                val mainModuleName = icCaches.last().moduleExternalName
                val jsExecutableProducer = JsExecutableProducer(
                    mainModuleName = mainModuleName,
                    moduleKind = configuration[JSConfigurationKeys.MODULE_KIND]!!,
                    sourceMapsInfo = SourceMapsInfo.from(configuration),
                    caches = icCaches,
                    relativeRequirePath = true
                )

                val (jsOutput, rebuiltModules) = jsExecutableProducer.buildExecutable(granularity, outJsProgram = true)
                val writtenFiles = writeJsCode(projStep.id, mainModuleName, jsOutput, dtsStrategy)

                verifyJsExecutableProducerBuildModules(projStep.id, rebuiltModules, dirtyData)
                verifyJsCode(projStep.id, mainModuleName, writtenFiles)
                verifyDTS(projStep.id, testInfo)
            }
        }
    }

    private fun String.isAllowedKtFile() = endsWith("".kt"") && !TEST_FILE_IGNORE_PATTERN.matches(this)

    private fun String.isAllowedJsFile() = (endsWith("".js"") || endsWith("".mjs"")) && !TEST_FILE_IGNORE_PATTERN.matches(this)

    protected fun CompilerConfiguration.addSourcesFromDir(sourceDir: File): List<KtFile> {
        assert(sourceDir.isDirectory && sourceDir.exists()) { ""Cannot find source directory $sourceDir"" }","val sourceFiles = Files.find(sourceDir.toPath(), Integer.MAX_VALUE, { path: Path, fileAttributes: BasicFileAttributes ->"
"/*
 * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the LICENSE file.
 */
@file:OptIn(FreezingIsDeprecated::class)

package test.text

import kotlin.reflect.KClass
import kotlin.test.*
import kotlinx.cinterop.toKString
import test.assertArrayContentEquals

internal actual val surrogateCodePointDecoding: String = ""\uFFFD"".repeat(3)

internal actual val surrogateCharEncoding: ByteArray = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())

// Native-specific part of stdlib/test/text/StringEncodingTest.kt
class StringEncodingTestNative {
    private fun bytes(vararg elements: Int) = ByteArray(elements.size) {
        val v = elements[it]
        require(v in Byte.MIN_VALUE..Byte.MAX_VALUE)
        v.toByte()
    }

    private fun testEncoding(isWellFormed: Boolean, expected: ByteArray, string: String) {","assertArrayContentEquals(expected, string.encodeToByteArray())"
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_PARAMETER
// KT-7440 Cannot complete type inference if two extension functions for interface hierarchy

package inferenceagain",interface Base<T>
"}
        builder.append(""$indent</$name>\n"")
    }

    private fun renderAttributes(): String? {
        val builder = StringBuilder()
        for (a in attributes.keys) {
            builder.append("" $a=\""${attributes[a]}\"""")
        }
        return builder.toString()
    }
}

abstract class TagWithText(name: String) : Tag(name) {
    operator fun String.unaryPlus() {
        children.add(TextElement(this))
    }
}

class HTML() : TagWithText(""html"") {
    inline fun head(init: Head.() -> Unit) = initTag(Head(), init)

    inline fun body(init: Body.() -> Unit) = initTag(Body(), init)

    fun bodyNoInline(init: Body.() -> Unit) = initTag(Body(), init)
}

class Head() : TagWithText(""head"") {
    inline fun title(init: Title.() -> Unit) = initTag(Title(), init)
}

class Title() : TagWithText(""title"")

abstract class BodyTag(name: String) : TagWithText(name) {
    inline fun b(init: B.() -> Unit) = initTag(B(), init)
    inline fun p(init: P.() -> Unit) = initTag(P(), init)
    inline fun pNoInline(init: P.() -> Unit) = initTag(P(), init)
    inline fun h1(init: H1.() -> Unit) = initTag(H1(), init)
    inline fun ul(init: UL.() -> Unit) = initTag(UL(), init)
    inline fun a(href: String, init: A.() -> Unit) {
        val a = initTag(A(), init)
        a.href = href
    }
}

class Body() : BodyTag(""body"")
class UL() : BodyTag(""ul"") {
    inline fun li(init: LI.() -> Unit) = initTag(LI(), init)
}

class B() : BodyTag(""b"")
class LI() : BodyTag(""li"")
class P() : BodyTag(""p"")
class H1() : BodyTag(""h1"")
class A() : BodyTag(""a"") {
    public var href: String
        get() = attributes[""href""]!!
        set(value) {
            attributes[""href""] = value
        }
}

inline fun html(init: HTML.() -> Unit): HTML {
    val html = HTML()
    html.init()",return html
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.tasks.configuration

import org.gradle.api.Project
import org.gradle.api.provider.Property
import org.gradle.api.provider.Provider
import org.gradle.api.tasks.TaskProvider
import org.gradle.api.tasks.compile.AbstractCompile
import org.jetbrains.kotlin.gradle.dsl.KotlinJvmCompilerOptions
import org.jetbrains.kotlin.gradle.dsl.KotlinJvmCompilerOptionsHelper
import org.jetbrains.kotlin.gradle.dsl.KotlinTopLevelExtension
import org.jetbrains.kotlin.gradle.internal.*
import org.jetbrains.kotlin.gradle.internal.Kapt3GradleSubplugin.Companion.KAPT_SUBPLUGIN_ID
import org.jetbrains.kotlin.gradle.internal.Kapt3GradleSubplugin.Companion.isIncludeCompileClasspath
import org.jetbrains.kotlin.gradle.internal.Kapt3GradleSubplugin.Companion.isUseK2
import org.jetbrains.kotlin.gradle.plugin.KaptExtension
import org.jetbrains.kotlin.gradle.plugin.KotlinCompilation
import org.jetbrains.kotlin.gradle.plugin.KotlinCompilationInfo
import org.jetbrains.kotlin.gradle.tasks.CompilerPluginOptions
import org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile
import org.jetbrains.kotlin.gradle.tasks.withType
import org.jetbrains.kotlin.gradle.utils.whenKaptEnabled

internal class KaptGenerateStubsConfig : BaseKotlinCompileConfig<KaptGenerateStubsTask> {

    constructor(
        compilation: KotlinCompilation<*>
    ) : super(KotlinCompilationInfo(compilation)) {
        configureFromExtension(project.extensions.getByType(KaptExtension::class.java))

        configureTask { kaptGenerateStubsTask ->
            // Syncing compiler options from related KotlinJvmCompile task
            @Suppress(""DEPRECATION"") val jvmCompilerOptions = compilation.compilerOptions.options as KotlinJvmCompilerOptions
            KotlinJvmCompilerOptionsHelper.syncOptionsAsConvention(
                from = jvmCompilerOptions,
                into = kaptGenerateStubsTask.compilerOptions
            )

            // This task should not sync any freeCompilerArgs from relevant KotlinCompile task
            // when someone explicitly configures any value for this task as well.
            // Here we reset any configured value and say that use KotlinCompile freeCompilerArgs as convention
            kaptGenerateStubsTask.compilerOptions.freeCompilerArgs.value(null as Iterable<String>?)
            kaptGenerateStubsTask.compilerOptions.freeCompilerArgs.convention(jvmCompilerOptions.freeCompilerArgs)
        }
    }","constructor(project: Project, ext: KotlinTopLevelExtension, kaptExtension: KaptExtension) : super(project, ext) {"
fun main() {,var result: String? = null
"// SKIP_KT_DUMP
// FIR_IDENTICAL
// TARGET_BACKEND: JVM
// FULL_JDK
// WITH_STDLIB

// FILE: Java1.java
public class Java1 {
    public <T> void foo(T a) { }
    public <T> T bar() {
        return null;
    }
}

// FILE: 1.kt

class A : Java1()

class B : Java1() {
    override fun <T : Any> foo(a: T?) { }",override fun <T : Any> bar(): T? {
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin

import org.gradle.api.Project
import org.jetbrains.kotlin.gradle.plugin.PropertiesProvider.Companion.kotlinPropertiesProvider
import org.jetbrains.kotlin.gradle.plugin.diagnostics.KotlinToolingDiagnostics.FailedToGetAgpVersionWarning
import org.jetbrains.kotlin.gradle.plugin.diagnostics.KotlinToolingDiagnostics.IncompatibleAgpVersionTooHighWarning
import org.jetbrains.kotlin.gradle.plugin.diagnostics.KotlinToolingDiagnostics.IncompatibleAgpVersionTooLowWarning
import org.jetbrains.kotlin.gradle.plugin.diagnostics.kotlinToolingDiagnosticsCollector
import org.jetbrains.kotlin.gradle.utils.androidPluginIds
import org.jetbrains.kotlin.gradle.utils.findAppliedAndroidPluginIdOrNull
import org.jetbrains.kotlin.gradle.utils.getOrPutRootProjectProperty
import org.jetbrains.kotlin.gradle.utils.runProjectConfigurationHealthCheck
import java.util.concurrent.atomic.AtomicBoolean

internal object KotlinMultiplatformAndroidGradlePluginCompatibilityHealthCheck {

    val compatibleAndroidGradlePluginVersionRange = AndroidGradlePluginVersionRange(
        minSupportedVersion = AndroidGradlePluginVersionRange.Version(7, 1),
        maxSupportedVersion = AndroidGradlePluginVersionRange.Version(8, 3)
    )

    /**
     * Used to store project paths that executed this health check
     */
    const val PROPERTY_KEY_EXECUTED_PROJECT_PATHS = ""KotlinMultiplatformAndroidGradlePluginCompatibilityHealthCheck.executedProjects""

    data class AndroidGradlePluginVersionRange(
        val minSupportedVersion: Version,
        val maxSupportedVersion: Version
    ) {

        constructor(
            minSupportedVersionMajor: Int, minSupportedVersionMinor: Int = 0,
            maxSupportedVersionMajor: Int, maxSupportedVersionMinor: Int = 0
        ) : this(
            minSupportedVersion = Version(minSupportedVersionMajor, minSupportedVersionMinor),
            maxSupportedVersion = Version(maxSupportedVersionMajor, maxSupportedVersionMinor)
        )

        data class Version(val major: Int, val minor: Int)

        fun isTooHigh(version: AndroidGradlePluginVersion): Boolean {
            if (version.major > this.maxSupportedVersion.major) return true",if (version.major < this.maxSupportedVersion.major) return false
"targetIds.map(incrementalComponents::getIncrementalCache)
        ),
        incrementalCompilationScope
    )
}

private class ProjectEnvironmentWithCoreEnvironmentEmulation(
    project: Project,
    localFileSystem: VirtualFileSystem,
    getPackagePartProviderFn: (GlobalSearchScope) -> PackagePartProvider,
    val initialRoots: List<JavaRoot>,
    val configuration: CompilerConfiguration
) : VfsBasedProjectEnvironment(project, localFileSystem, getPackagePartProviderFn) {

    val packagePartProviders = mutableListOf<JvmPackagePartProvider>()

    override fun getPackagePartProvider(fileSearchScope: AbstractProjectFileSearchScope): PackagePartProvider {
        return super.getPackagePartProvider(fileSearchScope).also {
            (it as? JvmPackagePartProvider)?.run {
                addRoots(initialRoots, configuration.getNotNull(CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY))
                packagePartProviders += this
            }
        }
    }
}

fun createProjectEnvironment(
    configuration: CompilerConfiguration,
    parentDisposable: Disposable,
    configFiles: EnvironmentConfigFiles,
    messageCollector: MessageCollector
): VfsBasedProjectEnvironment {
    setupIdeaStandaloneExecution()
    val appEnv = KotlinCoreEnvironment.getOrCreateApplicationEnvironmentForProduction(parentDisposable, configuration)
    // TODO: get rid of projEnv too - seems that all needed components could be easily extracted
    val projectEnvironment = KotlinCoreEnvironment.ProjectEnvironment(parentDisposable, appEnv, configuration)

    projectEnvironment.configureProjectEnvironment(configuration, configFiles)

    val project = projectEnvironment.project
    val localFileSystem = VirtualFileManager.getInstance().getFileSystem(StandardFileSystems.FILE_PROTOCOL)

    val javaFileManager = project.getService(CoreJavaFileManager::class.java) as KotlinCliJavaFileManagerImpl

    val releaseTarget = configuration.get(JVMConfigurationKeys.JDK_RELEASE)

    val javaModuleFinder =
        CliJavaModuleFinder(configuration.get(JVMConfigurationKeys.JDK_HOME), messageCollector, javaFileManager, project, releaseTarget)

    val outputDirectory =
        configuration.get(JVMConfigurationKeys.MODULES)?.singleOrNull()?.getOutputDirectory()
            ?: configuration.get(JVMConfigurationKeys.OUTPUT_DIRECTORY)?.absolutePath

    val classpathRootsResolver = ClasspathRootsResolver(
        PsiManager.getInstance(project),
        messageCollector,
        configuration.getList(JVMConfigurationKeys.ADDITIONAL_JAVA_MODULES),
        { contentRootToVirtualFile(it, localFileSystem, projectEnvironment.jarFileSystem, messageCollector) },
        javaModuleFinder,
        !configuration.getBoolean(CLIConfigurationKeys.ALLOW_KOTLIN_PACKAGE),
        outputDirectory?.let { localFileSystem.findFileByPath(it) },
        javaFileManager,
        releaseTarget
    )","val (initialRoots, javaModules) ="
"}
}

class E1 {
    val property: Any get() = TODO()
    fun function(value: Any): Any = value

    class Nested {
        val property: Any get() = TODO()
        fun function(value: Any): Any = value
    }

    inner class Inner {
        val property: Any get() = TODO()
        fun function(value: Any): Any = value
    }
}

class E2<T : Any?> {
    val property: T get() = TODO()
    fun function(value: T): T = value

    class Nested<T : Any?> {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }
}

class E3<R : Any?> {
    val property: R get() = TODO()
    fun function(value: R): R = value

    class Nested<R : Any?> {
        val property: R get() = TODO()
        fun function(value: R): R = value
    }

    inner class Inner {
        val property: R get() = TODO()
        fun function(value: R): R = value
    }
}

class E4<T : Any> {
    val property: T get() = TODO()
    fun function(value: T): T = value

    class Nested<T : Any> {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }
}

class E5<T : CharSequence> {
    val property: T get() = TODO()",fun function(value: T): T = value
"val deprecationProvider = DeprecationResolver(
        LockBasedStorageManager.NO_LOCKS, languageVersionSettings, JavaDeprecationSettings
    )

    // TODO: remove after cleanin up IDE counterpart
    var files: List<KtFile>? = null
    var codegenFactory: CodegenFactory? = null

    init {
        val icComponents = configuration.get(JVMConfigurationKeys.INCREMENTAL_COMPILATION_COMPONENTS)
        if (icComponents != null) {
            val targetId = targetId
                ?: moduleName?.let {
                    // hack for Gradle IC, Gradle does not use build.xml file, so there is no way to pass target id
                    TargetId(it, ""java-production"")
                } ?: error(""Target ID should be specified for incremental compilation"")
            incrementalCacheForThisTarget = icComponents.getIncrementalCache(targetId)
            packagesWithObsoleteParts = incrementalCacheForThisTarget.getObsoletePackageParts().map {
                JvmClassName.byInternalName(it).packageFqName
            }.toSet()
            obsoleteMultifileClasses = incrementalCacheForThisTarget.getObsoleteMultifileClasses().map {
                JvmClassName.byInternalName(it).fqNameForClassNameWithoutDollars
            }
        } else {
            incrementalCacheForThisTarget = null
            packagesWithObsoleteParts = emptySet()
            obsoleteMultifileClasses = emptyList()
        }
    }

    private val extraJvmDiagnosticsTrace: BindingTrace =
        DelegatingBindingTrace(
            originalFrontendBindingContext, ""For extra diagnostics in ${this::class.java}"", false,
            customSuppressCache = if (isIrBackend) OnDemandSuppressCache(originalFrontendBindingContext) else null,
        )

    private val interceptedBuilderFactory: ClassBuilderFactory
    private var used = false

    val diagnostics: DiagnosticSink get() = extraJvmDiagnosticsTrace
    val collectedExtraJvmDiagnostics: Diagnostics = LazyJvmDiagnostics {
        duplicateSignatureFactory?.reportDiagnostics()
        extraJvmDiagnosticsTrace.bindingContext.diagnostics
    }

    val moduleName: String = moduleName ?: JvmCodegenUtil.getModuleName(module)
    val classBuilderMode: ClassBuilderMode = builderFactory.classBuilderMode
    val bindingTrace: BindingTrace = DelegatingBindingTrace(originalFrontendBindingContext, ""trace in GenerationState"")
    val bindingContext: BindingContext = bindingTrace.bindingContext
    val mainFunctionDetector = MainFunctionDetector(originalFrontendBindingContext, languageVersionSettings)
    val typeMapper: KotlinTypeMapper = KotlinTypeMapper(
        bindingContext,
        classBuilderMode,
        this.moduleName,
        languageVersionSettings,
        config.useOldManglingSchemeForFunctionsWithInlineClassesInSignatures,
        config.target,
        isIrBackend
    )
    val intrinsics: IntrinsicMethods =
        IntrinsicMethods(languageVersionSettings.apiVersion <= ApiVersion.parse(KotlinVersion.CURRENT.toString())!!)

    val samWrapperClasses: SamWrapperClasses = SamWrapperClasses(this)
    val globalInlineContext: GlobalInlineContext = GlobalInlineContext()",val mappingsClassesForWhenByEnum: MappingsClassesForWhenByEnum = MappingsClassesForWhenByEnum(this)
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.util

import org.jetbrains.kotlin.gradle.idea.testFixtures.tcs.binaryCoordinates

/**
 * Legacy -jdk8 and -jdk7 dependencies:
 * Those artifacts will be published as empty jars starting from Kotlin 1.8.0 as
 * the classes will be included in the kotlin-stdlib artifact already.
 *
 * Note: The kotlin-stdlib will add a constraint to always resolve 1.8.0 of those artifacts.
 * This will be necessary in the future, when no more jdk8 or jdk7 artifacts will be published:
 * In this case we need to still resolve to a version that will contain empty artifacts (1.8.0)
 *
 */
fun legacyStdlibJdkDependencies(version: String = ""1.8.0"") = listOf(","binaryCoordinates(""org.jetbrains.kotlin:kotlin-stdlib-jdk8:$version""),"
"import org.gradle.util.GradleVersion
import org.jetbrains.kotlin.gradle.testbase.*
import org.junit.jupiter.api.DisplayName

@MppGradlePluginTests
class WasmConfigurationCacheIT : KGPBaseTest() {
    override val defaultBuildOptions =
        super.defaultBuildOptions.copy(
            configurationCache = true,
        )

    @DisplayName(""configuration cache is working for wasm"")
    @GradleTest
    fun testKotlinWasmCompilation(gradleVersion: GradleVersion) {
        project(""wasm-d8-simple-project"", gradleVersion) {
            assertSimpleConfigurationCacheScenarioWorks(
                ""assemble"",
                buildOptions = defaultBuildOptions,
                executedTaskNames = listOf("":compileKotlinWasmJs"")
            )
        }
    }

    @DisplayName(""D8 run correctly works with configuration cache"")
    @GradleTest
    @GradleTestVersions(minVersion = TestVersions.Gradle.G_7_6)
    fun testD8Run(gradleVersion: GradleVersion) {
        project(
            ""wasm-d8-simple-project"",
            gradleVersion,
            dependencyManagement = DependencyManagement.DisabledDependencyManagement // :d8Download adds custom ivy repository during build
        ) {
            build(""wasmJsD8Run"", buildOptions = buildOptions) {
                assertTasksExecuted("":wasmJsD8Run"")
                if (gradleVersion < GradleVersion.version(TestVersions.Gradle.G_8_5)) {
                    assertOutputContains(
                        ""Calculating task graph as no configuration cache is available for tasks: wasmJsD8Run""
                    )
                } else {
                    assertOutputContains(
                        ""Calculating task graph as no cached configuration is available for tasks: wasmJsD8Run""
                    )
                }

                assertConfigurationCacheStored()
            }

            build(""clean"", buildOptions = buildOptions)

            // Then run a build where tasks states are deserialized to check that they work correctly in this mode
            build(""wasmJsD8Run"", buildOptions = buildOptions) {
                assertTasksExecuted("":wasmJsD8Run"")
                assertConfigurationCacheReused()
            }
        }
    }

    @DisplayName(""Browser case works correctly with configuration cache"")
    @GradleTest
    @GradleTestVersions(minVersion = TestVersions.Gradle.G_7_6)
    fun testBrowser(gradleVersion: GradleVersion) {
        project(""wasm-browser-simple-project"", gradleVersion) {
            assertSimpleConfigurationCacheScenarioWorks(
                ""assemble"",","buildOptions = defaultBuildOptions,"
"assertPrints(result, ""{b=98, o=111, n=110, e=101,  =32, j=106, u=117, r=114, é=233}"")
    }

    @Sample
    fun associateWith() {
        val string = ""bonne journée""
        // associate each character with its code
        val result = string.associateWith { char -> char.code }
        // notice each letter occurs only once
        assertPrints(result, ""{b=98, o=111, n=110, e=101,  =32, j=106, u=117, r=114, é=233}"")
    }

    @Sample
    fun associateWithTo() {
        val string = ""bonne journée""
        // associate each character with its code
        val result = mutableMapOf<Char, Int>()
        string.associateWithTo(result) { char -> char.code }
        // notice each letter occurs only once
        assertPrints(result, ""{b=98, o=111, n=110, e=101,  =32, j=106, u=117, r=114, é=233}"")
    }

    @Sample
    fun partition() {
        fun isVowel(c: Char) = ""aeuio"".contains(c, ignoreCase = true)
        val string = ""Discussion""
        val result = string.partition(::isVowel)
        assertPrints(result, ""(iuio, Dscssn)"")
    }

    @Sample
    fun stringToByteArray() {
        val charset = Charsets.UTF_8
        val byteArray = ""Hello"".toByteArray(charset)
        assertPrints(byteArray.contentToString(), ""[72, 101, 108, 108, 111]"")
        assertPrints(byteArray.toString(charset), ""Hello"")
    }

    @Sample
    fun lowercase() {
        assertPrints(""Iced frappé!"".lowercase(), ""iced frappé!"")
    }

    @Sample
    fun lowercaseLocale() {
        assertPrints(""KOTLIN"".lowercase(), ""kotlin"")
        val turkishLocale = Locale.forLanguageTag(""tr"")
        assertPrints(""KOTLIN"".lowercase(turkishLocale), ""kotlın"")
    }

    @Sample
    fun uppercase() {
        assertPrints(""Iced frappé!"".uppercase(), ""ICED FRAPPÉ!"")
    }

    @Sample
    fun uppercaseLocale() {
        assertPrints(""Kotlin"".uppercase(), ""KOTLIN"")
        val turkishLocale = Locale.forLanguageTag(""tr"")
        assertPrints(""Kotlin"".uppercase(turkishLocale), ""KOTLİN"")
    }

    @Sample
    fun padStart() {
        val padWithSpace = ""125"".padStart(5)","assertPrints(""'$padWithSpace'"", ""'  125'"")"
"// TARGET_BACKEND: JVM
// WITH_STDLIB
// WITH_COROUTINES

// FILE: defaultParametersInSuspsendWithJvmOverloads.kt
import helpers.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.test.assertEquals",@JvmOverloads
"// EXPECTED_REACHABLE_NODES: 1706
// KJS_WITH_FULL_RUNTIME
// SKIP_DCE_DRIVEN
// RUN_UNIT_TESTS

import common.*
import kotlin.test.Test
import kotlin.test.BeforeTest
import kotlin.test.AfterTest

class Simple {
    @BeforeTest
    fun before() {
        call(""before"")
    }

    @AfterTest
    fun after() {
        call(""after"")
    }

    @Test
    fun foo() {
        call(""foo"")
    }

    @Test
    fun bar() {
        call(""bar"")
    }

    @Test
    fun withException() {
        call(""withException"")
        raise(""some exception"")
        call(""never happens"")
    }
}

fun box() = checkLog {
    suite(""Simple"") {
        test(""foo"") {
            call(""before"")
            call(""foo"")
            call(""after"")
        }
        test(""bar"") {
            call(""before"")
            call(""bar"")
            call(""after"")
        }
        test(""withException"") {
            call(""before"")","call(""withException"")"
"@Suppress(""UNCHECKED_CAST"")
        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()
    }
    return toMutableList().apply { sort() }
}

/**
 * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.
 * 
 * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.
 * 
 * @sample samples.collections.Collections.Sorting.sortedBy
 */
public inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {
    return sortedWith(compareBy(selector))
}

/**
 * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.
 * 
 * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.
 */
public inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {
    return sortedWith(compareByDescending(selector))
}

/**
 * Returns a list of all elements sorted descending according to their natural sort order.
 * 
 * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.
 */
public fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {
    return sortedWith(reverseOrder())
}

/**
 * Returns a list of all elements sorted according to the specified [comparator].
 * 
 * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.
 */
public fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {
    if (this is Collection) {
       if (size <= 1) return this.toList()
       @Suppress(""UNCHECKED_CAST"")
       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()
    }
    return toMutableList().apply { sortWith(comparator) }
}

/**
 * Returns an array of Boolean containing all of the elements of this collection.
 */
public fun Collection<Boolean>.toBooleanArray(): BooleanArray {
    val result = BooleanArray(size)
    var index = 0
    for (element in this)
        result[index++] = element
    return result
}

/**
 * Returns an array of Byte containing all of the elements of this collection.
 */
public fun Collection<Byte>.toByteArray(): ByteArray {
    val result = ByteArray(size)",var index = 0
"fun DescriptorRendererOptions.defaultDecompilerRendererOptions() {
    withDefinedIn = false
    classWithPrimaryConstructor = true
    secondaryConstructorsAsPrimary = false
    modifiers = DescriptorRendererModifier.ALL
    excludedTypeAnnotationClasses = emptySet()
    alwaysRenderModifiers = true
    parameterNamesInFunctionalTypes = false // to support parameters names in decompiled text we need to load annotation arguments
    defaultParameterValueRenderer = { _ -> COMPILED_DEFAULT_PARAMETER_VALUE }
    includePropertyConstant = true
    propertyConstantRenderer = { _ -> COMPILED_DEFAULT_INITIALIZER }
}

/**
 * @see org.jetbrains.kotlin.analysis.decompiler.stub.mustNotBeWrittenToStubs
 */
internal fun CallableMemberDescriptor.mustNotBeWrittenToDecompiledText(): Boolean {
    return when (kind) {
        CallableMemberDescriptor.Kind.DECLARATION, CallableMemberDescriptor.Kind.DELEGATION -> false
        CallableMemberDescriptor.Kind.FAKE_OVERRIDE -> true
        CallableMemberDescriptor.Kind.SYNTHESIZED -> syntheticMemberMustNotBeWrittenToDecompiledText()
    }
}

private fun CallableMemberDescriptor.syntheticMemberMustNotBeWrittenToDecompiledText(): Boolean {
    val containingClass = containingDeclaration as? ClassDescriptor ?: return false

    return when {
        containingClass.kind == ClassKind.ENUM_CLASS -> {
            name in arrayOf(
                StandardNames.ENUM_VALUES,
                StandardNames.ENUM_ENTRIES,
                StandardNames.ENUM_VALUE_OF,
            )
        }

        else -> false
    }
}

fun buildDecompiledText(
    packageFqName: FqName,
    descriptors: List<DeclarationDescriptor>,
    descriptorRenderer: DescriptorRenderer,
): DecompiledText {
    val builder = StringBuilder()

    fun appendDecompiledTextAndPackageName() {
        builder.append(""// IntelliJ API Decompiler stub source generated from a class file\n"" + ""// Implementation of methods is not available"")
        builder.append(""\n\n"")
        if (!packageFqName.isRoot) {
            builder.append(""package "").append(packageFqName.render()).append(""\n\n"")
        }
    }

    fun appendDescriptor(descriptor: DeclarationDescriptor, indent: String, lastEnumEntry: Boolean? = null) {
        if (isEnumEntry(descriptor)) {
            for (annotation in descriptor.annotations) {
                builder.append(descriptorRenderer.renderAnnotation(annotation))
                builder.append("" "")
            }
            builder.append(descriptor.name.asString().quoteIfNeeded())
            builder.append(if (lastEnumEntry!!) "";"" else "","")
        } else {","builder.append(descriptorRenderer.render(descriptor).replace(""= ..."", DECOMPILED_COMMENT_FOR_PARAMETER))"
"configuration,
            diagnosticReporter,
            metadataSerializer,
            tmpKlibDir,
            emptyList(),
            moduleFragment,
            emptyList(),
            true,
            perFile,
            abiVersion = KotlinAbiVersion.CURRENT,
            jsOutputName = null,
        )

        return tmpKlibDir
    }

    private fun doDeserializeModuleMetadata(moduleRef: KotlinLibrary): ModuleDescriptorImpl {
        return getModuleDescriptorByLibrary(moduleRef, emptyMap())
    }

    private data class DeserializedModuleInfo(
        val module: IrModuleFragment,
        val symbolTable: SymbolTable,
        val irBuiltIns: IrBuiltIns,
        val linker: JsIrLinker
    )


    private fun doSerializeIrModule(module: IrModuleFragment): SerializedIrModule {
        return JsIrModuleSerializer(
            KtDiagnosticReporterWithImplicitIrBasedContext(
                DiagnosticReporterFactory.createPendingReporter(),
                configuration.languageVersionSettings,
            ),
            module.irBuiltins,
            CompatibilityMode.CURRENT,
            normalizeAbsolutePaths = false,
            emptyList(),
            configuration.languageVersionSettings,
        ).serializedIrModule(module)
    }

    private fun doWriteIrModuleToStorage(serializedIrModule: SerializedIrModule, writer: KotlinLibraryOnlyIrWriter) {
        writer.writeIr(serializedIrModule)
    }

    @OptIn(ObsoleteDescriptorBasedAPI::class)
    private fun doDeserializeIrModule(moduleDescriptor: ModuleDescriptorImpl): DeserializedModuleInfo {
        val mangler = JsManglerDesc
        val signaturer = IdSignatureDescriptor(mangler)
        val symbolTable = SymbolTable(signaturer, IrFactoryImpl)
        val typeTranslator = TypeTranslatorImpl(symbolTable, languageVersionSettings, moduleDescriptor)
        val irBuiltIns = IrBuiltInsOverDescriptors(moduleDescriptor.builtIns, typeTranslator, symbolTable)

        val jsLinker = JsIrLinker(moduleDescriptor, IrMessageLogger.None, irBuiltIns, symbolTable, PartialLinkageSupportForLinker.DISABLED, null)

        val moduleFragment = jsLinker.deserializeFullModule(moduleDescriptor, moduleDescriptor.kotlinLibrary)
        jsLinker.init(null, emptyList())
        // Create stubs
        ExternalDependenciesGenerator(symbolTable, listOf(jsLinker))
            .generateUnboundSymbolsAsDependencies()

        jsLinker.postProcess(inOrAfterLinkageStep = true)
        jsLinker.clear()",moduleFragment.patchDeclarationParents()
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.resolve.calls.smartcasts

import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.calls.context.ResolutionContext
import org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValue
import org.jetbrains.kotlin.types.KotlinType

/**
 * This class is intended to create data flow values for different kind of expressions.
 * Then data flow values serve as keys to obtain data flow information for these expressions.
 */
interface DataFlowValueFactory {
    fun createDataFlowValue(
        expression: KtExpression,
        type: KotlinType,
        resolutionContext: ResolutionContext<*>
    ): DataFlowValue

    fun createDataFlowValue(
        expression: KtExpression,
        type: KotlinType,
        bindingContext: BindingContext,
        containingDeclarationOrModule: DeclarationDescriptor
    ): DataFlowValue

    fun createDataFlowValueForStableReceiver(receiver: ReceiverValue): DataFlowValue

    fun createDataFlowValue(
        receiverValue: ReceiverValue,
        resolutionContext: ResolutionContext<*>
    ): DataFlowValue

    fun createDataFlowValue(","receiverValue: ReceiverValue,"
"/*
 * TESTCASE NUMBER: 15
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28785
 */
fun <T: InterfaceWithFiveTypeParameters1<*, *, *, *, *>?> T.case_15() {
    if (this != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.itest1()

        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>equals<!>(this)
        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>itest1<!>()
        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>apply<!> {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>
            equals(null)
            propT
            propAny
            propNullableT
            propNullableAny
            funT()
            funAny()
            funNullableT()
            funNullableAny()
            itest1()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.itest1()
        }
        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>also<!> {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.itest1()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.funNullableAny()
        }
    }
}

/*
 * TESTCASE NUMBER: 16
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28785
 */",fun <T: InterfaceWithTypeParameter1<out T>?> T.case_16() {
"override val element: IrElement,
) : InferenceNode() {
    override val kind: NodeKind get() = NodeKind.Expression
    override val function: InferenceFunction? get() = null
    override val referenceContainer: InferenceNode? get() = null
}

/**
 * An [InferenceResolvedParameter] is a node that references a parameter of a container of this
 * node. For example, if the parameter is captured by a nested lambda this is resolved to the
 * captured parameter.
 */
class InferenceResolvedParameter(
    override val element: IrGetValue,
    override val function: InferenceFunction,
    val container: InferenceNode,
    val index: Int
) : InferenceNode() {
    override val kind: NodeKind get() = NodeKind.ParameterReference
    override fun parameterIndex(node: InferenceNode): Int =
        if (node.function == function) index else -1

    override val referenceContainer: InferenceNode get() = container

    override fun equals(other: Any?): Boolean =
        other is InferenceResolvedParameter && other.element == element

    override fun hashCode(): Int = element.hashCode() * 31 + 103
}

private inline fun <reified T> IrConstructorCall.firstParameterOrNull() =
    if (valueArgumentsCount >= 1) {
        (getValueArgument(0) as? IrConst<*>)?.value as? T
    } else null

private val IrConstructorCall.isComposableTarget get() =
    annotationClass?.isClassWithFqName(
        ComposeFqNames.ComposableTarget.toUnsafe()
    ) == true

private val IrConstructorCall.isComposableTargetMarked: Boolean get() =
    annotationClass?.owner?.annotations?.hasAnnotation(
        ComposeFqNames.ComposableTargetMarker
    ) == true

private val IrConstructorCall.isComposableInferredTarget get() =
    annotationClass?.isClassWithFqName(
        ComposeFqNames.ComposableInferredTarget.toUnsafe()
    ) == true

private val IrConstructorCall.isComposableOpenTarget get() =
    annotationClass?.isClassWithFqName(
        ComposeFqNames.ComposableOpenTarget.toUnsafe()
    ) == true

private fun IrType.samOwnerOrNull() =
    classOrNull?.let { cls ->
        if (cls.owner.kind == ClassKind.INTERFACE) {
            cls.functions.singleOrNull {
                it.owner.modality == Modality.ABSTRACT
            }?.owner
        } else null
    }

private val IrCall.arguments get() = Array(valueArgumentsCount) {",getValueArgument(it)
"// DONT_TARGET_EXACT_BACKEND: JS
fun <T> T.id() = this

const val minusOneVal = <!EVALUATED(""-1.0"")!>-1.0<!>
const val oneVal = <!EVALUATED(""1.0"")!>1.0<!>
const val twoVal = <!EVALUATED(""2.0"")!>2.0<!>
const val threeVal = <!EVALUATED(""3.0"")!>3.0<!>
const val fourVal = <!EVALUATED(""4.0"")!>4.0<!>
const val oneAndAHalf = <!EVALUATED(""1.5"")!>1.5<!>

const val byteVal = 2.<!EVALUATED(""2"")!>toByte()<!>
const val shortVal = 2.<!EVALUATED(""2"")!>toShort()<!>
const val intVal = <!EVALUATED(""2"")!>2<!>
const val longVal = <!EVALUATED(""2"")!>2L<!>
const val floatVal = <!EVALUATED(""2.0"")!>2.0f<!>
const val doubleVal = <!EVALUATED(""2.0"")!>2.0<!>

const val funCompareTo1 = oneVal.<!EVALUATED(""-1"")!>compareTo(twoVal)<!>
const val funCompareTo2 = twoVal.<!EVALUATED(""0"")!>compareTo(twoVal)<!>
const val funCompareTo3 = threeVal.<!EVALUATED(""1"")!>compareTo(twoVal)<!>
const val funCompareTo4 = twoVal.<!EVALUATED(""0"")!>compareTo(byteVal)<!>
const val funCompareTo5 = twoVal.<!EVALUATED(""0"")!>compareTo(shortVal)<!>
const val funCompareTo6 = twoVal.<!EVALUATED(""0"")!>compareTo(intVal)<!>
const val funCompareTo7 = twoVal.<!EVALUATED(""0"")!>compareTo(longVal)<!>
const val funCompareTo8 = twoVal.<!EVALUATED(""0"")!>compareTo(floatVal)<!>

const val singCompareTo1 = <!EVALUATED(""false"")!>oneVal >= twoVal<!>
const val singCompareTo2 = <!EVALUATED(""false"")!>twoVal > twoVal<!>
const val singCompareTo3 = <!EVALUATED(""false"")!>threeVal <= twoVal<!>
const val singCompareTo4 = <!EVALUATED(""false"")!>twoVal < byteVal<!>

const val plus1 = oneVal.<!EVALUATED(""3.0"")!>plus(twoVal)<!>
const val plus2 = twoVal.<!EVALUATED(""4.0"")!>plus(twoVal)<!>
const val plus3 = threeVal.<!EVALUATED(""5.0"")!>plus(twoVal)<!>
const val plus4 = twoVal.<!EVALUATED(""4.0"")!>plus(byteVal)<!>
const val plus5 = twoVal.<!EVALUATED(""4.0"")!>plus(shortVal)<!>
const val plus6 = twoVal.<!EVALUATED(""4.0"")!>plus(intVal)<!>
const val plus7 = twoVal.<!EVALUATED(""4.0"")!>plus(longVal)<!>
const val plus8 = twoVal.<!EVALUATED(""4.0"")!>plus(floatVal)<!>

const val minus1 = oneVal.<!EVALUATED(""-1.0"")!>minus(twoVal)<!>
const val minus2 = twoVal.<!EVALUATED(""0.0"")!>minus(twoVal)<!>
const val minus3 = threeVal.<!EVALUATED(""1.0"")!>minus(twoVal)<!>
const val minus4 = twoVal.<!EVALUATED(""0.0"")!>minus(byteVal)<!>
const val minus5 = twoVal.<!EVALUATED(""0.0"")!>minus(shortVal)<!>
const val minus6 = twoVal.<!EVALUATED(""0.0"")!>minus(intVal)<!>
const val minus7 = twoVal.<!EVALUATED(""0.0"")!>minus(longVal)<!>
const val minus8 = twoVal.<!EVALUATED(""0.0"")!>minus(floatVal)<!>

const val times1 = oneVal.<!EVALUATED(""2.0"")!>times(twoVal)<!>
const val times2 = twoVal.<!EVALUATED(""4.0"")!>times(twoVal)<!>
const val times3 = threeVal.<!EVALUATED(""6.0"")!>times(twoVal)<!>
const val times4 = twoVal.<!EVALUATED(""4.0"")!>times(byteVal)<!>
const val times5 = twoVal.<!EVALUATED(""4.0"")!>times(shortVal)<!>
const val times6 = twoVal.<!EVALUATED(""4.0"")!>times(intVal)<!>
const val times7 = twoVal.<!EVALUATED(""4.0"")!>times(longVal)<!>
const val times8 = twoVal.<!EVALUATED(""4.0"")!>times(floatVal)<!>

const val div1 = oneVal.<!EVALUATED(""0.5"")!>div(twoVal)<!>
const val div2 = twoVal.<!EVALUATED(""1.0"")!>div(twoVal)<!>
const val div3 = threeVal.<!EVALUATED(""1.5"")!>div(twoVal)<!>
const val div4 = twoVal.<!EVALUATED(""1.0"")!>div(byteVal)<!>
const val div5 = twoVal.<!EVALUATED(""1.0"")!>div(shortVal)<!>
const val div6 = twoVal.<!EVALUATED(""1.0"")!>div(intVal)<!>
const val div7 = twoVal.<!EVALUATED(""1.0"")!>div(longVal)<!>","const val div8 = twoVal.<!EVALUATED(""1.0"")!>div(floatVal)<!>"
"}
    }
    declaration.extensionReceiverParameter?.let {
        val superTypes = it.type.superTypes().joinTypes(context)
        nameBuilder.append(""_r$${it.type.asString(context)}$superTypes"")
    }
    declaration.valueParameters.ifNotEmpty {
        joinTo(nameBuilder, """") {
            val defaultValueSign = if (it.origin == JsLoweredDeclarationOrigin.JS_SHADOWED_DEFAULT_PARAMETER) ""?"" else """"
            val superTypes = it.type.superTypes().joinTypes(context)
            ""_${it.type.asString(context)}$superTypes$defaultValueSign""
        }
    }
    declaration.returnType.let {
        // Return type is only used in signature for inline class and Unit types because
        // they are binary incompatible with supertypes.
        if (context.inlineClassesUtils.isTypeInlined(it) || it.isUnit()) {
            nameBuilder.append(""_ret$${it.asString(context)}"")
        }
    }

    val signature = abs(nameBuilder.toString().hashCode()).toString(Character.MAX_RADIX)

    // TODO: Use better hashCode
    val sanitizedName = sanitizeName(declarationName, withHash = false)
    return context.globalIrInterner.string(""${sanitizedName}_$signature$RESERVED_MEMBER_NAME_SUFFIX"")
}

fun jsFunctionSignature(declaration: IrFunction, context: JsIrBackendContext): String {
    require(!declaration.isStaticMethodOfClass)
    require(declaration.dispatchReceiverParameter != null)

    if (declaration.hasStableJsName(context)) {
        val declarationName = declaration.getJsNameOrKotlinName().asString()
        // TODO: Handle reserved suffix in FE
        require(!declarationName.endsWith(RESERVED_MEMBER_NAME_SUFFIX)) {
            ""Function ${declaration.fqNameWhenAvailable} uses reserved name suffix \""$RESERVED_MEMBER_NAME_SUFFIX\""""
        }
        return declarationName
    }

    val declarationSignature = (declaration as? IrSimpleFunction)?.resolveFakeOverride() ?: declaration
    return calculateJsFunctionSignature(declarationSignature, context)
}

class LocalNameGenerator(val variableNames: NameTable<IrDeclaration>) : IrElementVisitorVoid {
    val localLoopNames = NameTable<IrLoop>()
    val localReturnableBlockNames = NameTable<IrReturnableBlock>()

    private val jumpableDeque: Deque<IrExpression> = LinkedList()

    override fun visitElement(element: IrElement) {
        element.acceptChildrenVoid(this)
    }

    override fun visitDeclaration(declaration: IrDeclarationBase) {
        super.visitDeclaration(declaration)
        if (declaration is IrDeclarationWithName) {
            variableNames.declareFreshName(declaration, declaration.name.asString())
        }
    }

    override fun visitBreak(jump: IrBreak) {
        val loop = jump.loop
        if (loop.label == null && loop != jumpableDeque.firstOrNull()) {","persistLoopName(SYNTHETIC_LOOP_LABEL, loop)"
"// EXPECTED_REACHABLE_NODES: 1292
package foo

// CHECK_CONTAINS_NO_CALLS: maxBySquare except=imul;Unit_getInstance

internal data class Result(var value: Int = 0, var invocationCount: Int = 0)

internal inline fun maxBy(a: Array<Int>, keyFun: (Int) -> Int): Int {
    var maxVal = a[0]
    var maxKey = keyFun(maxVal)

    for (element in a) {
        val key = keyFun(element)

        if (key > maxKey) {
            maxVal = element
            maxKey = key
        }
    }

    return maxVal
}

// CHECK_BREAKS_COUNT: function=maxBySquare count=0 TARGET_BACKENDS=JS_IR
// CHECK_LABELS_COUNT: function=maxBySquare name=$l$block count=0 TARGET_BACKENDS=JS_IR
internal fun maxBySquare(a: Array<Int>, r: Result): Result {
    var invocationCount = 0
    val maxVal = maxBy(a, { x -> invocationCount++; x * x;})

    r.value = maxVal
    r.invocationCount = invocationCount

    return r
}

fun box(): String {
    var r1 = maxBySquare(arrayOf(1,2,3,4,5), Result())
    assertEquals(Result(5, 6), r1)

    var r2 = maxBySquare(arrayOf(-5,1,2,3,4), Result())
    assertEquals(Result(-5, 6), r2)","return ""OK"""
"// Auto-generated by GenerateInRangeExpressionTestData. Do not edit!
// WITH_STDLIB
// DONT_TARGET_EXACT_BACKEND: JVM
// !LANGUAGE: +RangeUntilOperator
@file:OptIn(ExperimentalStdlibApi::class)



val range0 = 1.0F..<3.0F
val range1 = 3.0F..<1.0F

val element0 = -1F
val element1 = 0F
val element2 = 1F
val element3 = 2F
val element4 = 3F
val element5 = 4F

fun box(): String {
    testR0xE0()
    testR0xE1()
    testR0xE2()
    testR0xE3()
    testR0xE4()
    testR0xE5()
    testR1xE0()
    testR1xE1()
    testR1xE2()
    testR1xE3()
    testR1xE4()
    testR1xE5()
    return ""OK""
}

fun testR0xE0() {
    // with possible local optimizations
    if (-1F in 1.0F..<3.0F != range0.contains(-1F)) throw AssertionError()
    if (-1F !in 1.0F..<3.0F != !range0.contains(-1F)) throw AssertionError()
    if (!(-1F in 1.0F..<3.0F) != !range0.contains(-1F)) throw AssertionError()
    if (!(-1F !in 1.0F..<3.0F) != range0.contains(-1F)) throw AssertionError()
    // no local optimizations
    if (element0 in 1.0F..<3.0F != range0.contains(element0)) throw AssertionError()
    if (element0 !in 1.0F..<3.0F != !range0.contains(element0)) throw AssertionError()",if (!(element0 in 1.0F..<3.0F) != !range0.contains(element0)) throw AssertionError()
"firFile = firFile,
        nonLocalDeclaration = nonLocalDeclaration,
    )?.declarationTarget

    fun findPathToDeclarationWithTarget(
        firFile: FirFile,
        nonLocalDeclaration: KtDeclaration,
    ): List<FirDeclaration>? = collectDesignationPath(
        firFile = firFile,
        nonLocalDeclaration = nonLocalDeclaration,
    )?.let { it.path + it.declarationTarget }

    fun collectDesignationPath(
        firFile: FirFile,
        nonLocalDeclaration: KtDeclaration,
    ): FirDesignation? = collectDesignationPath(
        firFile = firFile,
        containerClassId = nonLocalDeclaration.containingClassOrObject?.getClassId(),
        expectedDeclarationAcceptor = { it.psi == nonLocalDeclaration },
    )

    /**
     * @see collectDesignationPath
     */
    private val FirDesignation.declarationTarget: FirDeclaration get() = target as FirDeclaration

    /**
     * @return [FirDesignation] where [FirDesignation.target] is [FirDeclaration]
     *
     * @see declarationTarget
     */
    private fun collectDesignationPath(
        firFile: FirFile,
        containerClassId: ClassId?,
        expectedDeclarationAcceptor: (FirDeclaration) -> Boolean,
    ): FirDesignation? {
        if (containerClassId != null) {
            requireWithAttachment(!containerClassId.isLocal, { ""ClassId should not be local"" }) {
                withEntry(""classId"", containerClassId) { it.asString() }
            }

            requireWithAttachment(
                firFile.packageFqName == containerClassId.packageFqName,
                { ""ClassId should not be local"" }
            ) {
                withEntry(""FirFile.packageName"", firFile.packageFqName) { it.asString() }
                withEntry(""ClassId.packageName"", containerClassId.packageFqName) { it.asString() }
            }
        }

        val classIdPathSegment = containerClassId?.relativeClassName?.pathSegments().orEmpty()
        val path = ArrayList<FirDeclaration>(classIdPathSegment.size + 2)
        var result: FirDeclaration? = null

        fun find(declarations: Iterable<FirDeclaration>, classIdPathIndex: Int): Boolean {
            val currentClassSegment = classIdPathSegment.getOrNull(classIdPathIndex)
            for (subDeclaration in declarations) {
                when {
                    currentClassSegment == null && expectedDeclarationAcceptor(subDeclaration) -> {
                        result = subDeclaration
                        return true
                    }

                    subDeclaration is FirScript -> {
                        path += subDeclaration",val scriptParameters = subDeclaration.parameters
"/**
 * Returns the smaller of three values.
 * 
 * If there are multiple equal minimal values, returns the first of them.
 */
@SinceKotlin(""1.1"")
public actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {
    return minOf(a, minOf(b, c))
}

/**
 * Returns the smaller of three values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {
    return Math.min(a.toInt(), Math.min(b.toInt(), c.toInt())).toByte()
}

/**
 * Returns the smaller of three values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun minOf(a: Short, b: Short, c: Short): Short {
    return Math.min(a.toInt(), Math.min(b.toInt(), c.toInt())).toShort()
}

/**
 * Returns the smaller of three values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun minOf(a: Int, b: Int, c: Int): Int {
    return minOf(a, minOf(b, c))
}

/**
 * Returns the smaller of three values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun minOf(a: Long, b: Long, c: Long): Long {
    return minOf(a, minOf(b, c))
}

/**
 * Returns the smaller of three values.
 * 
 * If any value is `NaN`, returns `NaN`.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun minOf(a: Float, b: Float, c: Float): Float {
    return minOf(a, minOf(b, c))
}

/**
 * Returns the smaller of three values.
 * 
 * If any value is `NaN`, returns `NaN`.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun minOf(a: Double, b: Double, c: Double): Double {","return minOf(a, minOf(b, c))"
"*/

package org.jetbrains.kotlin.ir.descriptors

import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.builtins.StandardNames.KOTLIN_REFLECT_FQ_NAME
import org.jetbrains.kotlin.builtins.functions.FunctionClassDescriptor
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.incremental.components.NoLookupLocation
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.builders.declarations.UNDEFINED_PARAMETER_INDEX
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.symbols.IrClassSymbol
import org.jetbrains.kotlin.ir.symbols.IrPropertySymbol
import org.jetbrains.kotlin.ir.symbols.IrSimpleFunctionSymbol
import org.jetbrains.kotlin.ir.symbols.IrTypeParameterSymbol
import org.jetbrains.kotlin.ir.symbols.impl.IrValueParameterSymbolImpl
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.types.SimpleTypeNullability
import org.jetbrains.kotlin.ir.types.impl.IrSimpleTypeBuilder
import org.jetbrains.kotlin.ir.types.impl.IrStarProjectionImpl
import org.jetbrains.kotlin.ir.types.impl.buildSimpleType
import org.jetbrains.kotlin.ir.types.impl.makeTypeProjection
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.name.SpecialNames
import org.jetbrains.kotlin.psi2ir.descriptors.IrBuiltInsOverDescriptors
import org.jetbrains.kotlin.resolve.descriptorUtil.isEffectivelyExternal
import org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter
import org.jetbrains.kotlin.types.KotlinType
import org.jetbrains.kotlin.types.Variance
import org.jetbrains.kotlin.utils.filterIsInstanceAnd
import org.jetbrains.kotlin.utils.memoryOptimizedMap

@OptIn(ObsoleteDescriptorBasedAPI::class)
abstract class IrAbstractDescriptorBasedFunctionFactory {

    abstract fun functionClassDescriptor(arity: Int): FunctionClassDescriptor
    abstract fun kFunctionClassDescriptor(arity: Int): FunctionClassDescriptor
    abstract fun suspendFunctionClassDescriptor(arity: Int): FunctionClassDescriptor
    abstract fun kSuspendFunctionClassDescriptor(arity: Int): FunctionClassDescriptor

    abstract fun functionN(arity: Int, declarator: SymbolTable.((IrClassSymbol) -> IrClass) -> IrClass): IrClass
    abstract fun kFunctionN(arity: Int, declarator: SymbolTable.((IrClassSymbol) -> IrClass) -> IrClass): IrClass
    abstract fun suspendFunctionN(arity: Int, declarator: SymbolTable.((IrClassSymbol) -> IrClass) -> IrClass): IrClass
    abstract fun kSuspendFunctionN(arity: Int, declarator: SymbolTable.((IrClassSymbol) -> IrClass) -> IrClass): IrClass

    fun functionN(n: Int) = functionN(n) { callback ->
        val descriptor = functionClassDescriptor(n)
        descriptorExtension.declareClass(descriptor) { symbol ->
            callback(symbol)
        }
    }

    fun kFunctionN(n: Int): IrClass {
        return kFunctionN(n) { callback ->
            val descriptor = kFunctionClassDescriptor(n)
            descriptorExtension.declareClass(descriptor) { symbol ->
                callback(symbol)
            }
        }
    }

    fun suspendFunctionN(n: Int): IrClass = suspendFunctionN(n) { callback ->",val descriptor = suspendFunctionClassDescriptor(n)
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.compilerRunner

import org.jetbrains.annotations.Nls
import org.jetbrains.jps.ModuleChunk
import org.jetbrains.jps.incremental.CompileContext
import org.jetbrains.jps.incremental.messages.ProgressMessage
import org.jetbrains.kotlin.jps.KotlinJpsBundle

interface ProgressReporter {",fun progress(message: String)
"@kotlin.internal.InlineOnly
public inline fun kotlin.LongArray.asList(): kotlin.collections.List<kotlin.Long>

@kotlin.internal.InlineOnly
public inline fun kotlin.ShortArray.asList(): kotlin.collections.List<kotlin.Short>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UByteArray.asList(): kotlin.collections.List<kotlin.UByte>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UIntArray.asList(): kotlin.collections.List<kotlin.UInt>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.ULongArray.asList(): kotlin.collections.List<kotlin.ULong>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UShortArray.asList(): kotlin.collections.List<kotlin.UShort>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun kotlin.ULongArray.asLongArray(): kotlin.LongArray

public fun <T> kotlin.collections.List<T>.asReversed(): kotlin.collections.List<T>

@kotlin.jvm.JvmName(name = ""asReversedMutable"")
public fun <T> kotlin.collections.MutableList<T>.asReversed(): kotlin.collections.MutableList<T>

public fun <T> kotlin.Array<out T>.asSequence(): kotlin.sequences.Sequence<T>

public fun kotlin.BooleanArray.asSequence(): kotlin.sequences.Sequence<kotlin.Boolean>

public fun kotlin.ByteArray.asSequence(): kotlin.sequences.Sequence<kotlin.Byte>

public fun kotlin.CharArray.asSequence(): kotlin.sequences.Sequence<kotlin.Char>

public fun kotlin.DoubleArray.asSequence(): kotlin.sequences.Sequence<kotlin.Double>

public fun kotlin.FloatArray.asSequence(): kotlin.sequences.Sequence<kotlin.Float>

public fun kotlin.IntArray.asSequence(): kotlin.sequences.Sequence<kotlin.Int>

public fun kotlin.LongArray.asSequence(): kotlin.sequences.Sequence<kotlin.Long>

public fun kotlin.ShortArray.asSequence(): kotlin.sequences.Sequence<kotlin.Short>

public fun <T> kotlin.collections.Iterable<T>.asSequence(): kotlin.sequences.Sequence<T>

public fun <K, V> kotlin.collections.Map<out K, V>.asSequence(): kotlin.sequences.Sequence<kotlin.collections.Map.Entry<K, V>>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun kotlin.UShortArray.asShortArray(): kotlin.ShortArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun kotlin.ByteArray.asUByteArray(): kotlin.UByteArray

@kotlin.SinceKotlin(version = ""1.3"")",@kotlin.ExperimentalUnsignedTypes
"package org.jetbrains.kotlin.ir.backend.js.utils.serialization

import org.jetbrains.kotlin.ir.backend.js.transformers.irToJs.JsIrIcClassModel
import org.jetbrains.kotlin.ir.backend.js.transformers.irToJs.JsIrProgramFragment
import org.jetbrains.kotlin.ir.backend.js.transformers.irToJs.JsIrProgramFragments
import org.jetbrains.kotlin.js.backend.ast.*
import org.jetbrains.kotlin.js.backend.ast.metadata.*
import org.jetbrains.kotlin.utils.addToStdlib.safeAs
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.OutputStream
import java.util.*

fun JsIrProgramFragments.serializeTo(output: OutputStream) {
    JsIrAstSerializer().append(this).saveTo(output)
}

private class DataWriter {

    val data = ByteArrayOutputStream()
    private val output = DataOutputStream(data)

    fun saveTo(output: DataOutputStream) {
        output.let {
            data.writeTo(it)
        }
    }

    fun writeByte(byte: Int) {
        // Limit bytes to positive values to avoid conversion in deserializer
        if ((byte and 0x7F.inv()) != 0) error(""Byte out of bounds: $byte"")
        output.writeByte(byte)
    }

    fun writeByteArray(byteArray: ByteArray) {
        output.writeInt(byteArray.size)
        output.write(byteArray)
    }

    fun writeString(string: String) {
        writeByteArray(string.toByteArray(SerializationCharset))
    }

    fun writeBoolean(boolean: Boolean) {
        output.writeBoolean(boolean)
    }

    fun writeInt(int: Int) {
        output.writeInt(int)
    }

    fun writeDouble(double: Double) {
        output.writeDouble(double)
    }

    inline fun <T> writeCollection(collection: Collection<T>, writeItem: (T) -> Unit) {
        output.writeInt(collection.size)
        collection.forEach(writeItem)
    }

    inline fun <T> ifNotNull(t: T?, write: (T) -> Unit): T? {
        output.writeBoolean(t != null)
        if (t != null) {
            write(t)
        }",return t
"class B
            class Foo<X, Y>(val x: X, val y: Y)
        """""",
        classDefSrc = """"""
            class Test(val foo: Foo<A, B>)
        """""",
        stability = ""Runtime(B)"",
        externalTypes = setOf(""dependency.Foo<_,*>"")
    )

    @Test
    fun testExternalGenericDefinedTypesAreStable() = assertStability(
        externalSrc = """"""
            class A
            class Foo<T>(val x: T)
        """""",
        classDefSrc = """"""
            class Test(val foo: Foo<A>)
        """""",
        stability = ""Stable"",
        externalTypes = setOf(""dependency.Foo"", ""dependency.A"")
    )

    @Test
    fun testExternalDeepPackageNameIsStable() = assertStability(
        externalSrc = """"""
            class A
        """""",
        classDefSrc = """"""
            class Test(val foo: A)
        """""",
        stability = ""Stable"",
        externalTypes = setOf(""dependency.b.c.d.A""),
        packageName = ""dependency.b.c.d""
    )

    @Test
    fun testListOfCallWithPrimitiveTypeIsStable() = assertStability(
        """",
        """",
        ""listOf(1)"",
        ""Stable""
    )

    @Test
    fun testListOfCallWithLocalInferredStableTypeIsStable() = assertStability(
        """",
        ""class Foo"",
        ""listOf(Foo())"",
        ""Stable""
    )

    @Test
    fun testListOfCallWithExternalInferredStableTypeIsRuntimeStable() = assertStability(
        ""class Foo"",
        """",
        ""listOf(Foo())"",
        ""Runtime(Foo)""
    )

    @Test
    fun testMapOfCallWithPrimitiveTypesIsStable() = assertStability(
        """",
        """",
        ""mapOf(1 to 1)"",","""Stable,Stable"""
"buildOptions = defaultBuildOptions.copy(logLevel = LogLevel.DEBUG)
        ) {
            build(""assemble"") {
                //register build service for buildSrc.
                when {
                    // until 8.0, Gradle was embedding the Kotlin version that used a slightly different approach to detect build finish,
                    // so the service was unregistered after the finish of the buildSrc build
                    // and then registered again in the root build
                    gradleVersion < GradleVersion.version(TestVersions.Gradle.G_8_0) -> {
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsService: new instance"", // the  service for buildSrc
                            1
                        )
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsBeanService: new instance"", // the legacy service for compatibility
                            1
                        )
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsBeanService_v2: new instance"", // the current default version of the service
                            1
                        )
                    }
                    gradleVersion < GradleVersion.version(TestVersions.Gradle.G_8_3) -> {
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsService: new instance"", // the legacy service for compatibility
                            1
                        )
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsBeanService_v2: new instance"", // the current default version of the service
                            1
                        )
                    }
                    //for gradle 8.3 kotlin 1.9.0 is used, log message is changed
                    gradleVersion < GradleVersion.version(TestVersions.Gradle.G_8_5) -> {
                        assertOutputContainsExactTimes(
                            ""Register JMX service for backward compatibility"", // the legacy service for compatibility
                            1
                        )
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsService_v2: new instance"", // the current default version of the service
                            1
                        )
                    }
                    //for other versions KGP from buildSrc registered both services
                    else -> {
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsService: new instance"", // the legacy service for compatibility
                            1
                        )
                        assertOutputContainsExactTimes(
                            ""Instantiated class org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatsService_v2: new instance"", // the current default version of the service
                            1
                        )

                    }
                }

                assertOutputDoesNotContain(""[org.jetbrains.kotlin.gradle.plugin.statistics.KotlinBuildStatHandler] Could not execute"")
            }
        }
    }

    @DisplayName(""smoke test for fus-statistics-gradle-plugin"")
    @GradleTest
    fun smokeTestForFusStatisticsPlugin(gradleVersion: GradleVersion) {","val metricName = ""METRIC_NAME"""
"import org.jetbrains.kotlin.config.KotlinCompilerVersion
import org.jetbrains.kotlin.descriptors.SourceElement
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.ThreadSafeMutableState
import org.jetbrains.kotlin.fir.builder.toMutableOrEmpty
import org.jetbrains.kotlin.fir.declarations.FirDeclarationOrigin
import org.jetbrains.kotlin.fir.declarations.getDeprecationsProvider
import org.jetbrains.kotlin.fir.deserialization.*
import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.java.FirJavaFacade
import org.jetbrains.kotlin.fir.java.declarations.FirJavaClass
import org.jetbrains.kotlin.fir.languageVersionSettings
import org.jetbrains.kotlin.fir.resolve.transformers.setLazyPublishedVisibility
import org.jetbrains.kotlin.fir.scopes.FirKotlinScopeProvider
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.fir.types.ConeFlexibleType
import org.jetbrains.kotlin.fir.types.ConeRawType
import org.jetbrains.kotlin.fir.types.ConeSimpleKotlinType
import org.jetbrains.kotlin.load.kotlin.*
import org.jetbrains.kotlin.load.kotlin.header.KotlinClassHeader
import org.jetbrains.kotlin.metadata.ProtoBuf
import org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf
import org.jetbrains.kotlin.metadata.jvm.deserialization.JvmFlags
import org.jetbrains.kotlin.metadata.jvm.deserialization.JvmMetadataVersion
import org.jetbrains.kotlin.metadata.jvm.deserialization.JvmProtoBufUtil
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.StandardClassIds
import org.jetbrains.kotlin.protobuf.InvalidProtocolBufferException
import org.jetbrains.kotlin.resolve.jvm.JvmClassName
import org.jetbrains.kotlin.serialization.deserialization.IncompatibleVersionErrorData
import org.jetbrains.kotlin.serialization.deserialization.builtins.BuiltInSerializerProtocol
import org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedContainerAbiStability
import org.jetbrains.kotlin.utils.toMetadataVersion
import java.nio.file.Path
import java.nio.file.Paths

// This symbol provider loads JVM classes, reading extra info from Kotlin `@Metadata` annotations
// if present. Use it for library and incremental compilation sessions. For source sessions use
// `JavaSymbolProvider`, as Kotlin classes should be parsed first.
@ThreadSafeMutableState
class JvmClassFileBasedSymbolProvider(
    session: FirSession,
    moduleDataProvider: ModuleDataProvider,
    kotlinScopeProvider: FirKotlinScopeProvider,
    private val packagePartProvider: PackagePartProvider,
    private val kotlinClassFinder: KotlinClassFinder,
    private val javaFacade: FirJavaFacade,
    defaultDeserializationOrigin: FirDeclarationOrigin = FirDeclarationOrigin.Library
) : AbstractFirDeserializedSymbolProvider(
    session, moduleDataProvider, kotlinScopeProvider, defaultDeserializationOrigin, BuiltInSerializerProtocol
) {
    private val annotationsLoader = AnnotationsLoader(session, kotlinClassFinder)
    private val ownMetadataVersion: JvmMetadataVersion = session.languageVersionSettings.languageVersion.toMetadataVersion()

    private val reportErrorsOnPreReleaseDependencies = with(session.languageVersionSettings) {
        !getFlag(AnalysisFlags.skipPrereleaseCheck) && !isPreRelease() && !KotlinCompilerVersion.isPreRelease()
    }

    override fun computePackagePartsInfos(packageFqName: FqName): List<PackagePartsCacheData> =
        packagePartProvider.findPackageParts(packageFqName.asString()).mapNotNull { partName ->
            computePackagePartInfo(packageFqName, partName)
        }

    private fun computePackagePartInfo(packageFqName: FqName, partName: String): PackagePartsCacheData? {",if (partName in KotlinBuiltins) return null
"// WITH_REFLECT
// TARGET_BACKEND: JVM
// FILE: Ann1.java
import java.lang.annotation.*;

@Target({ElementType.FIELD})",@Retention(RetentionPolicy.RUNTIME)
"// EXIT_CODE: !0
// OUTPUT_REGEX: Cannot run checkers when there are 1 alive runtimes at the shutdown.*
// MODULE: cinterop
// FILE: leakMemory.def
---
void test_RunInNewThread(void (*)());

// FILE: leakMemory.h
#ifdef __cplusplus
extern ""C"" {
#endif

void test_RunInNewThread(void (*)());

#ifdef __cplusplus
}
#endif

// FILE: leakMemory.cpp
#include ""leakMemory.h""

#include <atomic>
#include <thread>

extern ""C"" void test_RunInNewThread(void (*f)()) {
    std::atomic<bool> haveRun(false);
    std::thread t([f, &haveRun]() {
        f();
        haveRun = true;",while (true) {}
"}

    private fun generateOverridesInAClass(classDescriptor: ClassDescriptor, strategy: OverridingStrategy) {
        @Suppress(""UNCHECKED_CAST"")
        val membersFromSupertypesByName =
            classDescriptor.typeConstructor.supertypes.flatMapTo(linkedSetOf()) { type ->
                DescriptorUtils.getAllDescriptors(type.memberScope).filter {
                    it is PropertyDescriptor || it is SimpleFunctionDescriptor
                } as List<CallableMemberDescriptor>
            }.groupBy { it.name }

        for ((name, fromSupertypes) in membersFromSupertypesByName) {
            OverridingUtil.DEFAULT.generateOverridesInFunctionGroup(name, fromSupertypes, emptyList(), classDescriptor, strategy)
        }
    }

    private fun createSyntheticSubclass(): Pair<MutableClassDescriptor, List<TypeParameterDescriptor>> {
        val child = MutableClassDescriptor(
            descriptor.containingDeclaration,
            ClassKind.CLASS,
            /* isInner = */ false,
            /* isExternal */ false,
            Name.special(""<synthetic inheritor of ${descriptor.name}>""),
            descriptor.source,
            LockBasedStorageManager.NO_LOCKS
        )

        child.modality = Modality.FINAL
        child.visibility = DescriptorVisibilities.PUBLIC
        val typeParameters = descriptor.typeConstructor.parameters
        val newTypeParameters = ArrayList<TypeParameterDescriptor>(typeParameters.size)
        DescriptorSubstitutor.substituteTypeParameters(typeParameters, TypeSubstitution.EMPTY, child, newTypeParameters)
        child.setTypeParameterDescriptors(typeParameters)
        return Pair(child, newTypeParameters)
    }

    private fun FunctionDescriptor.findOverriddenFromDirectSuperClass(typeConstructor: TypeConstructor): FunctionDescriptor? =
        this.overriddenDescriptors.firstOrNull {
            (it.containingDeclaration as? ClassDescriptor)?.typeConstructor == typeConstructor
        }

    private fun newType(classDescriptor: ClassDescriptor, typeArguments: List<TypeProjection>): KotlinType {
        return KotlinTypeFactory.simpleNotNullType(TypeAttributes.Empty, classDescriptor, typeArguments)
    }

    private fun FunctionDescriptor.signature(): JvmMethodGenericSignature =
        typeMapper.mapSignatureWithGeneric(this, OwnerKind.IMPLEMENTATION)

    private fun generateMethodStub(v: ClassBuilder, signature: JvmMethodGenericSignature, synthetic: Boolean) {
        assert(descriptor.kind != ClassKind.INTERFACE) { ""No stubs should be generated for interface ${descriptor.fqNameUnsafe}"" }

        val access = ACC_PUBLIC or (if (synthetic) ACC_SYNTHETIC else 0)
        val asmMethod = signature.asmMethod
        val genericSignature = if (synthetic) null else signature.genericsSignature
        val mv = v.newMethod(CollectionStub, access, asmMethod.name, asmMethod.descriptor, genericSignature, null)
        mv.visitCode()
        AsmUtil.genThrow(
            InstructionAdapter(mv),
            ""java/lang/UnsupportedOperationException"",
            ""Operation is not supported for read-only collection""
        )
        FunctionCodegen.endVisit(mv, ""built-in stub for $signature"")
    }
}","private val READ_ONLY_ARE_EQUAL_TO_MUTABLE_TYPE_CHECKER = KotlinTypeCheckerImpl.withAxioms { x, y ->"
"return if (isAccessedBeforeAllClosureWriters(variableContainingDeclaration, writers, bindingContext, accessElement))
        DataFlowValue.Kind.STABLE_VARIABLE
    else
        DataFlowValue.Kind.CAPTURED_VARIABLE
}


fun hasNoWritersInClosures(
    variableContainingDeclaration: DeclarationDescriptor,
    writers: Set<AssignedVariablesSearcher.Writer>,
    bindingContext: BindingContext
): Boolean {
    return writers.none { (_, writerDeclaration) ->
        writerDeclaration != null &&
                variableContainingDeclaration != writerDeclaration.getDeclarationDescriptorIncludingConstructors(bindingContext)
    }
}

private fun isAccessedInsideClosureAfterAllWriters(
    writers: Set<AssignedVariablesSearcher.Writer>,
    accessElement: KtElement
): Boolean {
    val parent = accessElement.getElementParentDeclaration() ?: return false
    return writers.none { (assignment) -> !assignment.before(parent) }
}

private fun isAccessedBeforeAllClosureWriters(
    variableContainingDeclaration: DeclarationDescriptor,
    writers: Set<AssignedVariablesSearcher.Writer>,
    bindingContext: BindingContext,
    accessElement: KtElement
): Boolean {
    // All writers should be before access element, with the exception:
    // writer which is the same with declaration site does not count
    writers.mapNotNull { it.declaration }.forEach { writerDeclaration ->
        val writerDescriptor = writerDeclaration.getDeclarationDescriptorIncludingConstructors(bindingContext)
        // Access is after some writerDeclaration
        if (variableContainingDeclaration != writerDescriptor && !accessElement.before(writerDeclaration)) {
            return false
        }
    }
    // Access is before all writers
    return true
}

private fun DeclarationDescriptorWithVisibility.isInvisibleFromOtherModules(): Boolean {
    if (DescriptorVisibilities.INVISIBLE_FROM_OTHER_MODULES.contains(visibility)) return true

    val containingDeclaration = containingDeclaration
    return containingDeclaration is DeclarationDescriptorWithVisibility && containingDeclaration.isInvisibleFromOtherModules()
}

private fun PropertyDescriptor.hasDefaultGetter(): Boolean {
    val getter = getter
    return getter == null || getter.isDefault
}

private fun isAccessedInsideClosure(
    variableContainingDeclaration: DeclarationDescriptor,
    bindingContext: BindingContext,
    accessElement: KtElement
): Boolean {
    val parent = accessElement.getElementParentDeclaration()
    return if (parent != null) // Access is at the same declaration: not in closure, lower: in closure
        parent.getDeclarationDescriptorIncludingConstructors(bindingContext) != variableContainingDeclaration",else
"class Inv<X>
class In<in E>
class Out<out T>
class Final
open class Open

fun invOpen(x: Inv<Open>) {}
// method: TopLevelInvKt::invOpen
// generic signature: (LInv<LOpen;>;)V

fun invFinal(x: Inv<Final>) {}
// method: TopLevelInvKt::invFinal
// generic signature: (LInv<LFinal;>;)V

fun invOutOpen(x: Inv<Out<Open>>) {}
// method: TopLevelInvKt::invOutOpen
// generic signature: (LInv<LOut<LOpen;>;>;)V

fun invOutFinal(x: Inv<Out<Final>>) {}
// method: TopLevelInvKt::invOutFinal
// generic signature: (LInv<LOut<LFinal;>;>;)V",fun invInOutOpen(x: Inv<In<Out<Open>>>) {}
"import java.io.ObjectInputStream
import java.io.Serializable

class NativeDistributionCommonizerCache(
    private val outputDirectory: File,
    private val konanHome: File,
    private val logger: Logger,
    private val isCachingEnabled: Boolean
) : Serializable {
    fun isUpToDate(
        outputTargets: Set<SharedCommonizerTarget>
    ): Boolean = lock.withLock {
        todoTargets(outputTargets)
    }.isEmpty()

    /**
     * Calls [writeCacheAction] for uncached targets and marks them as cached if it succeeds
     */
    fun writeCacheForUncachedTargets(
        outputTargets: Set<SharedCommonizerTarget>,
        writeCacheAction: (todoTargets: Set<SharedCommonizerTarget>) -> Unit
    ) = lock.withLock {
        val todoOutputTargets = todoTargets(outputTargets)
        if (todoOutputTargets.isEmpty()) return@withLock

        writeCacheAction(todoOutputTargets)

        todoOutputTargets
            .map { outputTarget -> resolveCommonizedDirectory(outputDirectory, outputTarget) }
            .filter { commonizedDirectory -> commonizedDirectory.isDirectory }
            .forEach { commonizedDirectory -> commonizedDirectory.resolve("".success"").createNewFile() }
    }

    private fun todoTargets(
        outputTargets: Set<SharedCommonizerTarget>
    ): Set<SharedCommonizerTarget> {
        lock.checkLocked(outputDirectory)
        logInfo(""Calculating cache state for $outputTargets"")

        if (!isCachingEnabled) {
            logInfo(""Cache disabled"")
            return if (isMissingPlatformLibraries(outputTargets)) return emptySet()
            else outputTargets
        }

        val cachedOutputTargets = outputTargets
            .filter { outputTarget -> isCached(resolveCommonizedDirectory(outputDirectory, outputTarget)) }
            .onEach { outputTarget -> logInfo(""Cache hit: $outputTarget already commonized"") }
            .toSet()

        val todoOutputTargets = outputTargets - cachedOutputTargets

        if (todoOutputTargets.isEmpty() || isMissingPlatformLibraries(todoOutputTargets)) {
            logInfo(""All available targets are commonized already - Nothing to do"")
            if (todoOutputTargets.isNotEmpty()) {
                logInfo(""Platforms cannot be commonized, because of missing platform libraries: $todoOutputTargets"")
            }

            return emptySet()
        }

        return todoOutputTargets
    }

    private fun isMissingPlatformLibraries(",missingOutputTargets: Set<CommonizerTarget>
"// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE

interface ExpectedType

inline fun <reified M> parse(): M? = TODO()

fun test(s: String?, silent: Boolean) {
    val result: ExpectedType =
        if (s != null) {
            <!DEBUG_INFO_EXPRESSION_TYPE(""ExpectedType?"")!>parse()<!> ?: TODO()
        } else <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Nothing"")!>if (silent) {
            return
        } else {
            throw Exception()
        }<!>",<!DEBUG_INFO_SMARTCAST!>s<!>.length
"import kotlin.collections.*
import kotlin.text.isEmpty

const val result1 = <!EVALUATED: `OK`!>foo()<!>
const val result2 = <!EVALUATED: `OK`!>bar()<!>

const val result3 = <!EVALUATED: `fail 2; fail 3; fail 4; fail 5; fail 6; `!>checkForArrayList(1)<!>
const val result4 = <!EVALUATED: `fail 5; fail 6; `!>checkForArrayList(listOf<Int>())<!>
const val result5 = <!EVALUATED: `OK`!>checkForArrayList(arrayListOf<Int>())<!>

const val result6 = <!EVALUATED: `fail 1; fail 2; fail 3; fail 4; `!>checkForArray(1)<!>
const val result7 = <!EVALUATED: `fail 1; fail 2; fail 3; fail 4; `!>checkForArray(intArrayOf())<!>
const val result8 = <!EVALUATED: `fail 3; fail 4; `!>checkForArray(arrayOf<Int>())<!>

@CompileTimeCalculation
fun foo(): String {
    val a = arrayListOf<Int>()
    if (a !is Collection<Int>) return ""fail a 1""
    if (a !is Collection<Number>) return ""fail a 2""
    if (a !is Collection<*>) return ""fail a 3""

    val b: ArrayList<Int>? = null
    if (b is Collection<Int>) return ""fail b 1""
    if (b is Collection<Number>) return ""fail b 2""
    if (b is Collection<*>) return ""fail b 3""
    if (b is Collection<Any>) return ""fail b 4""

    if (b !is Collection<Int>?) return ""fail b 5""
    if (b !is Collection<Number>?) return ""fail b 6""
    if (b !is Collection<*>?) return ""fail b 7""
    if (b !is Collection<Any>?) return ""fail b 8""

    if (b is Collection<Int?>) return ""fail b 9""
    if (b is Collection<Number?>) return ""fail b 10""
    if (b is Collection<Any?>) return ""fail b 11""

    if (b !is Collection<Int?>?) return ""fail b 12""
    if (b !is Collection<Number?>?) return ""fail b 13""
    if (b !is Collection<Any?>?) return ""fail b 14""

    val c: ArrayList<*> = arrayListOf(1, 2)
    if (c !is Collection<*>) return ""fail c 1""
    if (c !is Collection<*>?) return ""fail c 2""
    if (c !is Collection<Any?>?) return ""fail c 3""

    val d: ArrayList<Any> = arrayListOf(1, 2)
    if (d !is Collection<*>) return ""fail d 1""
    if (d !is Collection<Any>) return ""fail d 2""
    if (d !is Collection<*>?) return ""fail d 3""
    if (d !is Collection<Any?>?) return ""fail d 4""

    val e: ArrayList<Any?> = arrayListOf(1, 2)
    if (e !is Collection<*>) return ""fail e 1""
    if (e !is Collection<*>?) return ""fail e 2""
    if (e !is Collection<Any?>?) return ""fail e 3""

    if (null is Any) return ""fail f 1""
    if (null !is Any?) return ""fail f 2""
    if (null is String) return ""fail f 3""
    if (null !is String?) return ""fail f 4""
    if (null is Nothing) return ""fail f 5""
    if (null !is Nothing?) return ""fail f 6""

    val g: Int? = 1
    if (g !is Int) return ""fail g 1""","if (g !is Int?) return ""fail g 2"""
")
        }
    ): IrValueParameter =
        valueParameterSlice.declareLocal(
            descriptor,
            { IrValueParameterSymbolImpl(descriptor) },
            valueParameterFactory
        )

    @OptIn(ObsoleteDescriptorBasedAPI::class)
    fun introduceValueParameter(irValueParameter: IrValueParameter) {
        valueParameterSlice.introduceLocal(irValueParameter.descriptor, irValueParameter.symbol)
    }

    override fun referenceValueParameter(declaration: ParameterDescriptor): IrValueParameterSymbol {
        return valueParameterSlice.referenced(declaration) {
            error(""Undefined parameter referenced: $declaration\n${valueParameterSlice.dump()}"")
        }
    }

    open fun referenceValue(value: ValueDescriptor): IrValueSymbol {
        return when (value) {
            is ParameterDescriptor -> valueParameterSlice.referenced(value) { error(""Undefined parameter referenced: $value"") }
            is VariableDescriptor -> variableSlice.referenced(value) { error(""Undefined variable referenced: $value"") }
            else -> error(""Unexpected value descriptor: $value"")
        }
    }


    // ------------------------------------ variable ------------------------------------

    fun declareVariable(
        startOffset: Int,
        endOffset: Int,
        origin: IrDeclarationOrigin,
        descriptor: VariableDescriptor,
        type: IrType,
    ): IrVariable =
        variableSlice.declareLocal(
            descriptor,
            { IrVariableSymbolImpl(descriptor) }
        ) {
            IrVariableImpl(
                startOffset, endOffset, origin, it, nameProvider.nameForDeclaration(descriptor), type,
                descriptor.isVar, descriptor.isConst, descriptor.isLateInit
            )
        }

    fun declareVariable(
        startOffset: Int,
        endOffset: Int,
        origin: IrDeclarationOrigin,
        descriptor: VariableDescriptor,
        type: IrType,
        irInitializerExpression: IrExpression?
    ): IrVariable =
        declareVariable(startOffset, endOffset, origin, descriptor, type).apply {
            initializer = irInitializerExpression
        }

    // ------------------------------------ local delegated property ------------------------------------

    fun declareLocalDelegatedProperty(
        startOffset: Int,
        endOffset: Int,","origin: IrDeclarationOrigin,"
"return contextReceiversGroup.map { contextReceiver ->
            collectMembers { getContributedVariablesAndIntercept(name, location, contextReceiver, extensionReceiver, scopeTower) }
        }.flatten()
    }

    override fun getObjects(
        name: Name,
        extensionReceiver: ReceiverValueWithSmartCastInfo?
    ): Collection<CandidateWithBoundDispatchReceiver> {
        return emptyList()
    }

    override fun getFunctions(
        name: Name,
        extensionReceiver: ReceiverValueWithSmartCastInfo?
    ): Collection<CandidateWithBoundDispatchReceiver> {
        val collectMembers = { contextReceiver: ReceiverValueWithSmartCastInfo ->
            collectMembers {
                getContributedFunctionsAndIntercept(
                    name,
                    location,
                    contextReceiver,
                    extensionReceiver,
                    scopeTower
                ) + it.getInnerConstructors(
                    name,
                    location
                ) + syntheticScopes.collectSyntheticMemberFunctions(listOfNotNull(it), name, location)
            }
        }
        return contextReceiversGroup.map(collectMembers).flatten()
    }

    override fun recordLookup(name: Name) {
        for (type in contextReceiversGroup.map { it.allOriginalTypes }.flatten()) {
            type.memberScope.recordLookup(name, location)
        }
    }
}

internal class QualifierScopeTowerLevel(scopeTower: ImplicitScopeTower, val qualifier: QualifierReceiver) :
    AbstractScopeTowerLevel(scopeTower) {
    override fun getVariables(name: Name, extensionReceiver: ReceiverValueWithSmartCastInfo?) = qualifier.staticScope
        .getContributedVariablesAndIntercept(
            name,
            location,
            qualifier.classValueReceiverWithSmartCastInfo,
            extensionReceiver,
            scopeTower
        ).map {
            createCandidateDescriptor(it, dispatchReceiver = null)
        }

    override fun getObjects(name: Name, extensionReceiver: ReceiverValueWithSmartCastInfo?) = qualifier.staticScope
        .getContributedObjectVariables(name, location).map {
            createCandidateDescriptor(it, dispatchReceiver = null)
        }

    override fun getFunctions(name: Name, extensionReceiver: ReceiverValueWithSmartCastInfo?) = qualifier.staticScope
        .getContributedFunctionsAndConstructors(
            name,
            location,
            qualifier.classValueReceiverWithSmartCastInfo,
            extensionReceiver,
            scopeTower",).map {
"}

fun builder(c: suspend Controller.() -> Unit) {
    val controller1 = Controller()
    val controller2 = Controller()

    c.startCoroutine(controller1, EmptyContinuation)
    c.startCoroutine(controller2, EmptyContinuation)

    runControllers(controller1, controller2)
}

// TODO: additional parameters are not supported yet
//fun builder2(coroutine c: Controller.(Long, String) -> Continuation<Unit>) {
//    val controller1 = Controller()
//    val controller2 = Controller()
//
//    c(controller1, 1234567890123456789L, ""Q"").resume(Unit)
//    c(controller2, 1234567890123456789L, ""Q"").resume(Unit)
//
//    runControllers(controller1, controller2)
//}

private fun runControllers(controller1: Controller, controller2: Controller) {
    while (controller1.hasNext()) {
        if (!controller2.hasNext()) throw RuntimeException(""fail 1"")

        if (controller1.lastSuspension === controller2.lastSuspension) throw RuntimeException(""equal references"")

        controller1.next()
        controller2.next()
    }

    if (controller2.hasNext()) throw RuntimeException(""fail 2"")

    if (controller1.result != ""OK"") throw RuntimeException(""fail 3"")
    if (controller2.result != ""OK"") throw RuntimeException(""fail 4"")
}

fun box(): String {
    // no suspension
    builder {
        result = ""OK""
    }

    // 1 suspension
    builder {
        if (suspendHere() != ""56"") return@builder
        result = ""OK""
    }

    // 2 suspensions
    builder {
        if (suspendHere() != ""56"") return@builder
        suspendHere()
        result = ""OK""
    }

    // with capture

    var x = ""O""
    var y = ""K""

    // no suspension
    builder {",result = x + y
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package kotlin.coroutines

import kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED

@SinceKotlin(""1.3"")
internal abstract class CoroutineImpl(private val resultContinuation: Continuation<Any?>?) : Continuation<Any?> {
    protected var state = 0
    protected var exceptionState = 0
    protected var result: Any? = null
    protected var exception: Throwable? = null
    protected var finallyPath: Array<Int>? = null

    private val _context: CoroutineContext? = resultContinuation?.context

    public override val context: CoroutineContext get() = _context!!

    private var intercepted_: Continuation<Any?>? = null

    public fun intercepted(): Continuation<Any?> =
        intercepted_
                ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)
                    .also { intercepted_ = it }

    override fun resumeWith(result: Result<Any?>) {
        var current = this
        var currentResult: Any? = result.getOrNull()
        var currentException: Throwable? = result.exceptionOrNull()

        // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume
        while (true) {
            with(current) {
                // Set result and exception fields in the current continuation
                if (currentException == null) {",this.result = currentResult
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.checkers.generator

import org.jetbrains.kotlin.fir.builder.SYNTAX_DIAGNOSTIC_LIST
import org.jetbrains.kotlin.fir.checkers.generator.diagnostics.DIAGNOSTICS_LIST
import org.jetbrains.kotlin.fir.checkers.generator.diagnostics.JS_DIAGNOSTICS_LIST
import org.jetbrains.kotlin.fir.checkers.generator.diagnostics.JVM_DIAGNOSTICS_LIST",import org.jetbrains.kotlin.fir.checkers.generator.diagnostics.NATIVE_DIAGNOSTICS_LIST
"// WITH_STDLIB
const val int = 456
const val uint = 456U

const val equal1 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, DEPRECATED_IDENTITY_EQUALS!>1 === 2<!>
const val equal2 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, DEPRECATED_IDENTITY_EQUALS!>int === 2<!>
const val equal3 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, DEPRECATED_IDENTITY_EQUALS!>1 === int<!>
const val equal4 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, EQUALITY_NOT_APPLICABLE, FORBIDDEN_IDENTITY_EQUALS!>1u === int<!>

const val equal5 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, FORBIDDEN_IDENTITY_EQUALS!>1u === 2u<!>
const val equal6 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, FORBIDDEN_IDENTITY_EQUALS!>uint === 2u<!>
const val equal7 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, EQUALITY_NOT_APPLICABLE, FORBIDDEN_IDENTITY_EQUALS!>1 === uint<!>
const val equal8 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, FORBIDDEN_IDENTITY_EQUALS!>1u === uint<!>

const val equal9 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, EQUALITY_NOT_APPLICABLE, FORBIDDEN_IDENTITY_EQUALS!>uint === int<!>
const val equal10 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, EQUALITY_NOT_APPLICABLE, FORBIDDEN_IDENTITY_EQUALS!>int === uint<!>","const val notEqual1 = <!CONST_VAL_WITH_NON_CONST_INITIALIZER, DEPRECATED_IDENTITY_EQUALS!>1 !== 2<!>"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.generators.tree.config

import org.jetbrains.kotlin.generators.tree.*
import org.jetbrains.kotlin.types.Variance
import kotlin.properties.PropertyDelegateProvider
import kotlin.properties.ReadOnlyProperty
import kotlin.reflect.KProperty

abstract class AbstractElementConfigurator<Element, Field, Category>
        where Element : AbstractElement<Element, Field, *>,
              Field : AbstractField<Field> {",inner class ElementDelegate(
"// NO_CHECK_LAMBDA_INLINING
// FILE: 1.kt

package test

inline fun <T> doSmth(a: T) : String {
    return { a.toString() }.let { it() }
}

inline fun <T> doSmth2(a: T) : String {
    return { { a.toString() }.let { it() } }.let { it() }
}

// FILE: 2.kt

import test.*

fun test1(s: Long): String {",return doSmth(s)
"if (check_is_I18(x0)) t = t + 19
    if (check_is_I19(x0)) t = t + 20
    if (check_is_I20(x0)) t = t + 21
    if (check_is_I21(x0)) t = t + 22
    if (check_is_I22(x0)) t = t + 23
    if (check_is_I23(x0)) t = t + 24
    if (check_is_I24(x0)) t = t + 25
    if (check_is_I25(x0)) t = t + 26
    if (check_is_I26(x0)) t = t + 27
    if (check_is_I27(x0)) t = t + 28
    if (check_is_I28(x0)) t = t + 29
    if (check_is_I29(x0)) t = t + 30
    if (check_is_I30(x0)) t = t + 31
    if (check_is_I31(x0)) t = t + 32
    if (check_is_I32(x0)) t = t + 33
    if (check_is_I33(x0)) t = t + 34
    if (check_is_I34(x0)) t = t + 35
    if (check_is_I35(x0)) t = t + 36
    if (check_is_I36(x0)) t = t + 37
    if (check_is_I37(x0)) t = t + 38
    if (check_is_I38(x0)) t = t + 39
    if (check_is_I39(x0)) t = t + 40
    if (check_is_I40(x0)) t = t + 41
    if (check_is_I41(x0)) t = t + 42
    if (check_is_I42(x0)) t = t + 43
    if (check_is_I43(x0)) t = t + 44
    if (check_is_I44(x0)) t = t + 45
    if (check_is_I45(x0)) t = t + 46
    if (check_is_I46(x0)) t = t + 47
    if (check_is_I47(x0)) t = t + 48
    if (check_is_I48(x0)) t = t + 49
    if (check_is_I49(x0)) t = t + 50
    if (check_is_I50(x0)) t = t + 51
    if (check_is_I51(x0)) t = t + 52
    if (check_is_I52(x0)) t = t + 53
    if (check_is_I53(x0)) t = t + 54
    if (check_is_I54(x0)) t = t + 55
    if (check_is_I55(x0)) t = t + 56
    if (check_is_I56(x0)) t = t + 57
    if (check_is_I57(x0)) t = t + 58
    if (check_is_I58(x0)) t = t + 59
    if (check_is_I59(x0)) t = t + 60
    if (check_is_I60(x0)) t = t + 61
    if (check_is_I61(x0)) t = t + 62
    if (check_is_I62(x0)) t = t + 63
    if (check_is_I63(x0)) t = t + 64
    if (check_is_I64(x0)) t = t + 65
    if (check_is_I65(x0)) t = t + 66
    if (check_is_I66(x0)) t = t + 67
    if (check_is_I67(x0)) t = t + 68
    if (check_is_I68(x0)) t = t + 69
    if (check_is_I69(x0)) t = t + 70
    if (check_is_I70(x0)) t = t + 71
    if (check_is_I71(x0)) t = t + 72
    if (check_is_I72(x0)) t = t + 73
    if (check_is_I73(x0)) t = t + 74
    if (check_is_I74(x0)) t = t + 75
    if (check_is_I75(x0)) t = t + 76
    if (check_is_I76(x0)) t = t + 77
    if (check_is_I77(x0)) t = t + 78
    if (check_is_I78(x0)) t = t + 79
    if (check_is_I79(x0)) t = t + 80
    if (check_is_I80(x0)) t = t + 81
    if (check_is_I81(x0)) t = t + 82
    if (check_is_I82(x0)) t = t + 83",if (check_is_I83(x0)) t = t + 84
"// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER -TOPLEVEL_TYPEALIASES_ONLY
// NI_EXPECTED_FILE

class C {
    typealias Self = C
    class Nested {
        class N2
        typealias Root = C
    }
    companion object X {
        val ok = ""OK""
        class InCompanion
    }
}",val c = C.Self.<!UNRESOLVED_REFERENCE!>Self<!>()
"public fun foo(p: String?, y: String?): Int {
    do {
        // After this !!, y. should be smartcasted in loop as well as outside
        y!!.length
        if (p == null) break
        y.length
    } while (true)",return y.length
"// !LANGUAGE: +UnrestrictedBuilderInference
// WITH_STDLIB
// SKIP_TXT
// !DIAGNOSTICS: -CAST_NEVER_SUCCEEDS -UNCHECKED_CAST -UNUSED_PARAMETER -UNUSED_VARIABLE -OPT_IN_USAGE_ERROR -UNUSED_EXPRESSION

import kotlin.experimental.ExperimentalTypeInference

fun <K> FlowCollector<K>.bar(): K = null as K
fun <K> FlowCollector<K>.foo(): K = null as K

fun <K> K.bar3(): K = null as K
fun <K> K.foo3(): K = null as K

fun bar2(): Int = 1
fun foo2(): Float = 1f

val bar4: Int
    get() = 1

var foo4: Float
    get() = 1f
    set(value) {}",val <K> FlowCollector<K>.bar5: K get() = null as K
"}

fun BaseGradleIT.CompiledProject.assertNoDiagnostic(diagnosticFactory: ToolingDiagnosticFactory, withSubstring: String? = null) {
    output.assertNoDiagnostic(diagnosticFactory, withSubstring)
}

fun BuildResult.assertHasDiagnostic(diagnosticFactory: ToolingDiagnosticFactory, withSubstring: String? = null) {
    output.assertHasDiagnostic(diagnosticFactory, withSubstring)
}

fun BuildResult.assertNoDiagnostic(diagnosticFactory: ToolingDiagnosticFactory, withSubstring: String? = null) {
    output.assertNoDiagnostic(diagnosticFactory, withSubstring)
}

fun String.assertHasDiagnostic(diagnosticFactory: ToolingDiagnosticFactory, withSubstring: String? = null) {
    val diagnosticsMessages = extractRenderedDiagnostics(diagnosticFactory, this)
    assertTrue(diagnosticsMessages.isNotEmpty(), ""Diagnostic with id=${diagnosticFactory.id} not found. Full text output:\n\n"" + this)
    if (withSubstring != null) {
        assertTrue(
            diagnosticsMessages.any { withSubstring in it },
            ""Diagnostic ${diagnosticFactory.id} doesn't have expected substring $withSubstring. "" +
                    ""Actual diagnostic messages with that ID:\n"" +
                    diagnosticsMessages.joinToString(separator = ""\n"") +
                    ""\nFull text output:\n\n"" +
                    this
        )
    }
}

fun String.assertNoDiagnostic(diagnosticFactory: ToolingDiagnosticFactory, withSubstring: String? = null) {
    val diagnosticMessages = extractRenderedDiagnostics(diagnosticFactory, this)
    if (withSubstring != null) {
        val matchedWithSubstring = diagnosticMessages.find { withSubstring in it }
        assertNull(
            matchedWithSubstring,
            ""Diagnostic with id=${diagnosticFactory.id} and substring '${withSubstring}' was expected to be absent, but was reported. "" +
                    ""Actual diagnostic message: \n"" +
                    matchedWithSubstring +
                    ""\nFull text output:\n\n"" +
                    this
        )
    } else {
        assertTrue(
            diagnosticMessages.isEmpty(),
            ""Expected no diagnostics with id=${diagnosticFactory.id}, but some were reported:\n"" +
                    diagnosticMessages.joinToString(separator = ""\n"") +
                    ""\nFull text output:\n\n"" +
                    this
        )
    }
}

/**
 * NB: Needs parsable formatting of diagnostics, see [org.jetbrains.kotlin.gradle.plugin.PropertiesProvider.internalDiagnosticsUseParsableFormat]
 * Because this mode is enabled by the 'kotlin.internal'-property, actual output will always contain
 * [org.jetbrains.kotlin.gradle.plugin.diagnostics.KotlinToolingDiagnostics.InternalKotlinGradlePluginPropertiesUsed].
 * For the sake of clarity, this diagnostic is filtered by default.
 */
fun BuildResult.extractProjectsAndTheirDiagnostics(): String = buildString {
    var diagnosticStarted = false
    var stacktraceStarted = false
    val currentDiagnostic = mutableListOf<String>()

    fun startDiagnostic(line: String, lineIndex: Int) {
        require(!diagnosticStarted) {",printBuildOutput()
"catch (e: Exception) {
        return
    }
    a.hashCode() // a is never null here
}
class A: Exception()
class B: Exception()
fun test2() {
    var a: Int?
    try {
        a = 4
    }
    catch (e: A) {
        return
    }
    catch (e: B) {
        return
    }
    a.hashCode() // a is never null here
}
fun test3() {
    var a: Int? = null
    try {
        a = 5
    }
    catch (e: A) {
        // do nothing
    }
    catch (e: B) {
        return
    }
    a<!UNSAFE_CALL!>.<!>hashCode() // a is nullable here
}
fun test4() {
    var a: Int? = null
    try {
        // do nothing
    }
    catch (e: A) {
        return
    }
    catch (e: B) {
        return
    }
    a<!UNSAFE_CALL!>.<!>hashCode() // a is nullable here
}
fun test5() {
    var a: Int?// = null
    try {
        a = 3
    }
    catch (e: Exception) {
        return
    }
    finally {
        a = 5
    }
    a.hashCode() // a is never null here
}
fun test6() {
    var a: Int?// = null
    try {
        a = 3
    }
    catch (e: Exception) {",return
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.lower

import org.jetbrains.kotlin.backend.common.BodyLoweringPass
import org.jetbrains.kotlin.backend.common.compilationException
import org.jetbrains.kotlin.ir.backend.js.JsIrBackendContext
import org.jetbrains.kotlin.ir.declarations.IrDeclaration
import org.jetbrains.kotlin.ir.expressions.IrBody
import org.jetbrains.kotlin.ir.expressions.IrConst
import org.jetbrains.kotlin.ir.expressions.IrConstKind
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.expressions.impl.IrConstImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrConstructorCallImpl
import org.jetbrains.kotlin.ir.symbols.IrClassSymbol
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.types.classifierOrNull
import org.jetbrains.kotlin.ir.types.defaultType
import org.jetbrains.kotlin.ir.util.constructors
import org.jetbrains.kotlin.ir.util.isUnsigned
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
import org.jetbrains.kotlin.ir.visitors.transformChildrenVoid

class ConstTransformer(private val context: JsIrBackendContext) : IrElementTransformerVoid() {
    private fun <C> lowerConst(
        expression: IrConst<*>,
        irClass: IrClassSymbol,
        carrierFactory: (Int, Int, IrType, C) -> IrExpression,
        vararg args: C
    ): IrExpression {
        val constructor = irClass.constructors.single { it.owner.isPrimary }
        val argType = constructor.owner.valueParameters.first().type

        return IrConstructorCallImpl.fromSymbolOwner(
                expression.startOffset,
                expression.endOffset,
                irClass.defaultType,
                constructor",).apply {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""unused"", ""MemberVisibilityCanBePrivate"")

package org.jetbrains.kotlin.sir.tree.generator

import org.jetbrains.kotlin.generators.tree.StandardTypes.boolean
import org.jetbrains.kotlin.generators.tree.StandardTypes.string
import org.jetbrains.kotlin.generators.tree.config.element
import org.jetbrains.kotlin.generators.tree.config.sealedElement
import org.jetbrains.kotlin.sir.tree.generator.config.AbstractSwiftIrTreeBuilder
import org.jetbrains.kotlin.sir.tree.generator.model.Element

object SwiftIrTree : AbstractSwiftIrTreeBuilder() {

    override val rootElement by sealedElement(name = ""Element"") {
        kDoc = ""The root interface of the Swift IR tree.""
    }

    val declarationParent by sealedElement()

    val declarationContainer by sealedElement {
        parent(declarationParent)
        customParentInVisitor = rootElement","+listField(""declarations"", declaration)"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.decompiler.stub.files

import com.intellij.psi.stubs.StubElement
import org.jetbrains.kotlin.contracts.description.*
import org.jetbrains.kotlin.psi.KtProjectionKind
import org.jetbrains.kotlin.psi.stubs.impl.*

fun extractAdditionalStubInfo(stub: StubElement<*>): String {
    val builder = StringBuilder()
    extractAdditionInfo(stub, builder, 0)
    return builder.toString()
}

private fun extractAdditionInfo(stub: StubElement<*>, builder: StringBuilder, level: Int) {
    builder.append(stub.toString())
    when (stub) {
        is KotlinUserTypeStubImpl -> {
            val upperBound = stub.upperBound
            if (upperBound != null) {
                builder.append(""    ft: "")
                appendFlexibleTypeInfo(builder, upperBound)
            }
        }
        is KotlinFunctionStubImpl -> {
            val contract = stub.contract
            if (contract != null) {
                for (element in contract) {
                    builder.append(""\n"" + ""  "".repeat(level)).append(""effect:"")
                    element.accept(KotlinContractRenderer(builder), null)
                }
            }
        }
        is KotlinPropertyStubImpl -> {
            val initializer = stub.constantInitializer
            if (initializer != null) {
                builder.append(""\n"").append(""  "".repeat(level)).append(""initializer: ${initializer.value}"")
            }
        }
        is KotlinAnnotationEntryStubImpl -> {
            val arguments = stub.valueArguments
            if (arguments != null) {
                builder
                    .append(""\n"")
                    .append(""  "".repeat(level))
                    .append(""valueArguments: "")
                    .append(arguments.entries.joinToString("", "", ""("", "")"") { ""${it.key.asString()} = ${it.value}"" })
            }
        }
        is KotlinParameterStubImpl -> {
            stub.functionTypeParameterName?.let { builder.append(""   paramNameByAnnotation: "").append(it) }
        }
    }
    for (child in stub.childrenStubs) {
        builder.append(""\n"").append(""  "".repeat(level))
        extractAdditionInfo(child, builder, level + 1)
    }
}","private fun appendFlexibleTypeInfo(builder: StringBuilder, typeBean: KotlinTypeBean) {"
"isNullable = expandedType.isNullable,
        attributes = expandedType.attributes
    )
}

// ---------------------------------------------- function type subtyping ----------------------------------------------

// expectedfunctionType is kotlin.FunctionN or kotlin.reflect.KFunctionN
fun ConeKotlinType.findSubtypeOfBasicFunctionType(session: FirSession, expectedFunctionType: ConeClassLikeType): ConeKotlinType? {
    require(expectedFunctionType.isFunctionOrKFunctionType(session, errorOnNotFunctionType = true))
    return findSubtypeOfBasicFunctionTypeImpl(session, expectedFunctionType)
}

// Function, KFunction
private fun ConeKotlinType.isFunctionOrKFunctionType(session: FirSession, errorOnNotFunctionType: Boolean): Boolean {
    return isFunctionTypeWithPredicate(session, errorOnNotFunctionType) { it.isBasicFunctionOrKFunction }
}

private fun ConeKotlinType.findSubtypeOfBasicFunctionTypeImpl(
    session: FirSession,
    expectedFunctionType: ConeClassLikeType
): ConeKotlinType? {
    return when (this) {
        is ConeClassLikeType -> {
            when {
                // Expect the argument type is a simple function type.
                isNotBasicFunctionType(session) -> null
                isSubtypeOfFunctionType(session, expectedFunctionType) -> this
                else -> null
            }
        }

        is ConeIntersectionType -> {
            runUnless(intersectedTypes.any { it.isNotBasicFunctionType(session) }) {
                intersectedTypes.find { it.findSubtypeOfBasicFunctionTypeImpl(session, expectedFunctionType) != null }
            }
        }

        is ConeTypeParameterType -> {
            val bounds = lookupTag.typeParameterSymbol.resolvedBounds.map { it.coneType }
            runUnless(bounds.any { it.isNotBasicFunctionType(session) }) {
                bounds.find { it.findSubtypeOfBasicFunctionTypeImpl(session, expectedFunctionType) != null }
            }
        }
        else -> null
    }
}

private fun ConeKotlinType.isSubtypeOfFunctionType(session: FirSession, expectedFunctionType: ConeClassLikeType): Boolean {
    return AbstractTypeChecker.isSubtypeOf(session.typeContext, this, expectedFunctionType.replaceArgumentsWithStarProjections())
}

// ---------------------------------------------- function type scope utils ----------------------------------------------

fun ConeClassLikeType.findBaseInvokeSymbol(session: FirSession, scopeSession: ScopeSession): FirNamedFunctionSymbol? {
    require(this.isSomeFunctionType(session))
    val functionN = (lookupTag.toSymbol(session)?.fir as? FirClass) ?: return null
    var baseInvokeSymbol: FirNamedFunctionSymbol? = null
    functionN.unsubstitutedScope(
        session,
        scopeSession,
        withForcedTypeCalculator = false,
        memberRequiredPhase = null,
    ).processFunctionsByName(OperatorNameConventions.INVOKE) { functionSymbol ->
        baseInvokeSymbol = functionSymbol",return@processFunctionsByName
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin.diagnostics

import org.gradle.api.DefaultTask
import org.gradle.api.InvalidUserCodeException
import org.gradle.api.Project
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.*
import org.gradle.language.base.plugins.LifecycleBasePlugin
import org.gradle.work.DisableCachingByDefault
import org.jetbrains.kotlin.gradle.tasks.KotlinCompileTool
import org.jetbrains.kotlin.gradle.tasks.withType
import org.jetbrains.kotlin.gradle.utils.onlyIfCompat

@DisableCachingByDefault(
    because = ""This task renders reported diagnostics; caching this task will hide diagnostics and obscure issues in the build""
)
internal abstract class CheckKotlinGradlePluginConfigurationErrors : DefaultTask() {
    @get:Input
    abstract val errorDiagnostics: ListProperty<ToolingDiagnostic>

    @get:Internal
    abstract val renderingOptions: Property<ToolingDiagnosticRenderingOptions>

    @TaskAction
    fun checkNoErrors() {
        if (errorDiagnostics.get().isNotEmpty()) {
            renderReportedDiagnostics(errorDiagnostics.get(), logger, renderingOptions.get())
            throw InvalidUserCodeException(""Kotlin Gradle Plugin reported errors. Check the log for details"")
        }
    }

    companion object {
        internal const val TASK_NAME = ""checkKotlinGradlePluginConfigurationErrors""
    }
}

private const val DESCRIPTION =
    ""Checks that Kotlin Gradle Plugin hasn't reported project configuration errors, failing otherwise. "" +
            ""This task always runs before compileKotlin* or similar tasks.""

internal fun Project.locateOrRegisterCheckKotlinGradlePluginErrorsTask(): TaskProvider<CheckKotlinGradlePluginConfigurationErrors> {
    val taskProvider = tasks.register(","CheckKotlinGradlePluginConfigurationErrors.TASK_NAME,"
"useHandlers(
                ::ClassicDiagnosticsHandler
            )
        }

        configureFirHandlersStep {
            useHandlers(
                ::FirDiagnosticsHandler
            )
        }

        configureCommonHandlersForBoxTest()

        configureJvmArtifactsHandlersStep {
            useHandlers(
                ::BytecodeListingHandler,
                ::BytecodeTextHandler.bind(true)
            )
        }

        useAfterAnalysisCheckers(::BlackBoxCodegenSuppressor)
        if (targetBackend.isIR) {
            useAfterAnalysisCheckers(::BlackBoxInlinerCodegenSuppressor)
        }

        defaultDirectives {
            +REPORT_ONLY_EXPLICITLY_DEFINED_DEBUG_INFO
        }

        forTestsNotMatching(""compiler/testData/codegen/box/diagnostics/functions/tailRecursion/*"") {
            defaultDirectives {
                DIAGNOSTICS with ""-warnings""
            }
        }

        configureModernJavaWhenNeeded()

        forTestsMatching(""compiler/testData/codegen/box/coroutines/varSpilling/debugMode/*"") {
            defaultDirectives {
                +ENABLE_DEBUG_MODE
            }
        }

        forTestsMatching(""compiler/testData/codegen/box/javaInterop/foreignAnnotationsTests/tests/*"") {
            defaultDirectives {
                ForeignAnnotationsDirectives.ANNOTATIONS_PATH with JavaForeignAnnotationType.Annotations
            }
            useConfigurators(::JvmForeignAnnotationsConfigurator)
        }

        forTestsMatching(""compiler/testData/codegen/box/involvesIrInterpreter/*"") {
            configureJvmArtifactsHandlersStep {
                useHandlers(::JvmIrInterpreterDumpHandler)
            }
        }

        enableMetaInfoHandler()
    }
}

fun TestConfigurationBuilder.configureModernJavaWhenNeeded() {
    forTestsMatching(""compiler/testData/codegen/boxModernJdk/testsWithJava11/*"") {
        configureModernJavaTest(TestJdkKind.FULL_JDK_11, JvmTarget.JVM_11)
    }","forTestsMatching(""compiler/testData/codegen/boxModernJdk/testsWithJava17/*"") {"
"if (logger is GradleKotlinLogger) {
        process.inputStream!!.bufferedReader().forEachLine {
            logger.lifecycle(it)
        }
    } else {
        process.inputStream!!.bufferedReader().forEachLine {
            println(it)
        }
    }

    readErrThread.join()

    val exitCode = process.waitFor()
    logger.logFinish(KotlinCompilerExecutionStrategy.OUT_OF_PROCESS)
    return exitCodeFromProcessExitCode(logger, exitCode)
}

private fun writeArgumentsToFile(directory: File, argsArray: Array<String>): File {
    val prefix = LocalDateTime.now().format(DateTimeFormatter.BASIC_ISO_DATE) + ""_""
    val suffix = "".compiler.options""
    val compilerOptions = if (directory.exists())
        Files.createTempFile(directory.toPath(), prefix, suffix).toFile()
    else
        Files.createTempFile(prefix, suffix).toFile()
    compilerOptions.writeText(
        argsArray.joinToString("" "") {
            ""\""${it.escapeJavaStyleString()}\""""
        }
    )
    return compilerOptions
}

// Ported method from Groovy:
// https://github.com/apache/groovy/blob/73c0f12ab35427bc3e7fd76929b482df61e1b80d/subprojects/groovy-json/src/main/java/groovy/json/StringEscapeUtils.java#L175
// Note: using '/f' char produces a compilation error, so removed it
internal fun String.escapeJavaStyleString(
    escapeSingleQuote: Boolean = false,
    escapeForwardSlash: Boolean = false,
): String {
    return buildString {
        this@escapeJavaStyleString.forEach { ch ->
            when {
                ch.toInt() > 0xfff -> append(""\\u${ch.hex()}"")
                ch.toInt() > 0xff -> append(""\\u0${ch.hex()}"")
                ch.toInt() >= 0x7f -> append(""\\u00${ch.hex()}"")
                ch < 32.toChar() -> when (ch) {
                    '\b' -> append('\\').append('b')
                    '\n' -> append('\\').append('n')
                    '\t' -> append('\\').append('t')
                    '\r' -> append('\\').append('r')
                    else -> if (ch > 0xf.toChar()) {
                        append(""\\u00${ch.hex()}"")
                    } else {
                        append(""\\u000${ch.hex()}"")
                    }
                }
                else -> when (ch) {
                    '\'' -> {
                        if (escapeSingleQuote) append('\\')
                        append('\'')
                    }
                    '""' -> append('\\').append('""')
                    '\\' -> append('\\').append('\\')
                    '/' -> {",if (escapeForwardSlash) append('\\')
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.native.checkers

import org.jetbrains.kotlin.KtNodeTypes.REFERENCE_EXPRESSION
import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind",import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
"import org.jetbrains.kotlin.asJava.AbstractCompilerLightClassTest
import org.jetbrains.kotlin.cfg.AbstractControlFlowTest
import org.jetbrains.kotlin.cfg.AbstractDataFlowTest
import org.jetbrains.kotlin.cfg.AbstractPseudoValueTest
import org.jetbrains.kotlin.cli.AbstractCliTest
import org.jetbrains.kotlin.codegen.*
import org.jetbrains.kotlin.codegen.defaultConstructor.AbstractDefaultArgumentsReflectionTest
import org.jetbrains.kotlin.codegen.defaultConstructor.fir.AbstractFirLightTreeDefaultArgumentsReflectionTest
import org.jetbrains.kotlin.codegen.defaultConstructor.fir.AbstractFirPsiDefaultArgumentsReflectionTest
import org.jetbrains.kotlin.codegen.defaultConstructor.ir.AbstractIrDefaultArgumentsReflectionTest
import org.jetbrains.kotlin.codegen.fir.*
import org.jetbrains.kotlin.codegen.flags.AbstractWriteFlagsTest
import org.jetbrains.kotlin.codegen.ir.*
import org.jetbrains.kotlin.codegen.ir.AbstractIrWriteSignatureTest
import org.jetbrains.kotlin.fir.builder.AbstractRawFirBuilderLazyBodiesByAstTest
import org.jetbrains.kotlin.fir.builder.AbstractRawFirBuilderLazyBodiesByStubTest
import org.jetbrains.kotlin.fir.builder.AbstractRawFirBuilderSourceElementMappingTestCase
import org.jetbrains.kotlin.fir.builder.AbstractRawFirBuilderTestCase
import org.jetbrains.kotlin.fir.java.AbstractFirOldFrontendLightClassesTest
import org.jetbrains.kotlin.fir.java.AbstractFirTypeEnhancementTest
import org.jetbrains.kotlin.fir.java.AbstractOwnFirTypeEnhancementTest
import org.jetbrains.kotlin.fir.lightTree.AbstractLightTree2FirConverterTestCase
import org.jetbrains.kotlin.generators.impl.generateTestGroupSuite
import org.jetbrains.kotlin.generators.util.TestGeneratorUtil
import org.jetbrains.kotlin.generators.util.TestGeneratorUtil.KT_OR_KTS_WITHOUT_DOTS_IN_NAME
import org.jetbrains.kotlin.integration.AbstractAntTaskTest
import org.jetbrains.kotlin.jvm.compiler.*
import org.jetbrains.kotlin.jvm.compiler.fir.AbstractFirLightTreeCompileJavaAgainstKotlinTest
import org.jetbrains.kotlin.jvm.compiler.fir.AbstractFirPsiCompileJavaAgainstKotlinTest
import org.jetbrains.kotlin.jvm.compiler.ir.*
import org.jetbrains.kotlin.jvm.compiler.javac.AbstractLoadJavaUsingJavacTest
import org.jetbrains.kotlin.klib.AbstractKlibIrTextTestCase
import org.jetbrains.kotlin.klib.AbstractKlibJsIrTextTestCase
import org.jetbrains.kotlin.lexer.kdoc.AbstractKDocLexerTest
import org.jetbrains.kotlin.lexer.kotlin.AbstractKotlinLexerTest
import org.jetbrains.kotlin.modules.xml.AbstractModuleXmlParserTest
import org.jetbrains.kotlin.multiplatform.AbstractMultiPlatformIntegrationTest
import org.jetbrains.kotlin.parsing.AbstractParsingTest
import org.jetbrains.kotlin.repl.AbstractReplInterpreterTest
import org.jetbrains.kotlin.resolve.AbstractResolveTest
import org.jetbrains.kotlin.resolve.calls.AbstractResolvedCallsTest
import org.jetbrains.kotlin.resolve.calls.AbstractResolvedConstructorDelegationCallsTests
import org.jetbrains.kotlin.test.TargetBackend
import org.jetbrains.kotlin.test.utils.CUSTOM_TEST_DATA_EXTENSION_PATTERN
import org.jetbrains.kotlin.types.AbstractTypeBindingTest

fun generateJUnit3CompilerTests(args: Array<String>, mainClassName: String?) {
    val excludedCustomTestdataPattern = CUSTOM_TEST_DATA_EXTENSION_PATTERN

    generateTestGroupSuite(args, mainClassName) {
        testGroup(""compiler/tests-gen"", ""compiler/testData"") {
            testClass<AbstractMultiPlatformIntegrationTest> {
                model(""multiplatform"", extension = null, recursive = true, excludeParentDirs = true)
            }

            testClass<AbstractResolveTest> {
                model(""resolve"", extension = ""resolve"")
            }

            testClass<AbstractResolvedCallsTest> {
                model(""resolvedCalls"", excludeDirs = listOf(""enhancedSignatures""))
            }

            testClass<AbstractResolvedConstructorDelegationCallsTests> {","model(""resolveConstructorDelegationCalls"")"
"package org.jetbrains.kotlin.incremental

import org.jetbrains.kotlin.incremental.DifferenceCalculatorForClass.Companion.getNonPrivateMembers
import org.jetbrains.kotlin.metadata.ProtoBuf.Visibility.PRIVATE
import org.jetbrains.kotlin.metadata.deserialization.Flags
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.resolve.sam.SAM_LOOKUP_NAME

//TODO(valtman) Should be in gradle daemon.
class AbiSnapshotDiffService() {

    companion object {
        //Store list of changed lookups
        private val diffCache: MutableMap<Pair<AbiSnapshot, AbiSnapshot>, DirtyData> = mutableMapOf()

        //TODO(valtman) move out from Kotlin daemon
        fun compareJarsInternal(
            oldSnapshot: AbiSnapshot, newSnapshot: AbiSnapshot,
            caches: IncrementalCacheCommon
        ) = diffCache.computeIfAbsent(Pair(oldSnapshot, newSnapshot)) { (snapshot, actual) -> doCompute(snapshot, actual, caches, emptyList()) }

        fun inScope(fqName: FqName, scopes: Collection<String>) = scopes.any { scope -> fqName.toString().startsWith(scope) }

        fun doCompute(snapshot: AbiSnapshot, actual: AbiSnapshot, caches: IncrementalCacheCommon, scopes: Collection<String>): DirtyData {

            val dirtyFqNames = mutableListOf<FqName>()
            val dirtyLookupSymbols = mutableListOf<LookupSymbol>()

            for ((fqName, protoData) in snapshot.protos) {
                if (!inScope(fqName, scopes)) continue
                val newProtoData = actual.protos[fqName]
                if (newProtoData == null) {
                    val (fqNames, symbols) = addProtoInfo(protoData, fqName)
                    dirtyFqNames.addAll(fqNames)
                    dirtyLookupSymbols.addAll(symbols)
                } else {
                    if (protoData is ClassProtoData && newProtoData is ClassProtoData) {
                        ProtoCompareGenerated(
                            protoData.nameResolver, newProtoData.nameResolver,
                            protoData.proto.typeTable, newProtoData.proto.typeTable
                        )
                        val diff = DifferenceCalculatorForClass(protoData, newProtoData).difference()

                        if (diff.isClassAffected) {
                            //TODO(valtman) get cache to mark dirty all subtypes if subclass affected
//                            val fqNames = if (!diff.areSubclassesAffected) listOf(fqName) else withSubtypes(fqName, caches)
                            dirtyFqNames.add(fqName)
                            assert(!fqName.isRoot) { ""$fqName is root"" }

                            val scope = fqName.parent().asString()
                            val name = fqName.shortName().identifier
                            dirtyLookupSymbols.add(LookupSymbol(name, scope))
                        }
                        for (member in diff.changedMembersNames) {
                            //TODO(valtman) mark dirty symbols for subclasses
                            val subtypeFqNames = withSubtypes(fqName, listOf(caches))
                            dirtyFqNames.addAll(subtypeFqNames)

                            for (subtypeFqName in subtypeFqNames) {
                                dirtyLookupSymbols.add(LookupSymbol(member, subtypeFqName.asString()))
                                dirtyLookupSymbols.add(LookupSymbol(SAM_LOOKUP_NAME.asString(), subtypeFqName.asString()))
                            }
                        }",} else if (protoData is PackagePartProtoData && newProtoData is PackagePartProtoData) {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""FunctionName"")

package org.jetbrains.kotlin.gradle.unitTests

import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinMetadataLibrariesIndexFile
import org.junit.Rule
import org.junit.rules.TemporaryFolder
import java.io.File
import java.io.FileNotFoundException
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertFailsWith

class KotlinMetadataLibrariesIndexFileTest {",@get:Rule
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer.utils

import com.intellij.util.SmartFMap
import org.jetbrains.kotlin.utils.addToStdlib.firstIsInstance
import java.util.*
import java.util.Collections.singletonList
import java.util.Collections.singletonMap

internal inline fun <K : Any, V, R> Map<K, V>.compactMapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> =
    when (size) {
        0 -> emptyMap()
        1 -> with(entries.iterator().next()) { singletonMap(key, transform(this)) }
        2, 3 -> entries.fold(SmartFMap.emptyMap()) { acc, entry -> acc.plus(entry.key, transform(entry)) }
        else -> mapValuesTo(CommonizerMap(size), transform)
    }

internal inline fun <T, R> Collection<T>.compactMap(transform: (T) -> R): List<R> =
    when (size) {
        0 -> emptyList()
        1 -> singletonList(transform(if (this is List) this[0] else iterator().next()))
        else -> mapTo(ArrayList(size), transform)
    }

internal inline fun <T, R> Array<T>.compactMap(transform: (T) -> R): List<R> =
    when (size) {
        0 -> emptyList()
        1 -> singletonList(transform(this[0]))
        else -> mapTo(ArrayList(size), transform)
    }

internal inline fun <T, R : Any> Array<T>.compactMapNotNull(transform: (T) -> R): List<R> {
    return mapNotNullTo(ArrayList<R>(size), transform).also { it.trimToSize() }
}

internal inline fun <T, reified R : Any> Collection<T>.compactMapNotNull(transform: (T) -> R?): List<R> =
    if (isEmpty()) emptyList() else mapNotNullTo(ArrayList(size), transform).compact()

internal inline fun <T, R> Collection<T>.compactMapIndexed(transform: (index: Int, T) -> R): List<R> =
    when (size) {
        0 -> emptyList()
        1 -> singletonList(transform(0, if (this is List) this[0] else iterator().next()))
        else -> mapIndexedTo(ArrayList(size), transform)
    }

internal inline fun <reified T> List<T>.compact(): List<T> =
    when (size) {
        0 -> emptyList()
        1 -> singletonList(this[0])
        else -> when (this) {",is java.util.ArrayList -> {
"expectSuccess(0) { singleVarargArgument() }
    expectSuccess(1) { singleVarargArgument(1) }
    expectSuccess(3) { singleVarargArgument(1, 2) }
    expectSuccess(1) { singleVarargArgument(*intArrayOf(1)) }
    expectSuccess(3) { singleVarargArgument(*intArrayOf(1, 2)) }
    expectSuccess(-6) { singleVarargArgumentWithDefaultValue() }
    expectSuccess(1) { singleVarargArgumentWithDefaultValue(1) }
    expectSuccess(3) { singleVarargArgumentWithDefaultValue(1, 2) }
    expectSuccess(1) { singleVarargArgumentWithDefaultValue(*intArrayOf(1)) }
    expectSuccess(3) { singleVarargArgumentWithDefaultValue(*intArrayOf(1, 2)) }
    expectSuccess(110) { varargArgumentAndOtherArguments(100, last = 10) }
    expectSuccess(111) { varargArgumentAndOtherArguments(100, 1, last = 10) }
    expectSuccess(113) { varargArgumentAndOtherArguments(100, 1, 2, last = 10) }
    expectSuccess(111) { varargArgumentAndOtherArguments(100, *intArrayOf(1), last = 10) }
    expectSuccess(113) { varargArgumentAndOtherArguments(100, *intArrayOf(1, 2), last = 10) }
    expectSuccess(-110) { varargArgumentAndOtherArgumentsWithDefaultValues() }
    expectSuccess(90) { varargArgumentAndOtherArgumentsWithDefaultValues(100) }
    expectSuccess(110) { varargArgumentAndOtherArgumentsWithDefaultValues(100, last = 10) }
    expectSuccess(91) { varargArgumentAndOtherArgumentsWithDefaultValues(100, 1) }
    expectSuccess(93) { varargArgumentAndOtherArgumentsWithDefaultValues(100, 1, 2) }
    expectSuccess(113) { varargArgumentAndOtherArgumentsWithDefaultValues(100, 1, 2, last = 10) }
    expectSuccess(-109) { @Suppress(""REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_FUNCTION"") varargArgumentAndOtherArgumentsWithDefaultValues(elements = *intArrayOf(1)) }
    expectSuccess(-107) { @Suppress(""REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_FUNCTION"") varargArgumentAndOtherArgumentsWithDefaultValues(elements = *intArrayOf(1, 2)) }
    expectSuccess(104) { varargArgumentWithDefaultValueAndOtherArguments(100, last = 10) }
    expectSuccess(111) { varargArgumentWithDefaultValueAndOtherArguments(100, 1, last = 10) }
    expectSuccess(113) { varargArgumentWithDefaultValueAndOtherArguments(100, 1, 2, last = 10) }
    expectSuccess(111) { varargArgumentWithDefaultValueAndOtherArguments(100, *intArrayOf(1), last = 10) }
    expectSuccess(113) { varargArgumentWithDefaultValueAndOtherArguments(100, *intArrayOf(1, 2), last = 10) }
    expectSuccess(-116) { varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues() }
    expectSuccess(84) { varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(100) }
    expectSuccess(104) { varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(100, last = 10) }
    expectSuccess(91) { varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(100, 1) }
    expectSuccess(93) { varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(100, 1, 2) }
    expectSuccess(113) { varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(100, 1, 2, last = 10) }
    expectSuccess(-109) { @Suppress(""REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_FUNCTION"") varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(elements = *intArrayOf(1)) }
    expectSuccess(-107) { @Suppress(""REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_FUNCTION"") varargArgumentWithDefaultValueAndOtherArgumentsWithDefaultValues(elements = *intArrayOf(1, 2)) }

    expectSuccess(-1) { suspendToNonSuspendFunction1(1) }
    expectSuccess(-2) { suspendToNonSuspendFunction2(2) }
    expectSuccess(-3) { suspendToNonSuspendFunction3(3) }
    expectFailure(linkage(""Function 'nonSuspendToSuspendFunction' can not be called: Suspend function can be called only from a coroutine or another suspend function"")) { nonSuspendToSuspendFunction1(4) }
    expectSuccess(-5) { nonSuspendToSuspendFunction2(5) }
    expectFailure(linkage(""Function 'nonSuspendToSuspendFunction' can not be called: Suspend function can be called only from a coroutine or another suspend function"")) { nonSuspendToSuspendFunction3(6) }
    expectSuccess(-7) { nonSuspendToSuspendFunction4(7) }

    expectFailure(linkage(""Abstract function 'suspendToNonSuspendFunction' is not implemented in non-abstract class 'InterfaceImpl'"")) { suspendToNonSuspendFunctionInInterface(i, 1) }
    expectFailure(linkage(""Function 'nonSuspendToSuspendFunction' can not be called: Suspend function can be called only from a coroutine or another suspend function"")) { nonSuspendToSuspendFunctionInInterface(i, 2) }
    expectSuccess(""InterfaceImpl.suspendToNonSuspendFunction(3)"") { suspendToNonSuspendFunctionInInterfaceImpl(ii, 3) }
    expectSuccess(""InterfaceImpl.nonSuspendToSuspendFunction(4)"") { nonSuspendToSuspendFunctionInInterfaceImpl(ii, 4) }

    expectFailure(linkage(""Abstract function 'suspendToNonSuspendFunction' is not implemented in non-abstract class 'AbstractClassImpl'"")) { suspendToNonSuspendFunctionInAbstractClass(ac, 5) }
    expectFailure(linkage(""Function 'nonSuspendToSuspendFunction' can not be called: Suspend function can be called only from a coroutine or another suspend function"")) { nonSuspendToSuspendFunctionInAbstractClass(ac, 6) }
    expectSuccess(""AbstractClassImpl.suspendToNonSuspendFunction(7)"") { suspendToNonSuspendFunctionInAbstractClassImpl(aci, 7) }
    expectSuccess(""AbstractClassImpl.nonSuspendToSuspendFunction(8)"") { nonSuspendToSuspendFunctionInAbstractClassImpl(aci, 8) }

    expectSuccess(""OpenClassV2.suspendToNonSuspendFunction(9)"") { suspendToNonSuspendFunctionInOpenClass(oc, 9) } // Function of the base class is called instead of overridden function in inherited class.
    expectFailure(linkage(""Function 'nonSuspendToSuspendFunction' can not be called: Suspend function can be called only from a coroutine or another suspend function"")) { nonSuspendToSuspendFunctionInOpenClass(oc, 10) }
    expectSuccess(""OpenClassImpl.suspendToNonSuspendFunction(11)"") { suspendToNonSuspendFunctionInOpenClassImpl(oci, 11) }
    expectSuccess(""OpenClassImpl.nonSuspendToSuspendFunction(12)"") { nonSuspendToSuspendFunctionInOpenClassImpl(oci, 12) }
    expectSuccess(""OpenClassV2.suspendToNonSuspendFunctionWithDelegation(13) called from OpenClassImpl.suspendToNonSuspendFunctionWithDelegation(13)"") { suspendToNonSuspendFunctionWithDelegation(oci, 13) }
    expectFailure(linkage(""Function 'nonSuspendToSuspendFunctionWithDelegation' can not be called: Suspend function can be called only from a coroutine or another suspend function"")) { nonSuspendToSuspendFunctionWithDelegation(oci, 14) }

    expectSuccess(""OpenClassV2.openNonInlineToInlineFunction(1)"") { openNonInlineToInlineFunctionInOpenClass(oc, 1) }
    expectSuccess(""OpenClassV2.openNonInlineToInlineFunctionWithDelegation(2)"") { openNonInlineToInlineFunctionWithDelegationInOpenClass(oc, 2) }
    expectSuccess(""OpenClassV2.newInlineFunction1(3)"") { newInlineFunction1InOpenClass(oc, 3) }","expectSuccess(""OpenClassV2.newInlineFunction2(4)"") { newInlineFunction2InOpenClass(oc, 4) }"
"fun useUnit(fn: () -> Unit) {
    fn.invoke()
}

var cInit = false

class C {
    init {
        cInit = true
    }
}

var cWithDefaultInit = false

class CWithDefault(x: Int = 1) {
    init {
        cWithDefaultInit = true
    }
}

var cWithVarargInit = false",class CWithVararg(vararg x: Int) {
"class A<T>

class B<T1, T2>

class C {","fun foo<caret>() = object : B<String, A<Unknown>> {"
") {
            with(KotlinTypeMapper) {
                val parameters = parameterSymbols.map { ConeTypeParameterLookupTag(it) }
                typeContext.writeGenericArguments(sw, arguments, parameters, mode) { type, sw, mode ->
                    mapType(type as ConeKotlinType, mode, sw)
                }
            }
        }

        private fun writeInnerParts(
            innerTypesAsList: List<PossiblyInnerConeType>,
            sw: JvmSignatureWriter,
            mode: TypeMappingMode,
            index: Int
        ) {
            for (innerPart in innerTypesAsList.subList(index, innerTypesAsList.size)) {
                sw.writeInnerClass(getJvmShortName(innerPart.classifier?.classId ?: NON_EXISTENT_ID))
                writeGenericArguments(sw, innerPart, mode)
            }
        }
    }

    private class PossiblyInnerConeType(
        val classifier: FirRegularClassSymbol?,
        val arguments: List<ConeTypeProjection>,
        private val outerType: PossiblyInnerConeType?
    ) {
        fun segments(): List<PossiblyInnerConeType> = outerType?.segments().orEmpty() + this
    }

    internal fun getJvmShortName(classId: ClassId): String {
        val result = runUnless(classId.isLocal) {
            classId.asSingleFqName().toUnsafe().let { JavaToKotlinClassMap.mapKotlinToJava(it)?.shortClassName?.asString() }
        }
        return result ?: safeShortClassName(classId)
    }

    private fun safeShortClassName(classId: ClassId): String {
        return SpecialNames.safeIdentifier(classId.shortClassName).identifier
    }
}

val FirSession.jvmTypeMapper: FirJvmTypeMapper by FirSession.sessionComponentAccessor()

class ConeTypeSystemCommonBackendContextForTypeMapping(
    val context: ConeTypeContext,
    val unresolvedQualifierRemapper: (String) -> String?
) : TypeSystemCommonBackendContext by context, TypeSystemCommonBackendContextForTypeMapping {
    private val session = context.session
    private val symbolProvider = session.symbolProvider

    override fun TypeConstructorMarker.isTypeParameter(): Boolean {
        return this is ConeTypeParameterLookupTag
    }

    override fun TypeConstructorMarker.asTypeParameter(): TypeParameterMarker {
        require(isTypeParameter())
        return this as ConeTypeParameterLookupTag
    }

    override fun TypeConstructorMarker.defaultType(): ConeSimpleKotlinType {
        require(this is ConeClassifierLookupTag)
        return when (this) {
            is ConeTypeParameterLookupTag -> ConeTypeParameterTypeImpl(this, isNullable = false)
            is ConeClassLikeLookupTag -> {",val symbol = toSymbol(session) as? FirRegularClassSymbol
"package foo.bar

/*p:<root>(JavaClass)*/import JavaClass
/*p:foo(KotlinClass)*/import foo.KotlinClass

/*p:foo.bar*/fun test() {
    val j = /*p:<root>*/JavaClass()
    val k = /*p:foo*/KotlinClass()

    /*p:<root>(JavaClass)*/j./*p:JavaClass*/getFoo()
    /*p:<root>(JavaClass)*/j./*p:JavaClass p:JavaClass(getSETFoo) p:JavaClass(getSetFoo) p:foo.bar p:java.lang p:kotlin p:kotlin.annotation p:kotlin.collections p:kotlin.comparisons p:kotlin.io p:kotlin.jvm p:kotlin.ranges p:kotlin.sequences p:kotlin.text*/setFoo(2)
    /*p:<root>(JavaClass)*/j./*p:JavaClass p:JavaClass(getFOO) p:JavaClass(getFoo) p:JavaClass(setFoo)*/foo = 2
    /*p:<root>(JavaClass)*/j./*p:JavaClass p:JavaClass(getFOO) p:JavaClass(getFoo) p:JavaClass(setFoo)*/foo
    /*p:<root>(JavaClass)*/j./*p:JavaClass p:JavaClass(getBAR) p:JavaClass(getBar) p:JavaClass(setBar)*/bar
    /*p:<root>(JavaClass)*/j./*p:JavaClass p:JavaClass(getBAR) p:JavaClass(getBar) p:JavaClass(setBar)*/bar = """"",/*p:<root>(JavaClass)*/j./*p:JavaClass p:JavaClass(getBAZBaz) p:JavaClass(getBazBaz) p:foo.bar p:java.lang p:kotlin p:kotlin.annotation p:kotlin.collections p:kotlin.comparisons p:kotlin.io p:kotlin.jvm p:kotlin.ranges p:kotlin.sequences p:kotlin.text*/bazBaz
"// !LANGUAGE: +IntrinsicConstEvaluation
// DONT_TARGET_EXACT_BACKEND: JVM
// DONT_TARGET_EXACT_BACKEND: JS

fun <T> T.id() = this","var result = ""OK"""
"// TODO generate better name for set parameter `<set-?>`?
        declaration.getter?.printAccessor(""get"", declaration)
        declaration.setter?.printAccessor(""set"", declaration)

        p.popIndent()
        p.printlnWithNoIndent()
    }

    private fun IrSimpleFunction.printAccessor(s: String, property: IrDeclaration) {
        val isDefaultAccessor = origin != IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR
        printSimpleFunction(
            property,
            keyword = """",
            name = s,
            printTypeParametersAndExtensionReceiver = false,
            printSignatureAndBody = isDefaultAccessor,
            printExtraTrailingNewLine = false,
        )
    }

    override fun visitField(declaration: IrField, data: IrDeclaration?) = wrap(declaration, data) {
        declaration.printlnAnnotations()
        p.printIndent()

        declaration.run {
            printModifiersWithNoIndent(
                this,
                Modifiers(
                    visibility = visibility,
                    isExternal = isExternal,
                ),
            )
        }

        if (declaration.isStatic || declaration.isFinal) {
            // it's not valid kotlin unless it's commented
            p.printWithNoIndent(CUSTOM_MODIFIER_START)
            p(declaration.isStatic, ""static"")
            p(declaration.isFinal, ""final"")
            p.printWithNoIndent(""field"")
            p.printWithNoIndent(CUSTOM_MODIFIER_END)
            p.printWithNoIndent("" "")
        }

        p.printWithNoIndent(if (declaration.isFinal) ""val "" else ""var "")
        p.printWithNoIndent(declaration.name.asString() + "": "")
        declaration.type.printTypeWithNoIndent()

        declaration.initializer?.let {
            if (options.bodyPrintingStrategy == BodyPrintingStrategy.PRINT_BODIES) {
                p.printWithNoIndent("" = "")
            }
            it.accept(this, declaration)
        }

        // TODO correspondingPropertySymbol

        p.printlnWithNoIndent()
    }

    override fun visitVariable(declaration: IrVariable, data: IrDeclaration?) = wrap(declaration, data) {
        declaration.printlnAnnotations()
        p.printIndent()

        p(declaration.isLateinit, ""lateinit"")","p(declaration.isConst, ""const"")"
"// SKIP_INLINE_CHECK_IN: inlineFun$default
// FILE: 1.kt
package test

class A(val value: String) {
    fun ok() = value
}

inline fun inlineFun(a: A, lambda: () -> String = a::ok): String {
    return lambda()
}

// FILE: 2.kt

import test.*",fun box(): String {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""FunctionName"", ""DuplicatedCode"")

package org.jetbrains.kotlin.gradle.unitTests

import org.gradle.api.internal.project.ProjectInternal
import org.gradle.testfixtures.ProjectBuilder
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeCompilation
import org.jetbrains.kotlin.gradle.targets.native.internal.cInteropCommonizationEnabled
import org.jetbrains.kotlin.gradle.targets.native.internal.copyCommonizeCInteropForIdeTask
import org.jetbrains.kotlin.gradle.util.*
import kotlin.test.*

class CommonizerTaskTests {

    private val rootProject = ProjectBuilder.builder().build() as ProjectInternal
    private val subproject = ProjectBuilder.builder().withName(""subproject"").withParent(rootProject).build() as ProjectInternal

    companion object {
        const val JVM_ECOSYSTEM_PLUGIN_ID = ""jvm-ecosystem""
    }

    init {
        subproject.applyMultiplatformPlugin().apply {
            linuxX64()
            linuxArm64()

            targets.flatMap { it.compilations }
                .filterIsInstance<KotlinNativeCompilation>()
                .forEach { compilation -> compilation.cinterops.create(""dummy"") }
        }

        rootProject.enableCInteropCommonization()
        subproject.enableCInteropCommonization()

        rootProject.evaluate()
        subproject.evaluate()
    }

    @Test
    fun `test runCommonizer task`() {
        subproject.tasks.getByName(""runCommonizer"")
            .assertDependsOn(subproject.tasks.getByName(""commonize""))

        /*
        Since commonizing the native distribution is done on the root project,
        we can also expect that the umbrella tasks are present there as well!
         */
        rootProject.tasks.getByName(""runCommonizer"")
            .assertDependsOn(rootProject.tasks.getByName(""commonize""))
    }

    @Test
    fun `test commonizeNativeDistributionTask`() {
        val commonizeNativeDistributionTaskName = ""commonizeNativeDistribution""
        subproject.assertContainsNoTaskWithName(commonizeNativeDistributionTaskName)

        /* Native Distribution Commonization is only done on the root project */",val rootProjectCommonizeNativeDistributionTask = rootProject.assertContainsTaskWithName(commonizeNativeDistributionTaskName)
"// FILE: main.kt
package test

import dependency.JavaInterface
import dependency.JavaInterface.Nested

class Foo : JavaInterface {
    <expr>val prop: JavaInterface.Nested = JavaInterface.Nested()</expr>
}

// FILE: dependency/JavaInterface.java",package dependency;
"*
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.resolve.jvm.platform

import org.jetbrains.kotlin.load.java.lazy.types.RawTypeImpl
import org.jetbrains.kotlin.psi.KtExpression
import org.jetbrains.kotlin.resolve.calls.checkers.AdditionalTypeChecker
import org.jetbrains.kotlin.resolve.calls.context.ResolutionContext
import org.jetbrains.kotlin.resolve.jvm.diagnostics.ErrorsJvm
import org.jetbrains.kotlin.types.*
import org.jetbrains.kotlin.types.error.ErrorUtils
import org.jetbrains.kotlin.types.checker.KotlinTypeChecker
import org.jetbrains.kotlin.types.checker.TypeCheckingProcedure

object JavaGenericVarianceViolationTypeChecker : AdditionalTypeChecker {
    // Prohibits covariant type argument conversions `List<String> -> (MutableList<Any>..List<Any>)` when expected type's lower bound is invariant.
    // It's needed to prevent accident unsafe covariant conversions of mutable collections.
    //
    // Example:
    // class JavaClass { static void fillWithDefaultObjects(List<Object> list); // add Object's to list }
    //
    // val x: MutableList<String>
    // JavaClass.fillWithDefaultObjects(x) // using `x` after this call may lead to CCE
    override fun checkType(
            expression: KtExpression,
            expressionType: KotlinType,
            expressionTypeWithSmartCast: KotlinType,
            c: ResolutionContext<*>
    ) {
        val expectedType = c.expectedType
        if (TypeUtils.noExpectedType(expectedType) || ErrorUtils.containsErrorType(expectedType) || ErrorUtils.containsUninferredTypeVariable(expectedType)) return

        // optimization: if no arguments or flexibility, everything is OK
        if (expectedType.arguments.isEmpty() || !expectedType.isFlexible()) return

        val lowerBound = expectedType.asFlexibleType().lowerBound
        val upperBound = expectedType.asFlexibleType().upperBound

        // Use site variance projection is always the same for flexible types
        if (lowerBound.constructor == upperBound.constructor) return
        // Anything is acceptable for raw types
        if (expectedType.unwrap() is RawTypeImpl) return

        val correspondingSubType = TypeCheckingProcedure.findCorrespondingSupertype(expressionTypeWithSmartCast, lowerBound) ?: return

        assert(lowerBound.arguments.size == upperBound.arguments.size) {
            ""Different arguments count in flexible bounds: "" +
            ""($lowerBound(${lowerBound.arguments.size})..$upperBound(${upperBound.arguments.size})""
        }

        assert(lowerBound.arguments.size == correspondingSubType.arguments.size) {
            ""Different arguments count in corresponding subtype and supertype: "" +
            ""($lowerBound(${lowerBound.arguments.size})..$correspondingSubType(${correspondingSubType.arguments.size})""
        }


        val lowerParameters = lowerBound.constructor.parameters",val upperParameters = upperBound.constructor.parameters
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.lazy

import com.intellij.openapi.project.Project
import com.intellij.psi.search.GlobalSearchScope
import org.jetbrains.kotlin.TestsCompiletimeError
import org.jetbrains.kotlin.analyzer.AnalysisResult
import org.jetbrains.kotlin.cli.jvm.compiler.CliBindingTrace
import org.jetbrains.kotlin.cli.jvm.compiler.KotlinCoreEnvironment
import org.jetbrains.kotlin.cli.jvm.compiler.NoScopeRecordCliBindingTrace
import org.jetbrains.kotlin.cli.jvm.compiler.TopDownAnalyzerFacadeForJVM
import org.jetbrains.kotlin.config.CompilerConfiguration
import org.jetbrains.kotlin.container.ComponentProvider
import org.jetbrains.kotlin.library.KotlinLibrary
import org.jetbrains.kotlin.load.kotlin.PackagePartProvider
import org.jetbrains.kotlin.psi.KtFile",import org.jetbrains.kotlin.resolve.AnalyzingUtils
"visitScript(declaration)

    open fun visitSimpleFunction(declaration: IrSimpleFunction): IrStatement =
        visitFunction(declaration)

    final override fun visitSimpleFunction(declaration: IrSimpleFunction, data: Nothing?): IrStatement =
        visitSimpleFunction(declaration)

    open fun visitTypeAlias(declaration: IrTypeAlias): IrStatement =
        visitDeclaration(declaration)

    final override fun visitTypeAlias(declaration: IrTypeAlias, data: Nothing?): IrStatement =
        visitTypeAlias(declaration)

    open fun visitVariable(declaration: IrVariable): IrStatement =
        visitDeclaration(declaration)

    final override fun visitVariable(declaration: IrVariable, data: Nothing?): IrStatement =
        visitVariable(declaration)

    open fun visitPackageFragment(declaration: IrPackageFragment): IrPackageFragment {
        declaration.transformChildren(this, null)
        return declaration
    }

    final override fun visitPackageFragment(declaration: IrPackageFragment, data: Nothing?): IrElement =
        visitPackageFragment(declaration)

    open fun visitExternalPackageFragment(declaration: IrExternalPackageFragment): IrExternalPackageFragment =
        visitPackageFragment(declaration) as IrExternalPackageFragment

    final override fun visitExternalPackageFragment(declaration: IrExternalPackageFragment, data: Nothing?): IrExternalPackageFragment =
        visitExternalPackageFragment(declaration)

    open fun visitFile(declaration: IrFile): IrFile =
        visitPackageFragment(declaration) as IrFile

    final override fun visitFile(declaration: IrFile, data: Nothing?): IrFile =
        visitFile(declaration)

    open fun visitExpression(expression: IrExpression): IrExpression {
        expression.transformChildren(this, null)
        return expression
    }

    final override fun visitExpression(expression: IrExpression, data: Nothing?): IrExpression =
        visitExpression(expression)

    open fun visitBody(body: IrBody): IrBody {
        body.transformChildren(this, null)
        return body
    }

    final override fun visitBody(body: IrBody, data: Nothing?): IrBody =
        visitBody(body)

    open fun visitExpressionBody(body: IrExpressionBody): IrBody =
        visitBody(body)

    final override fun visitExpressionBody(body: IrExpressionBody, data: Nothing?): IrBody =
        visitExpressionBody(body)

    open fun visitBlockBody(body: IrBlockBody): IrBody =
        visitBody(body)","final override fun visitBlockBody(body: IrBlockBody, data: Nothing?): IrBody ="
"// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect
// !OPT_IN: kotlin.contracts.ExperimentalContracts
// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER

import kotlin.contracts.*

fun nullWhenNull(x: Int?): Int? {
    contract {",returnsNotNull() implies (x != null)
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.decompiler.stub

import com.intellij.psi.stubs.StubElement
import org.jetbrains.kotlin.metadata.ProtoBuf
import org.jetbrains.kotlin.psi.KtContextReceiverList
import org.jetbrains.kotlin.psi.stubs.elements.KtStubElementTypes
import org.jetbrains.kotlin.psi.stubs.impl.KotlinContextReceiverStubImpl",import org.jetbrains.kotlin.psi.stubs.impl.KotlinPlaceHolderStubImpl
"// SKIP_TXT
// ISSUE: KT-33917

class Inv<T>(val value: T)

private inline fun foo10(crossinline f: () -> Int) = object {
    fun bar(): Int = f()
}

private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo11<!>(crossinline f: () -> Int) = Inv(object {
    fun bar(): Int = f()
})

private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo12<!>(crossinline f: () -> Int) = Inv(Inv(object {
    fun bar(): Int = f()
}))

interface I1
interface I2

private inline fun foo20(crossinline f: () -> Int) = object : I1 {
    fun bar(): Int = f()
}

private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo21<!>(crossinline f: () -> Int) = Inv(object : I1 {
    fun bar(): Int = f()
})

private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo22<!>(crossinline f: () -> Int) = Inv(Inv(object : I1 {
    fun bar(): Int = f()
}))

<!AMBIGUOUS_ANONYMOUS_TYPE_INFERRED!>private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo30<!>(crossinline f: () -> Int)<!> = object : I1, I2 {
    fun bar(): Int = f()
}

private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo31<!>(crossinline f: () -> Int) = Inv(object : I1, I2 {
    fun bar(): Int = f()
})

private inline fun <!PRIVATE_INLINE_FUNCTIONS_RETURNING_ANONYMOUS_OBJECTS!>foo32<!>(crossinline f: () -> Int) = Inv(Inv(object : I1, I2 {
    fun bar(): Int = f()
}))

private fun foo40(f: () -> Int) = object {
    fun bar(): Int = f()
}

private fun foo41(f: () -> Int) = Inv(object {
    fun bar(): Int = f()
})

private fun foo42(f: () -> Int) = Inv(Inv(object {
    fun bar(): Int = f()
}))

// ------------------------------------------------------------------------------------------------",fun test10(b: Boolean) {
"}
                    }
                    return
                }
                is KtProperty -> {
                    // NOTE: since we're explicitly going down a different branch for
                    // KtPropertyAccessor, the ONLY time we make it into this branch is when the
                    // call was done in the initializer of the property/variable.
                    val descriptor = bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, node]

                    if (resolvedCall.isComposableDelegateOperator()) {
                        // The call is initializer for fields like `val foo by composableDelegate()`.
                        // Creating the property doesn't have any requirements from Compose side,
                        // we will recheck on the property call site instead.
                        if (
                            descriptor is VariableDescriptorWithAccessors &&
                                descriptor.isDelegated
                        ) {
                            if (descriptor.isVar) {
                                // setValue delegate is not allowed for now.
                                illegalComposableDelegate(context, reportOn)
                            }
                            if (descriptor is PropertyDescriptor &&
                                descriptor.getter?.hasComposableAnnotation() != true) {
                                composableExpected(context, node.nameIdentifier ?: node)
                            }
                            return
                        }
                    }

                    if (
                        descriptor !is LocalVariableDescriptor &&
                        node.annotationEntries.hasComposableAnnotation(bindingContext)
                    ) {
                        // composables shouldn't have initializers in the first place
                        illegalCall(context, reportOn)
                        return
                    }
                }
                is KtPropertyAccessor -> {
                    val property = node.property
                    val isComposable = node
                        .annotationEntries.hasComposableAnnotation(bindingContext)
                    if (!isComposable) {
                        illegalCall(context, reportOn, property.nameIdentifier ?: property)
                    }
                    val descriptor = bindingContext[BindingContext.PROPERTY_ACCESSOR, node]
                        ?: return
                    if (descriptor.hasReadonlyComposableAnnotation()) {
                        // enforce that the original call was readonly
                        if (!resolvedCall.isReadOnlyComposableInvocation()) {
                            illegalCallMustBeReadonly(
                                context,
                                reportOn
                            )
                        }
                    }
                    return
                }
                is KtCallableReferenceExpression -> {
                    illegalComposableFunctionReference(context, node)
                    return
                }
                is KtFile -> {
                    // if we've made it this far, the call was made in a non-composable context.","illegalCall(context, reportOn)"
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.js.test.converters.incremental

import org.jetbrains.kotlin.js.test.converters.ClassicJsBackendFacade
import org.jetbrains.kotlin.js.test.utils.jsClassicIncrementalDataProvider
import org.jetbrains.kotlin.test.Constructor
import org.jetbrains.kotlin.test.TargetBackend
import org.jetbrains.kotlin.test.backend.classic.ClassicBackendInput
import org.jetbrains.kotlin.test.builders.TestConfigurationBuilder
import org.jetbrains.kotlin.test.directives.JsEnvironmentConfigurationDirectives.RECOMPILE
import org.jetbrains.kotlin.test.model.Frontend2BackendConverter
import org.jetbrains.kotlin.test.model.FrontendFacade
import org.jetbrains.kotlin.test.model.ResultingArtifact
import org.jetbrains.kotlin.test.model.TestModule
import org.jetbrains.kotlin.test.services.TestServices
import java.io.File

@Suppress(""warnings"")
class RecompileModuleJsBackendFacade<R : ResultingArtifact.FrontendOutput<R>>(
    testServices: TestServices,
    private val frontendFacade: Constructor<FrontendFacade<R>>,
    private val frontend2BackendConverter: Constructor<Frontend2BackendConverter<R, ClassicBackendInput>>
) : CommonRecompileModuleJsBackendFacade<R, ClassicBackendInput>(testServices, TargetBackend.JS) {
    override fun TestConfigurationBuilder.configure(module: TestModule) {
        facadeStep(frontendFacade)
        facadeStep(frontend2BackendConverter)
        facadeStep { ClassicJsBackendFacade(it, incrementalCompilationEnabled = true) }
    }",override fun TestServices.register(module: TestModule) {
"fun x(): Boolean { return true }

public fun foo(pp: Any): Int {
    var p = pp
    while(true) {
        (p as String).length
        if (x()) break",p = 42
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"")

package org.jetbrains.kotlin.fir.expressions.impl

import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.FirImplementationDetail
import org.jetbrains.kotlin.fir.MutableOrEmptyList
import org.jetbrains.kotlin.fir.builder.toMutableOrEmpty
import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.expressions.FirExpression",import org.jetbrains.kotlin.fir.expressions.UnresolvedExpressionTypeAccess
"return single
            """"""
        }
        body(CharSequences) {
            """"""
            return if (length == 1) this[0] else null
            """"""
        }
        body(Lists, ArraysOfObjects, ArraysOfPrimitives, ArraysOfUnsigned) {
            """"""
            return if (size == 1) this[0] else null
            """"""
        }
    }

    val f_single_predicate = fn(""single(predicate: (T) -> Boolean)"") {
        includeDefault()
        include(CharSequences, ArraysOfUnsigned)
    } builder {
        inline()
        specialFor(ArraysOfUnsigned) { inlineOnly() }

        doc { ""Returns the single ${f.element} matching the given [predicate], or throws exception if there is no or more than one matching ${f.element}."" }
        returns(""T"")

        body {
            """"""
            var single: T? = null
            var found = false
            for (element in this) {
                if (predicate(element)) {
                    if (found) throw IllegalArgumentException(""${f.doc.collection.capitalize()} contains more than one matching element."")
                    single = element
                    found = true
                }
            }
            if (!found) throw NoSuchElementException(""${f.doc.collection.capitalize()} contains no ${f.doc.element} matching the predicate."")
            @Suppress(""UNCHECKED_CAST"")
            return single as T
            """"""
        }
    }

    val f_singleOrNull_predicate = fn(""singleOrNull(predicate: (T) -> Boolean)"") {
        includeDefault()
        include(CharSequences, ArraysOfUnsigned)
    } builder {
        inline()
        specialFor(ArraysOfUnsigned) { inlineOnly() }

        doc { ""Returns the single ${f.element} matching the given [predicate], or `null` if ${f.element} was not found or more than one ${f.element} was found."" }
        returns(""T?"")

        body {
            """"""
            var single: T? = null
            var found = false
            for (element in this) {
                if (predicate(element)) {
                    if (found) return null
                    single = element
                    found = true
                }
            }
            if (!found) return null",return single
"if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableT()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableAny()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.equals(null)

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propT

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propAny

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableT

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableAny

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funT()

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funAny()

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableT()

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableAny()
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.equals(null)
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.propT
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.propAny
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.propNullableT
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.propNullableAny
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.funT()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.funAny()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.funNullableT()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.funNullableAny()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.equals(null)
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propT
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propAny
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableT
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableAny
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funT()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funAny()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableT()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableAny()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.equals(null)
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.propT
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.propAny
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.propNullableT
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.propNullableAny
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.funT()
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.funAny()
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.funNullableT()
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.funNullableAny()
        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.equals(null)
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propT
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propAny
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableT
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableAny
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funT()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funAny()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableT()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableAny()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.equals(null)
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.propT
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit""), DEBUG_INFO_SMARTCAST!>this.y<!>.propAny","if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>this.y<!>.propNullableT"
"// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER
// MODULE: m1
// FILE: a.kt

package p

public interface A<T>
public interface C
public interface D<T>
public class B : A<Int>, C, D<Int>
public class M1 {",public val b: B = B()
"<!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.equals(null)
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.propT
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!><!UNSAFE_CALL!>.<!>propAny
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.propNullableT
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.propNullableAny
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.funT()
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!><!UNSAFE_CALL!>.<!>funAny()
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.funNullableT()
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect? /* = kotlin.String? */"")!>x<!>.funNullableAny()
                }
            }
        }
    }
}

// TESTCASE NUMBER: 12
fun case_12(x: TypealiasNullableStringIndirect, y: TypealiasNullableStringIndirect) =
    if (<!DEPRECATED_IDENTITY_EQUALS!><!USELESS_IS_CHECK!>(x == null) !is Boolean<!> === false<!>) ""1""
    else if (<!USELESS_IS_CHECK!>(<!SENSELESS_COMPARISON!>y === null !== null<!>) is Boolean<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.equals(null)
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.propT
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!><!UNSAFE_CALL!>.<!>propAny
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.propNullableT
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.propNullableAny
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.funT()
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!><!UNSAFE_CALL!>.<!>funAny()
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.funNullableT()
    else if (<!SENSELESS_COMPARISON!>y === null != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableStringIndirect /* = kotlin.String? */"")!>x<!>.funNullableAny()
    else ""-1""

// TESTCASE NUMBER: 13
fun <!IMPLICIT_NOTHING_RETURN_TYPE!>case_13<!>(x: <!UNRESOLVED_REFERENCE!>otherpackage<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>Case13<!>?) =
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Nothing"")!>if (<!DEPRECATED_IDENTITY_EQUALS!>(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>==<!> <!USELESS_IS_CHECK!>null !is Boolean<!>) !== true<!>) {
        throw Exception()
    } else {
        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Unresolved type for otherpackage.Case13]?"")!>x<!>
        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Unresolved type for otherpackage.Case13]?"")!>x<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>equals<!>(<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!>)
    }<!>

// TESTCASE NUMBER: 14
class Case14 {
    val x: <!UNRESOLVED_REFERENCE!>otherpackage<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>Case14<!>?
    init {
        <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> = <!UNRESOLVED_REFERENCE!>otherpackage<!>.<!DEBUG_INFO_MISSING_UNRESOLVED!>Case14<!>()
    }
}

@Suppress(""UNREACHABLE_CODE"")
fun case_14() {
    val a = Case14()

    if (a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> <!USELESS_IS_CHECK!><!USELESS_IS_CHECK!>null !is Boolean<!> !is Boolean<!>) {
        if (a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null == true) {
            if (a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> !== null == false) {
                if (<!SENSELESS_COMPARISON!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null == null<!>) {
                    if (<!SENSELESS_COMPARISON!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null !== null<!>) {
                        if (<!DEPRECATED_IDENTITY_EQUALS!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null === true<!>) {
                            if (<!DEPRECATED_IDENTITY_EQUALS!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> !== null === <!USELESS_IS_CHECK!>true !is Boolean<!><!> == true) {
                                if (<!DEPRECATED_IDENTITY_EQUALS!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null !== false<!>) {
                                    if (<!DEPRECATED_IDENTITY_EQUALS!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null === false<!>) {
                                        if (<!DEPRECATED_IDENTITY_EQUALS!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> !== null === true<!>) {
                                            if (<!USELESS_IS_CHECK!>(a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> null != true) !is Boolean<!>) {
                                                if (a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> <!USELESS_IS_CHECK!>null is Boolean<!>) {
                                                    if (a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> <!USELESS_IS_CHECK!><!USELESS_IS_CHECK!>null is Boolean<!> is Boolean<!>) {
                                                        if (<!IMPLICIT_BOXING_IN_IDENTITY_EQUALS!>a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> !== <!USELESS_IS_CHECK!>null is Boolean<!><!>) {",if (a.<!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>x<!> <!DEBUG_INFO_MISSING_UNRESOLVED!>!=<!> <!USELESS_IS_CHECK!>null is Boolean<!>) {
"val functionReturnType = LlvmRetType(llvm.int8PtrType)
        val functionParameterTypes = listOf(LlvmParamType(llvm.int8PtrType), LlvmParamType(llvm.int8PtrType))

        val normalMessenger = codegen.llvm.externalNativeRuntimeFunction(
                ""objc_msgSend$messengerNameSuffix"",
                functionReturnType,
                functionParameterTypes,
                isVararg = true
        )
        val superMessenger = codegen.llvm.externalNativeRuntimeFunction(
                ""objc_msgSendSuper$messengerNameSuffix"",
                functionReturnType,
                functionParameterTypes,
                isVararg = true
        )

        val superClass = args.single()
        val messenger = LLVMBuildSelect(builder,
                If = icmpEq(superClass, llvm.kNullInt8Ptr),
                Then = normalMessenger.toConstPointer().llvm,
                Else = superMessenger.toConstPointer().llvm,
                Name = """"
        )!!

        return bitcast(llvm.int8PtrType, messenger)
    }

    private fun FunctionGenerationContext.emitAreEqualByValue(args: List<LLVMValueRef>): LLVMValueRef {
        val (first, second) = args
        assert (first.type == second.type) { ""Types are different: '${llvmtype2string(first.type)}' and '${llvmtype2string(second.type)}'"" }

        return when (val typeKind = LLVMGetTypeKind(first.type)) {
            LLVMTypeKind.LLVMFloatTypeKind, LLVMTypeKind.LLVMDoubleTypeKind,
            LLVMTypeKind.LLVMVectorTypeKind -> {
                // TODO LLVM API does not provide guarantee for LLVMIntTypeInContext availability for longer types; consider meaningful diag message instead of NPE
                val integerType = LLVMIntTypeInContext(llvm.llvmContext, first.type.sizeInBits())!!
                icmpEq(bitcast(integerType, first), bitcast(integerType, second))
            }
            LLVMTypeKind.LLVMIntegerTypeKind, LLVMTypeKind.LLVMPointerTypeKind -> icmpEq(first, second)
            else -> error(typeKind)
        }
    }

    private fun FunctionGenerationContext.emitIeee754Equals(args: List<LLVMValueRef>): LLVMValueRef {
        val (first, second) = args
        assert (first.type == second.type)
                { ""Types are different: '${llvmtype2string(first.type)}' and '${llvmtype2string(second.type)}'"" }
        val type = LLVMGetTypeKind(first.type)
        assert (type == LLVMTypeKind.LLVMFloatTypeKind || type == LLVMTypeKind.LLVMDoubleTypeKind)
                { ""Should be of floating point kind, not: '${llvmtype2string(first.type)}'""}
        return fcmpEq(first, second)
    }

    private fun FunctionGenerationContext.emitReinterpret(callSite: IrCall, args: List<LLVMValueRef>) =
            bitcast(callSite.llvmReturnType, args[0])

    private fun FunctionGenerationContext.emitExtractElement(callSite: IrCall, args: List<LLVMValueRef>): LLVMValueRef {
        val (vector, index) = args
        val elementSize = LLVMSizeOfTypeInBits(codegen.llvmTargetData, callSite.llvmReturnType).toInt()
        val vectorSize = LLVMSizeOfTypeInBits(codegen.llvmTargetData, vector.type).toInt()

        assert(callSite.llvmReturnType.isVectorElementType()
                && vectorSize % elementSize == 0
        ) { ""Invalid vector element type ${LLVMGetTypeKind(callSite.llvmReturnType)}""}",val elementCount = vectorSize / elementSize
"val jsImplFqName = FqName(""${jsInterfaceFqName.asString()}$IMPLEMENTATION_SUFFIX"")
    withPrinterToFile(fileFromFqName(srcDir, jsImplFqName)) {
        generateImpl(
            jsImplFqName,
            commonCompilerImpl,
            jsInterfaceFqName,
            jsOptions
        )
    }

    val k2JsCompilerArgumentsFqName = FqName(K2JSCompilerArguments::class.qualifiedName!!)
    val jsCompilerOptionsHelperFqName = FqName(
        ""${jsInterfaceFqName.asString()}$IMPLEMENTATION_HELPERS_SUFFIX""
    )
    withPrinterToFile(fileFromFqName(srcDir, jsCompilerOptionsHelperFqName)) {
        generateCompilerOptionsHelper(
            jsInterfaceFqName,
            jsCompilerOptionsHelperFqName,
            commonCompilerHelperName,
            k2JsCompilerArgumentsFqName,
            jsOptions
        )
    }
}

private fun generateKotlinNativeOptions(
    apiSrcDir: File,
    commonCompilerOptions: GeneratedOptions,
    withPrinterToFile: (targetFile: File, Printer.() -> Unit) -> Unit
): GeneratedOptions {
    val nativeInterfaceFqName = FqName(""$OPTIONS_PACKAGE_PREFIX.KotlinNativeCompilerOptions"")
    val nativeOptions = gradleOptions<K2NativeCompilerArguments>()
    withPrinterToFile(fileFromFqName(apiSrcDir, nativeInterfaceFqName)) {
        generateInterface(
            nativeInterfaceFqName,
            nativeOptions,
            parentType = commonCompilerOptions.optionsName,
            interfaceKDoc = NATIVE_COMPILER_OPTIONS_KDOC
        )
    }

    println(""\n### Attributes specific for Native\n"")
    generateMarkdown(nativeOptions)

    return GeneratedOptions(nativeInterfaceFqName, null, nativeOptions)
}

private fun generateKotlinNativeOptionsImpl(
    srcDir: File,
    nativeInterfaceFqName: FqName,
    commonCompilerImpl: FqName,
    commonCompilerHelper: FqName,
    nativeOptions: List<KProperty1<*, *>>,
    withPrinterToFile: (targetFile: File, Printer.() -> Unit) -> Unit
) {
    val nativeImplFqName = FqName(""${nativeInterfaceFqName.asString()}$IMPLEMENTATION_SUFFIX"")
    withPrinterToFile(fileFromFqName(srcDir, nativeImplFqName)) {
        generateImpl(
            nativeImplFqName,
            commonCompilerImpl,
            nativeInterfaceFqName,
            nativeOptions
        )
    }",val k2NativeCompilerArgumentsFqName = FqName(K2NativeCompilerArguments::class.qualifiedName!!)
"}

/**
 * Checks if the specified [value] belongs to this range.
 */
@SinceKotlin(""1.5"")
@WasExperimental(ExperimentalUnsignedTypes::class)
public operator fun ULongRange.contains(value: UShort): Boolean {
    return contains(value.toULong())
}

/**
 * Returns a progression from this value down to the specified [to] value with the step -1.
 * 
 * The [to] value should be less than or equal to `this` value.
 * If the [to] value is greater than `this` value the returned progression is empty.
 */
@SinceKotlin(""1.5"")
@WasExperimental(ExperimentalUnsignedTypes::class)
public infix fun UByte.downTo(to: UByte): UIntProgression {
    return UIntProgression.fromClosedRange(this.toUInt(), to.toUInt(), -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the step -1.
 * 
 * The [to] value should be less than or equal to `this` value.
 * If the [to] value is greater than `this` value the returned progression is empty.
 */
@SinceKotlin(""1.5"")
@WasExperimental(ExperimentalUnsignedTypes::class)
public infix fun UInt.downTo(to: UInt): UIntProgression {
    return UIntProgression.fromClosedRange(this, to, -1)
}

/**
 * Returns a progression from this value down to the specified [to] value with the step -1.
 * 
 * The [to] value should be less than or equal to `this` value.
 * If the [to] value is greater than `this` value the returned progression is empty.
 */
@SinceKotlin(""1.5"")
@WasExperimental(ExperimentalUnsignedTypes::class)
public infix fun ULong.downTo(to: ULong): ULongProgression {
    return ULongProgression.fromClosedRange(this, to, -1L)
}

/**
 * Returns a progression from this value down to the specified [to] value with the step -1.
 * 
 * The [to] value should be less than or equal to `this` value.
 * If the [to] value is greater than `this` value the returned progression is empty.
 */
@SinceKotlin(""1.5"")
@WasExperimental(ExperimentalUnsignedTypes::class)
public infix fun UShort.downTo(to: UShort): UIntProgression {
    return UIntProgression.fromClosedRange(this.toUInt(), to.toUInt(), -1)
}

/**
 * Returns a progression that goes over the same range in the opposite direction with the same step.
 */
@SinceKotlin(""1.5"")
@WasExperimental(ExperimentalUnsignedTypes::class)
public fun UIntProgression.reversed(): UIntProgression {","return UIntProgression.fromClosedRange(last, first, -step)"
"set(value) { memberAt<IntVar>(44).value = value }
    
    var isModuleImport: Int
        get() = memberAt<IntVar>(48).value
        set(value) { memberAt<IntVar>(48).value = value }
}

@CNaturalStruct(""file"", ""module"", ""loc"", ""isImplicit"")
class CXIdxImportedASTFileInfo(rawPtr: NativePtr) : CStructVar(rawPtr) {
    
    @Deprecated(""Use sizeOf\u003CT\u003E() or alignOf\u003CT\u003E() instead."", ReplaceWith(""""), DeprecationLevel.WARNING)
    companion object : CStructVar.Type(48, 8)
    
    var file: CXFile?
        get() = memberAt<CXFileVar>(0).value
        set(value) { memberAt<CXFileVar>(0).value = value }
    
    var module: CXModule?
        get() = memberAt<CXModuleVar>(8).value
        set(value) { memberAt<CXModuleVar>(8).value = value }
    
    val loc: CXIdxLoc
        get() = memberAt(16)
    
    var isImplicit: Int
        get() = memberAt<IntVar>(40).value
        set(value) { memberAt<IntVar>(40).value = value }
}

@CNaturalStruct(""kind"", ""cursor"", ""loc"")
class CXIdxAttrInfo(rawPtr: NativePtr) : CStructVar(rawPtr) {
    
    @Deprecated(""Use sizeOf\u003CT\u003E() or alignOf\u003CT\u003E() instead."", ReplaceWith(""""), DeprecationLevel.WARNING)
    companion object : CStructVar.Type(64, 8)
    
    var kind: CXIdxAttrKind
        get() = memberAt<CXIdxAttrKindVar>(0).value
        set(value) { memberAt<CXIdxAttrKindVar>(0).value = value }
    
    val cursor: CXCursor
        get() = memberAt(8)
    
    val loc: CXIdxLoc
        get() = memberAt(40)
}

@CNaturalStruct(""kind"", ""templateKind"", ""lang"", ""name"", ""USR"", ""cursor"", ""attributes"", ""numAttributes"")
class CXIdxEntityInfo(rawPtr: NativePtr) : CStructVar(rawPtr) {
    
    @Deprecated(""Use sizeOf\u003CT\u003E() or alignOf\u003CT\u003E() instead."", ReplaceWith(""""), DeprecationLevel.WARNING)
    companion object : CStructVar.Type(80, 8)
    
    var kind: CXIdxEntityKind
        get() = memberAt<CXIdxEntityKind.Var>(0).value
        set(value) { memberAt<CXIdxEntityKind.Var>(0).value = value }
    
    var templateKind: CXIdxEntityCXXTemplateKind
        get() = memberAt<CXIdxEntityCXXTemplateKindVar>(4).value
        set(value) { memberAt<CXIdxEntityCXXTemplateKindVar>(4).value = value }
    
    var lang: CXIdxEntityLanguage
        get() = memberAt<CXIdxEntityLanguageVar>(8).value
        set(value) { memberAt<CXIdxEntityLanguageVar>(8).value = value }
    
    var name: CPointer<ByteVar>?",get() = memberAt<CPointerVar<ByteVar>>(16).value
"/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress(
    ""unused"",
    ""nothing_to_inline"",
    ""useless_cast"",
    ""unchecked_cast"",
    ""extension_shadowed_by_member"",
    ""redundant_projection"",
    ""RemoveRedundantBackticks"",
    ""ObjectPropertyName"",
    ""deprecation""
)
@file:org.gradle.api.Generated

/* ktlint-disable */

package gradle.kotlin.dsl.accessors._44a939cf26bc074355463a0d554ee592


import org.gradle.api.Action
import org.gradle.api.Incubating
import org.gradle.api.NamedDomainObjectProvider
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurablePublishArtifact
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.Dependency",import org.gradle.api.artifacts.DependencyConstraint
"* having distinct keys returned by the given [selector] function.
 * 
 * The elements in the resulting list are in the same order as they were in the source array.
 * 
 * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy
 */
public inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {
    val set = HashSet<K>()
    val list = ArrayList<Long>()
    for (e in this) {
        val key = selector(e)
        if (set.add(key))
            list.add(e)
    }
    return list
}

/**
 * Returns a list containing only elements from the given array
 * having distinct keys returned by the given [selector] function.
 * 
 * The elements in the resulting list are in the same order as they were in the source array.
 * 
 * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy
 */
public inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {
    val set = HashSet<K>()
    val list = ArrayList<Float>()
    for (e in this) {
        val key = selector(e)
        if (set.add(key))
            list.add(e)
    }
    return list
}

/**
 * Returns a list containing only elements from the given array
 * having distinct keys returned by the given [selector] function.
 * 
 * The elements in the resulting list are in the same order as they were in the source array.
 * 
 * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy
 */
public inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {
    val set = HashSet<K>()
    val list = ArrayList<Double>()
    for (e in this) {
        val key = selector(e)
        if (set.add(key))
            list.add(e)
    }
    return list
}

/**
 * Returns a list containing only elements from the given array
 * having distinct keys returned by the given [selector] function.
 * 
 * The elements in the resulting list are in the same order as they were in the source array.
 * 
 * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy
 */
public inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {
    val set = HashSet<K>()",val list = ArrayList<Boolean>()
"expectMinMaxOf((0u - 1U).toUInt(), (0u - 1U).toUInt(), uintArrayOf(1U), { (0u - it).toUInt() })
        expectMinMaxOf((0u - 2U).toUInt(), (0u - 1U).toUInt(), uintArrayOf(1U, 2U), { (0u - it).toUInt() })
        expectMinMaxOf((0u - UInt.MAX_VALUE).toUInt(), (0u - 1U).toUInt(), uintArrayOf(1U, 2U, UInt.MAX_VALUE), { (0u - it).toUInt() })

    }
    
    @Test
    fun minMaxOfDouble() {
        val middle = 2U
        val items = uintArrayOf(1U, 2U, UInt.MAX_VALUE).apply { shuffle() }
        assertTrue(items.minOf { it.compareTo(middle).toDouble().pow(0.5) }.isNaN())
        assertTrue(items.minOfOrNull { it.compareTo(middle).toDouble().pow(0.5) }!!.isNaN())
        assertTrue(items.maxOf { it.compareTo(middle).toDouble().pow(0.5) }.isNaN())
        assertTrue(items.maxOfOrNull { it.compareTo(middle).toDouble().pow(0.5) }!!.isNaN())
        
        assertIsNegativeZero(items.minOf { it.compareTo(middle) * 0.0 })
        assertIsNegativeZero(items.minOfOrNull { it.compareTo(middle) * 0.0 }!!)
        assertIsPositiveZero(items.maxOf { it.compareTo(middle) * 0.0 })
        assertIsPositiveZero(items.maxOfOrNull { it.compareTo(middle) * 0.0 }!!)
    }
    
    @Test
    fun minMaxOfFloat() {
        val middle = 2U
        val items = uintArrayOf(1U, 2U, UInt.MAX_VALUE).apply { shuffle() }
        assertTrue(items.minOf { it.compareTo(middle).toFloat().pow(0.5F) }.isNaN())
        assertTrue(items.minOfOrNull { it.compareTo(middle).toFloat().pow(0.5F) }!!.isNaN())
        assertTrue(items.maxOf { it.compareTo(middle).toFloat().pow(0.5F) }.isNaN())
        assertTrue(items.maxOfOrNull { it.compareTo(middle).toFloat().pow(0.5F) }!!.isNaN())
        
        assertIsNegativeZero(items.minOf { it.compareTo(middle) * 0.0F }.toDouble())
        assertIsNegativeZero(items.minOfOrNull { it.compareTo(middle) * 0.0F }!!.toDouble())
        assertIsPositiveZero(items.maxOf { it.compareTo(middle) * 0.0F }.toDouble())
        assertIsPositiveZero(items.maxOfOrNull { it.compareTo(middle) * 0.0F }!!.toDouble())
    }
    
    @Test
    fun minMaxOfEmpty() {
        val empty = uintArrayOf()

        assertNull(empty.minOfOrNull { it.toString() })
        assertNull(empty.maxOfOrNull { it.toString() })
        assertFailsWith<NoSuchElementException> { empty.minOf { it.toString() } }
        assertFailsWith<NoSuchElementException> { empty.maxOf { it.toString() } }                       


        assertNull(empty.minOfOrNull { 0.0 })
        assertNull(empty.maxOfOrNull { 0.0 })
        assertFailsWith<NoSuchElementException> { empty.minOf { 0.0 } }
        assertFailsWith<NoSuchElementException> { empty.maxOf { 0.0 } }                       


        assertNull(empty.minOfOrNull { 0.0F })
        assertNull(empty.maxOfOrNull { 0.0F })
        assertFailsWith<NoSuchElementException> { empty.minOf { 0.0F } }
        assertFailsWith<NoSuchElementException> { empty.maxOf { 0.0F } }                       


    }
    
    
    private inline fun <R> expectMinMaxOfWith(min: R, max: R, elements: UIntArray, comparator: Comparator<R>, selector: (UInt) -> R) {
        assertEquals(min, elements.minOfWith(comparator, selector))
        assertEquals(min, elements.minOfWithOrNull(comparator, selector))
        assertEquals(max, elements.maxOfWith(comparator, selector))","assertEquals(max, elements.maxOfWithOrNull(comparator, selector))"
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package org.jetbrains.kotlin.ir.util
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.targets.js.typescript

import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.*
import org.gradle.work.DisableCachingByDefault
import org.gradle.work.NormalizeLineEndings
import org.jetbrains.kotlin.gradle.internal.execWithProgress
import org.jetbrains.kotlin.gradle.targets.js.RequiredKotlinJsDependency
import org.jetbrains.kotlin.gradle.targets.js.ir.KotlinIrJsGeneratedTSValidationStrategy
import org.jetbrains.kotlin.gradle.targets.js.ir.KotlinJsIrCompilation
import org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootPlugin.Companion.kotlinNodeJsExtension
import org.jetbrains.kotlin.gradle.targets.js.npm.RequiresNpmDependencies
import org.jetbrains.kotlin.gradle.targets.js.npm.npmProject
import javax.inject.Inject

@DisableCachingByDefault
abstract class TypeScriptValidationTask
@Inject
constructor(
    @Internal
    @Transient
    override val compilation: KotlinJsIrCompilation
) : DefaultTask(), RequiresNpmDependencies {
    private val npmProject = compilation.npmProject

    @get:Internal
    @Transient
    protected val nodeJs = project.rootProject.kotlinNodeJsExtension",private val versions = nodeJs.versions
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.light.classes.symbol.annotations

import com.intellij.psi.PsiAnnotation
import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.light.classes.symbol.methods.SymbolLightMethodBase
import org.jetbrains.kotlin.load.java.JvmAnnotationNames

internal object MethodAdditionalAnnotationsProvider : AdditionalAnnotationsProvider {
    override fun addAllAnnotations(
        currentRawAnnotations: MutableList<in PsiAnnotation>,
        foundQualifiers: MutableSet<String>,
        owner: PsiElement,
    ) {
        if (owner.parent.isMethodWithOverride()) {
            addSimpleAnnotationIfMissing(JvmAnnotationNames.OVERRIDE_ANNOTATION.asString(), currentRawAnnotations, foundQualifiers, owner)
        }
    }

    override fun findSpecialAnnotation(
        annotationsBox: GranularAnnotationsBox,
        qualifiedName: String,
        owner: PsiElement,
    ): PsiAnnotation? = if (owner.parent.isMethodWithOverride())
        createSimpleAnnotationIfMatches(
            qualifier = qualifiedName,
            expectedQualifier = JvmAnnotationNames.OVERRIDE_ANNOTATION.asString(),
            owner = owner,
        )",else
"* 
 * Note that `acc` value passed to [operation] function should not be mutated;
 * otherwise it would affect the previous value in resulting list.
 * 
 * @param [operation] function that takes the index of an element, current accumulator value
 * and the element itself, and calculates the next accumulator value.
 * 
 * @sample samples.collections.Collections.Aggregates.scan
 */
@SinceKotlin(""1.4"")
@kotlin.internal.InlineOnly
public inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {
    return runningFoldIndexed(initial, operation)
}

/**
 * Returns a list containing successive accumulation values generated by applying [operation] from left to right
 * to each element, its index in the original array and current accumulator value that starts with [initial] value.
 * 
 * Note that `acc` value passed to [operation] function should not be mutated;
 * otherwise it would affect the previous value in resulting list.
 * 
 * @param [operation] function that takes the index of an element, current accumulator value
 * and the element itself, and calculates the next accumulator value.
 * 
 * @sample samples.collections.Collections.Aggregates.scan
 */
@SinceKotlin(""1.4"")
@kotlin.internal.InlineOnly
public inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {
    return runningFoldIndexed(initial, operation)
}

/**
 * Returns a list containing successive accumulation values generated by applying [operation] from left to right
 * to each element, its index in the original array and current accumulator value that starts with [initial] value.
 * 
 * Note that `acc` value passed to [operation] function should not be mutated;
 * otherwise it would affect the previous value in resulting list.
 * 
 * @param [operation] function that takes the index of an element, current accumulator value
 * and the element itself, and calculates the next accumulator value.
 * 
 * @sample samples.collections.Collections.Aggregates.scan
 */
@SinceKotlin(""1.4"")
@kotlin.internal.InlineOnly
public inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {
    return runningFoldIndexed(initial, operation)
}

/**
 * Returns a list containing successive accumulation values generated by applying [operation] from left to right
 * to each element, its index in the original array and current accumulator value that starts with [initial] value.
 * 
 * Note that `acc` value passed to [operation] function should not be mutated;
 * otherwise it would affect the previous value in resulting list.
 * 
 * @param [operation] function that takes the index of an element, current accumulator value
 * and the element itself, and calculates the next accumulator value.
 * 
 * @sample samples.collections.Collections.Aggregates.scan
 */
@SinceKotlin(""1.4"")
@kotlin.internal.InlineOnly","public inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {"
"// Binds comments on the same line
object TrailingCommentsBinder : WhitespacesAndCommentsBinder {
    override fun getEdgePosition(
        tokens: List<IElementType>, atStreamEdge: Boolean, getter: WhitespacesAndCommentsBinder.TokenTextGetter
    ): Int {
        if (tokens.isEmpty()) return 0

        var result = 0
        tokens@ for (idx in tokens.indices) {
            val tokenType = tokens[idx]
            when (tokenType) {
                KtTokens.WHITE_SPACE -> if (StringUtil.containsLineBreak(getter[idx])) break@tokens

                KtTokens.EOL_COMMENT, KtTokens.BLOCK_COMMENT -> result = idx + 1

                else -> break@tokens
            }
        }

        return result
    }
}

private class AllCommentsBinder(val isTrailing: Boolean) : WhitespacesAndCommentsBinder {
    override fun getEdgePosition(
        tokens: List<IElementType>, atStreamEdge: Boolean, getter: WhitespacesAndCommentsBinder.TokenTextGetter
    ): Int {
        if (tokens.isEmpty()) return 0

        val size = tokens.size

        // Skip one whitespace if needed. Expect that there can't be several consecutive whitespaces
        val endToken = tokens[if (isTrailing) size - 1 else 0]
        val shift = if (endToken == KtTokens.WHITE_SPACE) 1 else 0

        return if (isTrailing) size - shift else shift
    }
}

@JvmField
val PRECEDING_ALL_COMMENTS_BINDER: WhitespacesAndCommentsBinder = AllCommentsBinder(false)

@JvmField
val TRAILING_ALL_COMMENTS_BINDER: WhitespacesAndCommentsBinder = AllCommentsBinder(true)

object DoNotBindAnything : WhitespacesAndCommentsBinder {
    override fun getEdgePosition(
        tokens: List<IElementType>, atStreamEdge: Boolean, getter: WhitespacesAndCommentsBinder.TokenTextGetter
    ): Int {
        return 0
    }
}

object BindFirstShebangWithWhitespaceOnly : WhitespacesAndCommentsBinder {
    override fun getEdgePosition(
        tokens: List<IElementType>, atStreamEdge: Boolean, getter: WhitespacesAndCommentsBinder.TokenTextGetter
    ): Int {
        if (tokens.firstOrNull() == KtTokens.SHEBANG_COMMENT) {
            return if (tokens.getOrNull(1) == KtTokens.WHITE_SPACE) 2 else 1
        }

        return 0
    }
}",class BindAll(val isTrailing: Boolean) : WhitespacesAndCommentsBinder {
"<!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.compareTo(it)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.get(0)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.iterator()
        }
    }
}

/*
 * TESTCASE NUMBER: 47
 * ISSUES: KT-28785
 */
fun <T> case_47(x: T?) where T : Inv<T>, T: Comparable<*>?, T: InterfaceWithTypeParameter1<out T>? {
    if (x != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.test()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>x<!>.ip1test1()

        x.equals(null)

        x.propT

        x.propAny

        x.propNullableT

        x.propNullableAny

        x.funT()

        x.funAny()

        x.funNullableT()

        x.funNullableAny()
        x.test()
        x.ip1test1()
        x.apply {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>
            equals(null)
            propT
            propAny
            propNullableT
            propNullableAny
            funT()
            funAny()
            funNullableT()
            funNullableAny()
            test()
            ip1test1()","<!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.equals(null)"
"fun byteArg(b: Byte) {}
fun charArg(c: Char) {}
fun shortArg(s: Short) {}

fun box(): String {
    var b = 42.toByte()
    b++
    ++b
    byteArg(b)

    var c = 'x'
    c++
    ++c
    charArg(c)",var s = 239.toShort()
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer.cli",internal object InputLibrariesOptionType : LibrariesSetOptionType(
"import org.jetbrains.kotlin.fir.declarations.utils.isStatic
import org.jetbrains.kotlin.fir.declarations.utils.modality
import org.jetbrains.kotlin.fir.declarations.utils.visibility
import org.jetbrains.kotlin.fir.symbols.SyntheticSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirSyntheticPropertySymbol
import org.jetbrains.kotlin.fir.symbols.impl.isExtension
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.Name

internal class KtFirSyntheticJavaPropertySymbol(
    override val firSymbol: FirSyntheticPropertySymbol,
    override val analysisSession: KtFirAnalysisSession,
) : KtSyntheticJavaPropertySymbol(), KtFirSymbol<FirSyntheticPropertySymbol> {
    override val psi: PsiElement? by cached { firSymbol.findPsi() }

    override val isVal: Boolean get() = withValidityAssertion { firSymbol.isVal }
    override val name: Name get() = withValidityAssertion { firSymbol.name }

    override val returnType: KtType get() = withValidityAssertion { firSymbol.returnType(builder) }
    override val receiverParameter: KtReceiverParameterSymbol? get() = withValidityAssertion { firSymbol.receiver(builder) }

    override val typeParameters: List<KtTypeParameterSymbol>
        get() = withValidityAssertion { firSymbol.createKtTypeParameters(builder) }


    override val isExtension: Boolean get() = withValidityAssertion { firSymbol.isExtension }

    override val initializer: KtInitializerValue? by cached { firSymbol.getKtConstantInitializer(builder) }

    override val modality: Modality get() = withValidityAssertion { firSymbol.modality }
    override val visibility: Visibility get() = withValidityAssertion { firSymbol.visibility }

    override val annotationsList by cached {
        KtFirAnnotationListForDeclaration.create(firSymbol, builder)
    }

    override val callableIdIfNonLocal: CallableId? get() = withValidityAssertion { firSymbol.getCallableIdIfNonLocal() }

    override val getter: KtPropertyGetterSymbol
        get() = withValidityAssertion {
            builder.callableBuilder.buildGetterSymbol(firSymbol.getterSymbol!!)
        }
    override val javaGetterSymbol: KtFunctionSymbol
        get() = withValidityAssertion {
            val fir = firSymbol.fir as FirSyntheticProperty
            return builder.functionLikeBuilder.buildFunctionSymbol(fir.getter.delegate.symbol)
        }
    override val javaSetterSymbol: KtFunctionSymbol?
        get() = withValidityAssertion {
            val fir = firSymbol.fir as FirSyntheticProperty
            return fir.setter?.delegate?.let { builder.functionLikeBuilder.buildFunctionSymbol(it.symbol) }
        }

    override val setter: KtPropertySetterSymbol?
        get() = withValidityAssertion {
            firSymbol.setterSymbol?.let { builder.callableBuilder.buildPropertyAccessorSymbol(it) } as? KtPropertySetterSymbol
        }

    override val backingFieldSymbol: KtBackingFieldSymbol?
        get() = null

    override val isFromPrimaryConstructor: Boolean get() = withValidityAssertion { false }
    override val isOverride: Boolean get() = withValidityAssertion { firSymbol.isOverride }
    override val isStatic: Boolean get() = withValidityAssertion { firSymbol.isStatic }",override val hasSetter: Boolean get() = withValidityAssertion { firSymbol.setterSymbol != null }
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.declarations

import org.jetbrains.kotlin.GeneratedDeclarationKey
import org.jetbrains.kotlin.fir.declarations.utils.FirScriptCustomizationKind

sealed class FirDeclarationOrigin(
    private val displayName: String? = null,
    val fromSupertypes: Boolean = false,
    val generated: Boolean = false,
    val fromSource: Boolean = false,
    val generatedAnyMethod: Boolean = false,
) {
    object Source : FirDeclarationOrigin(fromSource = true)
    object Library : FirDeclarationOrigin()
    object Precompiled : FirDeclarationOrigin() // currently used for incremental compilation
    object BuiltIns : FirDeclarationOrigin()","sealed class Java(displayName: String, fromSource: Boolean = false) : FirDeclarationOrigin(displayName, fromSource = fromSource) {"
"x.propT

        x.propAny

        x.propNullableT

        x.propNullableAny

        x.funT()

        x.funAny()

        x.funNullableT()

        x.funNullableAny()
        x.ip1test1()
        x.apply {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>
            equals(null)
            propT
            propAny
            propNullableT
            propNullableAny
            funT()
            funAny()
            funNullableT()
            funNullableAny()
            ip1test1()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>this<!>.ip1test1()
        }
        x.also {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T!!"")!>it<!>.ip1test1()
        }
    }
}

// TESTCASE NUMBER: 61
interface Case61_1<T>: InterfaceWithTypeParameter1<T>, Case61_2<T> { fun test1() }
interface Case61_2<T>: InterfaceWithTypeParameter1<T> { fun test2() }

class Case61_3<T>: InterfaceWithTypeParameter1<T>, Case61_1<T>, Case61_2<T> {
    override fun test1() {}
    override fun test2() {}
    fun test4() {}
}","fun <T> T.case_61(x: T) where T : InterfaceWithTypeParameter1<T>?, T: Case61_3<T>?, T: Case61_1<T>?, T: Case61_2<T>? {"
"/*
 * Copyright 2000-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.calls.components

import org.jetbrains.kotlin.builtins.isFunctionTypeOrSubtype
import org.jetbrains.kotlin.config.LanguageFeature
import org.jetbrains.kotlin.config.LanguageVersionSettings
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.descriptors.synthetic.SyntheticMemberDescriptor
import org.jetbrains.kotlin.resolve.calls.components.candidate.CallableReferenceResolutionCandidate
import org.jetbrains.kotlin.resolve.calls.components.candidate.ResolutionCandidate
import org.jetbrains.kotlin.resolve.calls.components.candidate.SimpleResolutionCandidate
import org.jetbrains.kotlin.resolve.calls.inference.NewConstraintSystem
import org.jetbrains.kotlin.resolve.calls.inference.addEqualityConstraintIfCompatible
import org.jetbrains.kotlin.resolve.calls.inference.components.ConstraintSystemCompletionMode
import org.jetbrains.kotlin.resolve.calls.inference.components.KotlinConstraintSystemCompleter
import org.jetbrains.kotlin.resolve.calls.inference.components.NewTypeSubstitutorByConstructorMap
import org.jetbrains.kotlin.resolve.calls.inference.components.TrivialConstraintTypeInferenceOracle
import org.jetbrains.kotlin.resolve.calls.inference.model.ConstraintStorage.Empty.hasContradiction
import org.jetbrains.kotlin.resolve.calls.inference.model.ExpectedTypeConstraintPositionImpl
import org.jetbrains.kotlin.resolve.calls.model.*
import org.jetbrains.kotlin.resolve.calls.tower.CandidateFactory
import org.jetbrains.kotlin.resolve.calls.tower.forceResolution",import org.jetbrains.kotlin.types.TypeUtils
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.checkers.context

import org.jetbrains.kotlin.fir.resolve.SessionHolder
import org.jetbrains.kotlin.fir.resolve.transformers.ReturnTypeCalculator

abstract class AbstractCheckerContext(
    override val sessionHolder: SessionHolder,
    override val returnTypeCalculator: ReturnTypeCalculator,
    override val allInfosSuppressed: Boolean,
    override val allWarningsSuppressed: Boolean,",override val allErrorsSuppressed: Boolean
"is CauseRendering.UsedFromSomewhere -> with(rendering) {
                    if (objectSymbol == rootCause.symbol) {
                        // 'rootCause.symbol' is already mentioned in `rendering.objectText`, so use shorter message
                        objectUses().unacceptableClassifier().via()
                    } else
                        objectUses().subject(capitalized = false).via().append("" that has "").unacceptableClassifier()
                }
            }
        }
    }

    return this
}

private fun Appendable.noDeclarationForSymbol(symbol: IrSymbol): Appendable =
    append(""No "").declarationKind(symbol, capitalized = false).append("" found for symbol "").signature(symbol)

private fun Appendable.declarationWithUnusableClassifier(
    declarationSymbol: IrSymbol,
    cause: Unusable,
    forExpression: Boolean
): Appendable {
    val functionDeclaration = declarationSymbol.owner as? IrFunction
    val functionIsUnusableDueToContainingClass = (functionDeclaration?.parent as? IrClass)?.symbol == cause.symbol

    // The user (object) of the unusable classifier. In case the current declaration is a function with its own parent class being
    // the dispatch receiver, the class is the ""object"".
    val objectSymbol = if (functionIsUnusableDueToContainingClass) cause.symbol else declarationSymbol

    val objectDescription = buildString {
        if (functionIsUnusableDueToContainingClass) {
            // Callable member is unusable due to unusable dispatch receiver.
            val functionIsConstructor = functionDeclaration is IrConstructor

            if (forExpression) {
                if (functionIsConstructor)
                    declarationKindName(objectSymbol, capitalized = true) // ""Class 'Foo'""
                else
                    append(""Dispatch receiver "").declarationKindName(objectSymbol, capitalized = false) // ""Dispatch receiver class 'Foo'""
            } else {
                declarationKindName(objectSymbol, capitalized = true) // ""Class 'Foo'""
                    .append(if (functionIsConstructor) "" created by "" else "", the dispatch receiver of "") // "", the dispatch receiver of""
                    .declarationKindName(declarationSymbol, capitalized = false) // ""function 'foo'""
            }
        } else {
            if (forExpression)
                declarationKind(objectSymbol, capitalized = true) // ""Function""
            else
                declarationKindName(objectSymbol, capitalized = true) // ""Function 'foo'""
        }
    }

    return unusableClassifier(
        cause,
        CauseRendering.UsedFromDeclaration(objectDescription, objectSymbol),
        printIntermediateCause = !functionIsUnusableDueToContainingClass
    )
}

private fun StringBuilder.expressionWithUnusableClassifier(
    expression: IrExpression,
    cause: Unusable
): Appendable = expression(expression) { expressionKind ->
    // Printing the intermediate cause may pollute certain types of error messages. Need to avoid it when possible.",val printIntermediateCause = when {
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.generators.protobuf

import org.jetbrains.kotlin.generators.util.GeneratorsFileUtil
import org.jetbrains.kotlin.library.metadata.DebugKlibMetadataProtoBuf
import org.jetbrains.kotlin.metadata.DebugExtOptionsProtoBuf
import org.jetbrains.kotlin.metadata.DebugProtoBuf
import org.jetbrains.kotlin.metadata.builtins.DebugBuiltInsProtoBuf
import org.jetbrains.kotlin.metadata.java.DebugJavaClassProtoBuf
import org.jetbrains.kotlin.metadata.js.DebugJsProtoBuf
import org.jetbrains.kotlin.metadata.jvm.DebugJvmProtoBuf
import org.jetbrains.kotlin.protobuf.Descriptors
import org.jetbrains.kotlin.utils.Printer
import java.io.File
import java.util.*

class GenerateProtoBufCompare {
    companion object {
        val DEST_FILE: File = File(""build-common/src/org/jetbrains/kotlin/incremental/ProtoCompareGenerated.kt"")

        @JvmStatic
        fun main(args: Array<String>) {
            generate(DEST_FILE)
        }

        fun generate(destFile: File, forbidGenerationOnTeamcity: Boolean = true) {
            GeneratorsFileUtil.writeFileIfContentChanged(
                destFile, GenerateProtoBufCompare().generate(),
                forbidGenerationOnTeamcity = forbidGenerationOnTeamcity
            )
        }
    }

    private val JAVA_TYPES_WITH_INLINED_EQUALS: EnumSet<Descriptors.FieldDescriptor.JavaType> = EnumSet.of(
        Descriptors.FieldDescriptor.JavaType.INT,
        Descriptors.FieldDescriptor.JavaType.LONG,
        Descriptors.FieldDescriptor.JavaType.FLOAT,
        Descriptors.FieldDescriptor.JavaType.DOUBLE,
        Descriptors.FieldDescriptor.JavaType.BOOLEAN,
        Descriptors.FieldDescriptor.JavaType.STRING,
        Descriptors.FieldDescriptor.JavaType.ENUM

    )

    private val RESULT_NAME = ""result""
    private val STRING_INDEXES_NAME = ""StringIndexes""
    private val CLASS_ID_INDEXES_NAME = ""ClassIdIndexes""","private val OLD_PREFIX = ""old"""
"import org.gradle.api.Action
import org.gradle.api.Incubating
import org.gradle.api.NamedDomainObjectProvider
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurablePublishArtifact
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.Dependency
import org.gradle.api.artifacts.DependencyConstraint
import org.gradle.api.artifacts.ExternalModuleDependency
import org.gradle.api.artifacts.ModuleDependency
import org.gradle.api.artifacts.PublishArtifact
import org.gradle.api.artifacts.dsl.ArtifactHandler
import org.gradle.api.artifacts.dsl.DependencyConstraintHandler
import org.gradle.api.artifacts.dsl.DependencyHandler
import org.gradle.api.provider.Provider
import org.gradle.api.provider.ProviderConvertible
import org.gradle.api.tasks.TaskContainer
import org.gradle.api.tasks.TaskProvider

import org.gradle.kotlin.dsl.*
import org.gradle.kotlin.dsl.accessors.runtime.*


/**
 * Adds a dependency to the 'testApiDependenciesMetadata' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`testApiDependenciesMetadata`(dependencyNotation: Any): Dependency? =
    add(""testApiDependenciesMetadata"", dependencyNotation)

/**
 * Adds a dependency to the 'testApiDependenciesMetadata' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`testApiDependenciesMetadata`(
    dependencyNotation: String,
    dependencyConfiguration: Action<ExternalModuleDependency>
): ExternalModuleDependency = addDependencyTo(
    this, ""testApiDependenciesMetadata"", dependencyNotation, dependencyConfiguration
) as ExternalModuleDependency

/**
 * Adds a dependency to the 'testApiDependenciesMetadata' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`testApiDependenciesMetadata`(","dependencyNotation: Provider<*>,"
"if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.equals(null)
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.propT
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.propAny
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.propNullableT
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.propNullableAny
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.funT()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.funAny()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableT()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableAny()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.equals(null)
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.propT
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.propAny
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.propNullableT
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.propNullableAny
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.funT()
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.funAny()
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableT()
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableAny()
        if (x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.equals(null)
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.propT
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.propAny
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.propNullableT
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.propNullableAny
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.funT()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.funAny()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.funNullableT()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.funNullableAny()
        if (this.x != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.equals(null)
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.propT
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.propAny
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.propNullableT
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.propNullableAny
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.funT()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?""), DEBUG_INFO_SMARTCAST!>x<!>.funAny()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.funNullableT()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>.funNullableAny()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>x<!>
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.equals(null)
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.propT
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.propAny
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.propNullableT
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.propNullableAny
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.funT()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char""), DEBUG_INFO_SMARTCAST!>this.x<!>.funAny()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableT()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>.funNullableAny()
        if (x != null || <!SENSELESS_COMPARISON!>this.x != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char & kotlin.Char?"")!>this.x<!>

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.equals(null)

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propT

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.propAny

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableT

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.propNullableAny

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funT()

        if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?""), DEBUG_INFO_SMARTCAST!>y<!>.funAny()","if (y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit & kotlin.Unit?"")!>y<!>.funNullableT()"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"", ""unused"")

package org.jetbrains.kotlin.fir.references.builder

import kotlin.contracts.*
import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.builder.FirBuilderDsl
import org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic
import org.jetbrains.kotlin.fir.references.FirResolvedErrorReference
import org.jetbrains.kotlin.fir.references.impl.FirResolvedErrorReferenceImpl
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.name.Name

@FirBuilderDsl
class FirResolvedErrorReferenceBuilder {
    var source: KtSourceElement? = null
    lateinit var name: Name",lateinit var resolvedSymbol: FirBasedSymbol<*>
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.js.inline.clean

import org.jetbrains.kotlin.js.backend.ast.JsNode
import org.jetbrains.kotlin.js.inline.util.IdentitySet
import java.util.*

internal class ReferenceTracker<in Reference, RemoveCandidate : JsNode> {
    private val reachable = IdentityHashMap<Reference, Boolean>()
    private val removableCandidates = IdentityHashMap<Reference, RemoveCandidate>()
    private val referenceFromTo = IdentityHashMap<Reference, MutableSet<Reference>>()
    private val visited = IdentitySet<Reference>()

    val removable: List<RemoveCandidate>
        get() {
            return reachable
                        .filter { !it.value }
                        .map { removableCandidates[it.key]!! }
        }

    fun addCandidateForRemoval(reference: Reference, candidate: RemoveCandidate) {
        assert(!isReferenceToRemovableCandidate(reference)) { ""Candidate for removal cannot be reassigned: $candidate"" }

        removableCandidates.put(reference, candidate)
        reachable.put(reference, false)
    }

    fun addRemovableReference(referrer: Reference, referenced: Reference) {
        if (!isReferenceToRemovableCandidate(referenced)) return

        getReferencedBy(referrer).add(referenced)

        if (isReachable(referrer)) {
            markReachable(referenced)
        }
    }

    fun markReachable(reference: Reference) {
        if (!isReferenceToRemovableCandidate(reference)) return",visited.add(reference)
"fun box() : String {
    test {
        <!RETURN_NOT_ALLOWED!>return@box<!> ""123""
    }

    return ""OK""
}

<!NOTHING_TO_INLINE!>inline<!> fun <T> test(p: T) {",p.toString()
"// !DIAGNOSTICS: -UNUSED_VARIABLE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_PARAMETER -UNUSED_EXPRESSION
// SKIP_TXT

/*
 * KOTLIN DIAGNOSTICS SPEC TEST (NEGATIVE)
 *
 * SPEC VERSION: 0.1-387
 * MAIN LINK: overload-resolution, choosing-the-most-specific-candidate-from-the-overload-candidate-set, algorithm-of-msc-selection -> paragraph 14 -> sentence 1
 * PRIMARY LINKS: overload-resolution, choosing-the-most-specific-candidate-from-the-overload-candidate-set, algorithm-of-msc-selection -> paragraph 7 -> sentence 3
 * overload-resolution, choosing-the-most-specific-candidate-from-the-overload-candidate-set, algorithm-of-msc-selection -> paragraph 11 -> sentence 1
 * overload-resolution, choosing-the-most-specific-candidate-from-the-overload-candidate-set, algorithm-of-msc-selection -> paragraph 11 -> sentence 2
 * overload-resolution, choosing-the-most-specific-candidate-from-the-overload-candidate-set, algorithm-of-msc-selection -> paragraph 11 -> sentence 4
 * NUMBER: 5
 * DESCRIPTION:  Both candidates are more applicable and few of them is non-parameterized
 */

// FILE: TestCase1.kt
/*
 * TESTCASE NUMBER: 1
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-38912
 */
package testPackCase1

import testPackCase1.I2.Companion.foo
import testPackCase1.I1.Companion.foo
import testPackCase1.I3.Companion.foo
import testPackCase1.I4.Companion.foo

class Case1() : I2, I1, I3, I4  {

    fun test() {
       <!CANNOT_INFER_PARAMETER_TYPE, NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo<!>(1)
    }
}

interface I2 {
    companion object {
        fun <T> foo(x: Int): Unit = print(1) // (1)
    }
}

interface I1 {
    companion object {
        fun foo(x: Int, y: Any = """"): String = ""print(2)"" // (2)
    }
}

interface I3 {",companion object {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.native.executors

import org.jetbrains.kotlin.konan.target.AppleConfigurables
import org.jetbrains.kotlin.konan.target.Configurables",import org.jetbrains.kotlin.konan.target.HostManager
"}


    fun testObjectJvmStaticFunctionMainClass() {
        val mainKt = tmpdir.resolve(""main.kt"").apply {
            writeText(
                """"""
                    object ObjectMain {
                        @JvmStatic
                        fun main(args: Array<String>) = println(""hello"")
                    }
                """"""
            )
        }
        compileAndCheckMainClass(listOf(mainKt), expectedMainClass = ""ObjectMain"")
    }

    fun testCompanionObjectJvmStaticFunctionMainClass() {
        val mainKt = tmpdir.resolve(""main.kt"").apply {
            writeText(
                """"""
                    class Test {
                        companion object {
                            @JvmStatic
                            fun main(args: Array<String>) = println(""hello"")
                        }
                    }
                """"""
            )
        }
        compileAndCheckMainClass(listOf(mainKt), expectedMainClass = ""Test"")
    }

    fun testInterfaceCompanionObjectJvmStaticFunctionMainClass() {
        val mainKt = tmpdir.resolve(""main.kt"").apply {
            writeText(
                """"""
                    interface Test {
                        companion object {
                            @JvmStatic
                            fun main(args: Array<String>) = println(""hello"")
                        }
                    }
                """"""
            )
        }
        compileAndCheckMainClass(listOf(mainKt), expectedMainClass = ""Test"")
    }

    fun testMultipleMainsInOneFile() {
        val mainKt = tmpdir.resolve(""main.kt"").apply {
            writeText(
                """"""
                    object ObjectMain {
                        @JvmStatic
                        fun main(args: Array<String>) = println(""hello"")
                    }
                    object ObjectMain2 {
                        @JvmStatic
                        fun main(args: Array<String>) = println(""hello2"")
                    }
                    fun main(args: Array<String>) = println(""hello3"")
                """"""
            )
        }","compileAndCheckMainClass(listOf(mainKt), expectedMainClass = null)"
"// FIR_IDENTICAL
// FILE: A.java
import java.io.Closeable;

public class A {",public static void foo(Runnable r) {
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.backend.konan.optimizations

import org.jetbrains.kotlin.backend.konan.Context
import org.jetbrains.kotlin.backend.konan.InteropFqNames
import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.util.defaultType
import org.jetbrains.kotlin.ir.util.isFunction
import org.jetbrains.kotlin.ir.util.isReal
import org.jetbrains.kotlin.ir.util.parentAsClass
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
import org.jetbrains.kotlin.ir.visitors.IrElementVisitorVoid
import org.jetbrains.kotlin.ir.visitors.acceptChildrenVoid
import org.jetbrains.kotlin.ir.visitors.transformChildrenVoid
import org.jetbrains.kotlin.util.OperatorNameConventions",internal fun dce(
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.internal.testing.tcsmc

import jetbrains.buildServer.messages.serviceMessages.TestFinished
import jetbrains.buildServer.messages.serviceMessages.TestStarted
import jetbrains.buildServer.messages.serviceMessages.TestSuiteFinished
import jetbrains.buildServer.messages.serviceMessages.TestSuiteStarted
import org.junit.Test

class TestFailureTest : TCServiceMessagesClientTest() {
    @Test
    fun testJs() {
        assertEvents(
            """"""
STARTED SUITE root // root
  STARTED SUITE  // root/
    STARTED TEST displayName: Test, classDisplayName: , className: , name: Test // root//Test
      FAILURE AssertionError: Expected value to be true.
    at AssertionError_init_0 (mpplib2/build/tmp/expandedArchives/kotlin-stdlib-js-1.3-SNAPSHOT.jar_730a1b227513cf16a9b639e009a985fc/kotlin/exceptions.kt:102:37)
    at DefaultJsAsserter.failWithMessage_0 (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/DefaultJsAsserter.kt:80:19)
    at DefaultJsAsserter.assertTrue_o10pc4${'$'} (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/DefaultJsAsserter.kt:60:13)
    at DefaultJsAsserter.assertTrue_4mavae${'$'} (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/DefaultJsAsserter.kt:67:9)
    at assertTrue_0 (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/Assertions.kt:36:21)
    at SampleTestsJS.testHello (mpplib2/src/jsTest/kotlin/sample/SampleTestsJS.kt:9:9)
    at mpplib2/build/js_test_node_modules/mpplib2_test.js:59:38
    at Object.fn [as test] (mpplib2/build/tmp/expandedArchives/src/KotlinTestRunner.ts:12:25)
    at Object.test (mpplib2/build/tmp/expandedArchives/src/KotlinTestTeamCityReporter.ts:80:28)
    at test (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/TestApi.kt:57:15) // root//Test
    COMPLETED FAILURE // root//Test
  COMPLETED FAILURE // root/
COMPLETED FAILURE // root
        """"""
        ) {
            serviceMessage(TestSuiteStarted(""""))
            serviceMessage(TestStarted(""Test"", false, null))
            serviceMessage(
                ""testFailed"",
                mapOf(
                    ""name"" to ""Test"",
                    ""message"" to ""Expected value to be true"",
                    ""details"" to """"""AssertionError: Expected value to be true.
    at AssertionError_init_0 (mpplib2/build/tmp/expandedArchives/kotlin-stdlib-js-1.3-SNAPSHOT.jar_730a1b227513cf16a9b639e009a985fc/kotlin/exceptions.kt:102:37)
    at DefaultJsAsserter.failWithMessage_0 (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/DefaultJsAsserter.kt:80:19)
    at DefaultJsAsserter.assertTrue_o10pc4$ (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/DefaultJsAsserter.kt:60:13)
    at DefaultJsAsserter.assertTrue_4mavae$ (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/DefaultJsAsserter.kt:67:9)
    at assertTrue_0 (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/Assertions.kt:36:21)
    at SampleTestsJS.testHello (mpplib2/src/jsTest/kotlin/sample/SampleTestsJS.kt:9:9)
    at mpplib2/build/js_test_node_modules/mpplib2_test.js:59:38
    at Object.fn [as test] (mpplib2/build/tmp/expandedArchives/src/KotlinTestRunner.ts:12:25)
    at Object.test (mpplib2/build/tmp/expandedArchives/src/KotlinTestTeamCityReporter.ts:80:28)
    at test (mpplib2/build/tmp/expandedArchives/kotlin-test-js-1.3-SNAPSHOT.jar_d60f1e6d0dd94843a03bf98a569bbb73/src/main/kotlin/kotlin/test/TestApi.kt:57:15)""""""
                )
            )
            serviceMessage(TestFinished(""Test"", 0))
            serviceMessage(TestSuiteFinished(""""))
        }
    }

    @Test
    fun testNative() {",treatFailedTestOutputAsStacktrace = true
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.jvm",import org.jetbrains.kotlin.config.JvmTarget
"// FILE: test.kt

infix fun String.execute(p: String) = this + p

fun box(){
    test() execute
            fail()

    fail() execute
            test()
}

inline fun test() : String {
    return ""123""
}

fun fail() : String {","return ""fail"""
"object IMPORT_DIRECTIVE : CallType<KtExpression?>(DescriptorKindFilter.ALL)

    object PACKAGE_DIRECTIVE : CallType<KtExpression?>(DescriptorKindFilter.PACKAGES)

    object TYPE : CallType<KtExpression?>(
        DescriptorKindFilter(DescriptorKindFilter.CLASSIFIERS_MASK or DescriptorKindFilter.PACKAGES_MASK)
                exclude DescriptorKindExclude.EnumEntry
    )

    object DELEGATE : CallType<KtExpression?>(DescriptorKindFilter.FUNCTIONS exclude NonOperatorExclude)

    object ANNOTATION : CallType<KtExpression?>(
        DescriptorKindFilter(DescriptorKindFilter.CLASSIFIERS_MASK or DescriptorKindFilter.PACKAGES_MASK)
                exclude NonAnnotationClassifierExclude
    )

    private object NonInfixExclude : DescriptorKindExclude() {
        override fun excludes(descriptor: DeclarationDescriptor) =
            !(descriptor is SimpleFunctionDescriptor && descriptor.isInfix)

        override val fullyExcludedDescriptorKinds: Int
            get() = 0
    }

    private object NonOperatorExclude : DescriptorKindExclude() {
        override fun excludes(descriptor: DeclarationDescriptor) =
            !(descriptor is SimpleFunctionDescriptor && descriptor.isOperator)

        override val fullyExcludedDescriptorKinds: Int
            get() = 0
    }

    private object CallableReferenceExclude : DescriptorKindExclude() {
        override fun excludes(descriptor: DeclarationDescriptor) /* currently not supported for locals and synthetic */ =
            descriptor !is CallableMemberDescriptor || descriptor.kind == CallableMemberDescriptor.Kind.SYNTHESIZED

        override val fullyExcludedDescriptorKinds: Int
            get() = 0
    }

    private object NonAnnotationClassifierExclude : DescriptorKindExclude() {
        override fun excludes(descriptor: DeclarationDescriptor): Boolean {
            if (descriptor !is ClassifierDescriptor) return false
            return descriptor !is ClassDescriptor || descriptor.kind != ClassKind.ANNOTATION_CLASS
        }

        override val fullyExcludedDescriptorKinds: Int get() = 0
    }

    private object AbstractMembersExclude : DescriptorKindExclude() {
        override fun excludes(descriptor: DeclarationDescriptor) =
            descriptor is CallableMemberDescriptor && descriptor.modality == Modality.ABSTRACT

        override val fullyExcludedDescriptorKinds: Int
            get() = 0
    }
}

sealed class CallTypeAndReceiver<TReceiver : KtElement?, out TCallType : CallType<TReceiver>>(
    val callType: TCallType,
    val receiver: TReceiver
) {
    object UNKNOWN : CallTypeAndReceiver<Nothing?, CallType.UNKNOWN>(CallType.UNKNOWN, null)
    object DEFAULT : CallTypeAndReceiver<Nothing?, CallType.DEFAULT>(CallType.DEFAULT, null)","class DOT(receiver: KtExpression) : CallTypeAndReceiver<KtExpression, CallType.DOT>(CallType.DOT, receiver)"
"import org.jetbrains.kotlin.codegen.pseudoInsns.fakeAlwaysTrueIfeq
import org.jetbrains.kotlin.lexer.KtTokens
import org.jetbrains.kotlin.types.KotlinType
import org.jetbrains.org.objectweb.asm.Label
import org.jetbrains.org.objectweb.asm.Opcodes.*
import org.jetbrains.org.objectweb.asm.Type
import org.jetbrains.org.objectweb.asm.commons.InstructionAdapter

open class BranchedValue(
    val arg1: StackValue,
    val arg2: StackValue? = null,
    val operandType: Type,
    val opcode: Int
) : StackValue(Type.BOOLEAN_TYPE) {

    override fun putSelector(type: Type, kotlinType: KotlinType?, v: InstructionAdapter) {
        val branchJumpLabel = Label()
        condJump(branchJumpLabel, v, true)
        val endLabel = Label()
        v.iconst(1)
        v.visitJumpInsn(GOTO, endLabel)
        v.visitLabel(branchJumpLabel)
        v.iconst(0)
        v.visitLabel(endLabel)
        coerceTo(type, kotlinType, v)
    }

    open fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean) {
        if (arg1 is CondJump) arg1.condJump(jumpLabel, v, jumpIfFalse) else arg1.put(operandType, v)
        arg2?.put(operandType, v)
        v.visitJumpInsn(patchOpcode(if (jumpIfFalse) opcode else negatedOperations[opcode]!!, v), jumpLabel)
    }

    open fun loopJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean) {
        condJump(jumpLabel, v, jumpIfFalse)
    }

    protected open fun patchOpcode(opcode: Int, v: InstructionAdapter): Int = opcode

    companion object {
        val negatedOperations = hashMapOf<Int, Int>()

        val TRUE: BranchedValue = object : BranchedValue(StackValue.none()/*not used*/, null, Type.BOOLEAN_TYPE, IFEQ) {
            override fun condJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean) {
                v.nop()
                if (!jumpIfFalse) {
                    v.goTo(jumpLabel)
                }
            }

            override fun loopJump(jumpLabel: Label, v: InstructionAdapter, jumpIfFalse: Boolean) {
                v.nop()
                if (!jumpIfFalse) {
                    v.fakeAlwaysTrueIfeq(jumpLabel)
                } else {
                    v.fakeAlwaysFalseIfeq(jumpLabel)
                }
            }

            override fun putSelector(type: Type, kotlinType: KotlinType?, v: InstructionAdapter) {
                v.iconst(1)
                coerceTo(type, kotlinType, v)
            }
        }","val FALSE: BranchedValue = object : BranchedValue(StackValue.none()/*not used*/, null, Type.BOOLEAN_TYPE, IFEQ) {"
"// DONT_TARGET_EXACT_BACKEND: JS
// ES_MODULES
// MODULE: lib
// FILE: lib.kt
package lib

val foo = 23

val boo: Int
    get() = 42

external val bar: Int = definedExternally

external val far: Int",get() = definedExternally
"// !LANGUAGE: +AssigningArraysToVarargsInNamedFormInAnnotations

// FILE: JavaAnn.java

@interface JavaAnn {
    String[] value() default {};
    String[] path() default {};
}

// FILE: test.kt

annotation class Ann(vararg val s: String)

@Ann(s = arrayOf())
fun test1() {}

@Ann(s = <!TYPE_MISMATCH!>intArrayOf()<!>)
fun test2() {}

@Ann(s = <!TYPE_MISMATCH!>arrayOf(1)<!>)
fun test3() {}

@Ann(""value1"", ""value2"")
fun test4() {}

@Ann(s = [""value""])
fun test5() {}

@JavaAnn(value = arrayOf(""value""))
fun jTest1() {}

@JavaAnn(value = [""value""])
fun jTest2() {}

@JavaAnn(value = [""value""], path = [""path""])
fun jTest3() {}


annotation class IntAnn(vararg val i: Int)

@IntAnn(i = [1, 2])
fun foo1() {}

@IntAnn(i = intArrayOf(0))",fun foo2() {}
"// WITH_REFLECT

// TARGET_BACKEND: JVM

// FILE: JavaAnn.java

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
@interface JavaAnn {
    String[] value() default {};
    String[] path() default {};
}

// FILE: test.kt

import java.util.Arrays
import kotlin.reflect.KClass",import kotlin.reflect.KFunction0
"PartialLinkageSupportForLoweringsImpl(builtIns, PartialLinkageLogger(messageLogger, partialLinkageConfig.logLevel))
else
    PartialLinkageSupportForLowerings.DISABLED

internal class PartialLinkageSupportForLoweringsImpl(
    private val builtIns: IrBuiltIns,
    private val logger: PartialLinkageLogger
) : PartialLinkageSupportForLowerings {
    override val isEnabled get() = true

    /** To track the amount of rendered linkage issues. */
    var linkageIssuesRendered = 0
        private set

    /**
     * To track the amount of logged linkage issues.
     * Note that the following condition is always true: [linkageIssuesLogged] <= [linkageIssuesRendered].
     */
    var linkageIssuesLogged = 0
        private set

    /**
     * To track the amount of generated `throw` expressions.
     * Note that the following condition is always true: [throwExpressionsGenerated] <= [linkageIssuesRendered].
     */
    var throwExpressionsGenerated = 0
        private set

    override fun throwLinkageError(
        partialLinkageCase: PartialLinkageCase,
        element: IrElement,
        file: PLFile,
        doNotLog: Boolean
    ): IrCall {
        val errorMessage = if (doNotLog)
            renderLinkageError(partialLinkageCase) // Just render a message.
        else
            renderAndLogLinkageError(partialLinkageCase, element, file) // Render + log with the appropriate severity.

        throwExpressionsGenerated++ // Track each generated `throw` expression.

        return IrCallImpl(
            startOffset = element.startOffset,
            endOffset = element.endOffset,
            type = builtIns.nothingType,
            symbol = builtIns.linkageErrorSymbol,
            typeArgumentsCount = 0,
            valueArgumentsCount = 1,
            origin = IrStatementOrigin.PARTIAL_LINKAGE_RUNTIME_ERROR
        ).apply {
            putValueArgument(0, IrConstImpl.string(startOffset, endOffset, builtIns.stringType, errorMessage))
        }
    }

    fun renderAndLogLinkageError(partialLinkageCase: PartialLinkageCase, element: IrElement, file: PLFile): String {
        val errorMessage = renderLinkageError(partialLinkageCase)
        val locationInSourceCode = file.computeLocationForOffset(element.startOffsetOfFirstDenotableIrElement())

        linkageIssuesLogged++ // Track each logged linkage issue.
        logger.log(errorMessage, locationInSourceCode)

        return errorMessage
    }

    private fun renderLinkageError(partialLinkageCase: PartialLinkageCase): String {",linkageIssuesRendered++ // Track each rendered linkage issue.
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/ir/ir.tree/tree-generator/ReadMe.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"")

package org.jetbrains.kotlin.ir.declarations.impl

import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.ir.IrImplementationDetail
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrDeclarationOrigin
import org.jetbrains.kotlin.ir.declarations.IrEnumEntry
import org.jetbrains.kotlin.ir.declarations.IrFactory
import org.jetbrains.kotlin.ir.expressions.IrConstructorCall
import org.jetbrains.kotlin.ir.expressions.IrExpressionBody
import org.jetbrains.kotlin.ir.symbols.IrEnumEntrySymbol
import org.jetbrains.kotlin.name.Name

class IrEnumEntryImpl @IrImplementationDetail constructor(
    override val startOffset: Int,","override val endOffset: Int,"
"override fun setUp() {
        super.setUp()
        header = null
        packageParts.clear()
        serializedIrFiles.clear()
    }

    override fun Services.Builder.registerAdditionalServices() {
        if (header != null) {
            register(
                IncrementalDataProvider::class.java,
                IncrementalDataProviderImpl(
                    headerMetadata = header!!,
                    compiledPackageParts = packageParts,
                    metadataVersion = JsMetadataVersion.INSTANCE.toArray(),
                    packageMetadata = emptyMap(), // TODO pass correct metadata
                    serializedIrFiles = serializedIrFiles
                )
            )
        }

        register(IncrementalResultsConsumer::class.java, IncrementalResultsConsumerImpl())
    }

    override fun markDirty(removedAndModifiedSources: Iterable<File>) {
        removedAndModifiedSources.forEach {
            packageParts.remove(it)
            serializedIrFiles.remove(it)
        }
    }

    override fun processCompilationResults(outputItemsCollector: OutputItemsCollectorImpl, services: Services) {
        val incrementalResults = services[IncrementalResultsConsumer::class.java] as IncrementalResultsConsumerImpl
        header = incrementalResults.headerMetadata
        packageParts.putAll(incrementalResults.packageParts)
        serializedIrFiles.putAll(incrementalResults.irFileData)
    }

    protected open val jsStdlibFile: File
        get() = PathUtil.kotlinPathsForDistDirectoryForTests.jsStdLibKlibPath

    protected open fun configureAdditionalArgs(args: K2JSCompilerArguments) {
    }

    override fun runCompiler(filesToCompile: Iterable<File>, env: JpsCompilerEnvironment): Any? {
        val args = K2JSCompilerArguments().apply {
            val libPaths = arrayListOf(jsStdlibFile.absolutePath) + (libraries ?: """").split(File.pathSeparator)
            libraries = libPaths.joinToString(File.pathSeparator)
            reportOutputFiles = true
            freeArgs = filesToCompile.map { it.canonicalPath }
            useFirLT = false
        }
        configureAdditionalArgs(args)
        return runJSCompiler(args, env)
    }
}

abstract class AbstractLookupTrackerTest : TestWithWorkingDir() {
    private val DECLARATION_KEYWORDS = listOf(""interface"", ""class"", ""enum class"", ""object"", ""fun"", ""operator fun"", ""val"", ""var"")
    private val DECLARATION_STARTS_WITH = DECLARATION_KEYWORDS.map { it + "" "" }

    // ignore KDoc like comments which starts with `/**`, example: /** text */
    private val COMMENT_WITH_LOOKUP_INFO = ""/\\*[^*]+\\*/"".toRegex()",protected lateinit var srcDir: File
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_PARAMETER
// !OPT_IN: kotlin.RequiresOptIn

import kotlin.experimental.ExperimentalTypeInference

suspend fun main() {",iFlow { emit(1) }
"expect class PClass
expect interface PInterface
expect object PObject
expect enum class PEnumClass
expect annotation class PAnnotationClass

internal expect object InternalObject
public expect object PublicObject

open expect class OpenClass
abstract expect class AbstractClass
final expect class FinalClass

expect class C1<A>
expect class C2<B>
expect class C3<D, E : D>

expect class C4<F>


expect abstract class ExtendsNumber : Number",expect fun interface FunInterface {
"fun actualizeClassifiers() {
        val classSymbolRemapper = object : SymbolRemapper.Empty() {
            override fun getReferencedClass(symbol: IrClassSymbol): IrClassSymbol {
                if (!symbol.owner.isExpect) return symbol
                if (symbol.owner.containsOptionalExpectation()) return symbol
                val classId = symbol.owner.classIdOrFail
                classActualizationInfo.actualTypeAliases[classId]?.let { return it.owner.expandedType.classOrFail }
                classActualizationInfo.actualClasses[classId]?.let { return it }
                // Can't happen normally, but possible on incorrect code.
                // In that case, it would later fail with error in matching inside [actualizeCallablesAndMergeModules]
                // Let's leave to expect class as is for that case, it is probably best effort to make errors reasonable.
                return symbol
            }

            override fun getReferencedClassifier(symbol: IrClassifierSymbol): IrClassifierSymbol {
                if (symbol !is IrClassSymbol) return symbol
                return getReferencedClass(symbol)
            }
        }
        dependentFragments.forEach { it.transform(ActualizerVisitor(classSymbolRemapper), null) }
    }

    fun actualizeCallablesAndMergeModules(): Map<IrSymbol, IrSymbol> {
        // 1. Collect expect-actual links for members of classes found on step 1.
        val expectActualMap = collector.matchAllExpectDeclarations(classActualizationInfo)

        if (useFirBasedFakeOverrideGenerator) {
            //   2. Actualize expect fake overrides in non-expect classes inside common or multi-platform module.
            //      It's probably important to run FakeOverridesActualizer before ActualFakeOverridesAdder
            FakeOverridesActualizer(expectActualMap, ktDiagnosticReporter).apply { dependentFragments.forEach { visitModuleFragment(it) } }

            //   3. Add fake overrides to non-expect classes inside common or multi-platform module,
            //      taken from these non-expect classes actualized super classes.
            ActualFakeOverridesAdder(
                expectActualMap,
                classActualizationInfo.actualClasses,
                typeSystemContext
            ).apply { dependentFragments.forEach { visitModuleFragment(it) } }
        }

        //   4. Copy and actualize function parameter default values from expect functions
        val symbolRemapper = ActualizerSymbolRemapper(expectActualMap)
        FunctionDefaultParametersActualizer(symbolRemapper, expectActualMap).actualize()

        //   5. Actualize expect calls in dependent fragments using info obtained in the previous steps
        val actualizerVisitor = ActualizerVisitor(symbolRemapper)
        dependentFragments.forEach { it.transform(actualizerVisitor, null) }

        //   6. Move all declarations to mainFragment
        mergeIrFragments(mainFragment, dependentFragments)
        return expectActualMap
    }

    fun runChecksAndFinalize(expectActualMap: Map<IrSymbol, IrSymbol>) : IrActualizedResult {
        //   Remove top-only expect declarations since they are not needed anymore and should not be presented in the final IrFragment
        //   Also, it doesn't remove unactualized expect declarations marked with @OptionalExpectation
        val removedExpectDeclarations = removeExpectDeclarations(dependentFragments, expectActualMap)

        IrExpectActualCheckers(expectActualMap, classActualizationInfo, typeSystemContext, ktDiagnosticReporter).check()
        return IrActualizedResult(removedExpectDeclarations, expectActualMap)
    }

    private fun removeExpectDeclarations(dependentFragments: List<IrModuleFragment>, expectActualMap: Map<IrSymbol, IrSymbol>): List<IrDeclaration> {
        val removedExpectDeclarations = mutableListOf<IrDeclaration>()",for (fragment in dependentFragments) {
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.jvm.checkers.expression

import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.expression.FirFunctionCallChecker
import org.jetbrains.kotlin.fir.analysis.diagnostics.jvm.FirJvmErrors
import org.jetbrains.kotlin.fir.declarations.FirAnonymousFunction
import org.jetbrains.kotlin.fir.declarations.FirFunction
import org.jetbrains.kotlin.fir.declarations.utils.isSuspend
import org.jetbrains.kotlin.fir.expressions.FirFunctionCall
import org.jetbrains.kotlin.fir.expressions.resolvedArgumentMapping
import org.jetbrains.kotlin.fir.references.toResolvedCallableSymbol
import org.jetbrains.kotlin.fir.resolve.transformers.unwrapAnonymousFunctionExpression
import org.jetbrains.kotlin.fir.types.FirResolvedTypeRef
import org.jetbrains.kotlin.fir.types.isSuspendOrKSuspendFunctionType
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.utils.addToStdlib.runIf

object FirJvmSuspensionPointInsideMutexLockChecker : FirFunctionCallChecker(MppCheckerKind.Common) {
    private val synchronizedCallableId = CallableId(FqName(""kotlin""), Name.identifier(""synchronized""))
    private val withLockCallableId = CallableId(FqName(""kotlin.concurrent""), Name.identifier(""withLock""))
    private val synchronizedBlockParamName = Name.identifier(""block"")

    override fun check(expression: FirFunctionCall, context: CheckerContext, reporter: DiagnosticReporter) {
        val symbol = expression.calleeReference.toResolvedCallableSymbol() ?: return
        if (!symbol.isSuspend) return
        var anonymousFunctionArg: FirAnonymousFunction? = null
        var isMutexLockFound = false
        var isSuspendFunctionFound = false

        for (element in context.containingElements.asReversed()) {
            if (element is FirFunctionCall) {
                val callableSymbol = element.calleeReference.toResolvedCallableSymbol() ?: continue
                val enclosingAnonymousFuncParam = element.resolvedArgumentMapping?.firstNotNullOfOrNull { entry ->",entry.key.unwrapAnonymousFunctionExpression()?.let {
"dfs(it)
                }
            sortedLibraries += library
        }

        for (library in artifactsLibraries.values)
            if (library !in visitedLibraries)
                dfs(library)

        for (library in sortedLibraries) {
            if (File(cacheDirectory, library.uniqueName.cachedName).listFilesOrEmpty().isNotEmpty())
                continue
            logger.info(""Compiling ${library.uniqueName} to cache"")
            val args = mutableListOf(
                ""-p"", konanCacheKind.produce!!,
                ""-target"", target
            )
            if (debuggable) args += ""-g""
            args += konanPropertiesService.additionalCacheFlags(konanTarget)
            args += settings.externalDependenciesArgs
            args += ""$PARTIAL_LINKAGE_PARAMETER=$partialLinkageMode""
            args += ""-Xadd-cache=${library.libraryFile.absolutePath}""
            args += ""-Xcache-directory=${cacheDirectory.absolutePath}""
            args += ""-Xcache-directory=${rootCacheDirectory.absolutePath}""

            dependenciesCacheDirectories.forEach {
                args += ""-Xcache-directory=${it.absolutePath}""
            }
            getAllDependencies(dependency)
                .flatMap { getArtifacts(it) }
                .map { it.file }
                .filterKlibsPassedToCompiler()
                .forEach {
                    args += ""-l""
                    args += it.absolutePath
                }
            library.unresolvedDependencies
                .mapNotNull { artifactsLibraries[it.path] }
                .forEach {
                    args += ""-l""
                    args += it.libraryFile.absolutePath
                }
            objectFactory.KotlinNativeCompilerRunner(settings.runnerSettings, GradleBuildMetricsReporter()).run(args)
        }
    }

    private val String.cachedName
        get() = getCacheFileName(this, konanCacheKind)

    private fun ensureCompilerProvidedLibPrecached(
        platformLibName: String,
        platformLibs: Map<String, File>,
        visitedLibs: MutableSet<String>,
    ) {
        if (platformLibName in visitedLibs)
            return
        visitedLibs += platformLibName
        val platformLib = platformLibs[platformLibName] ?: error(""$platformLibName is not found in platform libs"")
        if (File(rootCacheDirectory, platformLibName.cachedName).listFilesOrEmpty().isNotEmpty())
            return
        val unresolvedDependencies = resolveSingleFileKlib(
            KFile(platformLib.absolutePath),
            logger = GradleLoggerAdapter(logger),
            strategy = nativeSingleFileResolveStrategy
        ).unresolvedDependencies",for (dependency in unresolvedDependencies)
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.js.backend.ast

class JsImport(
    val module: String,
    val target: Target,
) : SourceInfoAwareJsNode(), JsStatement {
    constructor(module: String, vararg elements: Element) : this(module, Target.Elements(elements.toMutableList()))

    val elements: MutableList<Element>
        get() = (target as Target.Elements).elements

    sealed class Target {
        object Effect : Target()
        class Elements(val elements: MutableList<Element>) : Target()
        class Default(val name: JsNameRef) : Target() {
            constructor(name: String) : this(JsNameRef(name))
        }

        class All(val alias: JsNameRef) : Target() {
            constructor(alias: String) : this(JsNameRef(alias))
        }
    }

    class Element(
        val name: JsName,
        val alias: JsNameRef? = null
    )

    override fun accept(visitor: JsVisitor) {
        visitor.visitImport(this)
    }

    override fun acceptChildren(visitor: JsVisitor) {
        when (target) {
            is Target.Effect -> {}
            is Target.All -> visitor.accept(target.alias)",is Target.Default -> visitor.accept(target.name)
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.types

import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.container.DefaultImplementation
import org.jetbrains.kotlin.container.PlatformSpecificExtension
import org.jetbrains.kotlin.descriptors.annotations.Annotations
import org.jetbrains.kotlin.renderer.DescriptorRenderer
import org.jetbrains.kotlin.renderer.DescriptorRendererOptions
import org.jetbrains.kotlin.types.checker.KotlinTypeRefiner
import org.jetbrains.kotlin.types.model.DynamicTypeMarker
import org.jetbrains.kotlin.types.typeUtil.builtIns

@DefaultImplementation(impl = DynamicTypesSettings::class)
open class DynamicTypesSettings : PlatformSpecificExtension<DynamicTypesSettings> {
    open val dynamicTypesAllowed: Boolean
        get() = false
}

class DynamicTypesAllowed : DynamicTypesSettings() {
    override val dynamicTypesAllowed: Boolean
        get() = true
}

fun KotlinType.isDynamic(): Boolean = unwrap() is DynamicType

fun createDynamicType(builtIns: KotlinBuiltIns) = DynamicType(builtIns, TypeAttributes.Empty)

class DynamicType(","builtIns: KotlinBuiltIns,"
"assertEquals(
                setOf(""commonMain"", ""nativeMain""),
                sourceJarSourceRoots[null]
            )
            assertEquals(setOf(""commonMain"", ""jvm6Main""), sourceJarSourceRoots[""jvm6""])
            assertEquals(setOf(""commonMain"", ""nodeJsMain""), sourceJarSourceRoots[""nodejs""])
            assertEquals(setOf(""commonMain"", ""nativeMain"", ""linux64Main""), sourceJarSourceRoots[""linux64""])
        }
    }

    @Test
    fun testConsumeMppLibraryFromNonKotlinProject() {
        val libRepo = with(transformNativeTestProject(""sample-lib"", gradleVersion, ""new-mpp-lib-and-app"")) {
            build(""publish"") { assertSuccessful() }
            projectDir.resolve(""repo"")
        }

        with(transformNativeTestProject(""sample-app-without-kotlin"", gradleVersion, ""new-mpp-lib-and-app"")) {
            setupWorkingDir()
            gradleBuildScript().appendText(""\nrepositories { maven { url '${libRepo.toURI()}' } }"")

            build(""assemble"") {
                assertSuccessful()
                assertTasksExecuted("":compileJava"")
                assertFileExists(""build/classes/java/main/A.class"")
            }
        }
    }

    @Test
    fun testPublishMultimoduleProjectWithMetadata() {
        val libProject = transformNativeTestProject(""sample-lib"", gradleVersion, ""new-mpp-lib-and-app"")
        libProject.setupWorkingDir()

        transformNativeTestProject(""sample-external-lib"", gradleVersion, ""new-mpp-lib-and-app"").apply {
            setupWorkingDir()
            // Publish it into local repository of adjacent lib:
            gradleBuildScript().appendText(
                ""\n"" + """"""
                publishing {
                    repositories {
                        maven { url ""${'$'}{rootProject.projectDir.absolutePath.replace('\\', '/')}/../sample-lib/repo"" }
                    }
                }
                """""".trimIndent()
            )
            build(""publish"") {
                assertSuccessful()
            }
        }

        val appProject = transformNativeTestProject(""sample-app"", gradleVersion, ""new-mpp-lib-and-app"")

        with(libProject) {
            setupWorkingDir()
            appProject.setupWorkingDir(false)
            appProject.projectDir.copyRecursively(projectDir.resolve(""sample-app""))

            gradleSettingsScript().writeText(""include 'sample-app'"")
            gradleBuildScript(""sample-app"").modify {
                it.replace(""'com.example:sample-lib:1.0'"", ""project(':')"") + ""\n"" + """"""
                apply plugin: 'maven-publish'
                group = ""com.exampleapp""
                version = ""1.0""
                publishing {",repositories {
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.ic

import org.jetbrains.kotlin.backend.common.linkage.issues.checkNoUnboundSymbols
import org.jetbrains.kotlin.backend.common.linkage.partial.createPartialLinkageSupportForLinker
import org.jetbrains.kotlin.backend.common.serialization.DeserializationStrategy
import org.jetbrains.kotlin.backend.common.serialization.checkIsFunctionInterface
import org.jetbrains.kotlin.backend.common.serialization.encodings.BinarySymbolData
import org.jetbrains.kotlin.backend.common.serialization.signature.IdSignatureDescriptor
import org.jetbrains.kotlin.config.CompilerConfiguration
import org.jetbrains.kotlin.config.languageVersionSettings
import org.jetbrains.kotlin.descriptors.ModuleDescriptor
import org.jetbrains.kotlin.descriptors.impl.ModuleDescriptorImpl
import org.jetbrains.kotlin.incremental.components.LookupTracker
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.backend.js.FunctionTypeInterfacePackages
import org.jetbrains.kotlin.ir.backend.js.JsFactories
import org.jetbrains.kotlin.ir.backend.js.lower.serialization.ir.JsIrLinker
import org.jetbrains.kotlin.ir.backend.js.lower.serialization.ir.JsManglerDesc
import org.jetbrains.kotlin.ir.declarations.IrFactory",import org.jetbrains.kotlin.ir.declarations.IrFile
"for (mask in 0 until (1 shl 4)) {
                        val casedBefore = cased().repeat((mask shr 0) and 1)
                        val casedAfter = cased().repeat((mask shr 1) and 1)
                        val otherBefore = other().repeat((mask shr 2) and 1)
                        val otherAfter = other().repeat((mask shr 3) and 1)

                        val resultSigmaNearby =
                                if (otherBefore.isEmpty() && casedBefore.isNotEmpty() && (otherAfter.isNotEmpty() || casedAfter.isEmpty()))
                                    specialSigmaNearby
                                else
                                    lowerSigmaNearby

                        val actual = (casedBefore + otherBefore + sigmaNearby + otherAfter + casedAfter).lowercase()
                        val expected = casedBefore.lowercase() + otherBefore + resultSigmaNearby + otherAfter + casedAfter.lowercase()

                        assertEquals(
                                expected,
                                actual,
                                ""Expected <$expected>${expected.map { it.hex() }}, Actual <$actual>${actual.map { it.hex() }}""
                        )
                    }
                }
            }
        }
    }

    @Test
    fun uppercase() {
        // Non-ASCII
        assertEquals(""\u00DE\u03A9\u0403\uA779"", ""\u00FE\u03A9\u0453\uA77A"".uppercase())

        // Surrogate pairs
        assertEquals(""\ud801\udc00"", ""\ud801\udc28"".uppercase())
        assertEquals(""\ud801\udc00"", ""\ud801\udc00"".uppercase())
    }

    @Test
    fun capitalize() {
        // Non-ASCII
        assertEquals(""\u00DE\u03A9\u0453\uA77A"", ""\u00FE\u03A9\u0453\uA77A"".capitalize())
    }

    @Test fun indexOfString() {
        assertEquals(1, ""bceded"".indexOf(""ced"", -1))

        assertEquals(-1, ""bceded"".indexOf(""e"", 7))
        assertEquals(-1, ""bceded"".indexOf(""e"", Int.MAX_VALUE))
        assertEquals(6, ""bceded"".indexOf("""", Int.MAX_VALUE))

        assertEquals(-1, """".indexOf(""a"", -3))
        assertEquals(0, """".indexOf("""", 0))
    }

    @Test
    fun indexOfChar() {
        assertEquals(-1, ""bcedef"".indexOf('e', 5))

        assertEquals(-1, """".indexOf('a', -3))
        assertEquals(-1, """".indexOf('a', 10))

        assertEquals(-1, """".indexOf(0.toChar(), -3))
        assertEquals(-1, """".indexOf(0.toChar(), 10))
    }

    @Test",fun equalsIgnoreCase() {
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin

import org.gradle.api.Project
import org.gradle.api.file.FileCollection
import org.gradle.api.provider.Provider
import org.gradle.api.tasks.TaskProvider
import org.jetbrains.kotlin.gradle.dsl.*
import org.jetbrains.kotlin.gradle.internal.KaptGenerateStubsTask
import org.jetbrains.kotlin.gradle.internal.KaptWithoutKotlincTask
import org.jetbrains.kotlin.gradle.tasks.*
import org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile
import org.jetbrains.kotlin.gradle.tasks.configuration.KaptGenerateStubsConfig
import org.jetbrains.kotlin.gradle.tasks.configuration.KaptWithoutKotlincConfig
import org.jetbrains.kotlin.gradle.tasks.configuration.KotlinCompileConfig
import org.jetbrains.kotlin.gradle.utils.configureExperimentalTryNext

/** Plugin that can be used by third-party plugins to create Kotlin-specific DSL and tasks (compilation and KAPT) for JVM platform. */
abstract class KotlinBaseApiPlugin : DefaultKotlinBasePlugin(), KotlinJvmFactory {

    private lateinit var myProject: Project
    private val taskCreator = KotlinTasksProvider()

    override fun apply(project: Project) {
        super.apply(project)
        myProject = project
        setupAttributeMatchingStrategy(project, isKotlinGranularMetadata = false)
    }

    override fun addCompilerPluginDependency(dependency: Provider<Any>) {
        myProject.dependencies.addProvider(
            PLUGIN_CLASSPATH_CONFIGURATION_NAME,
            dependency
        )
    }

    override fun getCompilerPlugins(): FileCollection {
        return myProject.configurations.getByName(PLUGIN_CLASSPATH_CONFIGURATION_NAME)
    }

    override fun createCompilerJvmOptions(): KotlinJvmCompilerOptions {",return myProject.objects
")
    ),
    ""BasicText"" to Function(
        ""BasicText"",
        annotations = composable,
        body = listOf(
            call(""CoreText"")
        )
    ),
    ""Text"" to Function(
        ""Text"",
        annotations = composable,
        body = listOf(
            call(""BasicText"")
        )
    ),
    ""Circle"" to Function(
        ""Circle"",
        annotations = composable,
        body = listOf(
            call(""Vector/1"")
        )
    ),
    ""Square"" to Function(
        ""Square"",
        annotations = composable,
        body = listOf(
            call(""Vector/1"")
        )
    ),
    ""Provider"" to Function(
        ""Provider"",
        annotations = composable,
        parameters = listOf(Parameter(""content"", composableLambda())),
        body = listOf(
            call(""content"")
        )
    ),
    ""Row"" to Function(
        ""Row"",
        annotations = composable,
        parameters = listOf(Parameter(""content"", composableLambda())),
        body = listOf(
            call(""Layout/2"", Ref(""content""))
        )
    ),
    ""Button"" to Function(
        ""Button"",
        annotations = composable,
        parameters = listOf(Parameter(""content"", composableLambda())),
        body = listOf(
            call(""Row"", Ref(""content""))
        )
    ),
    ""Layer"" to Function(
        ""Layer"",
        annotations = composable,
        parameters = listOf(Parameter(""content"", composableLambda())),
        body = listOf(
            call(""Vector/2"", Ref(""content""))
        )
    ),

    ""SimpleOpen"" to Function(""SimpleOpen"", annotations = composable),","""OpenRecursive"" to Function("
"package test

import android.app.Activity
import android.view.View
import android.widget.*
import kotlinx.android.synthetic.main.layout.*
import kotlinx.android.synthetic.main.layout1.*

class R {
    class id {
        companion object {
            const val item_detail_container = 0
            const val textView1 = 1
            const val password = 2",const val textView2 = 3
")

        MAP.put(
            ErrorsParcelize.PARCELABLE_SHOULD_NOT_BE_ENUM_CLASS,
            ""'Parcelable' should not be a 'enum class'""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_SHOULD_BE_INSTANTIABLE,
            ""'Parcelable' should not be an 'abstract' class""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_CANT_BE_INNER_CLASS,
            ""'Parcelable' can't be an inner class""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_CANT_BE_LOCAL_CLASS,
            ""'Parcelable' can't be a local class""
        )

        MAP.put(
            ErrorsParcelize.NO_PARCELABLE_SUPERTYPE,
            ""No 'Parcelable' supertype""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_SHOULD_HAVE_PRIMARY_CONSTRUCTOR,
            ""'Parcelable' should have a primary constructor""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_PRIMARY_CONSTRUCTOR_IS_EMPTY,
            ""The primary constructor is empty, no data will be serialized to 'Parcel'""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_CONSTRUCTOR_PARAMETER_SHOULD_BE_VAL_OR_VAR,
            ""'Parcelable' constructor parameter should be 'val' or 'var'""
        )

        MAP.put(
            ErrorsParcelize.PROPERTY_WONT_BE_SERIALIZED,
            ""Property would not be serialized into a 'Parcel'. Add '@IgnoredOnParcel' annotation to remove the warning""
        )

        MAP.put(
            ErrorsParcelize.OVERRIDING_WRITE_TO_PARCEL_IS_NOT_ALLOWED,
            ""Overriding 'writeToParcel' is not allowed. Use 'Parceler' companion object instead""
        )

        MAP.put(
            ErrorsParcelize.CREATOR_DEFINITION_IS_NOT_ALLOWED,
            ""'CREATOR' definition is not allowed. Use 'Parceler' companion object instead""
        )

        MAP.put(
            ErrorsParcelize.PARCELABLE_TYPE_NOT_SUPPORTED,
            ""Type is not directly supported by 'Parcelize'. "" +
                    ""Annotate the parameter type with '@RawValue' if you want it to be serialized using 'writeValue()'""
        )

        MAP.put(
            ErrorsParcelize.PARCELER_SHOULD_BE_OBJECT,","""Parceler should be an object"""
"interface KonanArtifactSpec {
    fun artifactName(name: String)
}

interface KonanArtifactWithLibrariesSpec: KonanArtifactSpec {
    fun libraries(closure: Closure<Unit>)
    fun libraries(action: Action<KonanLibrariesSpec>)
    fun libraries(configure: KonanLibrariesSpec.() -> Unit)

    fun noDefaultLibs(flag: Boolean)
    fun noEndorsedLibs(flag: Boolean)
    fun dependencies(closure: Closure<Unit>)
}

interface KonanBuildingSpec: KonanArtifactWithLibrariesSpec {
    fun dumpParameters(flag: Boolean)

    fun extraOpts(vararg values: Any)
    fun extraOpts(values: List<Any>)
}

interface KonanCompileSpec: KonanBuildingSpec {
    fun srcDir(dir: Any)

    fun srcFiles(vararg files: Any)
    fun srcFiles(files: Collection<Any>)

    // DSL. Native libraries.

    fun nativeLibrary(lib: Any)
    fun nativeLibraries(vararg libs: Any)
    fun nativeLibraries(libs: FileCollection)

    // DSL. Multiplatform projects
    fun enableMultiplatform(flag: Boolean)

    // TODO: Get rid of commonSourceSet in 0.7
    @Deprecated(""Use commonSourceSets instead"", ReplaceWith(""commonSourceSets(sourceSetName)""))
    fun commonSourceSet(sourceSetName: String)
    fun commonSourceSets(vararg sourceSetNames: String)

    fun commonSrcDir(dir: Any)

    fun commonSrcFiles(vararg files: Any)
    fun commonSrcFiles(files: Collection<Any>)

    // DSL. Other parameters.

    fun linkerOpts(vararg values: String)
    fun linkerOpts(values: List<String>)

    fun enableDebug(flag: Boolean)
    fun noStdLib(flag: Boolean)
    fun noMain(flag: Boolean)
    fun noPack(flag: Boolean)
    fun enableOptimizations(flag: Boolean)
    fun enableAssertions(flag: Boolean)

    fun entryPoint(entryPoint: String)

    fun measureTime(flag: Boolean)
}

interface KonanInteropSpec: KonanBuildingSpec {",interface IncludeDirectoriesSpec {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.unitTests

import org.jetbrains.kotlin.gradle.internal.properties.PropertiesBuildService
import org.jetbrains.kotlin.gradle.plugin.extraProperties
import org.jetbrains.kotlin.gradle.util.buildProject
import org.jetbrains.kotlin.gradle.util.registerMinimalVariantImplementationFactoriesForTests
import org.junit.Assert.assertEquals
import org.junit.Test

class PropertiesBuildServiceTest {

    @Test
    fun testPrecedenceOrder() {
        val project = buildProject()
        project.extraProperties.apply {
            set(""a"", ""extra"")","set(""b"", ""extra"")"
"@CompileTimeCalculation fun ifGreaterOrEqualToZero(a: Int): Boolean {
    return if (a >= 0) {
        true
    } else {
        false
    }
}

@CompileTimeCalculation fun whenGreaterOrEqualToZero(a: Int): Boolean {
    return when {",a >= 0 -> true
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""FunctionName"")

package org.jetbrains.kotlin.gradle.unitTests

import org.jetbrains.kotlin.gradle.plugin.*
import org.jetbrains.kotlin.gradle.plugin.KotlinPluginLifecycle.IllegalLifecycleException
import org.jetbrains.kotlin.gradle.plugin.KotlinPluginLifecycle.Stage.*
import org.jetbrains.kotlin.gradle.util.buildProjectWithMPP
import org.jetbrains.kotlin.gradle.util.runLifecycleAwareTest
import org.jetbrains.kotlin.gradle.utils.newProperty
import org.junit.Test
import kotlin.test.assertEquals
import kotlin.test.assertFails
import kotlin.test.assertFailsWith
import kotlin.test.assertNull

class LifecycleAwaitFinalPropertyValueTest {
    private val project = buildProjectWithMPP()

    @Test
    fun `test - awaitFinalValue`() = project.runLifecycleAwareTest {
        val property = project.newProperty<Int>()

        launchInStage(FinaliseDsl.previousOrThrow.previousOrThrow) {",property.set(1)
"* ISSUES: KT-28329
 */
fun case_44(x: TypealiasNullableString<!REDUNDANT_NULLABLE!>?<!>, z1: Nothing?) {
    if (true && true && true && true && x !== z1) {

    } else if (false) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!><!UNSAFE_CALL!>.<!>propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!><!UNSAFE_CALL!>.<!>funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString?"")!>x<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 45
fun case_45() {
    val a = Class()
    <!CAN_BE_VAL!>var<!> z: Nothing? = null

    if (a.prop_4 != z || true) {
        if (a.prop_4 == null) {
            a.prop_4
            a.prop_4.hashCode()
        }
    }
}

// TESTCASE NUMBER: 46
fun case_46(x: TypealiasNullableString<!REDUNDANT_NULLABLE!>?<!>, y: TypealiasNullableString) {
    val t: TypealiasNullableString = null
    <!CAN_BE_VAL!>var<!> z: Nothing? = null

    if (x != nullableNothingProperty) {

    } else {
        if (y === nullableNothingProperty) {
            if (z != nullableStringProperty) {
                if (z === t || <!SENSELESS_COMPARISON!>t == nullableNothingProperty<!>) {
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString? & kotlin.Nothing?"")!>x<!>
                    <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString? & kotlin.Nothing?"")!>x<!>.hashCode()
                }
            }
        }
    }
}

/*
 * TESTCASE NUMBER: 47
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28328
 */
fun case_47(x: TypealiasNullableString, y: TypealiasNullableString, z: Nothing?) = if (x !== z && true && true && true) ""1""
    else if (y != z) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!><!UNSAFE_CALL!>.<!>propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!>.funT()","<!DEBUG_INFO_EXPRESSION_TYPE(""TypealiasNullableString"")!>x<!><!UNSAFE_CALL!>.<!>funAny()"
"return context.session.symbolProvider.getClassLikeSymbolByClassId(this)
    }

    private fun ClassId.resolveToClass(context: CheckerContext): FirRegularClassSymbol? {
        val classSymbol = resolveToClassLike(context) ?: return null
        return when (classSymbol) {
            is FirRegularClassSymbol -> classSymbol
            is FirTypeAliasSymbol -> classSymbol.fullyExpandedClass(context.session)
            is FirAnonymousObjectSymbol -> null
        }
    }

    private fun FirRegularClassSymbol.hasFunction(
        context: CheckerContext,
        name: Name,
        predicate: (FirNamedFunctionSymbol) -> Boolean
    ): Boolean {
        var result = false
        context.session.declaredMemberScope(this, memberRequiredPhase = null).processFunctionsByName(name) { sym ->
            if (!result) {
                result = predicate(sym)
            }
        }
        return result
    }

    private sealed class ImportStatus {
        data object OK : ImportStatus()
        data class Invisible(val symbol: FirCallableSymbol<*>) : ImportStatus()
        data object CannotBeImported : ImportStatus()
        data object Unresolved : ImportStatus()
    }

    private fun FirRegularClassSymbol.getImportStatusOfCallableMembers(context: CheckerContext, name: Name): ImportStatus {
        return if (classKind.isSingleton) {
            // Use declaredMemberScope first because it's faster, and it's relatively rare to import members declared from super types.
            val scopes = listOf(context.session.declaredMemberScope(this, memberRequiredPhase = null), unsubstitutedScope(context))
            getImportStatus(scopes, context, name) { true }
        } else {
            val scopes = listOfNotNull(
                // We first try resolution with declaredMemberScope because it's faster and typically imported members are not from
                // super types.
                context.session.declaredMemberScope(this, memberRequiredPhase = null),

                // Next, we try static scope, which can provide static (Java) members from super classes. Note that it's not available
                // for pure Kotlin classes.
                staticScope(context.sessionHolder),

                // Finally, we fall back to unsubstitutedScope to catch all
                unsubstitutedScope(context)
            )
            getImportStatus(scopes, context, name) { it.isStatic }
        }
    }

    private inline fun getImportStatus(
        scopes: List<FirContainingNamesAwareScope>,
        context: CheckerContext,
        name: Name,
        crossinline isApplicable: (FirCallableSymbol<*>) -> Boolean
    ): ImportStatus {
        var found = false
        var symbol: FirCallableSymbol<*>? = null

        for (scope in scopes) {",scope.processFunctionsByName(name) { sym ->
"// ISSUE: KT-62956

abstract class Builder<S, B : Builder<S, B>>(var s: S) {
    fun <T : B> test(x: T): T {
        s = x.s
        return x
    }
}

class BS : Builder<String, BS>("""")
class BI : Builder<Int, BI>(1)

fun bar(b: Builder<String, *>, bb: Builder<*, *>) {
    b.test<Builder<*, *>>(bb)
}

fun main() {
    val b = BS()
    bar(b, BI())",b.s.length
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlinx.serialization.compiler.backend.ir

import org.jetbrains.kotlin.backend.jvm.functionByName
import org.jetbrains.kotlin.builtins.StandardNames
import org.jetbrains.kotlin.ir.builders.*
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.declarations.IrVariable
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.expressions.impl.IrGetValueImpl
import org.jetbrains.kotlin.ir.symbols.IrClassSymbol
import org.jetbrains.kotlin.ir.symbols.IrFunctionSymbol
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlinx.serialization.compiler.extensions.SerializationPluginContext
import org.jetbrains.kotlinx.serialization.compiler.resolve.CallingConventions
import org.jetbrains.kotlinx.serialization.compiler.resolve.SerialEntityNames

class SerializerForEnumsGenerator(
    irClass: IrClass,
    compilerContext: SerializationPluginContext,",") : SerializerIrGenerator(irClass, compilerContext, null) {"
"class DescriptorKindFilter(
        kindMask: Int,
        val excludes: List<DescriptorKindExclude> = listOf()
) {
    val kindMask: Int

    init {
        var mask = kindMask
        excludes.forEach { mask = mask and it.fullyExcludedDescriptorKinds.inv() }
        this.kindMask = mask
    }

    fun accepts(descriptor: DeclarationDescriptor): Boolean
            = kindMask and descriptor.kind() != 0 && excludes.all { !it.excludes(descriptor) }

    fun acceptsKinds(kinds: Int): Boolean
            = kindMask and kinds != 0

    infix fun exclude(exclude: DescriptorKindExclude): DescriptorKindFilter
            = DescriptorKindFilter(kindMask, excludes + listOf(exclude))

    fun withoutKinds(kinds: Int): DescriptorKindFilter
            = DescriptorKindFilter(kindMask and kinds.inv(), excludes)

    fun withKinds(kinds: Int): DescriptorKindFilter
            = DescriptorKindFilter(kindMask or kinds, excludes)

    fun restrictedToKinds(kinds: Int): DescriptorKindFilter
            = DescriptorKindFilter(kindMask and kinds, excludes)

    fun restrictedToKindsOrNull(kinds: Int): DescriptorKindFilter? {
        val mask = kindMask and kinds
        if (mask == 0) return null
        return DescriptorKindFilter(mask, excludes)
    }

    fun intersect(other: DescriptorKindFilter) = DescriptorKindFilter(kindMask and other.kindMask, excludes + other.excludes)

    override fun toString(): String {
        val predefinedFilterName = DEBUG_PREDEFINED_FILTERS_MASK_NAMES.firstOrNull { it.mask == kindMask } ?.name
        val kindString = predefinedFilterName ?: DEBUG_MASK_BIT_NAMES
                .mapNotNull { if (acceptsKinds(it.mask)) it.name else null }
                .joinToString(separator = "" | "")

        return ""DescriptorKindFilter($kindString, $excludes)""
    }

    private fun DeclarationDescriptor.kind(): Int {
        return when (this) {
            is ClassDescriptor -> if (this.kind.isSingleton) SINGLETON_CLASSIFIERS_MASK else NON_SINGLETON_CLASSIFIERS_MASK
            is TypeAliasDescriptor -> TYPE_ALIASES_MASK
            is ClassifierDescriptor -> NON_SINGLETON_CLASSIFIERS_MASK
            is PackageFragmentDescriptor, is PackageViewDescriptor -> PACKAGES_MASK
            is FunctionDescriptor -> FUNCTIONS_MASK
            is VariableDescriptor -> VARIABLES_MASK
            else -> 0
        }
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as DescriptorKindFilter",if (excludes != other.excludes) return false
"// FIR_IDENTICAL
// !CHECK_TYPE
// FILE: a.kt

package a.b.c

class D {
    fun foo() = 42
}

// FILE: b.kt

import kotlin.reflect.KFunction1

fun main() {",val x = a.b.c.D::foo
"/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.codegen.range.forLoop

import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.codegen.DescriptorAsmUtil
import org.jetbrains.kotlin.codegen.ExpressionCodegen
import org.jetbrains.kotlin.codegen.StackValue
import org.jetbrains.kotlin.psi.KtForExpression
import org.jetbrains.kotlin.resolve.jvm.AsmTypes.OBJECT_TYPE
import org.jetbrains.kotlin.types.KotlinType
import org.jetbrains.org.objectweb.asm.Label
import org.jetbrains.org.objectweb.asm.Type

class ForInArrayLoopGenerator(
    codegen: ExpressionCodegen,
    forExpression: KtForExpression,
    private val canCacheArrayLength: Boolean,
    private val shouldAlwaysStoreArrayInNewVar: Boolean
) : AbstractForLoopGenerator(codegen, forExpression) {
    private var indexVar: Int = 0
    private var arrayVar: Int = 0
    private var arrayLengthVar: Int = 0
    private val loopRangeType: KotlinType = bindingContext.getType(forExpression.loopRange!!)!!

    override fun beforeLoop() {
        super.beforeLoop()

        indexVar = createLoopTempVariable(Type.INT_TYPE)

        val loopRange = forExpression.loopRange
        val value = codegen.gen(loopRange)
        val asmLoopRangeType = codegen.asmType(loopRangeType)
        if (!shouldAlwaysStoreArrayInNewVar && value is StackValue.Local && value.type == asmLoopRangeType) {
            arrayVar = value.index // no need to copy local variable into another variable
        } else {",arrayVar = createLoopTempVariable(OBJECT_TYPE)
"// EXPECTED_REACHABLE_NODES: 1289
package foo

fun box(): String {
    val ints: Any? = arrayOf(1, 2)
    val strings: Any? = arrayOf(""a"", ""b"")
    val nil: Any? = null",val obj: Any? = object{}
"// WITH_STDLIB
// WORKS_WHEN_VALUE_CLASS
// LANGUAGE: +ValueClasses

var result = ""Fail""

OPTIONAL_JVM_INLINE_ANNOTATION
value class A(val value: String) {","constructor() : this(""OK"")"
"fun runNoInline(block: ()-> Unit): Unit {
    block()
}

fun use(x: Int) {}",fun test(): Unit {
"// MODULE: library
// FILE: library.kt

inline fun bar(crossinline block: () -> Unit) {
    object {
        fun baz(param: Int) {
            val b = 2
            block()
            inlineCall {
                val g = 7
            }
            block()
            inlineCall {
                val g = 7
            }
            block()
            inlineCall {
                val g = 7
            }
        }
    }.baz(6)
}

inline fun inlineCall(block: () -> Unit) {
    block()
}

// MODULE: test(library)
// USE_INLINE_SCOPES_NUMBERS
// FILE: test.kt",fun box() {
"suspend fun dummy() {}

class C {
    suspend fun dummy() = ""OK""
}

class WithNested {
    class Nested {","suspend fun dummy() = ""OK"""
"fun testR0xE3() {
    // with possible local optimizations
    if (3u in 1u..<3u != range0.contains(3u)) throw AssertionError()
    if (3u !in 1u..<3u != !range0.contains(3u)) throw AssertionError()
    if (!(3u in 1u..<3u) != !range0.contains(3u)) throw AssertionError()
    if (!(3u !in 1u..<3u) != range0.contains(3u)) throw AssertionError()
    // no local optimizations
    if (element3 in 1u..<3u != range0.contains(element3)) throw AssertionError()
    if (element3 !in 1u..<3u != !range0.contains(element3)) throw AssertionError()
    if (!(element3 in 1u..<3u) != !range0.contains(element3)) throw AssertionError()
    if (!(element3 !in 1u..<3u) != range0.contains(element3)) throw AssertionError()
}

fun testR0xE4() {
    // with possible local optimizations
    if (4u in 1u..<3u != range0.contains(4u)) throw AssertionError()
    if (4u !in 1u..<3u != !range0.contains(4u)) throw AssertionError()
    if (!(4u in 1u..<3u) != !range0.contains(4u)) throw AssertionError()
    if (!(4u !in 1u..<3u) != range0.contains(4u)) throw AssertionError()
    // no local optimizations
    if (element4 in 1u..<3u != range0.contains(element4)) throw AssertionError()
    if (element4 !in 1u..<3u != !range0.contains(element4)) throw AssertionError()
    if (!(element4 in 1u..<3u) != !range0.contains(element4)) throw AssertionError()
    if (!(element4 !in 1u..<3u) != range0.contains(element4)) throw AssertionError()
}

fun testR1xE0() {
    // with possible local optimizations
    if (0u in 3u..<1u != range1.contains(0u)) throw AssertionError()
    if (0u !in 3u..<1u != !range1.contains(0u)) throw AssertionError()
    if (!(0u in 3u..<1u) != !range1.contains(0u)) throw AssertionError()
    if (!(0u !in 3u..<1u) != range1.contains(0u)) throw AssertionError()
    // no local optimizations
    if (element0 in 3u..<1u != range1.contains(element0)) throw AssertionError()
    if (element0 !in 3u..<1u != !range1.contains(element0)) throw AssertionError()
    if (!(element0 in 3u..<1u) != !range1.contains(element0)) throw AssertionError()
    if (!(element0 !in 3u..<1u) != range1.contains(element0)) throw AssertionError()
}

fun testR1xE1() {
    // with possible local optimizations
    if (1u in 3u..<1u != range1.contains(1u)) throw AssertionError()
    if (1u !in 3u..<1u != !range1.contains(1u)) throw AssertionError()
    if (!(1u in 3u..<1u) != !range1.contains(1u)) throw AssertionError()
    if (!(1u !in 3u..<1u) != range1.contains(1u)) throw AssertionError()
    // no local optimizations
    if (element1 in 3u..<1u != range1.contains(element1)) throw AssertionError()
    if (element1 !in 3u..<1u != !range1.contains(element1)) throw AssertionError()
    if (!(element1 in 3u..<1u) != !range1.contains(element1)) throw AssertionError()
    if (!(element1 !in 3u..<1u) != range1.contains(element1)) throw AssertionError()
}

fun testR1xE2() {
    // with possible local optimizations
    if (2u in 3u..<1u != range1.contains(2u)) throw AssertionError()
    if (2u !in 3u..<1u != !range1.contains(2u)) throw AssertionError()
    if (!(2u in 3u..<1u) != !range1.contains(2u)) throw AssertionError()
    if (!(2u !in 3u..<1u) != range1.contains(2u)) throw AssertionError()
    // no local optimizations
    if (element2 in 3u..<1u != range1.contains(element2)) throw AssertionError()
    if (element2 !in 3u..<1u != !range1.contains(element2)) throw AssertionError()
    if (!(element2 in 3u..<1u) != !range1.contains(element2)) throw AssertionError()
    if (!(element2 !in 3u..<1u) != range1.contains(element2)) throw AssertionError()
}",fun testR1xE3() {
"return this is ConeIntegerConstantOperatorType
    }

    override fun TypeConstructorMarker.isLocalType(): Boolean {
        if (this !is ConeClassLikeLookupTag) return false
        return classId.isLocal
    }

    override fun TypeConstructorMarker.isAnonymous(): Boolean {
        if (this !is ConeClassLikeLookupTag) return false
        return name == SpecialNames.ANONYMOUS
    }

    override val TypeVariableTypeConstructorMarker.typeParameter: TypeParameterMarker?
        get() {
            require(this is ConeTypeVariableTypeConstructor)
            return this.originalTypeParameter
        }

    override fun SimpleTypeMarker.possibleIntegerTypes(): Collection<KotlinTypeMarker> {
        return (this as? ConeIntegerLiteralType)?.possibleTypes ?: emptyList()
    }

    override fun SimpleTypeMarker.fastCorrespondingSupertypes(constructor: TypeConstructorMarker): List<SimpleTypeMarker>? {
        require(this is ConeKotlinType)
        return session.correspondingSupertypesCache.getCorrespondingSupertypes(this, constructor)
    }

    override fun SimpleTypeMarker.isIntegerLiteralType(): Boolean {
        return this is ConeIntegerLiteralType
    }

    override fun KotlinTypeMarker.asSimpleType(): SimpleTypeMarker? {
        assert(this is ConeKotlinType)
        return when (this) {
            is ConeClassLikeType -> fullyExpandedType(session)
            is ConeSimpleKotlinType -> this
            is ConeFlexibleType -> null
            else -> errorWithAttachment(""Unknown simpleType: ${this::class}"") {
                withConeTypeEntry(""type"", this@asSimpleType as? ConeKotlinType)
            }
        }
    }

    override fun KotlinTypeMarker.asFlexibleType(): FlexibleTypeMarker? {
        assert(this is ConeKotlinType)
        return this as? ConeFlexibleType
    }

    override fun KotlinTypeMarker.isError(): Boolean {
        assert(this is ConeKotlinType)
        return this is ConeErrorType || this is ConeErrorType || this.typeConstructor().isError() ||
                (this is ConeClassLikeType && this.lookupTag is ConeClassLikeErrorLookupTag)
    }

    override fun KotlinTypeMarker.isUninferredParameter(): Boolean {
        assert(this is ConeKotlinType)
        return this is ConeErrorType && this.isUninferredParameter
    }

    override fun FlexibleTypeMarker.asDynamicType(): ConeDynamicType? {
        assert(this is ConeKotlinType)
        return this as? ConeDynamicType
    }",override fun KotlinTypeMarker.isRawType(): Boolean {
"}

    @Test
    fun `test - mainClass - set via DSL`() = buildProjectWithMPP().runLifecycleAwareTest {
        val kotlin = project.multiplatformExtension
        val mainRun = assertNotNull(kotlin.jvm().mainRun.await())
        val mainRunTask = mainRun.task.get()

        assertNull(
            mainRunTask.mainClass.orNull,
            ""Expected mainClass to be null: No mainClass set via DSL or property""
        )

        // Set mainClass via DSL
        mainRun.mainClass.set(""Foo"")
        assertEquals(""Foo"", mainRunTask.mainClass.orNull)
    }


    @Test
    fun `test - args`() = buildProjectWithMPP().runLifecycleAwareTest {
        val kotlin = project.multiplatformExtension
        val task = assertNotNull(kotlin.jvm().mainRun.await()).task.get()

        /* Set properties using 'args()' */
        kotlin.jvm().mainRun {
            args(""first"", ""second"")
            args(listOf(""third"", ""fourth""))
        }

        launch {
            assertEquals(listOf(""first"", ""second"", ""third"", ""fourth""), task.args)
        }


        /* Set property using .setArgs */
        kotlin.jvm().mainRun {
            setArgs(listOf(""1"", ""2""))
        }

        launch {
            assertEquals(listOf(""1"", ""2""), task.args)
        }
    }

    @Test
    fun `test - classpath - contains main compilation output by default`() = buildProjectWithMPP().runLifecycleAwareTest {
        repositories.mavenLocal()
        repositories.mavenCentralCacheRedirector()

        val kotlin = project.multiplatformExtension
        val mainRunTask = assertNotNull(kotlin.jvm().mainRun.await()).task.get()
        val mainCompilation = kotlin.jvm().compilations.main

        configurationResult.await()

        mainCompilation.output.allOutputs.files.ifEmpty { fail(""Expected some file in 'allOutputs'"") }
        if (!mainRunTask.classpath.files.containsAll(mainCompilation.output.allOutputs.files)) {
            fail(""Missing output from main compilation in '$mainRunTask'"")
        }
    }

    @Test
    fun `test - classpath - contains main compilation runtime dependencies`() = buildProjectWithMPP().runLifecycleAwareTest {
        repositories.mavenLocal()",repositories.mavenCentralCacheRedirector()
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.mpp.publication

import org.jetbrains.kotlin.gradle.testbase.GradleProject
import org.jetbrains.kotlin.gradle.util.replaceText
import org.jetbrains.kotlin.tooling.core.KotlinToolingVersion
import kotlin.io.path.appendText

fun GradleProject.prepareProjectForPublication(
    scenarioProject: Scenario.Project,
) {
    buildGradleKts.appendText(""\n"" + """"""group = ""${scenarioProject.packageName}"" """""")
    buildGradleKts.appendText(""\n"" + """"""version = ""1.0"" """""")
    settingsGradleKts.appendText(""\n"" + """"""rootProject.name = ""${scenarioProject.artifactName}"" """""")

    when (scenarioProject.variant) {
        ProjectVariant.AndroidOnly -> prepareAndroidOnlyProjectForPublication(scenarioProject)
        ProjectVariant.JavaOnly -> Unit
        is ProjectVariant.Kmp -> prepareKmpProjectForPublication(scenarioProject)
    }
}

private fun GradleProject.prepareAndroidOnlyProjectForPublication(
    scenarioProject: Scenario.Project
) {
    generateCode(scenarioProject, ""main"")
}

private fun GradleProject.prepareKmpProjectForPublication(
    scenarioProject: Scenario.Project,
) {
    val projectVariant = scenarioProject.variant
    check(projectVariant is ProjectVariant.Kmp)
    val kotlinVersion = checkNotNull(scenarioProject.kotlinVersion)

    generateCode(scenarioProject, ""commonMain"")
    generateCode(scenarioProject, ""nativeMain"")

    if (projectVariant.withJvm) {
        buildGradleKts.replaceText(""// jvm() // JVM"", ""jvm() // JVM"")
        generateCode(scenarioProject, ""jvmMain"")
    }

    if (projectVariant.withAndroid) {
        if (kotlinVersion < KotlinToolingVersion(""1.9.20"")) {
            buildGradleKts.replaceText(""androidTarget"", ""android"")
        }
        buildGradleKts.replaceText(""// id(\""com.android.library\"") // AGP"", ""id(\""com.android.library\"") // AGP"")","buildGradleKts.replaceText(""/* Begin AGP"", ""// /* Begin AGP"")"
"annotation class RawDelimiter

    object Delimiters {
        const val default = "",""
        const val none = """"
        const val pathSeparator = ""<path_separator>""
    }
}

val Argument.isAdvanced: Boolean
    get() = isSpecial(ADVANCED_ARGUMENT_PREFIX)

val Argument.isInternal: Boolean
    get() = isSpecial(INTERNAL_ARGUMENT_PREFIX)

private fun Argument.isSpecial(prefix: String): Boolean {
    return value.startsWith(prefix) && value.length > prefix.length
}

@OptIn(Argument.RawDelimiter::class)
val Argument.resolvedDelimiter: String?
    get() = when (delimiter) {
        Argument.Delimiters.none -> null
        Argument.Delimiters.pathSeparator -> File.pathSeparator
        else -> delimiter
    }

private const val ADVANCED_ARGUMENT_PREFIX = ""-X""
internal const val INTERNAL_ARGUMENT_PREFIX = ""-XX""
private const val FREE_ARGS_DELIMITER = ""--""

data class ArgumentParseErrors(
    val unknownArgs: MutableList<String> = SmartList(),

    val unknownExtraFlags: MutableList<String> = SmartList(),

    // Names of extra (-X...) arguments which have been passed in an obsolete form (""-Xaaa bbb"", instead of ""-Xaaa=bbb"")
    val extraArgumentsPassedInObsoleteForm: MutableList<String> = SmartList(),

    // Non-boolean arguments which have been passed multiple times, possibly with different values.
    // The key in the map is the name of the argument, the value is the last passed value.
    val duplicateArguments: MutableMap<String, String> = mutableMapOf(),

    // Arguments where [Argument.deprecatedName] was used; the key is the deprecated name, the value is the new name ([Argument.value])
    val deprecatedArguments: MutableMap<String, String> = mutableMapOf(),

    var argumentWithoutValue: String? = null,

    var booleanArgumentWithValue: String? = null,

    val argfileErrors: MutableList<String> = SmartList(),

    // Reports from internal arguments parsers
    val internalArgumentsParsingProblems: MutableList<String> = SmartList()
)

inline fun <reified T : CommonToolArguments> parseCommandLineArguments(args: List<String>): T {
    return parseCommandLineArguments(T::class, args)
}

fun <T : CommonToolArguments> parseCommandLineArguments(clazz: KClass<T>, args: List<String>): T {
    val constructor = clazz.java.constructors.find { it.parameters.isEmpty() }
        ?: error(""Missing empty constructor on '${clazz.java.name}"")
    val arguments = clazz.cast(constructor.newInstance())
    parseCommandLineArguments(args, arguments)",return arguments
"assertNoDuplicateLibraryWarning()
                }

                build("":p1:compileAppleMainKotlinMetadata"") {
                    assertDirectoryInProjectExists(""p1/build/classes/kotlin/metadata/appleMain/klib/p1_appleMain"")
                    assertNoDuplicateLibraryWarning()
                }
            }

            build("":p1:compileLinuxMainKotlinMetadata"") {
                assertDirectoryInProjectExists(""p1/build/classes/kotlin/metadata/linuxMain/klib/p1_linuxMain"")
                assertNoDuplicateLibraryWarning()
            }

            build("":p1:compileAppleAndLinuxMainKotlinMetadata"") {
                assertDirectoryInProjectExists(""p1/build/classes/kotlin/metadata/appleAndLinuxMain/klib/p1_appleAndLinuxMain"")
                assertNoDuplicateLibraryWarning()
            }

            build("":p1:compileNativeMainKotlinMetadata"") {
                assertDirectoryInProjectExists(""p1/build/classes/kotlin/metadata/nativeMain/klib/p1_nativeMain"")
                assertNoDuplicateLibraryWarning()
            }

            build("":p1:compileConcurrentMainKotlinMetadata"") {
                assertDirectoryInProjectExists(""p1/build/classes/kotlin/metadata/concurrentMain/default"")
                assertNoDuplicateLibraryWarning()
            }
        }
    }

    @DisplayName(""Commonize hierarchically Klibrary compilations"")
    @GradleTest
    fun testCommonizeHierarchicallyKlibraryCompilations(gradleVersion: GradleVersion) {
        nativeProject(""commonizeHierarchically"", gradleVersion) {
            if (HostManager.hostIsMac) {
                build("":p1:iosArm64MainKlibrary"", "":p1:iosX64MainKlibrary"", "":p1:macosX64MainKlibrary"", "":p1:macosArm64MainKLibrary"") {
                    assertFileInProjectExists(""p1/build/classes/kotlin/iosArm64/main/klib/p1.klib"")
                    assertFileInProjectExists(""p1/build/classes/kotlin/iosX64/main/klib/p1.klib"")
                    assertFileInProjectExists(""p1/build/classes/kotlin/macosX64/main/klib/p1.klib"")
                    assertFileInProjectExists(""p1/build/classes/kotlin/macosArm64/main/klib/p1.klib"")
                    assertNoDuplicateLibraryWarning()
                }
            }

            build("":p1:linuxX64MainKlibrary"", "":p1:linuxArm64MainKlibrary"") {
                assertFileInProjectExists(""p1/build/classes/kotlin/linuxX64/main/klib/p1.klib"")
                assertFileInProjectExists(""p1/build/classes/kotlin/linuxArm64/main/klib/p1.klib"")
                assertNoDuplicateLibraryWarning()
            }

            build("":p1:mingwX64MainKlibrary"") {
                assertFileInProjectExists(""p1/build/classes/kotlin/mingwX64/main/klib/p1.klib"")
                assertNoDuplicateLibraryWarning()
            }
        }
    }

    @DisplayName(""Commonize hierarchically multi module"")
    @GradleTest
    fun testCommonizeHierarchicallyMultiModule(gradleVersion: GradleVersion) {
        nativeProject(""commonizeHierarchicallyMultiModule"", gradleVersion) {
            build(""assemble"") {
                assertTasksExecuted("":p1:commonizeCInterop"")
                assertTasksExecuted("":p2:commonizeCInterop"")","assertTasksExecuted("":p3:commonizeCInterop"")"
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.psi

import com.intellij.lang.ASTNode
import com.intellij.psi.PsiElement
import com.intellij.psi.PsiNameIdentifierOwner",import com.intellij.psi.search.LocalSearchScope
"// MODULE: m1-common
// FILE: common.kt

expect class A private constructor() {
    <!EXPECTED_PRIVATE_DECLARATION, EXPECTED_PRIVATE_DECLARATION{JVM}!>private<!> fun foo()
    <!EXPECTED_PRIVATE_DECLARATION, EXPECTED_PRIVATE_DECLARATION{JVM}!>private<!> val bar: String
    <!EXPECTED_PRIVATE_DECLARATION, EXPECTED_PRIVATE_DECLARATION{JVM}!>private<!> fun Int.memExt(): Any

    <!EXPECTED_PRIVATE_DECLARATION, EXPECTED_PRIVATE_DECLARATION{JVM}!>private<!> class Nested

    var baz: Any?
        private set
}

// MODULE: m1-jvm()()(m1-common)
// FILE: jvm.kt",actual class A actual private constructor() {
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.transformers.irToJs

import org.jetbrains.kotlin.ir.backend.js.utils.JsMainFunctionDetector
import org.jetbrains.kotlin.ir.backend.js.utils.emptyScope
import org.jetbrains.kotlin.js.backend.ast.*
import org.jetbrains.kotlin.serialization.js.ModuleKind
import org.jetbrains.kotlin.utils.DFS
import org.jetbrains.kotlin.utils.addToStdlib.partitionIsInstance

class Merger(
    private val moduleName: String,
    private val moduleKind: ModuleKind,","private val fragments: List<JsIrProgramFragment>,"
"// IGNORE_BACKEND: WASM
// WASM_MUTE_REASON: FAILS_IN_JS_IR
// IGNORE_BACKEND: JS, JS_IR
// IGNORE_BACKEND: JS_IR_ES6
// FILE: test.kt

fun checkEqual(x: Any, y: Any) {
    if (x != y || y != x) throw AssertionError(""$x and $y should be equal"")
    if (x.hashCode() != y.hashCode()) throw AssertionError(""$x and $y should have the same hash code"")
}

fun checkNotEqual(x: Any, y: Any) {
    if (x == y || y == x) throw AssertionError(""$x and $y should NOT be equal"")
}

fun target(x: Int, y: String = """", z: String = """"): Int = x

fun captureNoDefaults(fn: (Int, String, String) -> Unit): Any = fn
fun captureOneDefault(fn: (Int, String) -> Unit): Any = fn
fun captureAllDefaults(fn: (Int) -> Unit): Any = fn
fun captureOneDefaultWithoutCoercionToUnit(fn: (Int, String) -> Int): Any = fn

fun box(): String {
    checkEqual(captureNoDefaults(::target), captureNoDefaults(::target))","checkEqual(captureOneDefault(::target), captureOneDefault(::target))"
"// WITH_STDLIB

/*
 * KOTLIN CODEGEN BOX SPEC TEST (POSITIVE)
 *
 * SPEC VERSION: 0.1-268
 * MAIN LINK: overload-resolution, callables-and-invoke-convention -> paragraph 5 -> sentence 1
 * PRIMARY LINKS: overload-resolution, callables-and-invoke-convention -> paragraph 2 -> sentence 2
 * overload-resolution, callables-and-invoke-convention -> paragraph 2 -> sentence 8
 * overload-resolution, callables-and-invoke-convention -> paragraph 2 -> sentence 10
 * NUMBER: 9
 * DESCRIPTION: function-like prio is higher than property-like callables
 */

// FILE: KotlinLib.kt
package test.lib
class MyClass {
    //property-like (II prio)
    companion object foo {
        var fooCompanionObj = false",operator fun invoke() {
"// FILE: lib.kt

package utils

inline fun foo(a: Int) {
    bar(a)
}

inline fun bar(a: Int) {
    try {
        if (a > 0) throw Exception()","log(""foo($a) #1"")"
"fun testR0xE0() {
    // with possible local optimizations
    if (0uL in 1uL..<3uL != range0.contains(0uL)) throw AssertionError()
    if (0uL !in 1uL..<3uL != !range0.contains(0uL)) throw AssertionError()
    if (!(0uL in 1uL..<3uL) != !range0.contains(0uL)) throw AssertionError()
    if (!(0uL !in 1uL..<3uL) != range0.contains(0uL)) throw AssertionError()
    // no local optimizations
    if (element0 in 1uL..<3uL != range0.contains(element0)) throw AssertionError()
    if (element0 !in 1uL..<3uL != !range0.contains(element0)) throw AssertionError()
    if (!(element0 in 1uL..<3uL) != !range0.contains(element0)) throw AssertionError()
    if (!(element0 !in 1uL..<3uL) != range0.contains(element0)) throw AssertionError()
}

fun testR0xE1() {
    // with possible local optimizations
    if (1uL in 1uL..<3uL != range0.contains(1uL)) throw AssertionError()
    if (1uL !in 1uL..<3uL != !range0.contains(1uL)) throw AssertionError()
    if (!(1uL in 1uL..<3uL) != !range0.contains(1uL)) throw AssertionError()
    if (!(1uL !in 1uL..<3uL) != range0.contains(1uL)) throw AssertionError()
    // no local optimizations
    if (element1 in 1uL..<3uL != range0.contains(element1)) throw AssertionError()
    if (element1 !in 1uL..<3uL != !range0.contains(element1)) throw AssertionError()
    if (!(element1 in 1uL..<3uL) != !range0.contains(element1)) throw AssertionError()
    if (!(element1 !in 1uL..<3uL) != range0.contains(element1)) throw AssertionError()
}

fun testR0xE2() {
    // with possible local optimizations
    if (2uL in 1uL..<3uL != range0.contains(2uL)) throw AssertionError()
    if (2uL !in 1uL..<3uL != !range0.contains(2uL)) throw AssertionError()
    if (!(2uL in 1uL..<3uL) != !range0.contains(2uL)) throw AssertionError()
    if (!(2uL !in 1uL..<3uL) != range0.contains(2uL)) throw AssertionError()
    // no local optimizations
    if (element2 in 1uL..<3uL != range0.contains(element2)) throw AssertionError()
    if (element2 !in 1uL..<3uL != !range0.contains(element2)) throw AssertionError()
    if (!(element2 in 1uL..<3uL) != !range0.contains(element2)) throw AssertionError()
    if (!(element2 !in 1uL..<3uL) != range0.contains(element2)) throw AssertionError()
}

fun testR0xE3() {
    // with possible local optimizations
    if (3uL in 1uL..<3uL != range0.contains(3uL)) throw AssertionError()
    if (3uL !in 1uL..<3uL != !range0.contains(3uL)) throw AssertionError()
    if (!(3uL in 1uL..<3uL) != !range0.contains(3uL)) throw AssertionError()
    if (!(3uL !in 1uL..<3uL) != range0.contains(3uL)) throw AssertionError()
    // no local optimizations
    if (element3 in 1uL..<3uL != range0.contains(element3)) throw AssertionError()
    if (element3 !in 1uL..<3uL != !range0.contains(element3)) throw AssertionError()
    if (!(element3 in 1uL..<3uL) != !range0.contains(element3)) throw AssertionError()
    if (!(element3 !in 1uL..<3uL) != range0.contains(element3)) throw AssertionError()
}

fun testR0xE4() {
    // with possible local optimizations
    if (4uL in 1uL..<3uL != range0.contains(4uL)) throw AssertionError()
    if (4uL !in 1uL..<3uL != !range0.contains(4uL)) throw AssertionError()
    if (!(4uL in 1uL..<3uL) != !range0.contains(4uL)) throw AssertionError()
    if (!(4uL !in 1uL..<3uL) != range0.contains(4uL)) throw AssertionError()
    // no local optimizations
    if (element4 in 1uL..<3uL != range0.contains(element4)) throw AssertionError()
    if (element4 !in 1uL..<3uL != !range0.contains(element4)) throw AssertionError()
    if (!(element4 in 1uL..<3uL) != !range0.contains(element4)) throw AssertionError()
    if (!(element4 !in 1uL..<3uL) != range0.contains(element4)) throw AssertionError()
}",fun testR1xE0() {
"source,
                    origin = defaultDeserializationOrigin,
                    deserializeNestedClass = this::getClass,
                )

                if (resolvedLibrary is KotlinLibrary) {
                    symbol.fir.klibSourceFile = loadKlibSourceFileExtensionOrNull(
                        resolvedLibrary, nameResolver, classProto, KlibMetadataProtoBuf.classFile
                    )
                }

                symbol.fir.isNewPlaceForBodyGeneration = isNewPlaceForBodyGeneration(classProto)
            }
        }

        return null
    }

    private inline fun forEachFragmentInPackage(
        packageFqName: FqName,
        f: (L, ProtoBuf.PackageFragment, NameResolver) -> Unit
    ) {
        val packageStringName = packageFqName.asString()

        val librariesWithFragment = fragmentNamesInLibraries[packageStringName] ?: return

        for (resolvedLibrary in librariesWithFragment) {
            for (packageMetadataPart in resolvedLibrary.packageMetadataParts(packageStringName)) {

                val fragment = getPackageFragment(resolvedLibrary, packageStringName, packageMetadataPart)

                val nameResolver = NameResolverImpl(
                    fragment.strings,
                    fragment.qualifiedNames,
                )

                f(resolvedLibrary, fragment, nameResolver)
            }
        }
    }

    override fun loadFunctionExtensions(packagePart: PackagePartsCacheData, proto: ProtoBuf.Function, fir: FirFunction) {
        fir.klibSourceFile = loadKlibSourceFileExtensionOrNull(packagePart, proto, KlibMetadataProtoBuf.functionFile) ?: return
    }

    override fun loadPropertyExtensions(packagePart: PackagePartsCacheData, proto: ProtoBuf.Property, fir: FirProperty) {
        fir.klibSourceFile = loadKlibSourceFileExtensionOrNull(packagePart, proto, KlibMetadataProtoBuf.propertyFile) ?: return
    }

    private fun <T : GeneratedMessageLite.ExtendableMessage<T>> loadKlibSourceFileExtensionOrNull(
        packagePart: PackagePartsCacheData, proto: T, sourceFileExtension: GeneratedExtension<T, Int>,
    ): DeserializedSourceFile? {
        val library = (packagePart.extra as? MetadataLibraryPackagePartCacheDataExtra)?.library as? KotlinLibrary ?: return null
        return loadKlibSourceFileExtensionOrNull(library, packagePart.context.nameResolver, proto, sourceFileExtension)
    }

    private fun <T : GeneratedMessageLite.ExtendableMessage<T>> loadKlibSourceFileExtensionOrNull(
        library: KotlinLibrary, nameResolver: NameResolver, proto: T, sourceFileExtension: GeneratedExtension<T, Int>,
    ): DeserializedSourceFile? {
        return proto.getExtensionOrNull(sourceFileExtension)
            ?.let { fileId -> nameResolver.getString(fileId) }
            ?.let { fileName -> DeserializedSourceFile(fileName, library) }
    }",protected abstract fun createDeserializedContainerSource(
"IrConstKind.Byte -> Type.BYTE_TYPE
                    IrConstKind.Short -> Type.SHORT_TYPE
                    IrConstKind.String -> JAVA_STRING_TYPE
                    IrConstKind.Null -> OBJECT_TYPE
                }
                generator.putValueOrProcessConstant(StackValue.constant(arg.value, type, null))
            } else {
                val value = arg.accept(this, data)
                val generatingType = if (value.type == Type.VOID_TYPE) AsmTypes.UNIT_TYPE else value.type
                value.materializeAt(generatingType, value.irType)
                generator.invokeAppend(generatingType)
            }
        }
        generator.genToString()
        return MaterialValue(this@ExpressionCodegen, JAVA_STRING_TYPE, context.irBuiltIns.stringType)
    }

    override fun visitGetClass(expression: IrGetClass, data: BlockInfo): PromisedValue =
        generateClassLiteralReference(expression, wrapIntoKClass = true, wrapPrimitives = false, data = data)

    override fun visitClassReference(expression: IrClassReference, data: BlockInfo): PromisedValue =
        generateClassLiteralReference(expression, wrapIntoKClass = true, wrapPrimitives = false, data = data)

    fun generateClassLiteralReference(
        classReference: IrExpression,
        wrapIntoKClass: Boolean,
        wrapPrimitives: Boolean,
        data: BlockInfo
    ): MaterialValue {
        when (classReference) {
            is IrGetClass -> {
                // TODO transform one sort of access into the other?
                JavaClassProperty.invokeWith(classReference.argument.accept(this, data), wrapPrimitives)
            }
            is IrClassReference -> {
                val classType = classReference.classType
                val classifier = classType.classifierOrNull
                if (classifier is IrTypeParameterSymbol) {
                    val success = putReifiedOperationMarkerIfTypeIsReifiedParameter(classType, ReifiedTypeInliner.OperationKind.JAVA_CLASS)
                    assert(success) {
                        ""Non-reified type parameter under ::class should be rejected by type checker: ${classType.render()}""
                    }
                }

                generateClassInstance(mv, classType, typeMapper, wrapPrimitives)
            }
            else -> {
                throw AssertionError(""not an IrGetClass or IrClassReference: ${classReference.dump()}"")
            }
        }

        if (wrapIntoKClass) {
            wrapJavaClassIntoKClass(mv)
        }
        return classReference.onStack
    }

    private fun getOrCreateCallGenerator(
        element: IrFunctionAccessExpression,
        data: BlockInfo,
        signature: JvmMethodSignature
    ): IrCallGenerator {
        if (!element.symbol.owner.isInlineFunctionCall(context) ||
            classCodegen.irClass.fileParent.fileEntry is MultifileFacadeFileEntry ||
            irFunction.origin == JvmLoweredDeclarationOrigin.JVM_STATIC_WRAPPER ||",irFunction.isInvokeSuspendOfContinuation()
"package a

internal interface InternalInterface",public class PublicClass {
"}

    override fun transformDesugaredAssignmentValueReferenceExpression(
        desugaredAssignmentValueReferenceExpression: FirDesugaredAssignmentValueReferenceExpression,
        data: ResolutionMode,
    ): FirStatement {
        val referencedExpression = desugaredAssignmentValueReferenceExpression.expressionRef.value
        if (referencedExpression is FirQualifiedAccessExpression) {
            val typeFromCallee = components.typeFromCallee(referencedExpression)
            desugaredAssignmentValueReferenceExpression.resultType = session.typeApproximator.approximateToSubType(
                typeFromCallee.type,
                TypeApproximatorConfiguration.FinalApproximationAfterResolutionAndInference
            ) ?: typeFromCallee.type
        } else {
            desugaredAssignmentValueReferenceExpression.resultType = referencedExpression.resolvedType
        }
        return desugaredAssignmentValueReferenceExpression
    }

    override fun transformVariableAssignment(
        variableAssignment: FirVariableAssignment,
        data: ResolutionMode,
    ): FirStatement = whileAnalysing(session, variableAssignment) {
        variableAssignment.transformAnnotations(transformer, ResolutionMode.ContextIndependent)

        variableAssignment.transformLValue(transformer, ResolutionMode.AssignmentLValue(variableAssignment))

        val resolvedReference = variableAssignment.calleeReference

        if (assignAltererExtensions != null && resolvedReference is FirResolvedNamedReference) {
            val alteredAssignments = assignAltererExtensions.mapNotNull { alterer ->
                alterer.transformVariableAssignment(variableAssignment)?.let { it to alterer }
            }
            when (alteredAssignments.size) {
                0 -> {}
                1 -> {
                    val transformedAssignment = alteredAssignments.first().first
                    return transformedAssignment.transform(transformer, ResolutionMode.ContextIndependent)
                }

                else -> {
                    val extensionNames = alteredAssignments.map { it.second::class.qualifiedName }
                    val errorLValue = buildErrorExpression {
                        expression = variableAssignment.lValue
                        source = variableAssignment.lValue.source?.fakeElement(KtFakeSourceElementKind.AssignmentLValueError)
                        diagnostic = ConeAmbiguousAlteredAssign(extensionNames)
                    }
                    variableAssignment.replaceLValue(errorLValue)
                }
            }
        }

        val result = context.withAssignmentRhs {
            variableAssignment.transformRValue(
                transformer,
                withExpectedType(
                    variableAssignment.lValue.resolvedType.toFirResolvedTypeRef(),
                    expectedTypeMismatchIsReportedInChecker = true,
                ),
            )
        }

        // for cases like
        // buildSomething { tVar = """" // Should infer TV from String assignment }
        context.inferenceSession.addSubtypeConstraintIfCompatible(","lowerType = variableAssignment.rValue.resolvedType,"
"interface TextField {
    fun getText(): String
    fun setText(text: String)
}

class SimpleTextField : TextField {","private var text2 = """""
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer.mergedtree

import org.jetbrains.kotlin.commonizer.cir.CirName
import org.jetbrains.kotlin.commonizer.cir.CirPackage
import org.jetbrains.kotlin.commonizer.cir.CirPackageName
import org.jetbrains.kotlin.commonizer.utils.CommonizedGroup
import org.jetbrains.kotlin.commonizer.utils.CommonizerMap
import org.jetbrains.kotlin.commonizer.utils.firstNonNull
import org.jetbrains.kotlin.storage.NullableLazyValue

class CirPackageNode(
    override val targetDeclarations: CommonizedGroup<CirPackage>,
    override val commonDeclaration: NullableLazyValue<CirPackage>",") : CirNodeWithMembers<CirPackage, CirPackage> {"
"internal fun getMethodImplForTextTrackCueList(obj: TextTrackCueList, index: Int): TextTrackCue? { js(""return obj[index];"") }

public operator fun TextTrackCueList.get(index: Int): TextTrackCue? = getMethodImplForTextTrackCueList(this, index)

/**
 * Exposes the JavaScript [TextTrackCue](https://developer.mozilla.org/en/docs/Web/API/TextTrackCue) to Kotlin
 */
public external abstract class TextTrackCue : EventTarget, JsAny {
    open val track: TextTrack?
    open var id: String
    open var startTime: Double
    open var endTime: Double
    open var pauseOnExit: Boolean
    open var onenter: ((Event) -> Unit)?
    open var onexit: ((Event) -> Unit)?
}

/**
 * Exposes the JavaScript [TimeRanges](https://developer.mozilla.org/en/docs/Web/API/TimeRanges) to Kotlin
 */
public external abstract class TimeRanges : JsAny {
    open val length: Int
    fun start(index: Int): Double
    fun end(index: Int): Double
}

/**
 * Exposes the JavaScript [TrackEvent](https://developer.mozilla.org/en/docs/Web/API/TrackEvent) to Kotlin
 */
public external open class TrackEvent(type: String, eventInitDict: TrackEventInit = definedExternally) : Event, JsAny {
    open val track: UnionAudioTrackOrTextTrackOrVideoTrack?

    companion object {
        val NONE: Short
        val CAPTURING_PHASE: Short
        val AT_TARGET: Short
        val BUBBLING_PHASE: Short
    }
}

public external interface TrackEventInit : EventInit, JsAny {
    var track: UnionAudioTrackOrTextTrackOrVideoTrack? /* = null */
        get() = definedExternally
        set(value) = definedExternally
}

@Suppress(""UNUSED_PARAMETER"")
public fun TrackEventInit(track: UnionAudioTrackOrTextTrackOrVideoTrack? = null, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): TrackEventInit { js(""return { track, bubbles, cancelable, composed };"") }

/**
 * Exposes the JavaScript [HTMLMapElement](https://developer.mozilla.org/en/docs/Web/API/HTMLMapElement) to Kotlin
 */
public external abstract class HTMLMapElement : HTMLElement, JsAny {
    open var name: String
    open val areas: HTMLCollection

    companion object {
        val ELEMENT_NODE: Short
        val ATTRIBUTE_NODE: Short
        val TEXT_NODE: Short
        val CDATA_SECTION_NODE: Short
        val ENTITY_REFERENCE_NODE: Short
        val ENTITY_NODE: Short
        val PROCESSING_INSTRUCTION_NODE: Short
        val COMMENT_NODE: Short",val DOCUMENT_NODE: Short
"// !LANGUAGE: +AllowContractsForCustomFunctions +UseReturnsEffect
// !OPT_IN: kotlin.contracts.ExperimentalContracts
// !DIAGNOSTICS: -INVISIBLE_REFERENCE -INVISIBLE_MEMBER

import kotlin.contracts.*

fun isString(x: Any?): Boolean {
    contract {
        returns(true) implies (x is String)
    }
    return x is String
}

fun exhaustive(x: Any?) {
    when (isString(x)) {
        true -> <!DEBUG_INFO_SMARTCAST!>x<!>.length
        false -> x.<!UNRESOLVED_REFERENCE!>length<!>
    }",when(!isString(x)) {
"// IGNORE_BACKEND: JS
// WITH_STDLIB
// WITH_COROUTINES
import helpers.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*


class Controller {
    var result = """"

    suspend fun <T> suspendWithResult(value: T): T = suspendCoroutineUninterceptedOrReturn { c ->
        c.resume(value)
        COROUTINE_SUSPENDED
    }
}

fun builder(c: suspend Controller.() -> Unit): String {",val controller = Controller()
"// FILE: B.kt

import aa.A.use
import aa.A.useList

fun testPrimitives(b: Byte, ss: Short, i: Int, l: Long, d: Double, s: String, f: Float, bool: Boolean) {
    use(b)
    use(ss)
    use(i)
    use(l)
    use(s)
    use(f)
    use(d)
    use(bool)
}

class N
class S: java.io.Serializable

fun testArrays(ia: IntArray, ai: Array<Int>, an: Array<N>, a: Array<S>) {
    use(ia)
    use(ai)
    use(an)
    use(a)
}

fun testLiterals() {
    use(1)
    use(1.0)
    use(11111111111111)
    use(""Asdsd"")
    use(true)
}

fun testNotSerializable(l: List<Int>) {
    use(<!TYPE_MISMATCH!>l<!>)
    use(<!TYPE_MISMATCH!>N()<!>)
}

enum class C {
    E, E2
}

fun testEnums(a: Enum<*>) {
    use(C.E)
    use(C.E2)
    use(a)
}

fun testLists(a: List<Int>) {",useList(a)
"* @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.
 * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].
 */
public actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {
    checkCopyOfRangeArguments(fromIndex, toIndex, size)
    return copyOfUninitializedElements(fromIndex, toIndex)
}

/**
 * Returns a new array which is a copy of the specified range of the original array.
 * 
 * @param fromIndex the start of the range (inclusive) to copy.
 * @param toIndex the end of the range (exclusive) to copy.
 * 
 * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.
 * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].
 */
public actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {
    checkCopyOfRangeArguments(fromIndex, toIndex, size)
    return copyOfUninitializedElements(fromIndex, toIndex)
}

/**
 * Returns a new array which is a copy of the specified range of the original array.
 * 
 * @param fromIndex the start of the range (inclusive) to copy.
 * @param toIndex the end of the range (exclusive) to copy.
 * 
 * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.
 * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].
 */
public actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {
    checkCopyOfRangeArguments(fromIndex, toIndex, size)
    return copyOfUninitializedElements(fromIndex, toIndex)
}

/**
 * Returns new array which is a copy of the original array's range between [fromIndex] (inclusive)
 * and [toIndex] (exclusive) with new elements filled with **lateinit** _uninitialized_ values.
 * Attempts to read _uninitialized_ values from this array work in implementation-dependent manner,
 * either throwing exception or returning some kind of implementation-specific default value.
 */
internal fun <T> Array<T>.copyOfUninitializedElements(fromIndex: Int, toIndex: Int): Array<T> {
    val newSize = toIndex - fromIndex
    if (newSize < 0) {
        throw IllegalArgumentException(""$fromIndex > $toIndex"")
    }
    val result = arrayOfUninitializedElements<T>(newSize)
    this.copyInto(result, 0, fromIndex, toIndex.coerceAtMost(size))
    return result
}

/**
 * Returns new array which is a copy of the original array's range between [fromIndex] (inclusive)
 * and [toIndex] (exclusive) with new elements filled with **lateinit** _uninitialized_ values.
 * Attempts to read _uninitialized_ values from this array work in implementation-dependent manner,
 * either throwing exception or returning some kind of implementation-specific default value.
 */
internal fun ByteArray.copyOfUninitializedElements(fromIndex: Int, toIndex: Int): ByteArray {
    val newSize = toIndex - fromIndex
    if (newSize < 0) {
        throw IllegalArgumentException(""$fromIndex > $toIndex"")
    }
    val result = ByteArray(newSize)
    this.copyInto(result, 0, fromIndex, toIndex.coerceAtMost(size))",return result
"// EXPECTED_REACHABLE_NODES: 1286
/*
 * Copy of JVM-backend test
 * Found at: compiler/testData/codegen/boxInline/lambdaTransformation/lambdaCloning.1.kt
 */

// FILE: foo.kt
package foo

import test.*

fun test1(s: Long): String {
    return doSmth(s)
}

fun test2(s: Int): String {
    return doSmth2(s)
}

fun box(): String {",var result = test1(11)
"package com.example.dagger.kotlin

class DemoApplication : BaseApplication() {
    lateinit var component: ApplicationComponent

    override fun onCreate() {
        super.onCreate()
        val component = initDaggerComponent()","component.inject(this) // As of now, LocationManager should be injected into this."
"// !DIAGNOSTICS: -UNUSED_VARIABLE -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_PARAMETER -UNUSED_EXPRESSION
// SKIP_TXT

/*
 * KOTLIN DIAGNOSTICS SPEC TEST (POSITIVE)
 *
 * SPEC VERSION: 0.1-268
 * MAIN LINK: overload-resolution, building-the-overload-candidate-set-ocs, call-with-an-explicit-receiver -> paragraph 6 -> sentence 1
 * PRIMARY LINKS: overload-resolution, c-level-partition -> paragraph 1 -> sentence 1
 * overload-resolution, building-the-overload-candidate-set-ocs, call-with-an-explicit-receiver -> paragraph 3 -> sentence 1
 * overload-resolution, building-the-overload-candidate-set-ocs, call-with-an-explicit-receiver -> paragraph 2 -> sentence 1
 * overload-resolution, receivers -> paragraph 7 -> sentence 2
 * overload-resolution, receivers -> paragraph 7 -> sentence 3
 * NUMBER: 1
 * DESCRIPTION: sets of non-extension member callables only
 */

package tests.test2

// TESTCASE NUMBER: 1
open class Case1() {",companion object foo {
"internal val serializationExceptionName = ""kotlinx/serialization/$SERIAL_EXC""
internal val serializationExceptionMissingFieldName = ""kotlinx/serialization/$MISSING_FIELD_EXC""
internal val serializationExceptionUnknownIndexName = ""kotlinx/serialization/$UNKNOWN_FIELD_EXC""

internal val annotationType = Type.getObjectType(""java/lang/annotation/Annotation"")
internal val annotationArrayType = Type.getObjectType(""[${annotationType.descriptor}"")
internal val doubleAnnotationArrayType = Type.getObjectType(""[${annotationArrayType.descriptor}"")
internal val stringType = AsmTypes.JAVA_STRING_TYPE
internal val stringArrayType = Type.getObjectType(""[${stringType.descriptor}"")

internal val descriptorGetterName = JvmAbi.getterName(SERIAL_DESC_FIELD)
internal val getLazyValueName = JvmAbi.getterName(""value"")

val OPT_MASK_TYPE: Type = Type.INT_TYPE
val OPT_MASK_BITS = 32

// compare with zero. if result == 0, property was not seen.
internal fun InstructionAdapter.genValidateProperty(index: Int, bitMaskAddress: Int) {
    load(bitMaskAddress, OPT_MASK_TYPE)
    iconst(1 shl (index % OPT_MASK_BITS))
    and(OPT_MASK_TYPE)
    iconst(0)
}

internal fun InstructionAdapter.genMissingFieldExceptionThrow(fieldName: String) {
    anew(Type.getObjectType(serializationExceptionMissingFieldName))
    dup()
    aconst(fieldName)
    invokespecial(serializationExceptionMissingFieldName, ""<init>"", ""(Ljava/lang/String;)V"", false)
    checkcast(Type.getObjectType(""java/lang/Throwable""))
    athrow()
}

fun InstructionAdapter.genKOutputMethodCall(
    property: SerializableProperty, classCodegen: ImplementationBodyCodegen, expressionCodegen: ExpressionCodegen,
    propertyOwnerType: Type, ownerVar: Int, fromClassStartVar: Int? = null,
    generator: AbstractSerialGenerator
) {
    val propertyType = classCodegen.typeMapper.mapType(property.type)
    val sti = generator.getSerialTypeInfo(property, propertyType)
    val useSerializer = if (fromClassStartVar == null) stackValueSerializerInstanceFromSerializer(expressionCodegen, classCodegen, sti, generator)
    else stackValueSerializerInstanceFromClass(expressionCodegen, classCodegen, sti, fromClassStartVar, generator)
    val actualType = ImplementationBodyCodegen.genPropertyOnStack(
        this,
        expressionCodegen.context,
        property.descriptor,
        propertyOwnerType,
        ownerVar,
        classCodegen.state
    )
    actualType?.type?.let { type -> StackValue.coerce(type, sti.type, this) }
    invokeinterface(
        kOutputType.internalName,
        CallingConventions.encode + sti.elementMethodPrefix + (if (useSerializer) ""Serializable"" else """") + CallingConventions.elementPostfix,
        ""("" + descType.descriptor + ""I"" +
                (if (useSerializer) kSerialSaverType.descriptor else """") +
                (sti.type.descriptor) + "")V""
    )
}

internal fun InstructionAdapter.buildInternalConstructorDesc(
    propsStartVar: Int,
    bitMaskBase: Int,
    codegen: ClassBodyCodegen,
    args: List<SerializableProperty>",): String {
"fun IrConstantArrayImpl(
    startOffset: Int,
    endOffset: Int,
    type: IrType,
    initElements: List<IrConstantValue>,
) = IrConstantArrayImpl(
    constructorIndicator = null,
    startOffset = startOffset,
    endOffset = endOffset,
    type = type,
).apply {
    elements.addAll(initElements)
}

fun IrConstantObjectImpl(
    startOffset: Int,
    endOffset: Int,
    constructor: IrConstructorSymbol,
    initValueArguments: List<IrConstantValue>,
    initTypeArguments: List<IrType>,
    type: IrType = constructor.owner.constructedClassType,
) = IrConstantObjectImpl(
    constructorIndicator = null,
    startOffset = startOffset,
    endOffset = endOffset,
    constructor = constructor,
    type = type,
).apply {
    valueArguments.addAll(initValueArguments)
    typeArguments.addAll(initTypeArguments)
}

fun IrConstantPrimitiveImpl(
    startOffset: Int,
    endOffset: Int,
    value: IrConst<*>,
) = IrConstantPrimitiveImpl(
    constructorIndicator = null,
    startOffset = startOffset,
    endOffset = endOffset,
    value = value,
    type = value.type,
)

fun <T> IrConstImpl(
    startOffset: Int,
    endOffset: Int,
    type: IrType,
    kind: IrConstKind<T>,
    value: T,
) = IrConstImpl(
    constructorIndicator = null,
    startOffset = startOffset,
    endOffset = endOffset,
    type = type,
    kind = kind,
    value = value,
)

fun IrContinueImpl(
    startOffset: Int,
    endOffset: Int,
    type: IrType,
    loop: IrLoop,",) = IrContinueImpl(
"// FIR_IDENTICAL

fun test1(a: Int, b: Int) = a == b
fun test2(a: Int, b: Int) = a != b","fun test3(a: Any?, b: Any?) = a == b"
"fun `test - sample0 - assemble`(gradleVersion: GradleVersion) {
        val producer = project(""mpp-composite-build/sample0/producerBuild"", gradleVersion)

        project(""mpp-composite-build/sample0/consumerBuild"", gradleVersion) {
            settingsGradleKts.toFile().replaceText(""<producer_path>"", producer.projectPath.toUri().path)
            build(""cleanNativeDistributionCommonization"")

            build(""assemble"") {
                assertTasksExecuted("":consumerA:compileCommonMainKotlinMetadata"")
                assertTasksExecuted("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksExecuted("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksExecuted("":consumerA:compileKotlinLinuxX64"")
                assertTasksExecuted("":consumerA:compileKotlinJvm"")
            }

            build(""assemble"") {
                assertTasksUpToDate("":consumerA:compileCommonMainKotlinMetadata"")
                assertTasksUpToDate("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksUpToDate("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksUpToDate("":consumerA:compileKotlinLinuxX64"")
                assertTasksUpToDate("":consumerA:compileKotlinJvm"")
            }
        }
    }

    @GradleTest
    fun `test - sample0 - assemble - enableCInteropCommonization=true`(gradleVersion: GradleVersion) {
        val producer = project(""mpp-composite-build/sample0/producerBuild"", gradleVersion)

        project(
            ""mpp-composite-build/sample0/consumerBuild"", gradleVersion, defaultBuildOptions.copy(
                freeArgs = defaultBuildOptions.freeArgs + ""-Pkotlin.mpp.enableCInteropCommonization=true""
            )
        ) {
            settingsGradleKts.toFile().replaceText(""<producer_path>"", producer.projectPath.toUri().path)
            build(""assemble"") {
                assertTasksExecuted("":consumerA:compileCommonMainKotlinMetadata"")
                assertTasksExecuted("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksExecuted("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksExecuted("":consumerA:compileKotlinLinuxX64"")
                assertTasksExecuted("":consumerA:compileKotlinJvm"")
            }

            build(""assemble"") {
                assertTasksUpToDate("":consumerA:compileCommonMainKotlinMetadata"")
                assertTasksUpToDate("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksUpToDate("":consumerA:compileNativeMainKotlinMetadata"")
                assertTasksUpToDate("":consumerA:compileKotlinLinuxX64"")
                assertTasksUpToDate("":consumerA:compileKotlinJvm"")
            }
        }
    }

    /**
     * Test that verifies that after moving to 'buildPath' and 'buildName' in project coordinates (1.9.20),
     * the shape of the resolved coordinate are the same across different versions of Gradle.
     */
    @GradleTest
    fun `test - sample0 - buildId buildPath buildName`(gradleVersion: GradleVersion) {
        val producer = project(""mpp-composite-build/sample0/producerBuild"", gradleVersion)

        project(""mpp-composite-build/sample0/consumerBuild"", gradleVersion) {
            settingsGradleKts.toFile().replaceText(""<producer_path>"", producer.projectPath.toUri().path)
            resolveIdeDependencies("":consumerA"") { dependencies ->
                /* Pick some known dependency  and run check on it */","val dependency = dependencies[""commonMain""].getOrFail(regularSourceDependency("":producerBuild::producerA/commonMain""))"
"// FIR_IDENTICAL
// FILE: J.java

class J extends K {
    void foo() {}
}

// FILE: K.kt",class K : <!CYCLIC_INHERITANCE_HIERARCHY!>J<!>() {
"// Auto-generated by GenerateInRangeExpressionTestData. Do not edit!
// WITH_STDLIB",val range0 = 1u..3u
"// WITH_STDLIB
// ISSUE: KT-55379

fun test_1(b: Any) {
    require(b is Boolean)
    val x = <!NO_ELSE_IN_WHEN!>when<!> (b) {
        true -> 1
    }
    val y = when (b) {",true -> 1
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.fir.symbols

import org.jetbrains.kotlin.KtFakeSourceElementKind
import org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession
import org.jetbrains.kotlin.analysis.api.fir.KtSymbolByFirBuilder
import org.jetbrains.kotlin.analysis.api.fir.utils.firSymbol
import org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeOwner
import org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken
import org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion
import org.jetbrains.kotlin.analysis.api.symbols.KtClassLikeSymbol
import org.jetbrains.kotlin.analysis.api.symbols.KtSymbol
import org.jetbrains.kotlin.analysis.api.symbols.KtSymbolOrigin
import org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolKind
import org.jetbrains.kotlin.analysis.low.level.api.fir.util.errorWithFirSpecificEntries
import org.jetbrains.kotlin.fir.utils.exceptions.withFirEntry
import org.jetbrains.kotlin.utils.exceptions.errorWithAttachment
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.declarations.synthetic.FirSyntheticProperty",import org.jetbrains.kotlin.fir.declarations.synthetic.FirSyntheticPropertyAccessor
"// !LANGUAGE: +ProperFinally
var result = """"

fun test() {",for (z in 1..2) {
"// FIR_IDENTICAL
@file:OptIn(ExperimentalSubclassOptIn::class)

@RequiresOptIn
annotation class ApiMarker

@SubclassOptInRequired(ApiMarker::class)
interface Interface

fun foo() {
    // error: inheriting Interface requires an explicit opt-in
    open class LocalOpenKlassA: <!OPT_IN_USAGE_ERROR!>Interface<!>
    abstract class LocalAbstractKlassA: <!OPT_IN_USAGE_ERROR!>Interface<!>
    class LocalKlassA: <!OPT_IN_USAGE_ERROR!>Interface<!>
    data class LocalDataKlassA(val arg: Int): <!OPT_IN_USAGE_ERROR!>Interface<!>
    object: <!OPT_IN_USAGE_ERROR!>Interface<!> {}

    // opt-in is present, no errors
    @OptIn(ApiMarker::class) open class LocalOpenKlassB: Interface
    @OptIn(ApiMarker::class) abstract class LocalAbstractKlassB: Interface
    @OptIn(ApiMarker::class) class LocalKlassB: Interface",@OptIn(ApiMarker::class) data class LocalDataKlassB(val arg: Int): Interface
"@see IrFileEntry.getSourceRangeInfo
            """""".trimIndent()
        }

        +offsetField(""start"")
        +offsetField(""end"")

        kDoc = ""The root interface of the IR tree. Each IR node implements this interface.""
    }
    val statement: Element by element(Other)

    val declaration: Element by element(Declaration) {
        parent(statement)
        parent(symbolOwner)
        parent(mutableAnnotationContainer)

        +descriptor(""DeclarationDescriptor"")
        +field(""origin"", type(Packages.declarations, ""IrDeclarationOrigin""))
        +factory

        generationCallback = {
            println()
            printPropertyDeclaration(""parent"", declarationParent, VariableKind.VAR)
            println()
        }
    }
    val declarationBase: Element by element(Declaration) {
        // This class is defined manually, but the entry here needs to be kept actual as well,
        // to correctly generate related code.
        doPrint = false
        typeKind = TypeKind.Class
        transformByChildren = true
        transformerReturnType = statement
        nameInVisitorMethod = ""Declaration""

        parent(declaration)
    }
    val declarationParent: Element by element(Declaration)
    val declarationWithVisibility: Element by element(Declaration) {
        parent(declaration)

        +field(""visibility"", type(Packages.descriptors, ""DescriptorVisibility""))
    }
    val declarationWithName: Element by element(Declaration) {
        parent(declaration)

        +field(""name"", type<Name>())
    }
    val possiblyExternalDeclaration: Element by element(Declaration) {
        parent(declarationWithName)

        +field(""isExternal"", boolean) {
            useFieldInIrFactory(defaultValue = ""false"")
        }
    }
    val symbolOwner: Element by element(Declaration) {
        +declaredSymbol(symbolType)
    }
    val metadataSourceOwner: Element by element(Declaration) {
        val metadataField = +field(""metadata"", type(Packages.declarations, ""MetadataSource""), nullable = true) {
            skipInIrFactory()
            kDoc = """"""
            The arbitrary metadata associated with this IR node.
            
            @see ${render()}",""""""".trimIndent()"
"it.name == KtxNameConventions.ENDRESTARTGROUP && it.valueParameters.size == 0
            }
    }

    private val sourceInformationFunction by guardedLazy {
        getTopLevelFunction(ComposeCallableIds.sourceInformation).owner
    }

    private val sourceInformationMarkerStartFunction by guardedLazy {
        getTopLevelFunction(ComposeCallableIds.sourceInformationMarkerStart).owner
    }

    private val updateChangedFlagsFunction: IrSimpleFunction? by guardedLazy {
        getTopLevelFunctionOrNull(
            ComposeCallableIds.updateChangedFlags
        )?.let {
            val owner = it.owner
            if (owner.valueParameters.size == 1) owner else null
        }
    }

    private val isTraceInProgressFunction by guardedLazy {
        getTopLevelFunctions(ComposeCallableIds.isTraceInProgress).singleOrNull {
            it.owner.valueParameters.isEmpty()
        }?.owner
    }

    private val traceEventStartFunction by guardedLazy {
        getTopLevelFunctions(ComposeCallableIds.traceEventStart).singleOrNull {
            it.owner.valueParameters.map { p -> p.type } == listOf(
                context.irBuiltIns.intType,
                context.irBuiltIns.intType,
                context.irBuiltIns.intType,
                context.irBuiltIns.stringType
            )
        }?.owner
    }

    private val traceEventEndFunction by guardedLazy {
        getTopLevelFunctions(ComposeCallableIds.traceEventEnd).singleOrNull {
            it.owner.valueParameters.isEmpty()
        }?.owner
    }

    private val traceEventMarkersEnabled get() =
        traceMarkersEnabled && traceEventEndFunction != null

    private val sourceInformationMarkerEndFunction by guardedLazy {
        getTopLevelFunction(ComposeCallableIds.sourceInformationMarkerEnd).owner
    }

    private val rememberComposableLambdaFunction by guardedLazy {
        getTopLevelFunctions(ComposeCallableIds.rememberComposableLambda).singleOrNull()
    }

    private val useNonSkippingGroupOptimization by guardedLazy {
        // Uses `rememberComposableLambda` as a indication that the runtime supports
        // generating remember after call as it was added at the same time as the slot table was
        // modified to support remember after call.
        FeatureFlag.OptimizeNonSkippingGroups.enabled && rememberComposableLambdaFunction != null
    }

    private val IrType.arguments: List<IrTypeArgument>
        get() = (this as? IrSimpleType)?.arguments.orEmpty()",private val updateScopeFunction by guardedLazy {
"// EXPECTED_REACHABLE_NODES: 1291
package foo

class A(val value: Int) : Comparable<A> {
    override public fun compareTo(other: A): Int = other.value.compareTo(value)
}

class B(val value: Int)",fun testExtensionFunctionAsCompareTo() {
"// IGNORE_BACKEND: WASM
// WASM_MUTE_REASON: IGNORED_IN_JS
// TARGET_BACKEND: JVM

// FILE: Bar.java
public class Bar {
    public static String bar() {
        return null;
    }
}

// FILE: main.kt
fun foo(): Any? {
    return if (true) {
        if (true) {
            Bar.bar()",} else {
"package foo

class A {
    @JsName(""x_"") val x: Int
        <!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@JsName(""get_x"")<!> get() = 23

    @JsName(""y_"") val y = 0

    @JsName(""m_"") var m: Int
        <!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@JsName(""get_m"")<!> get() = 23","<!JS_NAME_ON_ACCESSOR_AND_PROPERTY!>@JsName(""set_m"")<!> set(value) {}"
"trace.report(
                    COMPATIBILITY_WARNING.on(callElement.getCalleeExpressionIfAny() ?: callElement, diagnostic.candidate)
                )
            }
            is NoContextReceiver -> {
                val callElement = psiKotlinCall.psiCall.callElement
                trace.report(
                    NO_CONTEXT_RECEIVER.on(
                        callElement.getCalleeExpressionIfAny() ?: callElement,
                        diagnostic.receiverDescriptor.value.toString()
                    )
                )
            }
            is MultipleArgumentsApplicableForContextReceiver -> {
                val callElement = psiKotlinCall.psiCall.callElement
                trace.report(
                    MULTIPLE_ARGUMENTS_APPLICABLE_FOR_CONTEXT_RECEIVER.on(callElement, diagnostic.receiverDescriptor.value.toString())
                )
            }
            is ContextReceiverAmbiguity -> {
                val callElement = psiKotlinCall.psiCall.callElement
                trace.report(AMBIGUOUS_CALL_WITH_IMPLICIT_CONTEXT_RECEIVER.on(callElement))
            }
            is UnsupportedContextualDeclarationCall -> {
                val callElement = psiKotlinCall.psiCall.callElement
                trace.report(UNSUPPORTED_CONTEXTUAL_DECLARATION_CALL.on(callElement))
            }

            is AdaptedCallableReferenceIsUsedWithReflection, is NotCallableMemberReference, is CallableReferencesDefaultArgumentUsed -> {
                // AdaptedCallableReferenceIsUsedWithReflection -> reported in onCallArgument
                // NotCallableMemberReference -> UNSUPPORTED reported in DoubleColonExpressionResolver
                // CallableReferencesDefaultArgumentUsed -> possible in 1.3 and earlier versions only
                return
            }

            else -> {
                unknownError(diagnostic, ""onCall"")
            }
        }
    }

    override fun onTypeArguments(diagnostic: KotlinCallDiagnostic) {
        val psiCallElement = psiKotlinCall.psiCall.callElement
        val reportElement =
            if (psiCallElement is KtCallExpression)
                psiCallElement.typeArgumentList ?: psiCallElement.calleeExpression ?: psiCallElement
            else
                psiCallElement

        when (diagnostic) {
            is WrongCountOfTypeArguments -> {
                val expectedTypeArgumentsCount = diagnostic.descriptor.typeParameters.size
                trace.report(WRONG_NUMBER_OF_TYPE_ARGUMENTS.on(reportElement, expectedTypeArgumentsCount, diagnostic.descriptor))
            }
            else -> {
                unknownError(diagnostic, ""onTypeArguments"")
            }
        }
    }

    private fun unknownError(diagnostic: KotlinCallDiagnostic, onTarget: String) {
        if (AbstractTypeChecker.RUN_SLOW_ASSERTIONS) {
            throw AssertionError(""$onTarget should not be called with ${diagnostic::class.java}"")
        } else if (reportAdditionalErrors) {
            trace.report(",NEW_INFERENCE_UNKNOWN_ERROR.on(
"/**
 * Returns the greater of two values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun maxOf(a: Int, b: Int): Int {
    return JsMath.max(a, b)
}

/**
 * Returns the greater of two values.
 */
@SinceKotlin(""1.1"")
@Suppress(""NOTHING_TO_INLINE"")
public actual inline fun maxOf(a: Long, b: Long): Long {
    return if (a >= b) a else b
}

/**
 * Returns the greater of two values.
 * 
 * If either value is `NaN`, returns `NaN`.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun maxOf(a: Float, b: Float): Float {
    return JsMath.max(a, b)
}

/**
 * Returns the greater of two values.
 * 
 * If either value is `NaN`, returns `NaN`.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun maxOf(a: Double, b: Double): Double {
    return JsMath.max(a, b)
}

/**
 * Returns the greater of three values.
 * 
 * If there are multiple equal maximal values, returns the first of them.
 */
@SinceKotlin(""1.1"")
public actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {
    return maxOf(a, maxOf(b, c))
}

/**
 * Returns the greater of three values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {
    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()
}

/**
 * Returns the greater of three values.
 */
@SinceKotlin(""1.1"")
@kotlin.internal.InlineOnly
public actual inline fun maxOf(a: Short, b: Short, c: Short): Short {","return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()"
"/*
 * Copyright 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:OptIn(UnsafeDuringIrConstructionAPI::class)

package androidx.compose.compiler.plugins.kotlin.lower

import androidx.compose.compiler.plugins.kotlin.KtxNameConventions
import androidx.compose.compiler.plugins.kotlin.hasComposableAnnotation
import java.util.Locale
import org.jetbrains.kotlin.descriptors.DescriptorVisibilities
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.ir.IrBuiltIns
import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.declarations.IrAnnotationContainer
import org.jetbrains.kotlin.ir.declarations.IrAnonymousInitializer
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrConstructor
import org.jetbrains.kotlin.ir.declarations.IrDeclaration
import org.jetbrains.kotlin.ir.declarations.IrDeclarationOrigin
import org.jetbrains.kotlin.ir.declarations.IrDeclarationWithName
import org.jetbrains.kotlin.ir.declarations.IrField
import org.jetbrains.kotlin.ir.declarations.IrFile
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.declarations.IrLocalDelegatedProperty
import org.jetbrains.kotlin.ir.declarations.IrModuleFragment
import org.jetbrains.kotlin.ir.declarations.IrPackageFragment
import org.jetbrains.kotlin.ir.declarations.IrProperty
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.declarations.IrTypeAlias
import org.jetbrains.kotlin.ir.declarations.IrTypeParameter
import org.jetbrains.kotlin.ir.declarations.IrValueDeclaration
import org.jetbrains.kotlin.ir.declarations.IrValueParameter
import org.jetbrains.kotlin.ir.declarations.IrVariable
import org.jetbrains.kotlin.ir.expressions.IrBlock
import org.jetbrains.kotlin.ir.expressions.IrBlockBody
import org.jetbrains.kotlin.ir.expressions.IrBranch
import org.jetbrains.kotlin.ir.expressions.IrBreak
import org.jetbrains.kotlin.ir.expressions.IrBreakContinue
import org.jetbrains.kotlin.ir.expressions.IrCall
import org.jetbrains.kotlin.ir.expressions.IrCatch
import org.jetbrains.kotlin.ir.expressions.IrClassReference
import org.jetbrains.kotlin.ir.expressions.IrComposite
import org.jetbrains.kotlin.ir.expressions.IrConst
import org.jetbrains.kotlin.ir.expressions.IrConstKind",import org.jetbrains.kotlin.ir.expressions.IrConstructorCall
"}

fun test12(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out kotlin.Any)"")!>foo12 { 1 }.value.value<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out kotlin.Any)"")!>foo12 { 2 }.value.value<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

// ------------------------------------------------------------------------------------------------

fun test20(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""I1"")!>foo20 { 1 }<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""I1"")!>foo20 { 2 }<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

fun test21(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo21 { 1 }.value<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo21 { 2 }.value<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

fun test22(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo22 { 1 }.value.value<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo22 { 2 }.value.value<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

// ------------------------------------------------------------------------------------------------

fun test30(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""I1"")!>foo30 { 1 }<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""I1"")!>foo30 { 2 }<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

fun test31(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo31 { 1 }.value<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo31 { 2 }.value<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

fun test32(b: Boolean) {
    var x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo32 { 1 }.value.value<!>
    if (b) {
        x = <!DEBUG_INFO_EXPRESSION_TYPE(""CapturedType(out I1)"")!>foo32 { 2 }.value.value<!>
    }
    x.<!UNRESOLVED_REFERENCE!>bar<!>()
}

// ------------------------------------------------------------------------------------------------

fun test40(b: Boolean) {","var x = <!DEBUG_INFO_EXPRESSION_TYPE(""<anonymous>"")!>foo40 { 1 }<!>"
"For language feature testing, use `// !LANGUAGE: [+-]FeatureName` directive instead,
            where FeatureName is an entry of the enum `LanguageFeature`
        """""".trimIndent()
    )


    // --------------------- Analysis Flags ---------------------

    val OPT_IN by stringDirective(
        description = ""List of opted in annotations (AnalysisFlags.optIn)""
    )

    val IGNORE_DATA_FLOW_IN_ASSERT by directive(
        description = ""Enables corresponding analysis flag (AnalysisFlags.ignoreDataFlowInAssert)""
    )

    val EXPLICIT_API_MODE by enumDirective(
        ""Configures explicit API mode (AnalysisFlags.explicitApiMode)"",
        additionalParser = ExplicitApiMode.Companion::fromString
    )

    val EXPLICIT_RETURN_TYPES_MODE by enumDirective(
        ""Configures explicit API mode (AnalysisFlags.explicitReturnTypes)"",
        additionalParser = ExplicitApiMode.Companion::fromString
    )

    val ALLOW_KOTLIN_PACKAGE by directive(
        description = ""Allow compiling code in package 'kotlin' and allow not requiring kotlin.stdlib in module-info (AnalysisFlags.allowKotlinPackage)""
    )

    val STDLIB_COMPILATION by directive(
        description = ""Enables corresponding analysis flag (AnalysisFlags.stdlibCompilation)""
    )

    // It's inverted because otherwise we would have warnings in almost all KMP tests
    val ENABLE_EXPECT_ACTUAL_CLASSES_WARNING by stringDirective(
        description = ""Disables -Xexpect-actual-classes key""
    )

    // --------------------- Jvm Analysis Flags ---------------------

    val JVM_DEFAULT_MODE by enumDirective(
        description = ""Configures corresponding analysis flag (JvmAnalysisFlags.jvmDefaultMode)"",
        additionalParser = JvmDefaultMode.Companion::fromStringOrNull
    )

    val JDK_RELEASE by valueDirective(
        description = ""Configures corresponding release flag"",
        parser = Integer::valueOf
    )

    val INHERIT_MULTIFILE_PARTS by directive(
        description = ""Enables corresponding analysis flag (JvmAnalysisFlags.inheritMultifileParts)""
    )

    val SANITIZE_PARENTHESES by directive(
        description = ""Enables corresponding analysis flag (JvmAnalysisFlags.sanitizeParentheses)""
    )

    val ENABLE_JVM_PREVIEW by directive(""Enable JVM preview features"")
    val EMIT_JVM_TYPE_ANNOTATIONS by directive(""Enable emitting jvm type annotations"")
    val NO_OPTIMIZED_CALLABLE_REFERENCES by directive(""Don't optimize callable references"")
    val DISABLE_PARAM_ASSERTIONS by directive(""Disable assertions on parameters"")
    val DISABLE_CALL_ASSERTIONS by directive(""Disable assertions on calls"")","val NO_UNIFIED_NULL_CHECKS by directive(""No unified null checks"")"
""""""".trimIndent()
            )

            build("":compileDebugKotlin"") {
                assertTasksExecuted("":compileDebugKotlin"")
                assertCompilerArgument("":compileDebugKotlin"", ""-jvm-target 11"")
            }
        }
    }

    private fun BuildResult.assertJdkHomeIsUsingJdk(
        javaexecPath: String
    ) = assertOutputContains(""[KOTLIN] Kotlin compilation 'jdkHome' argument: $javaexecPath"")

    private fun getUserJdk(): JavaInfo = Jvm.forHome(File(System.getProperty(""java.home"")))
    private fun getJdk11(): JavaInfo = Jvm.forHome(File(System.getProperty(""jdk11Home"")))
    // replace required for windows paths so Groovy will not complain about unexpected char '\'
    private fun getJdk11Path(): String = getJdk11().javaHome.absolutePath.replace(""\\"", ""\\\\"")
    private val JavaInfo.javaHomeRealPath
        get() = javaHome
            .toPath()
            .toRealPath()
            .toAbsolutePath()
            .toString()

    private val String.fullProjectName get() = ""kotlin-java-toolchain/$this""

    private fun TestProject.setJvmTarget(
        jvmTarget: String
    ) {
        //language=Groovy
        buildGradle.append(
            """"""
            import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
            
            tasks.withType(KotlinCompile).configureEach {
                 kotlinOptions {
                      jvmTarget = ""$jvmTarget""
                 }            
            }
            """""".trimIndent()
        )
    }

    private fun TestProject.setJavaCompilationCompatibility(
        target: JavaVersion
    ) {
        //language=Groovy
        buildGradle.append(
            """"""

            tasks.withType(JavaCompile.class).configureEach {
                sourceCompatibility = JavaVersion.${target.name}
                targetCompatibility = JavaVersion.${target.name}
            }
            
            """""".trimIndent()
        )
    }

    private fun TestProject.useJdkToCompile(
        jdkPath: String,
        jdkVersion: JavaVersion
    ) {
        //language=Groovy",buildGradle.append(
"// EXPECTED_REACHABLE_NODES: 1282
package test

external fun foo(): dynamic

external fun bar(): dynamic

fun box(): String {","val foo = ""local foo;"""
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir

import org.jetbrains.kotlin.fir.declarations.FirSimpleFunction
import org.jetbrains.kotlin.fir.declarations.utils.isLocal
import org.jetbrains.kotlin.fir.types.ConeKotlinType
import org.jetbrains.kotlin.fir.types.arrayElementType
import org.jetbrains.kotlin.fir.types.coneType",import org.jetbrains.kotlin.fir.types.isArrayType
"object EmptyTypeHierarchy : TypeHierarchy {
            override val allTypes: Array<DataFlowIR.Type.Declared> = emptyArray()

            override fun inheritorsOf(type: DataFlowIR.Type.Declared): BitSet {
                return BitSet()
            }
        }

        inner class TypeHierarchyImpl(override val allTypes: Array<DataFlowIR.Type.Declared>) : TypeHierarchy {
            private val typesSubTypes = Array(allTypes.size) { mutableListOf<DataFlowIR.Type.Declared>() }
            private val allInheritors = Array(allTypes.size) { BitSet() }

            init {
                val visited = BitSet()

                fun processType(type: DataFlowIR.Type.Declared) {
                    if (visited[type.index]) return
                    visited.set(type.index)
                    type.superTypes
                            .map { it.resolved() }
                            .forEach { superType ->
                                val subTypes = typesSubTypes[superType.index]
                                subTypes += type
                                processType(superType)
                            }
                }

                allTypes.forEach { processType(it) }
            }

            override fun inheritorsOf(type: DataFlowIR.Type.Declared): BitSet {
                val typeId = type.index
                val inheritors = allInheritors[typeId]
                if (!inheritors.isEmpty || type == DataFlowIR.Type.Virtual) return inheritors
                inheritors.set(typeId)
                for (subType in typesSubTypes[typeId])
                    inheritors.or(inheritorsOf(subType))
                return inheritors
            }
        }

        private fun DataFlowIR.Type.Declared.calleeAt(callSite: DataFlowIR.Node.VirtualCall) = when (callSite) {
            is DataFlowIR.Node.VtableCall ->
                vtable[callSite.calleeVtableIndex]

            is DataFlowIR.Node.ItableCall ->
                itable[callSite.interfaceId]!![callSite.calleeItableIndex]

            else -> error(""Unreachable"")
        }

        fun logPathToType(reversedEdges: IntArray, node: Node, type: Int) {
            val nodes = constraintGraph.nodes
            val visited = BitSet()
            val prev = mutableMapOf<Node, Node>()
            var front = mutableListOf<Node>()
            front.add(node)
            visited.set(node.id)
            lateinit var source: Node.Source
            bfs@while (front.isNotEmpty()) {
                val prevFront = front
                front = mutableListOf()
                for (from in prevFront) {
                    var endBfs = false
                    reversedEdges.forEachEdge(from.id) { toId ->",val to = nodes[toId]
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.scripting.compiler.plugin.repl

import com.intellij.core.JavaCoreProjectEnvironment
import org.jetbrains.kotlin.cli.common.CLIConfigurationKeys
import org.jetbrains.kotlin.cli.common.messages.*
import org.jetbrains.kotlin.cli.common.repl.ReplClassLoader
import org.jetbrains.kotlin.cli.common.repl.ReplEvalResult
import org.jetbrains.kotlin.cli.jvm.compiler.EnvironmentConfigFiles",import org.jetbrains.kotlin.cli.jvm.compiler.KotlinCoreEnvironment
"type.orExpected(index)
            } ?: expectedParameters.map { it.type.unwrap() }) to (if (receiverFromExpected) expectedReceiver else null)
    }
    val contextReceivers = (argumentAsFunctionExpression?.contextReceiversTypes ?: expectedContextReceivers).filterNotNull()

    val returnType = argumentAsFunctionExpression?.returnType ?: expectedType.getReturnTypeFromFunctionType().unwrap()

    return ResolvedLambdaAtom(
        argument,
        expectedType.isSuspendFunctionType,
        receiver,
        contextReceivers,
        parameters,
        returnType,
        typeVariableForLambdaReturnType = returnTypeVariable,
        expectedType = expectedType
    )
}

fun LambdaWithTypeVariableAsExpectedTypeAtom.transformToResolvedLambda(
    csBuilder: ConstraintSystemBuilder,
    diagnosticsHolder: KotlinDiagnosticsHolder,
    expectedType: UnwrappedType? = null,
    returnTypeVariable: TypeVariableForLambdaReturnType? = null
): ResolvedLambdaAtom {
    val fixedExpectedType = (csBuilder.buildCurrentSubstitutor() as NewTypeSubstitutor)
        .safeSubstitute(expectedType ?: this.expectedType)
    val resolvedLambdaAtom = preprocessLambdaArgument(
        csBuilder,
        atom,
        fixedExpectedType,
        diagnosticsHolder,
        forceResolution = true,
        returnTypeVariable = returnTypeVariable
    ) as ResolvedLambdaAtom

    setAnalyzed(resolvedLambdaAtom)

    return resolvedLambdaAtom
}

fun ResolvedLambdaAtom.transformToResolvedLambda(
    csBuilder: ConstraintSystemBuilder,
    diagnosticsHolder: KotlinDiagnosticsHolder,
    expectedType: UnwrappedType,
    returnTypeVariable: TypeVariableForLambdaReturnType? = null
): ResolvedLambdaAtom {
    return preprocessLambdaArgument(
        csBuilder,
        atom,
        expectedType,
        diagnosticsHolder,
        forceResolution = true,
        returnTypeVariable = returnTypeVariable
    ).also {
        this.setAnalyzedResults(null, listOf(it))
    } as ResolvedLambdaAtom
}

private fun preprocessCallableReference(
    csBuilder: ConstraintSystemBuilder,
    argument: CallableReferenceKotlinCallArgument,
    expectedType: UnwrappedType?,
    diagnosticsHolder: KotlinDiagnosticsHolder
): ResolvedAtom {","val result = EagerCallableReferenceAtom(argument, expectedType)"
// !DIAGNOSTICS: -UNUSED_PARAMETER,open class B(x: Int)
"// TODO: find out what to use instead here and in the dependent code
@OptIn(ObsoleteDescriptorBasedAPI::class)
private val ObjCExportBlockCodeGenerator.mappedFunctionNClasses get() =
    // failed attempt to migrate to descriptor-less IrBuiltIns
    ((context.irBuiltIns as IrBuiltInsOverDescriptors).functionFactory as BuiltInFictitiousFunctionIrClassFactory).builtFunctionNClasses
        .filter { it.descriptor.isMappedFunctionClass() }

private fun ObjCExportBlockCodeGenerator.emitFunctionConverters() {
    require(generationState.shouldDefineFunctionClasses)
    mappedFunctionNClasses.forEach { functionClass ->
        val convertToRetained = kotlinFunctionToRetainedBlockConverter(BlockPointerBridge(functionClass.arity, returnsVoid = false))

        val writableTypeInfoValue = buildWritableTypeInfoValue(convertToRetained = convertToRetained.toConstPointer())
        setOwnWritableTypeInfo(functionClass.irClass, writableTypeInfoValue)
    }
}

private fun ObjCExportBlockCodeGenerator.emitBlockToKotlinFunctionConverters() {
    require(generationState.shouldDefineFunctionClasses)
    val functionClassesByArity = mappedFunctionNClasses.associateBy { it.arity }

    val arityLimit = (functionClassesByArity.keys.maxOrNull() ?: -1) + 1

    val converters = (0 until arityLimit).map { arity ->
        functionClassesByArity[arity]?.let {
            val bridge = BlockPointerBridge(numberOfParameters = arity, returnsVoid = false)
            blockToKotlinFunctionConverter(bridge).toConstPointer()
        } ?: NullPointer(objCToKotlinFunctionType)
    }

    val type = pointerType(objCToKotlinFunctionType)
    val ptr = staticData.placeGlobalArray(
            """",
            type,
            converters
    ).pointer.getElementPtr(llvm, LLVMArrayType(type, converters.size)!!, 0)

    // Note: defining globals declared in runtime.
    staticData.placeGlobal(""Kotlin_ObjCExport_blockToFunctionConverters"", ptr, isExported = true)
    staticData.placeGlobal(""Kotlin_ObjCExport_blockToFunctionConverters_size"", llvm.constInt32(arityLimit), isExported = true)
}

private fun ObjCExportCodeGenerator.emitSpecialClassesConvertions() {
    setObjCExportTypeInfo(
            symbols.string.owner,
            llvm.Kotlin_ObjCExport_CreateRetainedNSStringFromKString.toConstPointer()
    )

    emitCollectionConverters()

    emitBoxConverters()
}

private fun ObjCExportCodeGenerator.emitCollectionConverters() {

    fun importConverter(name: String): ConstPointer =
            llvm.externalNativeRuntimeFunction(name, kotlinToObjCFunctionType).toConstPointer()

    setObjCExportTypeInfo(
            symbols.list.owner,
            importConverter(""Kotlin_Interop_CreateRetainedNSArrayFromKList"")
    )

    setObjCExportTypeInfo(
            symbols.mutableList.owner,","importConverter(""Kotlin_Interop_CreateRetainedNSMutableArrayFromKList"")"
"public fun kotlin.UShortArray.maxOrNull(): kotlin.UShort?

@kotlin.SinceKotlin(version = ""1.4"")
public fun <T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.maxOrNull(): T?

@kotlin.SinceKotlin(version = ""1.4"")
public fun kotlin.collections.Iterable<kotlin.Double>.maxOrNull(): kotlin.Double?

@kotlin.SinceKotlin(version = ""1.4"")
public fun kotlin.collections.Iterable<kotlin.Float>.maxOrNull(): kotlin.Float?

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun <T> kotlin.Array<out T>.maxWith(comparator: kotlin.Comparator<in T>): T

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.BooleanArray.maxWith(comparator: kotlin.Comparator<in kotlin.Boolean>): kotlin.Boolean

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.ByteArray.maxWith(comparator: kotlin.Comparator<in kotlin.Byte>): kotlin.Byte

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.CharArray.maxWith(comparator: kotlin.Comparator<in kotlin.Char>): kotlin.Char

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.DoubleArray.maxWith(comparator: kotlin.Comparator<in kotlin.Double>): kotlin.Double

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.FloatArray.maxWith(comparator: kotlin.Comparator<in kotlin.Float>): kotlin.Float

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.IntArray.maxWith(comparator: kotlin.Comparator<in kotlin.Int>): kotlin.Int

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.LongArray.maxWith(comparator: kotlin.Comparator<in kotlin.Long>): kotlin.Long

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow"")
public fun kotlin.ShortArray.maxWith(comparator: kotlin.Comparator<in kotlin.Short>): kotlin.Short

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UByteArray.maxWith(comparator: kotlin.Comparator<in kotlin.UByte>): kotlin.UByte

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UIntArray.maxWith(comparator: kotlin.Comparator<in kotlin.UInt>): kotlin.UInt

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.ULongArray.maxWith(comparator: kotlin.Comparator<in kotlin.ULong>): kotlin.ULong

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxWithOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes",public fun kotlin.UShortArray.maxWith(comparator: kotlin.Comparator<in kotlin.UShort>): kotlin.UShort
"private fun renderResolverModuleInfos(): String = projectContext.storageManager.compute {
        moduleInfoByDescriptor.entries.joinToString("",\n"") { (descriptor, moduleInfo) ->
            """"""
            {
                moduleDescriptor: $descriptor
                moduleInfo: $moduleInfo
            }
            """""".trimIndent()
        }
    }
}

private class DelegatingPackageFragmentProvider<M : ModuleInfo>(
    private val resolverForProject: AbstractResolverForProject<M>,
    private val module: ModuleDescriptor,
    moduleContent: ModuleContent<M>,
    private val packageOracle: PackageOracle
) : PackageFragmentProviderOptimized {
    private val syntheticFilePackages = moduleContent.syntheticFiles.map { it.packageFqName }.toSet()

    @Suppress(""OverridingDeprecatedMember"", ""OVERRIDE_DEPRECATION"")
    override fun getPackageFragments(fqName: FqName): List<PackageFragmentDescriptor> {
        if (certainlyDoesNotExist(fqName)) return emptyList()

        @Suppress(""DEPRECATION"")
        return resolverForProject.resolverForModuleDescriptor(module).packageFragmentProvider.getPackageFragments(fqName)
    }

    override fun collectPackageFragments(fqName: FqName, packageFragments: MutableCollection<PackageFragmentDescriptor>) {
        if (certainlyDoesNotExist(fqName)) return

        resolverForProject.resolverForModuleDescriptor(module)
            .packageFragmentProvider
            .collectPackageFragmentsOptimizedIfPossible(fqName, packageFragments)
    }

    override fun isEmpty(fqName: FqName): Boolean {
        if (certainlyDoesNotExist(fqName)) return true

        return resolverForProject.resolverForModuleDescriptor(module).packageFragmentProvider.isEmpty(fqName)
    }

    override fun getSubPackagesOf(fqName: FqName, nameFilter: (Name) -> Boolean): Collection<FqName> {
        if (certainlyDoesNotExist(fqName)) return emptyList()

        return resolverForProject.resolverForModuleDescriptor(module).packageFragmentProvider.getSubPackagesOf(fqName, nameFilter)
    }

    private fun certainlyDoesNotExist(fqName: FqName): Boolean {
        if (resolverForProject.isResolverForModuleDescriptorComputed(module)) return false // let this request get cached inside delegate

        return !packageOracle.packageExists(fqName) && fqName !in syntheticFilePackages
    }

    override fun toString(): String {
        return ""DelegatingProvider for $module in ${resolverForProject.name}""
    }
}

private object DiagnoseUnknownModuleInfoReporter {
    fun report(name: String, infos: List<ModuleInfo>, allModules: Collection<ModuleInfo>): Nothing {
        val message = ""$name does not know how to resolve""
        val error = when {
            name.contains(ResolverForProject.resolverForSdkName) -> errorInSdkResolver(message)
            name.contains(ResolverForProject.resolverForLibrariesName) -> errorInLibrariesResolver(message)",name.contains(ResolverForProject.resolverForModulesName) -> {
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.generators.impl

import org.jetbrains.kotlin.generators.MethodGenerator
import org.jetbrains.kotlin.generators.TestGenerator
import org.jetbrains.kotlin.generators.TestGroup
import org.jetbrains.kotlin.generators.model.*
import org.jetbrains.kotlin.generators.util.GeneratorsFileUtil
import org.jetbrains.kotlin.test.JUnit3RunnerWithInners
import org.jetbrains.kotlin.test.KotlinTestUtils
import org.jetbrains.kotlin.test.TestMetadata
import org.jetbrains.kotlin.test.util.KtTestUtil
import org.jetbrains.kotlin.utils.Printer
import org.junit.Test
import org.junit.runner.RunWith
import org.junit.runners.BlockJUnit4ClassRunner
import java.io.File
import java.io.IOException

private val METHOD_GENERATORS = listOf(
    RunTestMethodGenerator,
    SimpleTestClassModelTestAllFilesPresentMethodGenerator,
    SimpleTestMethodGenerator,
    SingleClassTestModelAllFilesPresentedMethodGenerator,
    TransformingTestMethodGenerator,
)",object TestGeneratorImpl : TestGenerator(METHOD_GENERATORS) {
"val supertypesSupplier: SupertypeSupplier = object : SupertypeSupplier() {
        override fun forClass(firClass: FirClass, useSiteSession: FirSession): List<ConeClassLikeType> {
            val typeRefsFromSession = (getSupertypesComputationStatus(firClass) as? SupertypeComputationStatus.Computed)?.supertypeRefs
            val typeRefsToReturn = typeRefsFromSession ?: getResolvedSuperTypeRefsForOutOfSessionDeclaration(firClass)
            return typeRefsToReturn?.mapNotNull { it.coneTypeSafe<ConeClassLikeType>() }.orEmpty()
        }

        override fun expansionForTypeAlias(typeAlias: FirTypeAlias, useSiteSession: FirSession): ConeClassLikeType? {
            if (typeAlias.expandedTypeRef is FirResolvedTypeRef) return typeAlias.expandedConeType
            return (getSupertypesComputationStatus(typeAlias) as? SupertypeComputationStatus.Computed)
                ?.supertypeRefs
                ?.getOrNull(0)?.coneTypeSafe()
        }
    }

    fun getSupertypesComputationStatus(classLikeDeclaration: FirClassLikeDeclaration): SupertypeComputationStatus =
        supertypeStatusMap[classLikeDeclaration] ?: SupertypeComputationStatus.NotComputed

    fun getOrPutFileScope(file: FirFile, scope: () -> ScopePersistentList): ScopePersistentList =
        fileScopesMap.getOrPut(file) { scope() }

    fun getOrPutScopeForNestedClasses(klass: FirClass, scope: () -> ScopePersistentList): ScopePersistentList =
        scopesForNestedClassesMap.getOrPut(klass) { scope() }

    fun getOrPutScopeForStaticNestedClasses(klass: FirClass, scope: () -> ScopePersistentList): ScopePersistentList =
        scopesForStaticNestedClassesMap.getOrPut(klass) { scope() }

    fun getOrPutScopeForCompanion(klass: FirClass, scope: () -> ScopePersistentList): ScopePersistentList =
        scopesForCompanionMap.getOrPut(klass) { scope() }

    fun startComputingSupertypes(classLikeDeclaration: FirClassLikeDeclaration) {
        require(supertypeStatusMap[classLikeDeclaration] == null) {
            ""Unexpected in startComputingSupertypes supertype status for $classLikeDeclaration: ${supertypeStatusMap[classLikeDeclaration]}""
        }

        supertypeStatusMap[classLikeDeclaration] = SupertypeComputationStatus.Computing
    }

    fun storeSupertypes(classLikeDeclaration: FirClassLikeDeclaration, resolvedTypesRefs: List<FirResolvedTypeRef>) {
        require(supertypeStatusMap[classLikeDeclaration] is SupertypeComputationStatus.Computing) {
            ""Unexpected in storeSupertypes supertype status for $classLikeDeclaration: ${supertypeStatusMap[classLikeDeclaration]}""
        }

        supertypeStatusMap[classLikeDeclaration] = SupertypeComputationStatus.Computed(resolvedTypesRefs)
        newClassifiersForBreakingLoops.add(classLikeDeclaration)
    }

    private val newClassifiersForBreakingLoops = mutableListOf<FirClassLikeDeclaration>()

    /**
     * @param supertypeRefs a collection where at least one element is [FirErrorTypeRef] for looped references
     */
    protected open fun reportLoopErrorRefs(classLikeDeclaration: FirClassLikeDeclaration, supertypeRefs: List<FirResolvedTypeRef>) {
        supertypeStatusMap[classLikeDeclaration] = SupertypeComputationStatus.Computed(supertypeRefs)
    }

    protected open fun getResolvedSuperTypeRefsForOutOfSessionDeclaration(
        classLikeDeclaration: FirClassLikeDeclaration,
    ): List<FirResolvedTypeRef>? = when (classLikeDeclaration) {
        is FirClass -> classLikeDeclaration.superTypeRefs.filterIsInstance<FirResolvedTypeRef>()
        is FirTypeAlias -> listOfNotNull(classLikeDeclaration.expandedTypeRef as? FirResolvedTypeRef)
        else -> null
    }",internal open fun supertypeRefs(declaration: FirClassLikeDeclaration): List<FirTypeRef> = when (declaration) {
"typeParameter.getStubType(originalReturnType.isNullable)
                    } else {
                        // This shouldn't happen actually.
                        this.stubReturnType
                    }
                    val typeArgument = TypeArgumentStub(typeParameter.getStubType(false))
                    val receiverType = ClassifierStubType(KotlinTypes.objCClassOf, listOf(typeArgument))
                    val receiver = ReceiverParameterStub(receiverType)
                    val createMethod = FunctionStub(
                            ""create"",
                            returnType,
                            parameters,
                            receiver = receiver,
                            typeParameters = listOf(typeParameter),
                            external = true,
                            origin = StubOrigin.ObjCCategoryInitMethod(method),
                            annotations = annotations.toMutableList(),
                            modality = MemberStubModality.FINAL
                    )
                    // TODO: Should we deprecate it as well?
                    createMethod
                }
                is ObjCProtocol -> null
            }
        } else {
            null
        }
        if (isDeprecatedCategoryMethod && annotations.filterIsInstance<AnnotationStub.Deprecated>().isEmpty()) {
            val target = if (method.isClass) ""class"" else ""instance""
            annotations += AnnotationStub.Deprecated(message = ""Use $target method instead"", replaceWith = """", level = DeprecationLevel.WARNING)
        }
        return listOfNotNull(
                FunctionStub(
                        name,
                        stubReturnType,
                        kotlinMethodParameters.toList(),
                        origin,
                        annotations.toMutableList(),
                        external,
                        receiver,
                        modality,
                        emptyList(),
                        isOverride),
                replacement
        )
    }
}

internal val ObjCContainer.classOrProtocol: ObjCClassOrProtocol
    get() = when (this) {
        is ObjCClassOrProtocol -> this
        is ObjCCategory -> this.clazz
    }

private fun deprecatedInit(className: String, initParameterNames: List<String>, factory: Boolean): AnnotationStub {
    val replacement = if (factory) ""$className.create"" else className
    val replacementKind = if (factory) ""factory method"" else ""constructor""
    val replaceWith = ""$replacement(${initParameterNames.joinToString { it.asSimpleName() }})""
    return AnnotationStub.Deprecated(""Use $replacementKind instead"", replaceWith, DeprecationLevel.ERROR)
}

private fun ObjCMethod.isAlloc(): Boolean =
        this.isClass && (this.selector == ""alloc"" || this.selector == ""allocWithZone:"")

internal val ObjCMethod.kotlinName: String",get() {
"/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress(
    ""unused"",
    ""nothing_to_inline"",
    ""useless_cast"",
    ""unchecked_cast"",
    ""extension_shadowed_by_member"",
    ""redundant_projection"",
    ""RemoveRedundantBackticks"",
    ""ObjectPropertyName"",
    ""deprecation""
)
@file:org.gradle.api.Generated

/* ktlint-disable */

package gradle.kotlin.dsl.accessors._44a939cf26bc074355463a0d554ee592


import org.gradle.api.Action
import org.gradle.api.Incubating
import org.gradle.api.NamedDomainObjectProvider
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurablePublishArtifact
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.Dependency
import org.gradle.api.artifacts.DependencyConstraint
import org.gradle.api.artifacts.ExternalModuleDependency
import org.gradle.api.artifacts.ModuleDependency
import org.gradle.api.artifacts.PublishArtifact
import org.gradle.api.artifacts.dsl.ArtifactHandler
import org.gradle.api.artifacts.dsl.DependencyConstraintHandler",import org.gradle.api.artifacts.dsl.DependencyHandler
""""""".trimIndent())
        output(""typedef unsigned short     ${prefix}_KChar;"")
        output(""typedef signed char        ${prefix}_KByte;"")
        output(""typedef short              ${prefix}_KShort;"")
        output(""typedef int                ${prefix}_KInt;"")
        output(""typedef long long          ${prefix}_KLong;"")
        output(""typedef unsigned char      ${prefix}_KUByte;"")
        output(""typedef unsigned short     ${prefix}_KUShort;"")
        output(""typedef unsigned int       ${prefix}_KUInt;"")
        output(""typedef unsigned long long ${prefix}_KULong;"")
        output(""typedef float              ${prefix}_KFloat;"")
        output(""typedef double             ${prefix}_KDouble;"")

        val typedef_KVector128 = ""typedef float __attribute__ ((__vector_size__ (16))) ${prefix}_KVector128;""
        if (target.family == Family.MINGW) {
            // Separate `output` for each line to ensure Windows EOL (LFCR), otherwise generated file will have inconsistent line ending.
            output(""#ifndef _MSC_VER"")
            output(typedef_KVector128)
            output(""#else"")
            output(""#include <xmmintrin.h>"")
            output(""typedef __m128 ${prefix}_KVector128;"")
            output(""#endif"")
        } else {
            output(typedef_KVector128)
        }

        output(""typedef void*              ${prefix}_KNativePtr;"")
        output(""struct ${prefix}_KType;"")
        output(""typedef struct ${prefix}_KType ${prefix}_KType;"")

        output("""")
        defineUsedTypes(top, 0)

        output("""")
        makeScopeDefinitions(top, DefinitionKind.C_HEADER_DECLARATION, 0)

        output("""")
        output(""typedef struct {"")
        output(""/* Service functions. */"", 1)
        output(""void (*DisposeStablePointer)(${prefix}_KNativePtr ptr);"", 1)
        output(""void (*DisposeString)(const char* string);"", 1)
        output(""${prefix}_KBoolean (*IsInstance)(${prefix}_KNativePtr ref, const ${prefix}_KType* type);"", 1)
        predefinedTypes.forEach {
            val nullableIt = it.makeNullable()
            val argument = if (!it.isUnit()) typeTranslator.translateType(it) else ""void""
            output(""${typeTranslator.translateType(nullableIt)} (*${it.createNullableNameForPredefinedType})($argument);"", 1)
            if (!it.isUnit())
                output(""$argument (*${it.createGetNonNullValueOfPredefinedType})(${typeTranslator.translateType(nullableIt)});"", 1)
        }

        output("""")
        output(""/* User functions. */"", 1)
        makeScopeDefinitions(top, DefinitionKind.C_HEADER_STRUCT, 1)
        output(""} ${prefix}_ExportedSymbols;"")

        output(""extern ${prefix}_ExportedSymbols* $exportedSymbol(void);"")
        output(""""""
    #ifdef __cplusplus
    }  /* extern ""C"" */
    #endif"""""".trimIndent())

        output(""#endif  /* KONAN_${prefix.uppercase()}_H */"")

        outputStreamWriter.close()",outputStreamWriter = cppAdapterFile.printWriter()
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer.core

import org.jetbrains.kotlin.commonizer.cir.CirExtensionReceiver

class ExtensionReceiverCommonizer(
    private val typeCommonizer: TypeCommonizer",") : NullableContextualSingleInvocationCommonizer<CirExtensionReceiver?, ExtensionReceiverCommonizer.Commonized> {"
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.backend.konan.objcexport

import org.jetbrains.kotlin.backend.konan.InternalKotlinNativeApi

object StubRenderer {
    fun render(stub: ObjCExportStub): List<String> = render(stub, false)

    private fun findPositionToInsertGeneratedCommentLine(kDoc: List<String>, generatedCommentLine: String): Int {
        val generatedWords = generatedCommentLine.trim().split("" "").map { it.trim() }
        if (generatedWords.size >= 2 && generatedWords[0] == ""@param"") {
            for (i in kDoc.indices.reversed()) {
                val kDocLineWords = kDoc[i].trim().split("" "").map { it.trim() }.filter { it.isNotEmpty() }.filterNot { it == ""*"" }
                if (kDocLineWords.size >= 2 && kDocLineWords[0] == generatedWords[0] && kDocLineWords[1] == generatedWords[1]) {
                    return i + 1  // position after last `@param` kDoc line, describing same parameter as in generatedCommentLine
                }
            }
        }
        return kDoc.size
    }

    @InternalKotlinNativeApi
    fun render(stub: ObjCExportStub, shouldExportKDoc: Boolean): List<String> = collect {
        stub.run {
            val (kDocEnding, commentBlockEnding) = if (comment?.contentLines == null) {","Pair(""*/"", null)  // Close kDoc with `*/`, and print nothing after empty comment"
"}
@Bar class ClassMarkedWithAnotherFoo {
    class NonMarkedClass {
        class NonMarkedClass
        @Foo class ClassMarkedWithFoo
        @Bar class ClassMarkedWithAnotherFoo
        @Another.Foo class ClassMarkedWithBar
        @Another.Bar class ClassMarkedWithAnotherBar
    }
    @Foo class ClassMarkedWithFoo
    @Bar class ClassMarkedWithAnotherFoo
    @Another.Foo class ClassMarkedWithBar
    @Another.Bar class ClassMarkedWithAnotherBar
}
@Another.Foo class ClassMarkedWithBar {
    class NonMarkedClass {
        class NonMarkedClass
        @Foo class ClassMarkedWithFoo
        @Bar class ClassMarkedWithAnotherFoo
        @Another.Foo class ClassMarkedWithBar
        @Another.Bar class ClassMarkedWithAnotherBar
    }
    @Foo class ClassMarkedWithFoo
    @Bar class ClassMarkedWithAnotherFoo
    @Another.Foo class ClassMarkedWithBar
    @Another.Bar class ClassMarkedWithAnotherBar
}
@Another.Bar class ClassMarkedWithAnotherBar {
    class NonMarkedClass {
        class NonMarkedClass
        @Foo class ClassMarkedWithFoo
        @Bar class ClassMarkedWithAnotherFoo
        @Another.Foo class ClassMarkedWithBar
        @Another.Bar class ClassMarkedWithAnotherBar
    }
    @Foo class ClassMarkedWithFoo
    @Bar class ClassMarkedWithAnotherFoo
    @Another.Foo class ClassMarkedWithBar
    @Another.Bar class ClassMarkedWithAnotherBar
}

class ClassWithConstructorMarkedWithFoo @Foo constructor()
class ClassWithConstructorMarkedWithAnotherFoo @Another.Foo constructor()
class ClassWithConstructorMarkedWithBar @Bar constructor()
class ClassWithConstructorMarkedWithAnotherBar @Another.Bar constructor()

fun nonMarkedFunction(): String = """"
@Foo fun functionMarkedWithFoo(): String = """"
@Bar fun functionMarkedWithAnotherFoo(): String = """"
@Another.Foo fun functionMarkedWithBar(): String = """"
@Another.Bar fun functionMarkedWithAnotherBar(): String = """"

var nonMarkedProperty: String get() = """"
    set(_) = Unit

@Foo var propertyWholeMarkedWithFoo: String get() = """"
    set(_) = Unit
@Another.Foo var propertyWholeMarkedWithAnotherFoo: String get() = """"
    set(_) = Unit
@Bar var propertyWholeMarkedWithBar: String get() = """"
    set(_) = Unit
@Another.Bar var propertyWholeMarkedWithAnotherBar: String get() = """"
    set(_) = Unit

var propertyGetterMarkedWithFoo: String @Foo get() = """"",set(_) = Unit
"} else {
            withTowerDataCleanup {
                addLocalScope(buildSecondaryConstructorParametersScope(constructor, session))
                f()
            }
        }
    }

    @OptIn(PrivateForInline::class)
    fun <T> withAnonymousFunction(
        anonymousFunction: FirAnonymousFunction,
        holder: SessionHolder,
        mode: ResolutionMode,
        f: () -> T
    ): T {
        require(mode !is ResolutionMode.ContextDependent)
        if (mode !is ResolutionMode.LambdaResolution) {
            storeContextForAnonymousFunction(anonymousFunction)
        }
        return withTowerDataCleanup {
            addLocalScope(FirLocalScope(holder.session))
            val receiverTypeRef = anonymousFunction.receiverParameter?.typeRef
            val labelName = anonymousFunction.label?.name?.let { Name.identifier(it) }
            withContainer(anonymousFunction) {
                withLabelAndReceiverType(labelName, anonymousFunction, receiverTypeRef?.coneType, holder) {
                    if (mode is ResolutionMode.LambdaResolution && mode.expectedReturnTypeRef == null) {
                        withLambdaBeingAnalyzedInDependentContext(anonymousFunction.symbol, f)
                    } else {
                        f()
                    }
                }
            }
        }
    }

    @OptIn(PrivateForInline::class)
    fun storeContextForAnonymousFunction(anonymousFunction: FirAnonymousFunction) {
        specialTowerDataContexts.storeAnonymousFunctionContext(
            anonymousFunction.symbol, towerDataContext, inferenceSession
        )
    }

    @OptIn(PrivateForInline::class)
    inline fun <T> withField(
        field: FirField,
        f: () -> T
    ): T {
        return withTowerDataMode(FirTowerDataMode.CONSTRUCTOR_HEADER) {
            withContainer(field) {
                withTowerDataCleanup {
                    getPrimaryConstructorAllParametersScope()?.let { addLocalScope(it) }
                    f()
                }
            }
        }
    }

    @OptIn(PrivateForInline::class)
    inline fun <T> withEnumEntry(
        enumEntry: FirEnumEntry,
        f: () -> T
    ): T = withTowerDataMode(FirTowerDataMode.ENUM_ENTRY) {
        withContainer(enumEntry, f)
    }",@OptIn(PrivateForInline::class)
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.components

import org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion
import org.jetbrains.kotlin.analysis.api.types.KtType

public abstract class KtSubtypingComponent : KtAnalysisSessionComponent() {
    public abstract fun isEqualTo(first: KtType, second: KtType, errorTypePolicy: KaSubtypingErrorTypePolicy): Boolean
    public abstract fun isSubTypeOf(subType: KtType, superType: KtType, errorTypePolicy: KaSubtypingErrorTypePolicy): Boolean
}

public interface KtSubtypingComponentMixIn : KtAnalysisSessionMixIn {
    public fun KtType.isEqualTo(other: KtType): Boolean =
        withValidityAssertion { analysisSession.subtypingComponent.isEqualTo(this, other, KaSubtypingErrorTypePolicy.STRICT) }","public fun KtType.isEqualTo(other: KtType, errorTypePolicy: KaSubtypingErrorTypePolicy): Boolean ="
"open val scrollX: Double
    open val pageXOffset: Double
    open val scrollY: Double
    open val pageYOffset: Double
    open val screenX: Int
    open val screenY: Int
    open val outerWidth: Int
    open val outerHeight: Int
    open val devicePixelRatio: Double
    fun close()
    fun stop()
    fun focus()
    fun blur()
    fun open(url: String = definedExternally, target: String = definedExternally, features: String = definedExternally): Window?
    fun alert()
    fun alert(message: String)
    fun confirm(message: String = definedExternally): Boolean
    fun prompt(message: String = definedExternally, default: String = definedExternally): String?
    fun print()
    fun requestAnimationFrame(callback: (Double) -> Unit): Int
    fun cancelAnimationFrame(handle: Int)
    fun postMessage(message: JsAny?, targetOrigin: String, transfer: JsArray<JsAny> = definedExternally)
    fun captureEvents()
    fun releaseEvents()
    fun matchMedia(query: String): MediaQueryList
    fun moveTo(x: Int, y: Int)
    fun moveBy(x: Int, y: Int)
    fun resizeTo(x: Int, y: Int)
    fun resizeBy(x: Int, y: Int)
    fun scroll(options: ScrollToOptions = definedExternally)
    fun scroll(x: Double, y: Double)
    fun scrollTo(options: ScrollToOptions = definedExternally)
    fun scrollTo(x: Double, y: Double)
    fun scrollBy(options: ScrollToOptions = definedExternally)
    fun scrollBy(x: Double, y: Double)
    fun getComputedStyle(elt: Element, pseudoElt: String? = definedExternally): CSSStyleDeclaration
}

@Suppress(""UNUSED_PARAMETER"")
internal fun getMethodImplForWindow(obj: Window, name: String): JsAny? { js(""return obj[name];"") }

public operator fun Window.get(name: String): JsAny? = getMethodImplForWindow(this, name)

public external abstract class BarProp : JsAny {
    open val visible: Boolean
}

/**
 * Exposes the JavaScript [History](https://developer.mozilla.org/en/docs/Web/API/History) to Kotlin
 */
public external abstract class History : JsAny {
    open val length: Int
    open var scrollRestoration: ScrollRestoration
    open val state: JsAny?
    fun go(delta: Int = definedExternally)
    fun back()
    fun forward()
    fun pushState(data: JsAny?, title: String, url: String? = definedExternally)
    fun replaceState(data: JsAny?, title: String, url: String? = definedExternally)
}

/**
 * Exposes the JavaScript [Location](https://developer.mozilla.org/en/docs/Web/API/Location) to Kotlin
 */
public external abstract class Location : JsAny {",open var href: String
"override fun transformField(field: FirField, data: Any?): FirField = whileAnalysing(session, field) {
        withScopeCleanup {
            field.transformReturnTypeRef(this, data).transformAnnotations(this, data)
            field
        }
    }

    override fun transformBackingField(backingField: FirBackingField, data: Any?): FirStatement = whileAnalysing(session, backingField) {
        backingField.transformAnnotations(this, data)
        super.transformBackingField(backingField, data)
    }

    override fun transformSimpleFunction(
        simpleFunction: FirSimpleFunction,
        data: Any?,
    ): FirSimpleFunction = whileAnalysing(session, simpleFunction) {
        withScopeCleanup {
            withDeclaration(simpleFunction) {
                addTypeParametersScope(simpleFunction)
                val result = transformDeclaration(simpleFunction, data).also {
                    unboundCyclesInTypeParametersSupertypes(it as FirTypeParametersOwner)
                }

                if (result.source?.kind == KtFakeSourceElementKind.DataClassGeneratedMembers &&
                    result is FirSimpleFunction &&
                    result.name == StandardNames.DATA_CLASS_COPY
                ) {
                    for (valueParameter in result.valueParameters) {
                        valueParameter.moveOrDeleteIrrelevantAnnotations()
                    }
                }

                result
            }
        } as FirSimpleFunction
    }

    private fun unboundCyclesInTypeParametersSupertypes(typeParametersOwner: FirTypeParameterRefsOwner) {
        for (typeParameter in typeParametersOwner.typeParameters) {
            if (typeParameter !is FirTypeParameter) continue
            if (hasSupertypePathToParameter(typeParameter, typeParameter, mutableSetOf())) {
                val errorType = buildErrorTypeRef {
                    diagnostic = ConeCyclicTypeBound(typeParameter.symbol, typeParameter.bounds.toImmutableList())
                }
                typeParameter.replaceBounds(
                    listOf(errorType)
                )
            }
        }
    }

    private fun hasSupertypePathToParameter(
        currentTypeParameter: FirTypeParameter,
        typeParameter: FirTypeParameter,
        visited: MutableSet<FirTypeParameter>
    ): Boolean {
        if (visited.isNotEmpty() && currentTypeParameter == typeParameter) return true
        if (!visited.add(currentTypeParameter)) return false

        fun ConeKotlinType.toNextTypeParameter(): FirTypeParameter? = when (this) {
            is ConeTypeParameterType -> lookupTag.typeParameterSymbol.fir
            is ConeDefinitelyNotNullType -> original.toNextTypeParameter()
            else -> null
        }",return currentTypeParameter.bounds.any {
"/**
 * Asserts Gradle output contains [expectedSubString] string.
 */
fun BuildResult.assertOutputContains(
    expectedSubString: String,
    message: String = ""Build output does not contain \""$expectedSubString\"""",
) {
    assert(output.contains(expectedSubString)) {
        printBuildOutput()
        message
    }
}

/**
 * Asserts Gradle output contains any of [expectedSubStrings] strings.
 */
fun BuildResult.assertOutputContainsAny(
    vararg expectedSubStrings: String,
) {
    assert(expectedSubStrings.any { output.contains(it) }) {
        printBuildOutput()
        ""Build output does not contain any of \""${expectedSubStrings.toList()}\""""
    }
}

/**
 * Asserts Gradle output contains [expectedSubString] string exact times.
 */
fun BuildResult.assertOutputContainsExactTimes(
    expectedSubString: String,
    expectedRepetitionTimes: Int = 1,
) {
    var currentOffset = 0
    var count = 0
    var nextIndex = output.indexOf(expectedSubString, currentOffset)

    while (nextIndex != -1 && count < expectedRepetitionTimes + 1) {
        count++
        currentOffset = nextIndex + expectedSubString.length
        nextIndex = output.indexOf(expectedSubString, currentOffset)
    }

    assert(count == expectedRepetitionTimes) {
        printBuildOutput()
        ""Build output contains \""$expectedSubString\"" $count times""
    }
}


/**
 * Asserts Gradle output does not contain [notExpectedSubString] string.
 *
 * @param wrappingCharsCount amount of chars to include before and after [notExpectedSubString] occurrence
 */
fun BuildResult.assertOutputDoesNotContain(
    notExpectedSubString: String,
    wrappingCharsCount: Int = 100,
) {
    assert(!output.contains(notExpectedSubString)) {
        printBuildOutput()

        // In case if notExpectedSubString is multiline string
        val occurrences = mutableListOf<Pair<Int, Int>>()
        var startIndex = output.indexOf(notExpectedSubString)",var endIndex = startIndex + notExpectedSubString.length
"open fun visitContinue(x: JsContinue): Unit =
            visitElement(x)

    open fun visitYield(x: JsYield): Unit =
        visitElement(x)

    open fun visitDebugger(x: JsDebugger): Unit =
            visitElement(x)

    open fun visitDefault(x: JsDefault): Unit =
            visitElement(x)

    open fun visitDoWhile(x: JsDoWhile): Unit =
            visitLoop(x)

    open fun visitEmpty(x: JsEmpty): Unit =
            visitElement(x)

    open fun visitExpressionStatement(x: JsExpressionStatement): Unit =
            visitElement(x)

    open fun visitFor(x: JsFor): Unit =
            visitLoop(x)

    open fun visitForIn(x: JsForIn): Unit =
            visitLoop(x)

    open fun visitFunction(x: JsFunction): Unit =
            visitElement(x)

    open fun visitIf(x: JsIf): Unit =
            visitElement(x)

    open fun visitInvocation(invocation: JsInvocation): Unit =
            visitElement(invocation)

    open fun visitLabel(x: JsLabel): Unit =
            visitElement(x)

    open fun visitLoop(x: JsLoop): Unit =
        visitElement(x)

    open fun visitNameRef(nameRef: JsNameRef): Unit =
            visitElement(nameRef)

    open fun visitNew(x: JsNew): Unit =
            visitElement(x)

    open fun visitNull(x: JsNullLiteral): Unit =
            visitElement(x)

    open fun visitInt(x: JsIntLiteral): Unit =
            visitElement(x)

    open fun visitDouble(x: JsDoubleLiteral): Unit =
            visitElement(x)

    open fun visitObjectLiteral(x: JsObjectLiteral): Unit =
            visitElement(x)

    open fun visitParameter(x: JsParameter): Unit =
            visitElement(x)

    open fun visitPostfixOperation(x: JsPostfixOperation): Unit =",visitElement(x)
class A {,"inner class B(val a: String = ""a"", val b: Int = 55, val c: String = ""c"")"
"fun B<(@A C)>.receiverArgument()
fun B<(@A C)?>.receiverArgumentN()

fun parameter(a: (@A C))
fun parameterN(a: (@A C)?)

fun parameterArgument(a: B<(@A C)>)
fun parameterArgumentN(a: B<(@A C)?>)

fun returnValue(): (@A C)
fun returnValueN(): (@A C)?

fun <T> returnTypeParameterValue(): (@A T)
fun <T> returnTypeParameterValueN(): (@A T)?

fun returnArgument(): B<(@A C)>
fun returnArgumentN(): B<(@A C)>?

val lambdaType: (@A() (() -> C))
val lambdaTypeN: (@A() (() -> C))?

val lambdaParameter: ((@A C)) -> C",val lambdaParameterN: ((@A C))? -> C
"if (nodeElementType == KtNodeTypes.NULL) return NullValue().wrap()

        val result: Any = when (nodeElementType) {
            KtNodeTypes.INTEGER_CONSTANT, KtNodeTypes.FLOAT_CONSTANT -> parseNumericLiteral(text, nodeElementType)
            KtNodeTypes.BOOLEAN_CONSTANT -> parseBoolean(text)
            KtNodeTypes.CHARACTER_CONSTANT -> CompileTimeConstantChecker.parseChar(expression)
            else -> throw IllegalArgumentException(""Unsupported constant: $expression"")
        } ?: return null

        if (result is Double) {
            if (result.isInfinite()) {
                trace.report(Errors.FLOAT_LITERAL_CONFORMS_INFINITY.on(expression))
            }
            if (result == 0.0 && !TypeConversionUtil.isFPZero(text)) {
                trace.report(Errors.FLOAT_LITERAL_CONFORMS_ZERO.on(expression))
            }
        }

        if (result is Float) {
            if (result.isInfinite()) {
                trace.report(Errors.FLOAT_LITERAL_CONFORMS_INFINITY.on(expression))
            }
            if (result == 0.0f && !TypeConversionUtil.isFPZero(text)) {
                trace.report(Errors.FLOAT_LITERAL_CONFORMS_ZERO.on(expression))
            }
        }

        val isIntegerConstant = nodeElementType == KtNodeTypes.INTEGER_CONSTANT
        val isUnsignedLong = isIntegerConstant && hasUnsignedLongSuffix(text)
        val isUnsigned = isUnsignedLong || hasUnsignedSuffix(text)
        val isTyped = isUnsigned || hasLongSuffix(text)

        return createConstant(
            result,
            expectedType,
            CompileTimeConstant.Parameters(
                canBeUsedInAnnotation = true,
                isPure = !isTyped,
                isUnsignedNumberLiteral = isUnsigned,
                isUnsignedLongNumberLiteral = isUnsignedLong,
                usesVariableAsConstant = false,
                usesNonConstValAsConstant = false,
                isConvertableConstVal = false
            )
        )
    }

    override fun visitParenthesizedExpression(expression: KtParenthesizedExpression, expectedType: KotlinType?): CompileTimeConstant<*>? {
        val deparenthesizedExpression = KtPsiUtil.deparenthesize(expression)
        if (deparenthesizedExpression != null && deparenthesizedExpression != expression) {
            return evaluate(deparenthesizedExpression, expectedType)
        }
        return null
    }

    override fun visitLabeledExpression(expression: KtLabeledExpression, expectedType: KotlinType?): CompileTimeConstant<*>? {
        val baseExpression = expression.baseExpression
        if (baseExpression != null) {
            return evaluate(baseExpression, expectedType)
        }
        return null
    }

    override fun visitStringTemplateExpression(expression: KtStringTemplateExpression, expectedType: KotlinType?): CompileTimeConstant<*>? {
        val sb = StringBuilder()",var interupted = false
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.resolve.substitution

import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.diagnostics.ConeSimpleDiagnostic
import org.jetbrains.kotlin.fir.diagnostics.ConeTypeVariableTypeIsNotInferred
import org.jetbrains.kotlin.fir.diagnostics.DiagnosticKind
import org.jetbrains.kotlin.fir.resolve.fullyExpandedType
import org.jetbrains.kotlin.fir.resolve.toFirRegularClassSymbol
import org.jetbrains.kotlin.fir.resolve.withCombinedAttributesFrom",import org.jetbrains.kotlin.fir.symbols.impl.FirTypeParameterSymbol
"/*
 * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the LICENSE file.
 */
// WITH_STDLIB

import kotlin.test.*

class A(val x: Int)",fun box(): String {
"i++
        }
        keysArray.resetRange(j, length)
        valuesArray?.resetRange(j, length)
        length = j
        //check(length == size) { ""Internal invariant violated during compact: length=$length != size=$size"" }
    }

    private fun rehash(newHashSize: Int) {
        registerModification()
        if (length > _size) compact()
        if (newHashSize != hashSize) {
            hashArray = IntArray(newHashSize)
            hashShift = computeShift(newHashSize)
        } else {
            hashArray.fill(0, 0, hashSize)
        }
        var i = 0
        while (i < length) {
            if (!putRehash(i++)) {
                throw IllegalStateException(""This cannot happen with fixed magic multiplier and grow-only hash array. "" +
                        ""Have object hashCodes changed?"")
            }
        }
    }

    private fun putRehash(i: Int): Boolean {
        var hash = hash(keysArray[i])
        var probesLeft = maxProbeDistance
        while (true) {
            val index = hashArray[hash]
            if (index == 0) {
                hashArray[hash] = i + 1
                presenceArray[i] = hash
                return true
            }
            if (--probesLeft < 0) return false
            if (hash-- == 0) hash = hashSize - 1
        }
    }

    private fun findKey(key: K): Int {
        var hash = hash(key)
        var probesLeft = maxProbeDistance
        while (true) {
            val index = hashArray[hash]
            if (index == 0) return TOMBSTONE
            if (index > 0 && keysArray[index - 1] == key) return index - 1
            if (--probesLeft < 0) return TOMBSTONE
            if (hash-- == 0) hash = hashSize - 1
        }
    }

    private fun findValue(value: V): Int {
        var i = length
        while (--i >= 0) {
            if (presenceArray[i] >= 0 && valuesArray!![i] == value)
                return i
        }
        return TOMBSTONE
    }

    internal fun addKey(key: K): Int {
        checkIsMutable()
        retry@ while (true) {",var hash = hash(key)
"<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!><!UNSAFE_CALL!>.<!>not()
}

/*
 * TESTCASE NUMBER: 4
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28333
 */
fun case_4(x: Boolean?, y: Boolean?) {
    do {
        y != null && break
        x!!
    } while (true)

    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!><!UNSAFE_CALL!>.<!>not()
}

// TESTCASE NUMBER: 5
fun case_5(x: Boolean?, y: Boolean?) {
    while (true) {
        y.to(break)
        x!!
    }

    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!><!UNSAFE_CALL!>.<!>not()
}

// TESTCASE NUMBER: 6
fun case_6(x: Boolean?, y: ((x: Nothing) -> Unit)?) {
    while (true) {
        y!!(break)
        x!!
    }

    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!><!UNSAFE_CALL!>.<!>not()
}

// TESTCASE NUMBER: 7
fun case_7(x: Boolean?, y: Boolean?) {
    while (true) {
        y ?: break
        x!!
    }

    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!><!UNSAFE_CALL!>.<!>not()
}

/*
 * TESTCASE NUMBER: 8
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28333
 */
fun case_8(x: Boolean?, y: Boolean?) {
    while (true) {
        y ?: (y!! || break)
        x!!
    }

    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!>","<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Boolean?"")!>x<!><!UNSAFE_CALL!>.<!>not()"
"@kotlin.internal.InlineOnly
public inline fun kotlin.DoubleArray.sumOf(selector: (kotlin.Double) -> kotlin.Long): kotlin.Long

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfUInt"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
@kotlin.internal.InlineOnly
public inline fun kotlin.DoubleArray.sumOf(selector: (kotlin.Double) -> kotlin.UInt): kotlin.UInt

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfULong"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
@kotlin.internal.InlineOnly
public inline fun kotlin.DoubleArray.sumOf(selector: (kotlin.Double) -> kotlin.ULong): kotlin.ULong

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfDouble"")
@kotlin.internal.InlineOnly
public inline fun kotlin.FloatArray.sumOf(selector: (kotlin.Float) -> kotlin.Double): kotlin.Double

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfInt"")
@kotlin.internal.InlineOnly
public inline fun kotlin.FloatArray.sumOf(selector: (kotlin.Float) -> kotlin.Int): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfLong"")
@kotlin.internal.InlineOnly
public inline fun kotlin.FloatArray.sumOf(selector: (kotlin.Float) -> kotlin.Long): kotlin.Long

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfUInt"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
@kotlin.internal.InlineOnly
public inline fun kotlin.FloatArray.sumOf(selector: (kotlin.Float) -> kotlin.UInt): kotlin.UInt

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfULong"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
@kotlin.internal.InlineOnly
public inline fun kotlin.FloatArray.sumOf(selector: (kotlin.Float) -> kotlin.ULong): kotlin.ULong

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfDouble"")
@kotlin.internal.InlineOnly
public inline fun kotlin.IntArray.sumOf(selector: (kotlin.Int) -> kotlin.Double): kotlin.Double

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfInt"")
@kotlin.internal.InlineOnly
public inline fun kotlin.IntArray.sumOf(selector: (kotlin.Int) -> kotlin.Int): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(name = ""sumOfLong"")
@kotlin.internal.InlineOnly",public inline fun kotlin.IntArray.sumOf(selector: (kotlin.Int) -> kotlin.Long): kotlin.Long
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.diagnostics.impl

import org.jetbrains.kotlin.diagnostics.DiagnosticContext
import org.jetbrains.kotlin.diagnostics.KtDiagnostic
import org.jetbrains.kotlin.diagnostics.Severity

class SimpleDiagnosticsCollectorWithSuppress(override val rawReport: (Boolean, String) -> Unit) : BaseDiagnosticsCollector() {
    private val _diagnosticsByFilePath: MutableMap<String?, MutableList<KtDiagnostic>> = mutableMapOf()
    override val diagnostics: List<KtDiagnostic>
        get() = _diagnosticsByFilePath.flatMap { it.value }","override val diagnosticsByFilePath: Map<String?, List<KtDiagnostic>>"
"icFeatures = icFeatures,
) {
    override val shouldTrackChangesInLookupCache
        get() = false

    override val shouldStoreFullFqNamesInLookupCache
        get() = icFeatures.withAbiSnapshot

    override fun createCacheManager(icContext: IncrementalCompilationContext, args: K2JSCompilerArguments) =
        IncrementalJsCachesManager(icContext, if (!args.isIrBackendEnabled()) JsSerializerProtocol else KlibMetadataSerializerProtocol, cacheDirectory)

    override fun destinationDir(args: K2JSCompilerArguments): File {
        return File(args.outputDir!!)
    }

    override fun calculateSourcesToCompile(
        caches: IncrementalJsCachesManager,
        changedFiles: ChangedFiles.Known,
        args: K2JSCompilerArguments,
        messageCollector: MessageCollector,
        classpathAbiSnapshots: Map<String, AbiSnapshot> //Ignore for now
    ): CompilationMode {
        if (buildHistoryFile == null) {
            error(""The build is configured to use the build-history based IC approach, but doesn't specify the buildHistoryFile"")
        }
        if (!icFeatures.withAbiSnapshot && !buildHistoryFile.isFile) {
            return CompilationMode.Rebuild(BuildAttribute.NO_BUILD_HISTORY)
        }
        val lastBuildInfo = BuildInfo.read(lastBuildInfoFile, messageCollector) ?: return CompilationMode.Rebuild(BuildAttribute.INVALID_LAST_BUILD_INFO)

        val dirtyFiles = DirtyFilesContainer(caches, reporter, kotlinSourceFilesExtensions)
        initDirtyFiles(dirtyFiles, changedFiles)

        val libs = (args.libraries ?: """").split(File.pathSeparator).map { File(it) }
        //TODO(valtman) check for JS
        val classpathChanges = getClasspathChanges(
            libs, changedFiles, lastBuildInfo, modulesApiHistory, reporter,
            mapOf(), false, caches.platformCache,
            caches.lookupCache.lookupSymbols.map { if (it.scope.isBlank()) it.name else it.scope }.distinct()
        )

        when (classpathChanges) {
            is ChangesEither.Unknown -> {
                reporter.info { ""Could not get classpath's changes: ${classpathChanges.reason}"" }
                return CompilationMode.Rebuild(classpathChanges.reason)
            }
            is ChangesEither.Known -> {
                dirtyFiles.addByDirtySymbols(classpathChanges.lookupSymbols)
                dirtyFiles.addByDirtyClasses(classpathChanges.fqNames)
            }
        }

        val removedClassesChanges = getRemovedClassesChanges(caches, changedFiles)
        dirtyFiles.addByDirtySymbols(removedClassesChanges.dirtyLookupSymbols)
        dirtyFiles.addByDirtyClasses(removedClassesChanges.dirtyClassesFqNames)
        dirtyFiles.addByDirtyClasses(removedClassesChanges.dirtyClassesFqNamesForceRecompile)

        if (dirtyFiles.isEmpty() && changedFiles.removed.isNotEmpty()) {
            return CompilationMode.Rebuild(BuildAttribute.DEP_CHANGE_REMOVED_ENTRY)
        }
        return CompilationMode.Incremental(dirtyFiles)
    }

    override fun makeServices(
        args: K2JSCompilerArguments,","lookupTracker: LookupTracker,"
"*
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`metadataCompilationApi`(
    dependencyNotation: String,
    dependencyConfiguration: Action<ExternalModuleDependency>
): ExternalModuleDependency = addDependencyTo(
    this, ""metadataCompilationApi"", dependencyNotation, dependencyConfiguration
) as ExternalModuleDependency

/**
 * Adds a dependency to the 'metadataCompilationApi' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`metadataCompilationApi`(
    dependencyNotation: Provider<*>,
    dependencyConfiguration: Action<ExternalModuleDependency>
): Unit = addConfiguredDependencyTo(
    this, ""metadataCompilationApi"", dependencyNotation, dependencyConfiguration
)

/**
 * Adds a dependency to the 'metadataCompilationApi' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`metadataCompilationApi`(
    dependencyNotation: ProviderConvertible<*>,
    dependencyConfiguration: Action<ExternalModuleDependency>
): Unit = addConfiguredDependencyTo(
    this, ""metadataCompilationApi"", dependencyNotation, dependencyConfiguration
)

/**
 * Adds a dependency to the 'metadataCompilationApi' configuration.
 *
 * @param group the group of the module to be added as a dependency.
 * @param name the name of the module to be added as a dependency.
 * @param version the optional version of the module to be added as a dependency.
 * @param configuration the optional configuration of the module to be added as a dependency.
 * @param classifier the optional classifier of the module artifact to be added as a dependency.
 * @param ext the optional extension of the module artifact to be added as a dependency.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.create]
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`metadataCompilationApi`(
    group: String,
    name: String,
    version: String? = null,","configuration: String? = null,"
"}
            }
            val originalSuperMethod = context.mapping.functionWithContinuationsToSuspendFunctions[transformedSuperMethod] ?: transformedSuperMethod
            buildInvokeMethod(originalSuperMethod)

            functionReferenceClass.superTypes += superTypes
            if (!isLambda) {
                fun addOverrideInner(name: String, value: IrBuilderWithScope.(IrFunction) -> IrExpression) {
                    val overridden = functionReferenceClass.superTypes.mapNotNull { superType ->
                        superType.getClass()
                                ?.declarations
                                ?.filterIsInstance<IrSimpleFunction>()
                                ?.singleOrNull { it.name.asString() == name }
                                ?.symbol
                    }
                    require(overridden.isNotEmpty())
                    val function = functionReferenceClass.addFunction {
                        startOffset = SYNTHETIC_OFFSET
                        endOffset = SYNTHETIC_OFFSET
                        this.name = Name.identifier(name)
                        modality = Modality.FINAL
                        returnType = overridden[0].owner.returnType
                    }
                    function.createDispatchReceiverParameter()
                    function.overriddenSymbols += overridden
                    function.body = context.createIrBuilder(function.symbol, SYNTHETIC_OFFSET, SYNTHETIC_OFFSET).irBlockBody {
                        +irReturn(
                                value(function)
                        )
                    }
                }

                fun addOverride(name: String, value: IrBuilderWithScope.() -> IrExpression) {
                    addOverrideInner(name) { _ -> value() }
                }


                listOfNotNull(
                        functionReference.symbol.owner.dispatchReceiverParameter,
                        functionReference.symbol.owner.extensionReceiverParameter
                ).singleOrNull { it in boundFunctionParameters }
                        ?.let { receiver ->
                            addOverrideInner(""computeReceiver"") { f ->
                                irGetField(irGet(f.dispatchReceiverParameter!!), argumentToPropertiesMap[receiver]!!)
                            }
                        }
            }

            functionReferenceClass.addFakeOverrides(
                    context.typeSystem,
                    // Built function overrides originalSuperMethod, while, if parent class is already lowered, it would
                    // transformedSuperMethod in its declaration list. We need not fake override in that case.
                    // Later lowerings will fix it and replace function with one overriding transformedSuperMethod.
                    ignoredParentSymbols = listOf(transformedSuperMethod.symbol)
            )

            functionReferenceClass.remapTypes(typeParameterRemapper)

            return functionReferenceClass
        }

        private fun buildConstructor() = functionReferenceClass.addConstructor {
            startOffset = this@FunctionReferenceBuilder.startOffset
            endOffset = this@FunctionReferenceBuilder.endOffset
            origin = DECLARATION_ORIGIN_FUNCTION_REFERENCE_IMPL",isPrimary = true
"functionalType.lookupTag,
            Array(size) { index -> if (index != size - 1) functionalType.typeArguments[index] else returnVariable.defaultType },
            isNullable = functionalType.isNullable,
            functionalType.attributes
        )
        csBuilder.addSubtypeConstraint(expectedType, functionalType, ConeArgumentConstraintPosition(atom.atom))
        atom.replaceExpectedType(expectedType, returnVariable.defaultType)
        atom.replaceTypeVariableForLambdaReturnType(returnVariable)
    }

    fun createCompletionResultsWriter(
        substitutor: ConeSubstitutor,
        mode: FirCallCompletionResultsWriterTransformer.Mode = FirCallCompletionResultsWriterTransformer.Mode.Normal,
    ): FirCallCompletionResultsWriterTransformer {
        return FirCallCompletionResultsWriterTransformer(
            session, components.scopeSession, substitutor, components.returnTypeCalculator,
            session.typeApproximator,
            components.dataFlowAnalyzer,
            components.integerLiteralAndOperatorApproximationTransformer,
            components.samResolver,
            components.context,
            mode,
        )
    }

    fun createPostponedArgumentsAnalyzer(context: ResolutionContext): PostponedArgumentsAnalyzer {
        val lambdaAnalyzer = LambdaAnalyzerImpl()
        return PostponedArgumentsAnalyzer(
            context,
            lambdaAnalyzer,
            session.inferenceComponents,
            transformer.components.callResolver
        )
    }

    private inner class LambdaAnalyzerImpl : LambdaAnalyzer {
        override fun analyzeAndGetLambdaReturnArguments(
            lambdaAtom: ResolvedLambdaAtom,
            receiverType: ConeKotlinType?,
            contextReceivers: List<ConeKotlinType>,
            parameters: List<ConeKotlinType>,
            expectedReturnType: ConeKotlinType?,
            candidate: Candidate,
            withPCLASession: Boolean,
            forOverloadByLambdaReturnType: Boolean,
        ): ReturnArgumentsAnalysisResult {
            val lambdaArgument: FirAnonymousFunction = lambdaAtom.atom
            val needItParam = lambdaArgument.valueParameters.isEmpty() && parameters.size == 1

            val matchedParameter = candidate.argumentMapping?.firstNotNullOfOrNull { (currentArgument, currentValueParameter) ->
                val currentLambdaArgument =
                    (currentArgument as? FirAnonymousFunctionExpression)?.anonymousFunction
                if (currentLambdaArgument === lambdaArgument) {
                    currentValueParameter
                } else {
                    null
                }
            }

            lambdaArgument.matchingParameterFunctionType = matchedParameter?.returnTypeRef?.coneType

            val itParam = when {
                needItParam -> {
                    val name = StandardNames.IMPLICIT_LAMBDA_PARAMETER_NAME
                    val itType = parameters.single()",buildValueParameter {
"listBuilder.addMarkerInterfaceIfNeeded(superType.classId)
                    }
                }
            }
        }

    return listBuilder
}

context(KtAnalysisSession)
internal fun KtSymbolWithMembers.createInnerClasses(
    manager: PsiManager,
    containingClass: SymbolLightClassBase,
    classOrObject: KtClassOrObject?
): List<SymbolLightClassBase> {
    val result = SmartList<SymbolLightClassBase>()

    getStaticDeclaredMemberScope().getClassifierSymbols().filterIsInstance<KtNamedClassOrObjectSymbol>().mapNotNullTo(result) {
        val classOrObjectDeclaration = it.sourcePsiSafe<KtClassOrObject>()
        if (classOrObjectDeclaration != null) {
            classOrObjectDeclaration.toLightClass() as? SymbolLightClassBase
        } else {
            createLightClassNoCache(it, ktModule = containingClass.ktModule, manager)
        }
    }

    val jvmDefaultMode = classOrObject
        ?.let { getModule(it) as? KtSourceModule }
        ?.languageVersionSettings
        ?.getFlag(JvmAnalysisFlags.jvmDefaultMode)
        ?: JvmDefaultMode.DISABLE

    if (containingClass is SymbolLightClassForInterface &&
        classOrObject?.hasInterfaceDefaultImpls == true &&
        jvmDefaultMode != JvmDefaultMode.ALL
    ) {
        result.add(SymbolLightClassForInterfaceDefaultImpls(containingClass))
    }

    if (containingClass is SymbolLightClassForAnnotationClass &&
        this is KtNamedClassOrObjectSymbol &&
        hasAnnotation(StandardClassIds.Annotations.Repeatable) &&
        !hasAnnotation(JvmStandardClassIds.Annotations.Java.Repeatable)
    ) {
        result.add(SymbolLightClassForRepeatableAnnotationContainer(containingClass))
    }

    return result
}

context(KtAnalysisSession)
internal fun KtClassOrObject.checkIsInheritor(superClassOrigin: KtClassOrObject, checkDeep: Boolean): Boolean {
    if (this == superClassOrigin) return false
    if (superClassOrigin is KtEnumEntry) {
        return false // enum entry cannot have inheritors
    }
    if (!superClassOrigin.canBeAnalysed()) {
        return false
    }

    val superClassSymbol = superClassOrigin.getClassOrObjectSymbol() ?: return false

    when (this) {
        is KtEnumEntry -> {
            val enumEntrySymbol = this.getEnumEntrySymbol()",val classId = enumEntrySymbol.containingEnumClassIdIfNonLocal ?: return false
"import abitestutils.abiTest
import lib1.*
import lib2.*

fun box() = abiTest {
    val abstractClass: AbstractClass = AbstractClassImpl()
    val _interface: Interface = InterfaceImpl()","expectFailure(nonImplementedCallable(""function 'foo'"", ""class 'AbstractClassImpl'"")) { abstractClass.foo() }"
"DOWNLOAD_COMPILER              (""download.compiler""),

        // Properties used instead of env vars until https://github.com/gradle/gradle/issues/3468 is fixed.
        // TODO: Remove them when an API for env vars is provided.
        KONAN_CONFIGURATION_BUILD_DIR  (""konan.configuration.build.dir""),
        KONAN_DEBUGGING_SYMBOLS        (""konan.debugging.symbols""),
        KONAN_OPTIMIZATIONS_ENABLE     (""konan.optimizations.enable""),
    }

    companion object {
        internal const val ARTIFACTS_CONTAINER_NAME = ""konanArtifacts""
        internal const val COMPILE_ALL_TASK_NAME = ""compileKonan""

        internal const val KONAN_EXTENSION_NAME = ""konan""

        internal val REQUIRED_GRADLE_VERSION = GradleVersion.version(""6.7"")
    }

    private fun checkGradleVersion() =  GradleVersion.current().let { current ->
        check(current >= REQUIRED_GRADLE_VERSION) {
            ""Kotlin/Native Gradle plugin is incompatible with this version of Gradle.\n"" +
            ""The minimal required version is $REQUIRED_GRADLE_VERSION\n"" +
            ""Current version is ${current}""
        }
    }

    private lateinit var konanJvmLauncher: JavaLauncher

    private fun getJavaLauncher(project: Project): Provider<JavaLauncher> = project.providers.provider {
        if (!::konanJvmLauncher.isInitialized) {
            val toolchain = project.extensions.getByType(JavaPluginExtension::class.java).toolchain
            val service = project.extensions.getByType(JavaToolchainService::class.java)
            konanJvmLauncher = try {
                service.launcherFor(toolchain).get()
            } catch (ex: GradleException) {
                // If the JDK that was set is not available get the JDK 11 as a default
                service.launcherFor(object : Action<JavaToolchainSpec> {
                    override fun execute(toolchainSpec: JavaToolchainSpec) {
                        toolchainSpec.languageVersion.set(JavaLanguageVersion.of(11))   // FIXME: not resolved from buildSrc JdkMajorVersion.JDK_11_0.majorVersion))
                    }
                }).get()
            }
        }
        konanJvmLauncher
    }

    override fun apply(project: ProjectInternal) {
        checkGradleVersion()
        project.plugins.apply(""base"")
        project.plugins.apply(""java"")
        // Create necessary tasks and extensions.
        project.extensions.create(KONAN_EXTENSION_NAME, KonanExtension::class.java)
        val container = project.extensions.create(
            KonanArtifactContainer::class.java,
            ARTIFACTS_CONTAINER_NAME,
            KonanArtifactContainer::class.java,
            project
        )
        project.setProperty(ProjectProperty.KONAN_JVM_LAUNCHER, getJavaLauncher(project))

        project.warnAboutDeprecatedProperty(ProjectProperty.KONAN_HOME)

        // Set additional project properties like org.jetbrains.kotlin.native.home, konan.build.targets etc.
        if (!project.useCustomDist) {
            project.setProperty(ProjectProperty.KONAN_HOME, project.konanCompilerDownloadDir())","project.setProperty(ProjectProperty.DOWNLOAD_COMPILER, true)"
"// !DIAGNOSTICS: -UNUSED_EXPRESSION -UNUSED_VARIABLE -UNUSED_VALUE
// SKIP_TXT

/*
 * KOTLIN DIAGNOSTICS NOT LINKED SPEC TEST (NEGATIVE)
 *
 * SECTIONS: dfa
 * NUMBER: 25
 * DESCRIPTION: Raw data flow analysis test
 * HELPERS: classes, objects, typealiases, functions, enumClasses, interfaces, sealedClasses
 */

// TESTCASE NUMBER: 1, 2
class ClassWithEqualsOverride {
    override fun equals(other: Any?) = true",fun fun_1() = true
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.resolve.calls.smartcasts

import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.calls.context.ResolutionContext
import org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValue
import org.jetbrains.kotlin.types.KotlinType

/**
 * This class is intended to create data flow values for different kind of expressions.
 * Then data flow values serve as keys to obtain data flow information for these expressions.
 */
interface DataFlowValueFactory {
    fun createDataFlowValue(
        expression: KtExpression,
        type: KotlinType,
        resolutionContext: ResolutionContext<*>
    ): DataFlowValue

    fun createDataFlowValue(
        expression: KtExpression,
        type: KotlinType,
        bindingContext: BindingContext,
        containingDeclarationOrModule: DeclarationDescriptor
    ): DataFlowValue

    fun createDataFlowValueForStableReceiver(receiver: ReceiverValue): DataFlowValue

    fun createDataFlowValue(
        receiverValue: ReceiverValue,
        resolutionContext: ResolutionContext<*>
    ): DataFlowValue

    fun createDataFlowValue(
        receiverValue: ReceiverValue,
        bindingContext: BindingContext,
        containingDeclarationOrModule: DeclarationDescriptor
    ): DataFlowValue

    fun createDataFlowValueForProperty(
        property: KtProperty,
        variableDescriptor: VariableDescriptor,
        bindingContext: BindingContext,",usageContainingModule: ModuleDescriptor?
".distinctBy { namer.getPropertyName(it) }
                .forEach { base -> add { buildProperty(property, base, objCExportScope) } }
        }
    }

    private fun StubBuilder<ObjCExportStub>.translateBaseMembers(members: List<CallableMemberDescriptor>) {
        // TODO: add some marks about modality.

        val methods = mutableListOf<FunctionDescriptor>()
        val properties = mutableListOf<PropertyDescriptor>()

        members.toObjCMembers(methods, properties)

        methods.forEach { exportThrown(it) }

        methods.retainAll { mapper.isBaseMethod(it) }

        properties.retainAll {
            if (mapper.isBaseProperty(it)) {
                true
            } else {
                methods.addIfNotNull(it.setter?.takeIf(mapper::isBaseMethod))
                false
            }
        }

        translatePlainMembers(methods, properties, ObjCRootExportScope)
    }

    private fun StubBuilder<ObjCExportStub>.translatePlainMembers(
        members: List<CallableMemberDescriptor>,
        objCExportScope: ObjCExportScope,
    ) {
        val methods = mutableListOf<FunctionDescriptor>()
        val properties = mutableListOf<PropertyDescriptor>()

        members.toObjCMembers(methods, properties)

        methods.forEach { exportThrown(it) }

        translatePlainMembers(methods, properties, objCExportScope)
    }

    private fun StubBuilder<ObjCExportStub>.translatePlainMembers(
        methods: List<FunctionDescriptor>,
        properties: List<PropertyDescriptor>,
        objCExportScope: ObjCExportScope,
    ) {
        methods.makeMethodsOrderStable().forEach { add { buildMethod(it, it, objCExportScope) } }
        properties.makePropertiesOrderStable().forEach { add { buildProperty(it, it, objCExportScope) } }
    }
    // TODO: consider checking that signatures for bases with same selector/name are equal.

    private fun getSelector(method: FunctionDescriptor): String {
        return namer.getSelector(method)
    }

    private fun buildProperty(
        property: PropertyDescriptor,
        baseProperty: PropertyDescriptor,
        objCExportScope: ObjCExportScope,
    ): ObjCProperty {
        assert(mapper.isBaseProperty(baseProperty))
        assert(mapper.isObjCProperty(baseProperty))",val getterBridge = mapper.bridgeMethod(baseProperty.getter!!)
"* Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.mainKts.test

import org.jetbrains.kotlin.mainKts.COMPILED_SCRIPTS_CACHE_DIR_ENV_VAR
import org.jetbrains.kotlin.mainKts.COMPILED_SCRIPTS_CACHE_DIR_PROPERTY
import org.jetbrains.kotlin.scripting.compiler.plugin.*
import org.jetbrains.kotlin.utils.KotlinPaths
import org.jetbrains.kotlin.utils.PathUtil
import org.junit.Assert
import org.junit.Ignore
import org.junit.Test
import java.io.File
import java.nio.file.Path
import kotlin.io.path.*

class MainKtsIT {

    @Test
    fun testResolveJunit() {
        runWithKotlincAndMainKts(""$TEST_DATA_ROOT/hello-resolve-junit.main.kts"", listOf(""Hello, World!""))
    }

    @Test
    @Ignore // Fails on TC most likely due to repo proxying
    fun testKotlinxHtml() {
        runWithK2JVMCompilerAndMainKts(
            ""$TEST_DATA_ROOT/kotlinx-html.main.kts"",
            listOf(""<html>"", ""  <body>"", ""    <h1>Hello, World!</h1>"", ""  </body>"", ""</html>"")
        )
    }

    @Test
    fun testImport() {
        val mainKtsJar = File(""dist/kotlinc/lib/kotlin-main-kts.jar"")
        Assert.assertTrue(""kotlin-main-kts.jar not found, run dist task: ${mainKtsJar.absolutePath}"", mainKtsJar.exists())

        runWithK2JVMCompiler(
            ""$TEST_DATA_ROOT/import-test.main.kts"",
            listOf(""Hi from common"", ""Hi from middle"", ""Hi from main"", ""sharedVar == 5""),
            classpath = listOf(mainKtsJar)
        )
    }

    @Test
    fun testThreadContextClassLoader() {
        runWithKotlincAndMainKts(""$TEST_DATA_ROOT/context-classloader.main.kts"", listOf(""MainKtsConfigurator""))
    }

    @OptIn(ExperimentalPathApi::class)
    @Test
    fun testCachedReflection() {
        val cache = createTempDirectory(""main.kts.test"")

        try {
            runWithKotlinRunner(""$TEST_DATA_ROOT/use-reflect.main.kts"", listOf(""false""), cacheDir = cache)
            // second run uses the cached script
            runWithKotlinRunner(""$TEST_DATA_ROOT/use-reflect.main.kts"", listOf(""false""), cacheDir = cache)
        } finally {
            cache.toFile().deleteRecursively()
        }
    }",@OptIn(ExperimentalPathApi::class)
"}

    /**
     * Gets the next random `Long` from the random number generator.
     *
     * Generates a `Long` random value uniformly distributed between `Long.MIN_VALUE` and `Long.MAX_VALUE` (inclusive).
     *
     * @sample samples.random.Randoms.nextLong
     */
    public open fun nextLong(): Long = nextInt().toLong().shl(32) + nextInt()

    /**
     * Gets the next random non-negative `Long` from the random number generator less than the specified [until] bound.
     *
     * Generates a `Long` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).
     *
     * @param until must be positive.
     *
     * @throws IllegalArgumentException if [until] is negative or zero.
     *
     * @sample samples.random.Randoms.nextLongFromUntil
     */
    public open fun nextLong(until: Long): Long = nextLong(0, until)

    /**
     * Gets the next random `Long` from the random number generator in the specified range.
     *
     * Generates a `Long` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.
     *
     * @throws IllegalArgumentException if [from] is greater than or equal to [until].
     *
     * @sample samples.random.Randoms.nextLongFromUntil
     */
    public open fun nextLong(from: Long, until: Long): Long {
        checkRangeBounds(from, until)
        val n = until - from
        if (n > 0) {
            val rnd: Long
            if (n and -n == n) {
                val nLow = n.toInt()
                val nHigh = (n ushr 32).toInt()
                rnd = when {
                    nLow != 0 -> {
                        val bitCount = fastLog2(nLow)
                        // toUInt().toLong()
                        nextBits(bitCount).toLong() and 0xFFFF_FFFF
                    }
                    nHigh == 1 ->
                        // toUInt().toLong()
                        nextInt().toLong() and 0xFFFF_FFFF
                    else -> {
                        val bitCount = fastLog2(nHigh)
                        nextBits(bitCount).toLong().shl(32) + (nextInt().toLong() and 0xFFFF_FFFF)
                    }
                }
            } else {
                var v: Long
                do {
                    val bits = nextLong().ushr(1)
                    v = bits % n
                } while (bits - v + (n - 1) < 0)
                rnd = v
            }
            return from + rnd
        } else {",while (true) {
"// TARGET_BACKEND: JVM

class MyListIterator<T> : ListIterator<T> {
    override fun next(): T = null!!
    override fun hasNext(): Boolean = null!!
    override fun hasPrevious(): Boolean = null!!
    override fun previous(): T = null!!
    override fun nextIndex(): Int = null!!
    override fun previousIndex(): Int = null!!
}

fun expectUoe(block: () -> Any) {
    try {",block()
"<!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 20
fun <K, V: K>case_20(map: MutableMap<K?, V>) {
    for ((k, v) in map) {
        if (true && true && true && k !== null && v != null && true) else continue
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any""), DEBUG_INFO_SMARTCAST!>v<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""V & V & Any"")!>v<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 21
fun <K, V>case_21(map: MutableMap<out K?, in V>) {
    for ((k, v) in map) {
        if (k == null) continue
        if (v === null || false) break
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?""), DEBUG_INFO_SMARTCAST!>k<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""K & Any & K?"")!>k<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?"")!>v<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?""), DEBUG_INFO_SMARTCAST!>v<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?""), DEBUG_INFO_SMARTCAST!>v<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?""), DEBUG_INFO_SMARTCAST!>v<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?"")!>v<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?"")!>v<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?""), DEBUG_INFO_SMARTCAST!>v<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?""), DEBUG_INFO_SMARTCAST!>v<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?"")!>v<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?"")!>v<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 22
fun <T> case_22(x: T?) {",while (true) {
"}
                }

                is FirProperty -> {
                    if (innerDeclaration.isRelatedToParameter(primaryConstructorParametersByName[innerDeclaration.name])) {
                        primaryConstructorPropertiesByName[innerDeclaration.name] = innerDeclaration
                    } else {
                        when {
                            innerDeclaration.delegate != null ->
                                reporter.reportOn(
                                    innerDeclaration.delegate!!.source,
                                    FirErrors.DELEGATED_PROPERTY_INSIDE_VALUE_CLASS,
                                    context
                                )

                            innerDeclaration.hasBackingField &&
                                    innerDeclaration.source?.kind !is KtFakeSourceElementKind -> {
                                reporter.reportOn(
                                    innerDeclaration.source, FirErrors.PROPERTY_WITH_BACKING_FIELD_INSIDE_VALUE_CLASS,
                                    context
                                )
                            }
                        }
                    }
                }

                else -> {}
            }
        }

        val reservedNames = boxAndUnboxNames + if (isCustomEqualsSupported) emptySet() else equalsAndHashCodeNames
        val classScope = declaration.unsubstitutedScope(context)
        for (reservedName in reservedNames) {
            classScope.processFunctionsByName(Name.identifier(reservedName)) {
                val functionSymbol = it.unwrapFakeOverrides()
                if (functionSymbol.isAbstract) return@processFunctionsByName
                val containingClassSymbol = functionSymbol.getContainingClassSymbol(context.session) ?: return@processFunctionsByName
                if (containingClassSymbol == declaration.symbol) {
                    if (functionSymbol.source?.kind is KtRealSourceElementKind) {
                        reporter.reportOn(
                            functionSymbol.source,
                            FirErrors.RESERVED_MEMBER_INSIDE_VALUE_CLASS,
                            reservedName,
                            context
                        )
                    }
                } else if (containingClassSymbol.classKind == ClassKind.INTERFACE) {
                    reporter.reportOn(
                        declaration.source,
                        FirErrors.RESERVED_MEMBER_FROM_INTERFACE_INSIDE_VALUE_CLASS,
                        containingClassSymbol.name.asString(),
                        reservedName,
                        context
                    )
                }
            }
        }

        if (primaryConstructor?.source?.kind !is KtRealSourceElementKind) {
            reporter.reportOn(declaration.source, FirErrors.ABSENCE_OF_PRIMARY_CONSTRUCTOR_FOR_VALUE_CLASS, context)
            return
        }

        if (context.languageVersionSettings.supportsFeature(LanguageFeature.ValueClasses)) {
            if (primaryConstructorParametersByName.isEmpty()) {","reporter.reportOn(primaryConstructor.source, FirErrors.VALUE_CLASS_EMPTY_CONSTRUCTOR, context)"
"* you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.js.translate.declaration

import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.builtins.StandardNames
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.js.backend.ast.*
import org.jetbrains.kotlin.js.translate.context.Namer
import org.jetbrains.kotlin.js.translate.context.TranslationContext
import org.jetbrains.kotlin.js.translate.general.AbstractTranslator
import org.jetbrains.kotlin.js.translate.utils.JsAstUtils
import org.jetbrains.kotlin.resolve.DescriptorUtils
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe

class EnumTranslator(
        context: TranslationContext,
        val descriptor: ClassDescriptor,
        val entries: List<ClassDescriptor>,
        private val psi: PsiElement
) : AbstractTranslator(context) {
    fun generateStandardMethods() {
        generateValuesFunction()
        generateValueOfFunction()
    }

    private fun generateValuesFunction() {
        val function = createFunction(DescriptorUtils.getFunctionByName(descriptor.staticScope, StandardNames.ENUM_VALUES))

        val values = entries.map {
            JsInvocation(JsAstUtils.pureFqn(context().getNameForObjectInstance(it), null)).source(psi)
        }
        function.body.statements += JsReturn(JsArrayLiteral(values).source(psi)).apply { source = psi }
    }

    private fun generateValueOfFunction() {
        val function = createFunction(DescriptorUtils.getFunctionByName(descriptor.staticScope, StandardNames.ENUM_VALUE_OF))

        val nameParam = JsScope.declareTemporaryName(""name"")
        function.parameters += JsParameter(nameParam)

        val clauses = entries.map { entry ->
            JsCase().apply {
                caseExpression = JsStringLiteral(entry.name.asString()).source(psi)
                statements += JsReturn(JsInvocation(JsAstUtils.pureFqn(context().getNameForObjectInstance(entry), null)).source(psi))
                        .apply { source = psi }
                source = psi
            }
        }

        val message = JsBinaryOperation(JsBinaryOperator.ADD,
                                        JsStringLiteral(""No enum constant ${descriptor.fqNameSafe}.""),
                                        nameParam.makeRef())
        val throwFunction = context().getReferenceToIntrinsic(Namer.THROW_ILLEGAL_ARGUMENT_EXCEPTION_FUN_NAME)","val throwStatement = JsExpressionStatement(JsInvocation(throwFunction, message).source(psi))"
"/*
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-37431
 */

class Case1() {

    fun foo() {
        val x = sequence<String> {

            val  y = this
            //this is Case1 instead of SequenceScope<String>","yield("""") // UNRESOLVED_REFERENCE"
"// !DIAGNOSTICS: -UNUSED_PARAMETER

fun test(a: D1, b: D2) {
    id<Out<Base>>(
        makeOut(
            select(a, b)
        )
    )
    id<Inv<Base>>(
        makeInv(
            select(a, b)
        )
    )
    id<In<Base>>(
        makeIn(
            select(a, b)
        )
    )
    id<In<In<Base>>>(
        makeInIn(
            select(a, b)
        )
    )
}

interface Base
interface B1 : Base
interface B2 : Base
interface D1 : B1, B2
interface D2 : B1, B2

fun <S> select(a: S, b: S): S = TODO()
class Inv<T>",class Out<out O>
"// FIR_IDENTICAL
// !LANGUAGE: +DefinitelyNonNullableTypes

interface A<T> {
    fun foo(x: T): T
    fun bar(x: T & Any): T & Any
}

interface B<T1> : A<T1> {
    override fun foo(x: T1): T1
    override fun bar(x: T1 & Any): T1 & Any
}

interface C<T2> : A<T2> {
    <!NOTHING_TO_OVERRIDE!>override<!> fun foo(x: T2 & Any): T2 & Any
    <!NOTHING_TO_OVERRIDE!>override<!> fun bar(x: T2): T2
}

interface D : A<String?> {
    override fun foo(x: String?): String?
    override fun bar(x: String): String
}

interface E : A<String> {
    override fun foo(x: String): String
    override fun bar(x: String): String
}

interface F : A<String?> {",<!NOTHING_TO_OVERRIDE!>override<!> fun foo(x: String): String
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.ir.expressions.impl

import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.declarations.IrAttributeContainer
import org.jetbrains.kotlin.ir.expressions.IrEnumConstructorCall
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.expressions.IrStatementOrigin
import org.jetbrains.kotlin.ir.symbols.IrConstructorSymbol
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.util.initializeParameterArguments
import org.jetbrains.kotlin.ir.util.initializeTypeArguments

class IrEnumConstructorCallImpl(
    override val startOffset: Int,
    override val endOffset: Int,
    override var type: IrType,
    override var symbol: IrConstructorSymbol,
    typeArgumentsCount: Int,
    valueArgumentsCount: Int
) : IrEnumConstructorCall() {",override var origin: IrStatementOrigin? = null
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""FunctionName"")

package org.jetbrains.kotlin.gradle.unitTests.compilerArgumetns

import org.jetbrains.kotlin.compilerRunner.ArgumentUtils
import org.jetbrains.kotlin.gradle.dsl.multiplatformExtension
import org.jetbrains.kotlin.gradle.plugin.CreateCompilerArgumentsContext
import org.jetbrains.kotlin.gradle.plugin.KotlinCompilerArgumentsProducer.ArgumentType.*
import org.jetbrains.kotlin.gradle.plugin.KotlinCompilerArgumentsProducer.CreateCompilerArgumentsContext.Companion.default",import org.jetbrains.kotlin.gradle.plugin.KotlinCompilerArgumentsProducer.CreateCompilerArgumentsContext.Companion.lenient
"if (0.toShort() !in 3L..1L != !range1.contains(0.toShort())) throw AssertionError()
    if (!(0.toShort() in 3L..1L) != !range1.contains(0.toShort())) throw AssertionError()
    if (!(0.toShort() !in 3L..1L) != range1.contains(0.toShort())) throw AssertionError()
    // no local optimizations
    if (element5 in 3L..1L != range1.contains(element5)) throw AssertionError()
    if (element5 !in 3L..1L != !range1.contains(element5)) throw AssertionError()
    if (!(element5 in 3L..1L) != !range1.contains(element5)) throw AssertionError()
    if (!(element5 !in 3L..1L) != range1.contains(element5)) throw AssertionError()
}

fun testR1xE6() {
    // with possible local optimizations
    if (0 in 3L..1L != range1.contains(0)) throw AssertionError()
    if (0 !in 3L..1L != !range1.contains(0)) throw AssertionError()
    if (!(0 in 3L..1L) != !range1.contains(0)) throw AssertionError()
    if (!(0 !in 3L..1L) != range1.contains(0)) throw AssertionError()
    // no local optimizations
    if (element6 in 3L..1L != range1.contains(element6)) throw AssertionError()
    if (element6 !in 3L..1L != !range1.contains(element6)) throw AssertionError()
    if (!(element6 in 3L..1L) != !range1.contains(element6)) throw AssertionError()
    if (!(element6 !in 3L..1L) != range1.contains(element6)) throw AssertionError()
}

fun testR1xE7() {
    // with possible local optimizations
    if (0L in 3L..1L != range1.contains(0L)) throw AssertionError()
    if (0L !in 3L..1L != !range1.contains(0L)) throw AssertionError()
    if (!(0L in 3L..1L) != !range1.contains(0L)) throw AssertionError()
    if (!(0L !in 3L..1L) != range1.contains(0L)) throw AssertionError()
    // no local optimizations
    if (element7 in 3L..1L != range1.contains(element7)) throw AssertionError()
    if (element7 !in 3L..1L != !range1.contains(element7)) throw AssertionError()
    if (!(element7 in 3L..1L) != !range1.contains(element7)) throw AssertionError()
    if (!(element7 !in 3L..1L) != range1.contains(element7)) throw AssertionError()
}

fun testR1xE8() {
    // with possible local optimizations
    if (1.toByte() in 3L..1L != range1.contains(1.toByte())) throw AssertionError()
    if (1.toByte() !in 3L..1L != !range1.contains(1.toByte())) throw AssertionError()
    if (!(1.toByte() in 3L..1L) != !range1.contains(1.toByte())) throw AssertionError()
    if (!(1.toByte() !in 3L..1L) != range1.contains(1.toByte())) throw AssertionError()
    // no local optimizations
    if (element8 in 3L..1L != range1.contains(element8)) throw AssertionError()
    if (element8 !in 3L..1L != !range1.contains(element8)) throw AssertionError()
    if (!(element8 in 3L..1L) != !range1.contains(element8)) throw AssertionError()
    if (!(element8 !in 3L..1L) != range1.contains(element8)) throw AssertionError()
}

fun testR1xE9() {
    // with possible local optimizations
    if (1.toShort() in 3L..1L != range1.contains(1.toShort())) throw AssertionError()
    if (1.toShort() !in 3L..1L != !range1.contains(1.toShort())) throw AssertionError()
    if (!(1.toShort() in 3L..1L) != !range1.contains(1.toShort())) throw AssertionError()
    if (!(1.toShort() !in 3L..1L) != range1.contains(1.toShort())) throw AssertionError()
    // no local optimizations
    if (element9 in 3L..1L != range1.contains(element9)) throw AssertionError()
    if (element9 !in 3L..1L != !range1.contains(element9)) throw AssertionError()
    if (!(element9 in 3L..1L) != !range1.contains(element9)) throw AssertionError()
    if (!(element9 !in 3L..1L) != range1.contains(element9)) throw AssertionError()
}

fun testR1xE10() {
    // with possible local optimizations
    if (1 in 3L..1L != range1.contains(1)) throw AssertionError()",if (1 !in 3L..1L != !range1.contains(1)) throw AssertionError()
"parentSerializer ?: create(container, extension, null, languageVersionSettings, project)
            else
                createTopLevel(extension, languageVersionSettings)
            val plugins = project?.let { DescriptorSerializerPlugin.getInstances(it) }.orEmpty()
            val typeAttributeTranslators = project?.let { TypeAttributeTranslatorExtension.createTranslators(it) }

            // Calculate type parameter ids for the outer class beforehand, as it would've had happened if we were always
            // serializing outer classes before nested classes.
            // Otherwise our interner can get wrong ids because we may serialize classes in any order.
            val serializer = DescriptorSerializer(
                descriptor,
                Interner(parent.typeParameters),
                extension,
                MutableTypeTable(),
                if (container is ClassDescriptor && !isVersionRequirementTableWrittenCorrectly(extension.metadataVersion))
                    parent.versionRequirementTable else MutableVersionRequirementTable(),
                serializeTypeTableToFunction = false,
                languageVersionSettings,
                plugins,
                typeAttributeTranslators
            )
            for (typeParameter in descriptor.declaredTypeParameters) {
                serializer.typeParameters.intern(typeParameter)
            }
            return serializer
        }

        private fun variance(variance: Variance): ProtoBuf.TypeParameter.Variance = when (variance) {
            Variance.INVARIANT -> ProtoBuf.TypeParameter.Variance.INV
            Variance.IN_VARIANCE -> ProtoBuf.TypeParameter.Variance.IN
            Variance.OUT_VARIANCE -> ProtoBuf.TypeParameter.Variance.OUT
        }

        private fun projection(projectionKind: Variance): ProtoBuf.Type.Argument.Projection = when (projectionKind) {
            Variance.INVARIANT -> ProtoBuf.Type.Argument.Projection.INV
            Variance.IN_VARIANCE -> ProtoBuf.Type.Argument.Projection.IN
            Variance.OUT_VARIANCE -> ProtoBuf.Type.Argument.Projection.OUT
        }

        private fun hasAnnotations(descriptor: Annotated?): Boolean =
            descriptor != null && descriptor.nonSourceAnnotations.isNotEmpty()

        fun <T : DeclarationDescriptor> sort(descriptors: Collection<T>): List<T> =
            ArrayList(descriptors).apply {
                //NOTE: the exact comparator does matter here
                Collections.sort(this, MemberComparator.INSTANCE)
            }

        fun writeLanguageVersionRequirement(
            languageFeature: LanguageFeature,
            versionRequirementTable: MutableVersionRequirementTable
        ): Int {
            val languageVersion = languageFeature.sinceVersion!!
            return writeVersionRequirement(
                languageVersion.major, languageVersion.minor, 0,
                ProtoBuf.VersionRequirement.VersionKind.LANGUAGE_VERSION,
                versionRequirementTable
            )
        }

        fun writeVersionRequirement(
            major: Int,
            minor: Int,
            patch: Int,
            versionKind: ProtoBuf.VersionRequirement.VersionKind,",versionRequirementTable: MutableVersionRequirementTable
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.buildtools.api

import java.io.File

/**
 * Allows users to customize the compiler execution strategy.
 *
 * This interface is not intended to be implemented by the API consumers.
 */
@ExperimentalBuildToolsApi
public interface CompilerExecutionStrategyConfiguration {
    /**
     * Marks the compilation to be run inside the same JVM as the caller.
     * The default strategy.
     */
    public fun useInProcessStrategy(): CompilerExecutionStrategyConfiguration

    /**
     * Marks the compilation to be run in Kotlin daemon launched as a separate process and shared across similar compilation requests.
     * See Kotlin daemon documentation here: https://kotlinlang.org/docs/gradle-compilation-and-caches.html#the-kotlin-daemon-and-how-to-use-it-with-gradle
     * @param jvmArguments a list of JVM startup arguments for the daemon
     */
    public fun useDaemonStrategy(","jvmArguments: List<String>,"
"var intNWrapper: IntNWrapper
    var intNWrapperN: /*boxed*/ IntNWrapper?
    var fooWrapper: FooWrapper
    var fooWrapperN: FooWrapper?
    var fooNWrapper: FooNWrapper
    var fooNWrapperN: /*boxed*/ FooNWrapper?
    var nativeFooWrapper: NativeFooWrapper
    var nativeFooWrapperN: NativeFooWrapper?
    var nativeFooNWrapper: NativeFooNWrapper
    var nativeFooNWrapperN: /*boxed*/ NativeFooNWrapper?

    val readOnlyIntWrapper: IntWrapper
    val readOnlyIntWrapperN: IntWrapper?
    val readOnlyIntNWrapper: IntNWrapper
    val readOnlyIntNWrapperN: /*boxed*/ IntNWrapper?
    val readOnlyFooWrapper: FooWrapper
    val readOnlyFooWrapperN: FooWrapper?
    val readOnlyFooNWrapper: FooNWrapper
    val readOnlyFooNWrapperN: /*boxed*/ FooNWrapper?
    val readOnlyNativeFooWrapper: NativeFooWrapper
    val readOnlyNativeFooWrapperN: NativeFooWrapper?
    val readOnlyNativeFooNWrapper: NativeFooNWrapper
    val readOnlyNativeFooNWrapperN: /*boxed*/ NativeFooNWrapper?

    fun getIntWrapper(): IntWrapper
    fun getIntWrapperN(): IntWrapper?
    fun getIntNWrapper(): IntNWrapper
    fun getIntNWrapperN(): /*boxed*/ IntNWrapper?
    fun getFooWrapper(): FooWrapper
    fun getFooWrapperN(): FooWrapper?
    fun getFooNWrapper(): FooNWrapper
    fun getFooNWrapperN(): /*boxed*/ FooNWrapper?
    fun getNativeFooWrapper(): NativeFooWrapper
    fun getNativeFooWrapperN(): NativeFooWrapper?
    fun getNativeFooNWrapper(): NativeFooNWrapper
    fun getNativeFooNWrapperN(): /*boxed*/ NativeFooNWrapper?
}

fun testInterfaceMethodsWithValueClassesInArgs() {
    val o = makeTestInterfaceInstance()

    assertEquals(""42 (number)"", o.describeIntWrapper(IntWrapper(42)))
    assertEquals(""100 (number)"", o.describeIntWrapperN(IntWrapper(100)))
    assertEquals(""null (object)"", o.describeIntWrapperN(null))

    assertEquals(""42 (number)"", o.describeIntNWrapper(IntNWrapper(42)))
    assertEquals(""null (object)"", o.describeIntNWrapper(IntNWrapper(null)))
    assertEquals(""IntNWrapper(value=100) (object)"", o.describeIntNWrapperN(IntNWrapper(100)))
    assertEquals(""IntNWrapper(value=null) (object)"", o.describeIntNWrapperN(IntNWrapper(null)))
    assertEquals(""null (object)"", o.describeIntNWrapperN(null))

    assertEquals(""Foo(s=hello) (object)"", o.describeFooWrapper(FooWrapper(Foo(""hello""))))
    assertEquals(""Foo(s=goodbye) (object)"", o.describeFooWrapperN(FooWrapper(Foo(""goodbye""))))
    assertEquals(""null (object)"", o.describeFooWrapperN(null))

    assertEquals(""Foo(s=hello) (object)"", o.describeFooNWrapper(FooNWrapper(Foo(""hello""))))
    assertEquals(""null (object)"", o.describeFooNWrapper(FooNWrapper(null)))
    assertEquals(""FooNWrapper(fooN=Foo(s=goodbye)) (object)"", o.describeFooNWrapperN(FooNWrapper(Foo(""goodbye""))))
    assertEquals(""FooNWrapper(fooN=null) (object)"", o.describeFooNWrapperN(FooNWrapper(null)))
    assertEquals(""null (object)"", o.describeFooNWrapperN(null))

    assertEquals(""NativeFoo('hello') (object)"", o.describeNativeFooWrapper(NativeFooWrapper(NativeFoo(""hello""))))
    assertEquals(""NativeFoo('goodbye') (object)"", o.describeNativeFooWrapperN(NativeFooWrapper(NativeFoo(""goodbye""))))
    assertEquals(""null (object)"", o.describeNativeFooWrapperN(null))","assertEquals(""NativeFoo('hello') (object)"", o.describeNativeFooNWrapper(NativeFooNWrapper(NativeFoo(""hello""))))"
"return collection as C
    }
}

class ListExternalizer<T>(elementExternalizer: DataExternalizer<T>) :
    CollectionExternalizerV2<T, List<T>>(elementExternalizer, { size -> ArrayList(size) })

class SetExternalizer<T>(elementExternalizer: DataExternalizer<T>) :
    CollectionExternalizerV2<T, Set<T>>(elementExternalizer, { size -> LinkedHashSet(size) })

open class MapExternalizer<K, V, M : Map<K, V>>(
    private val keyExternalizer: DataExternalizer<K>,
    private val valueExternalizer: DataExternalizer<V>,
    private val newMap: (size: Int) -> MutableMap<K, V> = { size -> LinkedHashMap(size) }
) : DataExternalizer<M> {

    override fun save(output: DataOutput, map: M) {
        output.writeInt(map.size)
        for ((key, value) in map) {
            keyExternalizer.save(output, key)
            valueExternalizer.save(output, value)
        }
    }

    override fun read(input: DataInput): M {
        val size = input.readInt()
        val map = newMap(size)
        repeat(size) {
            val key = keyExternalizer.read(input)
            val value = valueExternalizer.read(input)
            map[key] = value
        }
        @Suppress(""UNCHECKED_CAST"")
        return map as M
    }
}

class LinkedHashMapExternalizer<K, V>(
    keyExternalizer: DataExternalizer<K>,
    valueExternalizer: DataExternalizer<V>
) : MapExternalizer<K, V, LinkedHashMap<K, V>>(keyExternalizer, valueExternalizer, { size -> LinkedHashMap(size) })

object JvmMethodSignatureExternalizer : DataExternalizer<JvmMemberSignature.Method> {

    override fun save(output: DataOutput, method: JvmMemberSignature.Method) {
        StringExternalizer.save(output, method.name)
        StringExternalizer.save(output, method.desc)
    }

    override fun read(input: DataInput): JvmMemberSignature.Method {
        return JvmMemberSignature.Method(
            name = StringExternalizer.read(input),
            desc = StringExternalizer.read(input)
        )
    }
}

object InlineFunctionOrAccessorExternalizer : DataExternalizer<InlineFunctionOrAccessor> by DelegateDataExternalizer(
    types = listOf(InlineFunction::class.java, InlinePropertyAccessor::class.java),
    typesExternalizers = listOf(InlineFunctionExternalizer, InlinePropertyAccessorExternalizer)
)

private object InlineFunctionExternalizer : DataExternalizer<InlineFunction> {

    override fun save(output: DataOutput, function: InlineFunction) {","JvmMethodSignatureExternalizer.save(output, function.jvmMethodSignature)"
"// LANGUAGE: +MultiPlatformProjects
// IGNORE_BACKEND_K1: ANY
// TARGET_BACKEND: JVM_IR

// MODULE: common
// FILE: Base.kt
expect interface Base

// MODULE: jvm()()(common)
// FILE: Property.kt
public actual interface Base {
    fun getValue(): PropType // /Base.PropType

    interface PropType {
        val name: String
    }
}

// FILE: Derived.java
public abstract class Derived implements Base {
    @Override
    public Base.PropType getValue() { // /Base/PropType
        return new Base.PropType() {
            @Override",public String getName() {
"}

class TryExpressionExitNode(owner: ControlFlowGraph, override val fir: FirTryExpression, level: Int) : CFGNode<FirTryExpression>(owner, level),
    ExitNodeMarker {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitTryExpressionExitNode(this, data)
    }
}

// ----------------------------------- Boolean operators -----------------------------------

abstract class AbstractBinaryExitNode<T : FirElement>(owner: ControlFlowGraph, level: Int) : CFGNode<T>(owner, level) {
    val leftOperandNode: CFGNode<*> get() = previousNodes[0]
    val rightOperandNode: CFGNode<*> get() = previousNodes[1]
}

class BinaryAndEnterNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : CFGNode<FirBinaryLogicExpression>(owner, level),
    EnterNodeMarker {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryAndEnterNode(this, data)
    }
}
class BinaryAndExitLeftOperandNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : CFGNode<FirBinaryLogicExpression>(owner, level) {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryAndExitLeftOperandNode(this, data)
    }
}
class BinaryAndEnterRightOperandNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : CFGNode<FirBinaryLogicExpression>(owner, level) {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryAndEnterRightOperandNode(this, data)
    }
}
class BinaryAndExitNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : AbstractBinaryExitNode<FirBinaryLogicExpression>(owner, level),
    ExitNodeMarker {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryAndExitNode(this, data)
    }
}

class BinaryOrEnterNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : CFGNode<FirBinaryLogicExpression>(owner, level),
    EnterNodeMarker {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryOrEnterNode(this, data)
    }
}
class BinaryOrExitLeftOperandNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : CFGNode<FirBinaryLogicExpression>(owner, level) {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryOrExitLeftOperandNode(this, data)
    }
}
class BinaryOrEnterRightOperandNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : CFGNode<FirBinaryLogicExpression>(owner, level) {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryOrEnterRightOperandNode(this, data)
    }
}
class BinaryOrExitNode(owner: ControlFlowGraph, override val fir: FirBinaryLogicExpression, level: Int) : AbstractBinaryExitNode<FirBinaryLogicExpression>(owner, level),
    ExitNodeMarker {
    override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {
        return visitor.visitBinaryOrExitNode(this, data)
    }
}

// ----------------------------------- Operator call -----------------------------------

class TypeOperatorCallNode(owner: ControlFlowGraph, override val fir: FirTypeOperatorCall, level: Int) : CFGNode<FirTypeOperatorCall>(owner, level) {","override fun <R, D> accept(visitor: ControlFlowGraphVisitor<R, D>, data: D): R {"
"On the JS platform it represents a plain reference to a JavaScript function.
        
        On the JVM platform it represents a [java.lang.invoke.MethodHandle] constant.
        """""".trimIndent()

        +referencedSymbol(functionSymbolType)
    }
    val containerExpression: Element by element(Expression) {
        parent(expression)
        parent(statementContainer)

        +field(""origin"", statementOriginType, nullable = true)
    }
    val block: Element by element(Expression) {
        needAcceptMethod()

        parent(containerExpression)
    }
    val composite: Element by element(Expression) {
        parent(containerExpression)
    }
    val returnableBlock: Element by element(Expression) {
        parent(block)
        parent(symbolOwner)
        parent(returnTarget)

        +declaredSymbol(returnableBlockSymbolType)
    }
    val inlinedFunctionBlock: Element by element(Expression) {
        parent(block)

        visitorParameterName = ""inlinedBlock""

        +field(""inlineCall"", functionAccessExpression, isChild = false)
        +field(""inlinedElement"", rootElement, isChild = false)
    }
    val syntheticBody: Element by element(Expression) {
        visitorParameterName = ""body""

        parent(body)

        +field(""kind"", type(Packages.exprs, ""IrSyntheticBodyKind""))
    }
    val breakContinue: Element by element(Expression) {
        visitorParameterName = ""jump""

        parent(expression)

        +field(""loop"", loop, isChild = false)
        +field(""label"", string, nullable = true)
    }
    val `break` by element(Expression) {
        visitorParameterName = ""jump""

        parent(breakContinue)
    }
    val `continue` by element(Expression) {
        visitorParameterName = ""jump""

        parent(breakContinue)
    }
    val call: Element by element(Expression) {
        parent(functionAccessExpression)",+referencedSymbol(simpleFunctionSymbolType)
"This associator has two jobs
        1) It will add the output of the 'main' compilation as compile & runtime dependency to the 'auxiliary' compilation
        2) It will add all 'declared dependencies' present on 'main' to 'auxiliary'

        For 1)
        This is necessary so that all symbols that are declared/produced in 'main' are available in 'auxiliary'.
        We use the 'compileOnlyConfiguration' and 'runtimeOnlyConfigurationName' to add the respective classes.
            Note (a): This 'associate' function will be called for 'all' associated compilations (full transitive closure)
            Note (b): It is important that the compiled output of 'main' is prioritised in the compile path order:
                      We therefore ensure that the files are added to the front of the compile path.

                      This is necessary as other binaries might leak into the compile path which contain the same symbols but
                      are not marked as 'friend'. We ensure that associate dependencies are resolved first

        For 2)
        This is an agreed upon convention: 'test' is able to see all dependencies declared for 'main'
        As described in 1b: It needs to be taken care of, that the dependencies are ordered after the output of 'main'
        */
        project.dependencies.add(auxiliary.compileOnlyConfigurationName, main.output.classesDirs)
        project.dependencies.add(auxiliary.runtimeOnlyConfigurationName, main.output.allOutputs)

        // Adding classes that could be produced into non-default destination for JVM target
        // Check KotlinSourceSetProcessor for details
        project.dependencies.add(
            auxiliary.implementationConfigurationName,
            project.filesProvider { main.defaultSourceSet.kotlin.classesDirectory.orNull?.asFile }
        )

        // Adding declared dependencies
        auxiliary.compileDependencyConfigurationName.addAllDependenciesFromOtherConfigurations(
            project,
            main.apiConfigurationName,
            main.implementationConfigurationName,
            main.compileOnlyConfigurationName
        )

        auxiliary.runtimeDependencyConfigurationName?.addAllDependenciesFromOtherConfigurations(
            project,
            main.apiConfigurationName,
            main.implementationConfigurationName,
            main.runtimeOnlyConfigurationName
        )
    }
}

internal object KotlinNativeCompilationAssociator : KotlinCompilationAssociator {
    override fun associate(target: KotlinTarget, auxiliary: InternalKotlinCompilation<*>, main: InternalKotlinCompilation<*>) {
        auxiliary.compileDependencyFiles +=
            main.output.classesDirs + target.project.filesProvider { main.compileDependencyFiles }

        target.project.configurations.named(auxiliary.implementationConfigurationName).configure { configuration ->
            configuration.extendsFrom(target.project.configurations.findByName(main.implementationConfigurationName))
        }
    }
}

internal object KotlinJvmCompilationAssociator : KotlinCompilationAssociator {
    override fun associate(target: KotlinTarget, auxiliary: InternalKotlinCompilation<*>, main: InternalKotlinCompilation<*>) {
        /* Main to Test association handled already by java plugin */
        if (
            ((target is KotlinWithJavaTarget<*, *> && target.platformType == jvm) ||
                    (target is KotlinJvmTarget && target.withJavaEnabled)) &&
            auxiliary.isTest() && main.isMain()
        ) {
            return","} else DefaultKotlinCompilationAssociator.associate(target, auxiliary, main)"
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */


package org.jetbrains.kotlin.gradle.plugin.ide

import org.gradle.api.Project
import org.gradle.api.logging.Logger
import org.gradle.api.logging.Logging
import org.jetbrains.kotlin.gradle.ExternalKotlinTargetApi
import org.jetbrains.kotlin.gradle.dsl.kotlinExtension
import org.jetbrains.kotlin.gradle.dsl.multiplatformExtensionOrNull
import org.jetbrains.kotlin.gradle.idea.serialize.IdeaKotlinExtrasSerializationExtension
import org.jetbrains.kotlin.gradle.idea.serialize.IdeaKotlinExtrasSerializationExtensionBuilder",import org.jetbrains.kotlin.gradle.idea.tcs.IdeaKotlinDependency
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package generators
"/**
         * Exception text, which should be used together with exception object when available.
         */
        val text: String,
        /**
         * Line number of the exception location (0-based).
         */
        val lineNumber: Int,
        /**
         * Column number of the exception location (0-based).
         */
        val columnNumber: Int,
        /**
         * Script ID of the exception location.
         */
        val scriptId: ScriptId? = null,
        /**
         * URL of the exception location, to be used when the script was not reported.
         */
        val url: String? = null,
        /**
         * JavaScript stack trace if available.
         */
        val stackTrace: StackTrace? = null,
        /**
         * Exception object if available.
         */
        val exception: RemoteObject? = null,
        /**
         * Identifier of the context where exception happened.
         */
        val executionContextId: ExecutionContextId? = null,
    )

    /**
     * Description of an isolated world.
     *
     * See [Runtime.ExecutionContextDescription](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-ExecutionContextDescription)
     */
    @Serializable
    class ExecutionContextDescription(
        /**
         * Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed.
         */
        val id: ExecutionContextId,
        /**
         * Execution context origin.
         */
        val origin: String,
        /**
         * Human readable name describing given context.
         */
        val name: String,
    )

    /**
     * An event in the `Runtime` CDP domain.
     */
    @Serializable
    sealed class Event : CDPEvent() {
        /**
         * Issued when new execution context is created.
         *
         * See [Runtime.executionContextCreated](https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#event-executionContextCreated)
         */",@Serializable
"else -> target.transformSingle(transformer, data = null)
        }
    }

    private fun resolveClass(firClass: FirRegularClass) {
        transformer.statusComputationSession.startComputing(firClass)

        if (resolveMode.resolveSupertypes) {
            transformer.forceResolveStatusesOfSupertypes(firClass)
        }

        performCustomResolveUnderLock(firClass) {
            transformer.transformClassStatus(firClass)
            transformer.transformValueClassRepresentation(firClass)
            transformer.storeClass(firClass) {
                resolveClassTypeParameters(firClass)
                firClass
            }
        }

        if (resolveMode.resolveSupertypes) {
            transformer.storeClass(firClass) {
                withContainingDeclaration(firClass) {
                    resolveCallableMembers(firClass)
                }

                firClass
            }

            transformer.statusComputationSession.endComputing(firClass)
        } else {
            transformer.statusComputationSession.computeOnlyClassStatus(firClass)
        }
    }

    private inner class Transformer(
        session: FirSession,
        scopeSession: ScopeSession,
    ) : FirStatusResolveTransformer(session, scopeSession, statusComputationSession) {
        val computationSession: LLStatusComputationSession get() = this@LLFirStatusTargetResolver.statusComputationSession

        override fun FirDeclaration.needResolveMembers(): Boolean = false
        override fun FirDeclaration.needResolveNestedClassifiers(): Boolean = false

        override fun transformClass(klass: FirClass, data: FirResolvedDeclarationStatus?): FirStatement {
            return klass
        }

        override fun forceResolveStatusesOfSupertypes(regularClass: FirClass) {
            computationSession.withClassSession(regularClass) {
                super.forceResolveStatusesOfSupertypes(regularClass)
            }
        }

        override fun superTypeToSymbols(typeRef: FirTypeRef): Collection<FirClassifierSymbol<*>> {
            val type = typeRef.coneType
            return SmartSet.create<FirClassifierSymbol<*>>().apply {
                // Resolution order: from declaration site to use site
                for (useSiteSession in computationSession.useSiteSessions.asReversed()) {
                    type.toSymbol(useSiteSession)?.let(::add)
                }
            }
        }

        override fun resolveClassForSuperType(regularClass: FirRegularClass): Boolean {",val target = regularClass.tryCollectDesignation()?.asResolveTarget() ?: return false
"intWrapper: IntWrapper,
    intWrapperN: IntWrapper?,
    intNWrapper: IntNWrapper,
    intNWrapperN: /*boxed*/ IntNWrapper?,
    fooWrapper: FooWrapper,
    fooWrapperN: FooWrapper?,
    fooNWrapper: FooNWrapper,
    fooNWrapperN: /*boxed*/ FooNWrapper?,
    nativeFooWrapper: NativeFooWrapper,
    nativeFooWrapperN: NativeFooWrapper?,
    nativeFooNWrapper: NativeFooNWrapper,
    nativeFooNWrapperN: /*boxed*/ NativeFooNWrapper?
) {
    fun describeIntWrapper(x: IntWrapper): String
    fun describeIntWrapperN(x: IntWrapper?): String
    fun describeIntNWrapper(x: IntNWrapper): String
    fun describeIntNWrapperN(x: /*boxed*/ IntNWrapper?): String
    fun describeFooWrapper(x: FooWrapper): String
    fun describeFooWrapperN(x: FooWrapper?): String
    fun describeFooNWrapper(x: FooNWrapper): String
    fun describeFooNWrapperN(x: /*boxed*/ FooNWrapper?): String
    fun describeNativeFooWrapper(x: NativeFooWrapper): String
    fun describeNativeFooWrapperN(x: NativeFooWrapper?): String
    fun describeNativeFooNWrapper(x: NativeFooNWrapper): String
    fun describeNativeFooNWrapperN(x: /*boxed*/ NativeFooNWrapper?): String

    var intWrapper: IntWrapper
    var intWrapperN: IntWrapper?
    var intNWrapper: IntNWrapper
    var intNWrapperN: /*boxed*/ IntNWrapper?
    var fooWrapper: FooWrapper
    var fooWrapperN: FooWrapper?
    var fooNWrapper: FooNWrapper
    var fooNWrapperN: /*boxed*/ FooNWrapper?
    var nativeFooWrapper: NativeFooWrapper
    var nativeFooWrapperN: NativeFooWrapper?
    var nativeFooNWrapper: NativeFooNWrapper
    var nativeFooNWrapperN: /*boxed*/ NativeFooNWrapper?

    val readOnlyIntWrapper: IntWrapper
    val readOnlyIntWrapperN: IntWrapper?
    val readOnlyIntNWrapper: IntNWrapper
    val readOnlyIntNWrapperN: /*boxed*/ IntNWrapper?
    val readOnlyFooWrapper: FooWrapper
    val readOnlyFooWrapperN: FooWrapper?
    val readOnlyFooNWrapper: FooNWrapper
    val readOnlyFooNWrapperN: /*boxed*/ FooNWrapper?
    val readOnlyNativeFooWrapper: NativeFooWrapper
    val readOnlyNativeFooWrapperN: NativeFooWrapper?
    val readOnlyNativeFooNWrapper: NativeFooNWrapper
    val readOnlyNativeFooNWrapperN: /*boxed*/ NativeFooNWrapper?

    fun getIntWrapper(): IntWrapper
    fun getIntWrapperN(): IntWrapper?
    fun getIntNWrapper(): IntNWrapper
    fun getIntNWrapperN(): /*boxed*/ IntNWrapper?
    fun getFooWrapper(): FooWrapper
    fun getFooWrapperN(): FooWrapper?
    fun getFooNWrapper(): FooNWrapper
    fun getFooNWrapperN(): /*boxed*/ FooNWrapper?
    fun getNativeFooWrapper(): NativeFooWrapper
    fun getNativeFooWrapperN(): NativeFooWrapper?
    fun getNativeFooNWrapper(): NativeFooNWrapper
    fun getNativeFooNWrapperN(): /*boxed*/ NativeFooNWrapper?",companion object {
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_EXPRESSION -SENSELESS_COMPARISON -UNUSED_PARAMETER

// FILE: J.java

import org.jetbrains.annotations.*;

public class J {
    @NotNull
    public static J staticNN;
    @Nullable
    public static J staticN;
    public static J staticJ;
}

// FILE: k.kt",fun test() {
"if (thisBytes.size != otherBytes.size) {
            return false
        }

        for (index in 0 .. thisBytes.size - 1) {
            if (thisBytes[index] != otherBytes[index]) {
                return false
            }
        }

        return true
    }

    public override fun hashCode(): Int {
        var result = 0
        for (byte in this.getBytes()) {
            result = result * 31 + byte
        }
        return result
    }

    public abstract val size: Int

    public abstract val align: Int

    /**
     * Copy the referenced values to [placement] and return placement pointer.
     */
    public abstract fun place(placement: CPointer<T>): CPointer<T>
}

@ExperimentalForeignApi
public fun <T : CVariable> CValues<T>.placeTo(scope: AutofreeScope): CPointer<T> = this.getPointer(scope)

/**
 * The single immutable C value.
 * It is self-contained and doesn't depend on native memory.
 *
 * TODO: consider providing an adapter instead of subtyping [CValues].
 */
@ExperimentalForeignApi
public abstract class CValue<T : CVariable> : CValues<T>()

/**
 * C pointer.
 */
@ExperimentalForeignApi
public class CPointer<T : CPointed> internal constructor(@PublishedApi internal val value: NonNullNativePtr) : CValuesRef<T>() {

    // TODO: replace by [value].
    @Suppress(""NOTHING_TO_INLINE"")
    public inline val rawValue: NativePtr get() = value.toNativePtr()

    public override fun equals(other: Any?): Boolean {
        if (this === other) {
            return true // fast path
        }

        return (other is CPointer<*>) && (rawValue == other.rawValue)
    }

    public override fun hashCode(): Int {
        return rawValue.hashCode()
    }",public override fun toString(): String = this.cPointerToString()
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.targets.js.npm

import org.gradle.api.tasks.Input
import java.io.Serializable

data class NpmDependencyDeclaration(
    @Input
    val scope: NpmDependency.Scope,
    @Input
    val name: String,
    @Input
    val version: String
) : Serializable

fun NpmDependencyDeclaration.uniqueRepresentation() =
    ""$scope $name:$version""",internal fun NpmDependency.toDeclaration(): NpmDependencyDeclaration =
"annotation(""@OptIn(kotlin.experimental.ExperimentalTypeInference::class)"")
            annotation(""@OverloadResolutionByLambdaReturnType"")
            if (family != ArraysOfUnsigned)
                annotation(""""""@kotlin.jvm.JvmName(""flatMapIndexed$containerClass"")"""""")
            sample(""samples.collections.Collections.Transformations.flatMapIndexed"")
            typeParam(""R"")
            returns(""List<R>"")
            body {
                ""return flatMapIndexedTo(ArrayList<R>(), transform)""
            }
            specialFor(Sequences) {
                inline(Inline.No)
                returns(""Sequence<R>"")
                body {
                    ""return flatMapIndexed(this, transform, $containerClass<R>::iterator)""
                }
            }
        }
    }


    val f_flatMapIndexedTo = listOf(Iterables, Sequences).map { containerFamily ->
        val containerClass = containerFamily.name.dropLast(1)
        fn(""flatMapIndexedTo(destination: C, transform: (index: Int, T) -> $containerClass<R>)"") {
            when (containerFamily) {
                Iterables -> include(Iterables, Sequences, ArraysOfObjects, ArraysOfPrimitives, ArraysOfUnsigned, CharSequences)
                Sequences -> include(Sequences, Iterables, ArraysOfObjects)
                else -> {}
            }
        } builder {
            inlineOnly()

            since(""1.4"")
            doc {
                """"""
                Appends all elements yielded from results of [transform] function being invoked on each ${f.element} 
                and its index in the original ${f.collection}, to the given [destination].
                """"""
            }
            annotation(""@OptIn(kotlin.experimental.ExperimentalTypeInference::class)"")
            annotation(""@OverloadResolutionByLambdaReturnType"")
            if (family != ArraysOfUnsigned)
                annotation(""""""@kotlin.jvm.JvmName(""flatMapIndexed${containerClass}To"")"""""")
            typeParam(""R"")
            typeParam(""C : MutableCollection<in R>"")
            returns(""C"")
            body {
                fun checkOverflow(value: String) = if (f == Sequences || f == Iterables) ""checkIndexOverflow($value)"" else value
                """"""
                var index = 0
                for (element in this) {
                    val list = transform(${checkOverflow(""index++"")}, element)
                    destination.addAll(list)
                }
                return destination
                """"""
            }
        }
    }

    val f_groupBy_key = fn(""groupBy(keySelector: (T) -> K)"") {
        includeDefault()
        include(CharSequences, ArraysOfUnsigned)
    } builder {
        inline()",specialFor(ArraysOfUnsigned) { inlineOnly() }
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.descriptors.types

import org.jetbrains.kotlin.analysis.api.KtAnalysisApiInternals
import org.jetbrains.kotlin.analysis.api.KtTypeProjection
import org.jetbrains.kotlin.analysis.api.base.KtContextReceiver
import org.jetbrains.kotlin.analysis.api.descriptors.Fe10AnalysisContext
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.KtFe10DescNamedClassOrObjectSymbol
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.ktNullability
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.toKtClassSymbol
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.toKtType
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.toKtTypeProjection
import org.jetbrains.kotlin.analysis.api.descriptors.types.base.KtFe10Type
import org.jetbrains.kotlin.analysis.api.descriptors.types.base.asStringForDebugging
import org.jetbrains.kotlin.analysis.api.descriptors.utils.KtFe10JvmTypeMapperContext
import org.jetbrains.kotlin.analysis.api.impl.base.KtContextReceiverImpl
import org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion
import org.jetbrains.kotlin.analysis.api.symbols.KtClassLikeSymbol
import org.jetbrains.kotlin.analysis.api.types.KtClassTypeQualifier
import org.jetbrains.kotlin.analysis.api.types.KtFunctionalType
import org.jetbrains.kotlin.analysis.api.types.KtType
import org.jetbrains.kotlin.analysis.api.types.KtTypeNullability
import org.jetbrains.kotlin.builtins.*
import org.jetbrains.kotlin.builtins.functions.FunctionClassDescriptor
import org.jetbrains.kotlin.builtins.functions.isSuspendOrKSuspendFunction
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.types.SimpleType

internal class KtFe10FunctionalType(
    override val fe10Type: SimpleType,
    private val descriptor: FunctionClassDescriptor,
    override val analysisContext: Fe10AnalysisContext
) : KtFunctionalType(), KtFe10Type {
    override fun asStringForDebugging(): String = withValidityAssertion { fe10Type.asStringForDebugging(analysisContext) }

    override val nullability: KtTypeNullability
        get() = withValidityAssertion { fe10Type.ktNullability }

    override val qualifiers: List<KtClassTypeQualifier.KtResolvedClassTypeQualifier>
        get() = withValidityAssertion {
            KtFe10JvmTypeMapperContext.getNestedType(fe10Type).allInnerTypes.map { innerType ->
                KtClassTypeQualifier.KtResolvedClassTypeQualifier(","innerType.classDescriptor.toKtClassSymbol(analysisContext),"
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.incremental.storage

import com.intellij.util.io.DataExternalizer
import com.intellij.util.io.EnumeratorStringDescriptor
import org.jetbrains.kotlin.incremental.IncrementalCompilationContext
import org.jetbrains.kotlin.name.FqName
import java.io.DataInput
import java.io.DataOutput
import java.io.File

internal open class ClassOneToManyMap(","storageFile: File,"
"// Check that unresolved super type doesn't interfere with unqualified super resolution.

open class Base() {
    open fun foo() {}

    open fun ambiguous() {}

    open val prop: Int
        get() = 1234

    open val ambiguousProp: Int
        get() = 111
}

interface Interface {",fun bar() {}
"private lateinit var generatedSources: File

        @JvmStatic
        @BeforeAll
        fun setUp(@TempDir tmp: File) {
            cache = JavaClassCacheManager(tmp.newCacheFolder())
            generatedSources = tmp.newGeneratedSourcesFolder()
            cache.close()
            val processor = SimpleProcessor().toAggregating()
            val srcFiles = listOf(
                ""MyEnum.java"",
                ""MyNumber.java"",
                ""NumberAnnotation.java"",
                ""NumberException.java"",
                ""NumberHolder.java"",
                ""NumberManager.java"",
                ""GenericNumber.java""
            ).map { File(MY_TEST_DIR, it) }
            runAnnotationProcessing(
                srcFiles,
                listOf(processor),
                generatedSources
            ) { elements, trees -> MentionedTypesTaskListener(cache.javaCache, elements, trees) }
            cache.updateCache(listOf(processor), false)
        }
    }

    @Test
    fun testEnum() {
        val myEnum = cache.javaCache.getStructure(MY_TEST_DIR.resolve(""MyEnum.java""))!! as SourceFileStructure

        assertEquals(setOf(""test.MyEnum""), myEnum.declaredTypes)
        assertEquals(emptySet<String>(), myEnum.getMentionedAnnotations())
        assertEquals(emptySet<String>(), myEnum.getPrivateTypes())
        assertEquals(setOf(""test.MyEnum"", ""test.TypeGeneratedByApt""), myEnum.getMentionedTypes())
    }

    @Test
    fun testMyNumber() {
        val myNumber = cache.javaCache.getStructure(MY_TEST_DIR.resolve(""MyNumber.java""))!! as SourceFileStructure

        assertEquals(
            setOf(
                ""test.MyNumber"",
                ""test.FieldAnnotation"",
                ""test.MethodAnnotation"",
                ""test.ParameterAnnotation"",
                ""test.TypeUseAnnotation"",
                ""test.AnotherTypeUseAnnotation"",
                ""test.ThrowTypeUseAnnotation""
            ), myNumber.declaredTypes
        )
        assertEquals(
            setOf(
                ""java.lang.annotation.Target"",
                ""test.FieldAnnotation"",
                ""test.ParameterAnnotation"",
                ""test.MethodAnnotation"",
                ""test.TypeUseAnnotation"",
                ""test.AnotherTypeUseAnnotation"",
                ""test.ThrowTypeUseAnnotation""
            ), myNumber.getMentionedAnnotations()
        )
        assertEquals(
            setOf(","""test.FieldAnnotation"","
"// FIR_IDENTICAL
// JSPECIFY_STATE: warn

// FILE: IgnoreAnnotations.java
import org.jspecify.annotations.*;

@NullMarked
public class IgnoreAnnotations {
    @Nullable public Derived field = null;

    @Nullable
    public Derived foo(Derived x, @NullnessUnspecified Base y) {
        return null;
    }

    public Derived everythingNotNullable(Derived x) { return null; }

    public @Nullable Derived everythingNullable(@Nullable Derived x) { return null; }

    public @NullnessUnspecified Derived everythingUnknown(@NullnessUnspecified Derived x) { return null; }
}

// FILE: Base.java
public class Base {
    void foo() {}
}

// FILE: Derived.java
public class Derived extends Base { }

// FILE: main.kt
fun main(a: IgnoreAnnotations, x: Derived): Unit {
    // jspecify_nullness_mismatch
    <!RECEIVER_NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS!>a.foo(x, null)<!>.foo()
    // jspecify_nullness_mismatch, jspecify_nullness_mismatch
    <!RECEIVER_NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS!>a.foo(<!NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS!>null<!>, x)<!>.foo()

    // jspecify_nullness_mismatch
    <!RECEIVER_NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS!>a.field<!>.foo()

    // jspecify_nullness_mismatch
    a.everythingNotNullable(<!NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS!>null<!>).foo()
    a.everythingNotNullable(x).foo()

    // jspecify_nullness_mismatch",<!RECEIVER_NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS!>a.everythingNullable(null)<!>.foo()
"import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.FirElement
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.isValueClass
import org.jetbrains.kotlin.fir.analysis.checkers.leastUpperBound
import org.jetbrains.kotlin.fir.analysis.checkers.valOrVarKeyword
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors
import org.jetbrains.kotlin.fir.declarations.FirAnonymousFunction
import org.jetbrains.kotlin.fir.declarations.FirConstructor
import org.jetbrains.kotlin.fir.declarations.FirFunction
import org.jetbrains.kotlin.fir.diagnostics.ConeSimpleDiagnostic
import org.jetbrains.kotlin.fir.diagnostics.DiagnosticKind
import org.jetbrains.kotlin.fir.expressions.FirPropertyAccessExpression
import org.jetbrains.kotlin.fir.expressions.FirQualifiedAccessExpression
import org.jetbrains.kotlin.fir.references.toResolvedValueParameterSymbol
import org.jetbrains.kotlin.fir.resolve.fullyExpandedType
import org.jetbrains.kotlin.fir.types.*
import org.jetbrains.kotlin.fir.visitors.FirVisitorVoid

object FirFunctionParameterChecker : FirFunctionChecker(MppCheckerKind.Common) {
    override fun check(declaration: FirFunction, context: CheckerContext, reporter: DiagnosticReporter) {
        checkVarargParameters(declaration, context, reporter)
        checkParameterTypes(declaration, context, reporter)
        checkUninitializedParameter(declaration, context, reporter)
        checkValOrVarParameter(declaration, context, reporter)
    }

    private fun checkParameterTypes(function: FirFunction, context: CheckerContext, reporter: DiagnosticReporter) {
        if (function is FirAnonymousFunction) return
        for (valueParameter in function.valueParameters) {
            val returnTypeRef = valueParameter.returnTypeRef
            if (returnTypeRef !is FirErrorTypeRef) continue
            // type problems on real source are already reported by ConeDiagnostic.toFirDiagnostics
            if (returnTypeRef.source?.kind == KtRealSourceElementKind) continue

            val diagnostic = returnTypeRef.diagnostic
            if (diagnostic is ConeSimpleDiagnostic && diagnostic.kind == DiagnosticKind.ValueParameterWithNoTypeAnnotation) {
                reporter.reportOn(
                    valueParameter.source, FirErrors.VALUE_PARAMETER_WITH_NO_TYPE_ANNOTATION,
                    context
                )
            }
        }
    }

    private fun checkVarargParameters(function: FirFunction, context: CheckerContext, reporter: DiagnosticReporter) {
        val varargParameters = function.valueParameters.filter { it.isVararg }
        if (varargParameters.size > 1) {
            for (parameter in varargParameters) {
                reporter.reportOn(parameter.source, FirErrors.MULTIPLE_VARARG_PARAMETERS, context)
            }
        }

        for (varargParameter in varargParameters) {
            val coneType = varargParameter.returnTypeRef.coneType
            val varargParameterType = when (function) {
                is FirAnonymousFunction -> coneType
                else -> coneType.arrayElementType()
            }?.fullyExpandedType(context.session) ?: continue
            // LUB is checked to ensure varargParameterType may
            // never be anything except `Nothing` or `Nothing?`
            // in case it is a complex type that quantifies
            // over many other types.",if (varargParameterType.leastUpperBound(context.session).fullyExpandedType(context.session).isNothingOrNullableNothing ||
"if (!mfvc.isKotlinExternalStub()) {
        body = with(context.createJvmIrBuilder(this.symbol)) {
            mfvc.throwWhenNotExternalIsNull(newPrimaryConstructor)
            irExprBody(irCall(newPrimaryConstructor).apply {
                for ((index, parameter) in parameters.withIndex()) {
                    putValueArgument(index, irGet(parameter))
                }
            })
        }
    }
}

private fun makePrimaryConstructorImpl(
    context: JvmBackendContext,
    oldPrimaryConstructor: IrConstructor,
    mfvc: IrClass,
    leaves: List<LeafMfvcNode>,
    subnodes: List<NameableMfvcNode>,
) = context.irFactory.buildFun {
    name = InlineClassAbi.mangledNameFor(context, oldPrimaryConstructor, false, false)
    visibility = oldPrimaryConstructor.visibility
    origin = JvmLoweredDeclarationOrigin.STATIC_MULTI_FIELD_VALUE_CLASS_CONSTRUCTOR
    returnType = context.irBuiltIns.unitType
    modality = Modality.FINAL
}.apply {
    parent = mfvc
    copyTypeParametersFrom(mfvc)
    for (leaf in leaves) {
        addValueParameter(leaf.fullFieldName, leaf.type.substitute(mfvc.typeParameters, typeParameters.map { it.defaultType }))
    }
    for ((index, oldParameter) in oldPrimaryConstructor.valueParameters.withIndex()) {
        val node = subnodes[index]
        val subnodesIndices = subnodes.subnodeIndices
        if (node is LeafMfvcNode) {
            val newIndex = subnodesIndices[node]!!.first
            valueParameters[newIndex].annotations = oldParameter.annotations
        }
    }
    annotations = oldPrimaryConstructor.annotations
    if (oldPrimaryConstructor.metadata != null) {
        metadata = oldPrimaryConstructor.metadata
        oldPrimaryConstructor.metadata = null
    }
    copyAttributes(oldPrimaryConstructor as? IrAttributeContainer)
    // body is added in the Lowering file as it needs to be lowered
}

private fun makeMfvcPrimaryConstructor(
    context: JvmBackendContext,
    oldPrimaryConstructor: IrConstructor,
    mfvc: IrClass,
    leaves: List<LeafMfvcNode>,
    fields: List<IrField>?
) = context.irFactory.buildConstructor {
    updateFrom(oldPrimaryConstructor)
    visibility = DescriptorVisibilities.PRIVATE
    origin = JvmLoweredDeclarationOrigin.SYNTHETIC_MULTI_FIELD_VALUE_CLASS_MEMBER
    returnType = oldPrimaryConstructor.returnType
}.apply {
    require(oldPrimaryConstructor.typeParameters.isEmpty()) { ""Constructors do not support type parameters yet"" }
    this.parent = mfvc
    val parameters = leaves.map { addValueParameter(it.fullFieldName, it.type) }
    val irConstructor = this@apply
    if (!mfvc.isKotlinExternalStub()) {
        body = context.createIrBuilder(irConstructor.symbol).irBlockBody(irConstructor) {",+irDelegatingConstructorCall(context.irBuiltIns.anyClass.owner.constructors.single())
"/**
 * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer]
 * and the default thread-safety mode [LazyThreadSafetyMode.SYNCHRONIZED].
 *
 * If the initialization of a value throws an exception, it will attempt to reinitialize the value at next access.
 *
 * Note that the returned instance uses itself to synchronize on. Do not synchronize from external code on
 * the returned instance as it may cause accidental deadlock. Also this behavior can be changed in the future.
 */
public actual fun <T> lazy(initializer: () -> T): Lazy<T> = SynchronizedLazyImpl(initializer)

/**
 * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer]
 * and thread-safety [mode].
 *
 * If the initialization of a value throws an exception, it will attempt to reinitialize the value at next access.
 *
 * Note that when the [LazyThreadSafetyMode.SYNCHRONIZED] mode is specified the returned instance uses itself
 * to synchronize on. Do not synchronize from external code on the returned instance as it may cause accidental deadlock.
 * Also this behavior can be changed in the future.
 */
public actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> =
    when (mode) {
        LazyThreadSafetyMode.SYNCHRONIZED -> SynchronizedLazyImpl(initializer)
        LazyThreadSafetyMode.PUBLICATION -> SafePublicationLazyImpl(initializer)
        LazyThreadSafetyMode.NONE -> UnsafeLazyImpl(initializer)
    }

/**
 * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer]
 * and the default thread-safety mode [LazyThreadSafetyMode.SYNCHRONIZED].
 *
 * If the initialization of a value throws an exception, it will attempt to reinitialize the value at next access.
 *
 * The returned instance uses the specified [lock] object to synchronize on.
 * When the [lock] is not specified the instance uses itself to synchronize on,
 * in this case do not synchronize from external code on the returned instance as it may cause accidental deadlock.
 * Also this behavior can be changed in the future.
 */
public actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = SynchronizedLazyImpl(initializer, lock)



private class SynchronizedLazyImpl<out T>(initializer: () -> T, lock: Any? = null) : Lazy<T>, Serializable {
    private var initializer: (() -> T)? = initializer
    @Volatile private var _value: Any? = UNINITIALIZED_VALUE
    // final field is required to enable safe publication of constructed instance
    private val lock = lock ?: this

    override val value: T
        get() {
            val _v1 = _value
            if (_v1 !== UNINITIALIZED_VALUE) {
                @Suppress(""UNCHECKED_CAST"")
                return _v1 as T
            }

            return synchronized(lock) {
                val _v2 = _value
                if (_v2 !== UNINITIALIZED_VALUE) {
                    @Suppress(""UNCHECKED_CAST"") (_v2 as T)
                } else {
                    val typedValue = initializer!!()
                    _value = typedValue",initializer = null
"// TARGET_BACKEND: JVM
// FILE: A.java
public class A {
    public static String o = ""O"";

    public static String k() {
        return ""K"";
    }
}

// FILE: B.kt",open class B : A()
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin

import org.jetbrains.kotlin.test.KotlinTestUtils
import org.junit.Assert
import java.io.File
import java.util.regex.Matcher
import java.util.regex.Pattern

private enum class ExceptionType {
    ANALYZING_EXPRESSION,
    UNKNOWN
}

class TestExceptionsComparator(wholeFile: File) {
    companion object {
        private const val EXCEPTIONS_FILE_PREFIX = ""exceptions""

        private val exceptionMessagePatterns = mapOf(
            ExceptionType.ANALYZING_EXPRESSION to","Pattern.compile(""""""Exception while analyzing expression at \((?<lineNumber>\d+),(?<symbolNumber>\d+)\) in /(?<filename>.*?)$"""""")"
class Foo {,class Bar
"val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }
}

class A7<T> {
    val property: T get() = TODO()
    fun function(value: T): T = value

    class Nested<T> {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }
}

class B1<T : Any> {
    val property: T get() = TODO()
    fun function(value: T): T = value

    class Nested<T : Any> {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }
}

class B2<T : Any> {
    val property: T get() = TODO()
    fun function(value: T): T = value

    class Nested<T : Any> {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }
}

class B3<T : Any> {
    val property: T get() = TODO()
    fun function(value: T): T = value

    class Nested<T : Any> {
        val property: T get() = TODO()
        fun function(value: T): T = value
    }

    inner class Inner {",val property: T get() = TODO()
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.resolve.scopes

import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.incremental.components.LookupLocation
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.utils.Printer
import org.jetbrains.kotlin.utils.addToStdlib.ifNotEmpty

// see utils/ScopeUtils.kt

interface HierarchicalScope : ResolutionScope {
    val parent: HierarchicalScope?

    fun printStructure(p: Printer)
}

interface LexicalScope : HierarchicalScope {
    override val parent: HierarchicalScope

    val ownerDescriptor: DeclarationDescriptor
    val isOwnerDescriptorAccessibleByLabel: Boolean

    val implicitReceiver: ReceiverParameterDescriptor?",val contextReceiversGroup: List<ReceiverParameterDescriptor>
"@EAnno val property = """"

@ExperimentalAPI
@EAnno typealias Typealias = Unit

@ExperimentalAPI
@EAnno class Klass

@ExperimentalAPI
annotation class AnnotationArgument(val p: EAnno)

@ExperimentalAPI
fun insideBody() {
    @EAnno fun local() {}
}

@ExperimentalAPI
fun inDefaultArgument(f: () -> Unit = @EAnno fun() {}) {}

@ExperimentalAPI
val inProperty = @EAnno fun() {}

@ExperimentalAPI
val inPropertyAccessor: () -> Unit
    get() = @EAnno fun() {}

// FILE: usage-use.kt

package usage2

import api.*

@OptIn(ExperimentalAPI::class)
@EAnno fun function() {}

@OptIn(ExperimentalAPI::class)
fun parameter(@EAnno p: String) {}

@OptIn(ExperimentalAPI::class)
fun parameterType(p: <!WRONG_ANNOTATION_TARGET!>@EAnno<!> String) {}

@OptIn(ExperimentalAPI::class)
fun returnType(): <!WRONG_ANNOTATION_TARGET!>@EAnno<!> Unit {}

@OptIn(ExperimentalAPI::class)
@EAnno val property = """"

@OptIn(ExperimentalAPI::class)
@EAnno typealias Typealias = Unit

@OptIn(ExperimentalAPI::class)
@EAnno class Klass

@OptIn(ExperimentalAPI::class)
annotation class AnnotationArgument(val p: EAnno)

fun insideBody() {
    @OptIn(ExperimentalAPI::class) @EAnno fun local() {}
}

fun inDefaultArgument(@OptIn(ExperimentalAPI::class) f: () -> Unit = @EAnno fun() {}) {}

@OptIn(ExperimentalAPI::class)
val inProperty = @EAnno fun() {}",val inPropertyAccessor: () -> Unit
"val inKt = File(depDir, ""Dependency.kt"").apply { writeText(""class Dependency(val v: Int)"") }
        val outStream = ByteArrayOutputStream()
        val compileExitCode = K2JVMCompiler().exec(
            PrintStream(outStream),
            ""-d"", outJar.path, ""-no-stdlib"", ""-cp"", standardJars.joinToString(File.pathSeparator),
            ""-language-version"", if (isK2) ""2.0"" else ""1.9"",
            inKt.path
        )
        assertTrue(
            ""Compilation Failed:\n$outStream"",
            outStream.size() == 0 && compileExitCode == ExitCode.OK && outJar.exists()
        )
        return outJar
    }

    private fun checkWithCache(
        cache: ScriptingCacheWithCounters, script: SourceCode, expectedOutput: List<String>, checkDirectEval: Boolean = true,
        compilationConfiguration: ScriptCompilationConfiguration.Builder.() -> Unit = {},
        evaluationConfiguration: ScriptEvaluationConfiguration.Builder.() -> Unit = {}
    ) {
        val myHostConfiguration = defaultJvmScriptingHostConfiguration.with {
            jvm {
                baseClassLoader.replaceOnlyDefault(null)
                compilationCache(cache)
            }
        }
        val compiler = JvmScriptCompiler(myHostConfiguration)
        val evaluator = BasicJvmScriptEvaluator()
        val host = BasicJvmScriptingHost(compiler = compiler, evaluator = evaluator)

        val scriptCompilationConfiguration = ScriptCompilationConfiguration(body = compilationConfiguration).with {
            updateClasspath(KotlinJars.kotlinScriptStandardJarsWithReflect)
            hostConfiguration.update { myHostConfiguration }
        }

        val scriptEvaluationConfiguration = ScriptEvaluationConfiguration(body = evaluationConfiguration)

        Assert.assertEquals(0, cache.storedScripts)
        var compiledScript: CompiledScript? = null
        val output = captureOut {
            runBlocking {
                compiler(script, scriptCompilationConfiguration).onSuccess {
                    compiledScript = it
                    evaluator(it, scriptEvaluationConfiguration)
                }.throwOnFailure()
            }
        }.lines()
        Assert.assertEquals(expectedOutput, output)
        Assert.assertEquals(1, cache.storedScripts)
        Assert.assertEquals(0, cache.retrievedScripts)

        if (checkDirectEval) {
            val cachedScript = cache.get(script, scriptCompilationConfiguration)
            Assert.assertNotNull(cachedScript)
            Assert.assertEquals(1, cache.retrievedScripts)

            val compiledScriptClassRes = runBlocking { compiledScript!!.getClass(null) }
            val cachedScriptClassRes = runBlocking { cachedScript!!.getClass(null) }

            val compiledScriptClass = compiledScriptClassRes.valueOrThrow()
            val cachedScriptClass = cachedScriptClassRes.valueOrThrow()

            Assert.assertEquals(compiledScriptClass.qualifiedName, cachedScriptClass.qualifiedName)
            Assert.assertEquals(compiledScriptClass.java.supertypes(), cachedScriptClass.java.supertypes())",val output2 = captureOut {
"val jvmNameExpression = jvmNameEntry.valueArguments.firstOrNull()?.getArgumentExpression() as? KtStringTemplateExpression
                ?: continue
            ElementManipulators.handleContentChange(jvmNameExpression, name)
        }

        return this
    }

    override fun getQualifiedName() = facadeClassFqName.asString()

    override fun getNameIdentifier(): PsiIdentifier? = null

    override fun isValid() = files.all { it.isValid && it.hasTopLevelCallables() && facadeClassFqName == it.javaFileFacadeFqName }

    abstract override fun copy(): KtLightClassForFacade

    override fun getNavigationElement() = firstFileInFacade

    override fun isEquivalentTo(another: PsiElement?): Boolean =
        equals(another) ||
                (another is KtLightClassForFacade && another.facadeClassFqName == facadeClassFqName)

    override fun getElementIcon(flags: Int): Icon? = throw UnsupportedOperationException(""This should be done by KotlinIconProvider"")

    override fun isInheritor(baseClass: PsiClass, checkDeep: Boolean): Boolean {
        return baseClass.qualifiedName == CommonClassNames.JAVA_LANG_OBJECT
    }

    override fun getSuperClass(): PsiClass? {
        return JavaPsiFacade.getInstance(project).findClass(CommonClassNames.JAVA_LANG_OBJECT, resolveScope)
    }

    override fun getSupers(): Array<PsiClass> {
        return superClass?.let { arrayOf(it) } ?: arrayOf()
    }

    override fun getSuperTypes(): Array<PsiClassType> {
        return arrayOf(PsiType.getJavaLangObject(manager, resolveScope))
    }

    override fun hashCode() = facadeClassFqName.hashCode()

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other == null || this::class.java != other::class.java) {
            return false
        }

        val lightClass = other as KtLightClassForFacadeBase

        if (facadeClassFqName != lightClass.facadeClassFqName) return false
        if (files != lightClass.files) return false

        return true
    }

    override fun toString() = ""${KtLightClassForFacadeBase::class.java.simpleName}:$facadeClassFqName""

    override val originKind: LightClassOriginKind
        get() = LightClassOriginKind.SOURCE

    override fun getText() = firstFileInFacade.text ?: """"

    override fun getTextRange(): TextRange = firstFileInFacade.textRange ?: TextRange.EMPTY_RANGE",override fun getTextOffset() = firstFileInFacade.textOffset
"/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress(
    ""unused"",
    ""nothing_to_inline"",
    ""useless_cast"",
    ""unchecked_cast"",
    ""extension_shadowed_by_member"",
    ""redundant_projection"",
    ""RemoveRedundantBackticks"",
    ""ObjectPropertyName"",
    ""deprecation""
)
@file:org.gradle.api.Generated

/* ktlint-disable */

package gradle.kotlin.dsl.accessors._c8feb92ae88f9e0cc4f1c07aacfeaaf1


import org.gradle.api.Action
import org.gradle.api.Incubating
import org.gradle.api.NamedDomainObjectProvider
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurablePublishArtifact
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.Dependency
import org.gradle.api.artifacts.DependencyConstraint
import org.gradle.api.artifacts.ExternalModuleDependency",import org.gradle.api.artifacts.ModuleDependency
")
            simpleSingleSourceTarget(
                ""b"", """"""
                interface ABCD
                fun x(): ABCD = null!!
                """"""
            )
            simpleSingleSourceTarget(
                ""c"", """"""
                interface ABCD
                fun x(): ABCD = null!!
                """"""
            )

            simpleSingleSourceTarget(
                ""d"", """"""
                interface ABCD
                fun x(): ABCD = null!!
                """"""
            )
        }

        result.assertCommonized(
            ""(a, b)"", """"""
            expect interface ABCD
            expect fun x(): ABCD
            """"""
        )

        result.assertCommonized(
            ""(c, d)"", """"""
            expect interface ABCD
            expect fun x(): ABCD
            """"""
        )

        result.assertCommonized(
            ""((a,b), (c,d))"", """"""
            expect interface ABCD
            expect fun x(): ABCD
            """"""
        )
    }

    fun `test function with returnType from dependency 1`() {
        val result = commonize {
            outputTarget(""(a, b)"", ""(c, d)"", ""(a, b, c, d)"")
            registerDependency(""a"", ""b"", ""c"", ""d"", ""(a, b)"", ""(c, d)"", ""(a, b, c, d)"") { source(""interface ABCD"") }
            simpleSingleSourceTarget(""a"", ""fun x(): ABCD = null!!"")
            simpleSingleSourceTarget(""b"", ""fun x(): ABCD = null!!"")
            simpleSingleSourceTarget(""c"", ""fun x(): ABCD = null!!"")
            simpleSingleSourceTarget(""d"", ""fun x(): ABCD = null!!"")
        }

        result.assertCommonized(""(c, d)"", ""expect fun x(): ABCD"")
        result.assertCommonized(""(a, b)"", ""expect fun x(): ABCD"")
        result.assertCommonized(""((a,b), (c,d))"", ""expect fun x(): ABCD"")
    }

    fun `test function with returnType from dependency 2`() {
        val result = commonize {
            outputTarget(""(a, b)"", ""(c, d)"", ""(a, b, c, d)"")
            registerDependency(""a"", ""b"", ""c"", ""d"") { source(""interface ABCD"") }
            registerDependency(""(a, b)"") { source(""interface ABCD"") }
            registerDependency(""(c,d)"") { source(""interface ABCD"") }","simpleSingleSourceTarget(""a"", ""fun x(): ABCD = null!!"")"
"/**
     * Adds the specified frameworks in this XCFramework.
     */
    fun from(vararg frameworks: Framework) {
        frameworks.forEach { framework ->
            require(framework.konanTarget.family.isAppleFamily) {
                ""XCFramework supports Apple frameworks only""
            }
            dependsOn(framework.linkTask)
        }
        fromFrameworkDescriptors(frameworks.map { FrameworkDescriptor(it) })
    }

    fun fromFrameworkDescriptors(vararg frameworks: FrameworkDescriptor) = fromFrameworkDescriptors(frameworks.toList())

    fun fromFrameworkDescriptors(frameworks: Iterable<FrameworkDescriptor>) {
        val frameworkName = groupedFrameworkFiles.values.flatten().firstOrNull()?.name

        frameworks.forEach { framework ->
            if (frameworkName != null && framework.name != frameworkName) {
                error(
                    ""All inner frameworks in XCFramework '${baseName.get()}' should have same names. "" +
                            ""But there are two with '$frameworkName' and '${framework.name}' names""
                )
            }
            val group = AppleTarget.values().first { it.targets.contains(framework.target) }
            groupedFrameworkFiles.getOrPut(group, { mutableListOf() }).add(framework)
        }
    }

    @TaskAction
    fun assemble() {
        val frameworks = groupedFrameworkFiles.values.flatten()
        val xcfName = xcFrameworkName.get()
        if (frameworks.isNotEmpty()) {
            val rawXcfName = baseName.get()
            val name = frameworks.first().name
            if (frameworks.any { it.name != name }) {
                error(""All inner frameworks in XCFramework '$rawXcfName' should have same names!"" +
                              frameworks.joinToString(""\n"") { it.file.path })
            }
            if (name != xcfName) {
                toolingDiagnosticsCollector.get().report(this, KotlinToolingDiagnostics.XCFrameworkDifferentInnerFrameworksName(
                    xcFramework = rawXcfName,
                    innerFrameworks = name,
                ))
            }
        }

        val frameworksForXCFramework = groupedFrameworkFiles.entries.mapNotNull { (group, files) ->
            when {
                files.size == 1 -> files.first()
                files.size > 1 -> FrameworkDescriptor(
                    fatFrameworksDir.resolve(group.targetName).resolve(""$xcfName.framework""),
                    files.all { it.isStatic },
                    group.targets.first() //will be not used
                )
                else -> null
            }
        }
        createXCFramework(frameworksForXCFramework, outputXCFrameworkFile)
    }

    private fun createXCFramework(frameworkFiles: List<FrameworkDescriptor>, output: File) {",if (output.exists()) output.deleteRecursively()
"// FIR_IDENTICAL
annotation class Ann
annotation class Second","<!INAPPLICABLE_PARAM_TARGET, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@param:Ann<!>"
"scope: IrParcelerScope?,
        parcelizeType: IrType,
        strict: Boolean = false,
        toplevel: Boolean = false
    ): IrParcelSerializer {
        fun strict() = strict && !irType.hasAnyAnnotation(RAW_VALUE_ANNOTATION_FQ_NAMES)

        scope.getCustomSerializer(irType)?.let { parceler ->
            return IrCustomParcelSerializer(parceler)
        }

        val classifier = irType.erasedUpperBound
        val classifierFqName = classifier.fqNameWhenAvailable?.asString()
        when (classifierFqName) {
            // Built-in parcel serializers
            ""kotlin.String"", ""java.lang.String"" ->
                return stringSerializer
            ""kotlin.CharSequence"", ""java.lang.CharSequence"" ->
                return charSequenceSerializer
            ""android.os.Bundle"" ->
                return IrParcelSerializerWithClassLoader(parcelizeType, symbols.parcelReadBundle, symbols.parcelWriteBundle)
            ""android.os.PersistableBundle"" ->
                return IrParcelSerializerWithClassLoader(
                    parcelizeType,
                    symbols.parcelReadPersistableBundle,
                    symbols.parcelWritePersistableBundle
                )

            // Non-nullable built-in serializers
            ""kotlin.Byte"", ""java.lang.Byte"" ->
                return wrapNullableSerializerIfNeeded(irType, byteSerializer)
            ""kotlin.Boolean"", ""java.lang.Boolean"" ->
                return wrapNullableSerializerIfNeeded(irType, booleanSerializer)
            ""kotlin.Char"", ""java.lang.Character"" ->
                return wrapNullableSerializerIfNeeded(irType, charSerializer)
            ""kotlin.Short"", ""java.lang.Short"" ->
                return wrapNullableSerializerIfNeeded(irType, shortSerializer)
            ""kotlin.Int"", ""java.lang.Integer"" ->
                return wrapNullableSerializerIfNeeded(irType, intSerializer)
            ""kotlin.Long"", ""java.lang.Long"" ->
                return wrapNullableSerializerIfNeeded(irType, longSerializer)
            ""kotlin.Float"", ""java.lang.Float"" ->
                return wrapNullableSerializerIfNeeded(irType, floatSerializer)
            ""kotlin.Double"", ""java.lang.Double"" ->
                return wrapNullableSerializerIfNeeded(irType, doubleSerializer)
            ""java.io.FileDescriptor"" ->
                return wrapNullableSerializerIfNeeded(irType, fileDescriptorSerializer)
            ""android.util.Size"" ->
                return wrapNullableSerializerIfNeeded(irType, sizeSerializer)
            ""android.util.SizeF"" ->
                return wrapNullableSerializerIfNeeded(irType, sizeFSerializer)

            // Unsigned primitive types
            ""kotlin.UByte"" ->
                return wrapNullableSerializerIfNeeded(irType, ubyteSerializer)
            ""kotlin.UShort"" ->
                return wrapNullableSerializerIfNeeded(irType, ushortSerializer)
            ""kotlin.UInt"" ->
                return wrapNullableSerializerIfNeeded(irType, uintSerializer)
            ""kotlin.ULong"" ->
                return wrapNullableSerializerIfNeeded(irType, ulongSerializer)

            // Built-in non-parameterized container types.
            ""kotlin.IntArray"" ->
                if (!scope.hasCustomSerializer(irBuiltIns.intType))",return intArraySerializer
"import org.jetbrains.kotlin.analysis.low.level.api.fir.LLFirInternals
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.*
import org.jetbrains.kotlin.analysis.low.level.api.fir.compile.CodeFragmentCapturedId
import org.jetbrains.kotlin.analysis.low.level.api.fir.compile.CodeFragmentCapturedValueAnalyzer
import org.jetbrains.kotlin.analysis.low.level.api.fir.compile.CompilationPeerCollector
import org.jetbrains.kotlin.analysis.low.level.api.fir.project.structure.llFirModuleData
import org.jetbrains.kotlin.analysis.low.level.api.fir.sessions.LLFirSession
import org.jetbrains.kotlin.analysis.low.level.api.fir.sessions.llFirSession
import org.jetbrains.kotlin.analysis.low.level.api.fir.util.codeFragment
import org.jetbrains.kotlin.analysis.project.structure.KtDanglingFileModule
import org.jetbrains.kotlin.analysis.project.structure.KtModule
import org.jetbrains.kotlin.backend.common.extensions.IrGenerationExtension
import org.jetbrains.kotlin.backend.common.phaser.PhaseConfig
import org.jetbrains.kotlin.backend.jvm.*
import org.jetbrains.kotlin.builtins.DefaultBuiltIns
import org.jetbrains.kotlin.cli.jvm.compiler.NoScopeRecordCliBindingTrace
import org.jetbrains.kotlin.codegen.CodegenFactory
import org.jetbrains.kotlin.codegen.state.GenerationState
import org.jetbrains.kotlin.config.CommonConfigurationKeys
import org.jetbrains.kotlin.config.CompilerConfiguration
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.diagnostics.*
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.analysis.diagnostics.toFirDiagnostics
import org.jetbrains.kotlin.fir.backend.*
import org.jetbrains.kotlin.fir.backend.jvm.FirJvmBackendExtension
import org.jetbrains.kotlin.fir.backend.jvm.FirJvmKotlinMangler
import org.jetbrains.kotlin.fir.backend.jvm.FirJvmVisibilityConverter
import org.jetbrains.kotlin.fir.backend.jvm.JvmFir2IrExtensions
import org.jetbrains.kotlin.fir.backend.jvm.initializeActualDeclarationExtractorIfStdlib
import org.jetbrains.kotlin.fir.backend.utils.CodeFragmentConversionData
import org.jetbrains.kotlin.fir.backend.utils.InjectedValue
import org.jetbrains.kotlin.fir.backend.utils.conversionData
import org.jetbrains.kotlin.fir.declarations.FirDeclaration
import org.jetbrains.kotlin.fir.declarations.FirFile
import org.jetbrains.kotlin.fir.declarations.FirFunction
import org.jetbrains.kotlin.fir.declarations.FirResolvePhase
import org.jetbrains.kotlin.fir.declarations.utils.hasBody
import org.jetbrains.kotlin.fir.diagnostics.ConeSyntaxDiagnostic
import org.jetbrains.kotlin.fir.languageVersionSettings
import org.jetbrains.kotlin.fir.lazy.AbstractFir2IrLazyDeclaration
import org.jetbrains.kotlin.fir.pipeline.*
import org.jetbrains.kotlin.fir.psi
import org.jetbrains.kotlin.fir.references.FirReference
import org.jetbrains.kotlin.fir.references.FirThisReference
import org.jetbrains.kotlin.fir.references.toResolvedSymbol
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.fir.symbols.lazyResolveToPhaseRecursively
import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.PsiIrFileEntry
import org.jetbrains.kotlin.ir.backend.jvm.serialization.JvmIrMangler
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.descriptors.IrBasedDeclarationDescriptor
import org.jetbrains.kotlin.ir.descriptors.IrBasedReceiverParameterDescriptor
import org.jetbrains.kotlin.ir.descriptors.IrBasedValueParameterDescriptor
import org.jetbrains.kotlin.ir.descriptors.IrBasedVariableDescriptor
import org.jetbrains.kotlin.ir.expressions.*
import org.jetbrains.kotlin.ir.symbols.IrClassSymbol
import org.jetbrains.kotlin.ir.symbols.IrSymbol
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
import org.jetbrains.kotlin.ir.types.IrSimpleType
import org.jetbrains.kotlin.ir.util.IdSignature
import org.jetbrains.kotlin.ir.util.StubGeneratorExtensions
import org.jetbrains.kotlin.ir.util.SymbolTable",import org.jetbrains.kotlin.ir.util.classId
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package org.jetbrains.kotlin.fir.caches
"TLong: Long,
        TFloat: Float,
        TDouble: Double,
        // unsigned integer types
        TUByte: UByte,
        TUShort: UShort,
        TUInt: UInt,
        TULong: ULong,
        // string types
        TString: String,
        // function types
        TFunction: () -> Unit,
        // external types
        TExternalInterface: ExternalInterface,
        TExternalOpenClass: ExternalOpenClass,
        TExternalObject: ExternalObject,
        // correct type parameter
        TCorrectTypeParameter: TExternalInterface
>


// correct JS interop types as property types

// primitive types
external val booleanProperty: Boolean
external val charProperty: Char
external val byteProperty: Byte
external val shortProperty: Short
external val intProperty: Int
external val longProperty: Long
external val floatProperty: Float
external val doubleProperty: Double

// unsigned integer types
external val uByteProperty: UByte
external val uShortProperty: UShort
external val uIntProperty: UInt
external val uLongProperty: ULong

// string types
external val stringProperty: String

// function types
external val functionProperty: () -> Unit

// external types
external val externalInterfaceProperty: ExternalInterface
external val externalOpenClassProperty: ExternalOpenClass
external val externalObjectProperty: ExternalObject


external fun correctJsInteropTypesAsFunctionTypeParameterTypes(
    primitiveTypes: (Boolean, Char, Byte, Short, Int, Long, Float, Double) -> Unit,
    unsignedIntegerTypes: (UByte, UShort, UInt, ULong) -> Unit,
    string: (String) -> Unit,
    function: (() -> Unit) -> Unit,
    externalTypes: (ExternalInterface, ExternalOpenClass, ExternalObject) -> Unit,
)

external fun correctJsInteropTypesAsFunctionTypeReturnTypes(
    // Unit and Nothing
    unit: () -> Unit,
    nothing: () -> Nothing,
    // primitive types
    boolean: () -> Boolean,","char: () -> Char,"
"@Test
    fun testTheThing(): Unit = controlFlow(
        """"""
            @NonRestartableComposable
            @Composable
            fun Simple() {
              // this has a composable call in it, and since we don't know the number of times the
              // lambda will get called, we place a group around the whole call
              run {
                A()
              }
              A()
            }

            @NonRestartableComposable
            @Composable
            fun WithReturn() {
              // this has an early return in it, so it needs to end all of the groups present.
              run {
                A()
                return@WithReturn
              }
              A()
            }

            @NonRestartableComposable
            @Composable
            fun NoCalls() {
              // this has no composable calls in it, so shouldn't cause any groups to get created
              run {
                println(""hello world"")
              }
              A()
            }

            @NonRestartableComposable
            @Composable
            fun NoCallsAfter() {
              // this has a composable call in the lambda, but not after it, which means the
              // group should be able to be coalesced into the group of the function
              run {
                A()
              }
            }
        """"""
    )

    @Test
    fun testLetWithComposableCalls(): Unit = controlFlow(
        """"""
            @Composable
            fun Example(x: Int?) {
              x?.let {
                if (it > 0) {
                  A(a)
                }
                A(b)
              }
              A(c)
            }
        """"""
    )

    @Test",fun testLetWithoutComposableCalls(): Unit = controlFlow(
"// !DIAGNOSTICS: -UNUSED_PARAMETER

fun foo(x: Int, f: () -> Unit, y: Int) {}

fun bar() {",var x: Int?
"public val publicProperty = 1
internal val publicOrInternalProperty = 1
internal val internalProperty = 1
private val internalOrPrivateProperty = 1
private val privateProperty = 1

public fun publicFunction() = 1
internal fun publicOrInternalFunction() = 1
internal fun internalFunction() = 1
private fun internalOrPrivateFunction() = 1
private fun privateFunction() = 1

open class Outer1 {
    public val publicProperty = 1
    internal val publicOrInternalProperty = 1
    internal val internalProperty = 1
    private val internalOrPrivateProperty = 1
    private val privateProperty = 1

    public fun publicFunction() = 1
    internal fun publicOrInternalFunction() = 1
    internal fun internalFunction() = 1
    private fun internalOrPrivateFunction() = 1
    private fun privateFunction() = 1

    open class Inner1 {
        public val publicProperty = 1
        internal val publicOrInternalProperty = 1
        internal val internalProperty = 1
        private val internalOrPrivateProperty = 1
        private val privateProperty = 1

        public fun publicFunction() = 1
        internal fun publicOrInternalFunction() = 1
        internal fun internalFunction() = 1
        private fun internalOrPrivateFunction() = 1
        private fun privateFunction() = 1
    }
}

open class Outer2 {
    public open val publicProperty = 1
    internal open val publicOrInternalProperty = 1
    internal open val internalProperty = 1
    private val internalOrPrivateProperty = 1
    private val privateProperty = 1",public open fun publicFunction() = 1
"@DeprecatedSinceKotlin(warningSince = ""1.5"")
public inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {
    var sum: Double = 0.0
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the array.
 */
@Deprecated(""Use sumOf instead."", ReplaceWith(""this.sumOf(selector)""))
@DeprecatedSinceKotlin(warningSince = ""1.5"")
public inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {
    var sum: Double = 0.0
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the array.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""sumOfDouble"")
@kotlin.internal.InlineOnly
public inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {
    var sum: Double = 0.toDouble()
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the array.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""sumOfDouble"")
@kotlin.internal.InlineOnly
public inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {
    var sum: Double = 0.toDouble()
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the array.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""sumOfDouble"")
@kotlin.internal.InlineOnly
public inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {
    var sum: Double = 0.toDouble()
    for (element in this) {",sum += selector(element)
"fun connectThread(threadNo: Int) = thread(name = ""daemonConnect$threadNo"") {
            try {
                withFlagFile(getTestName(true), "".alive"") { flagFile ->
                    withLogFile(""kotlin-daemon-test"", printLogOnException = false) { logFile ->
                        logFiles[threadNo] = logFile
                        val daemonJVMOptions = makeTestDaemonJvmOptions(logFile)
                        val compileServiceSession =
                                KotlinCompilerClient.connectAndLease(compilerId, flagFile, daemonJVMOptions, daemonOptions,
                                                                     DaemonReportingTargets(out = PrintStream(outStreams[threadNo])), autostart = true,
                                                                     leaseSession = true)
                        daemonInfos[threadNo] = compileServiceSession?.compileService?.getDaemonInfo() to compileServiceSession?.sessionId

                        resultCodes[threadNo] = when {
                            compileServiceSession?.compileService == null -> {
                                ParallelStartParams.connectionFailedErr
                            }
                            ParallelStartParams.performCompilation -> {
                                val jar = testTempDir.absolutePath + File.separator + ""hello.$threadNo.jar""
                                KotlinCompilerClient.compile(
                                    compileServiceSession.compileService,
                                    compileServiceSession.sessionId,
                                    CompileService.TargetPlatform.JVM,
                                    arrayOf(File(getHelloAppBaseDir(), ""hello.kt"").absolutePath, ""-d"", jar),
                                    PrintingMessageCollector(PrintStream(outStreams[threadNo]), MessageRenderer.WITHOUT_PATHS, true))
                            }
                            else -> 0 // compilation skipped, assuming - successful
                        }
                    }
                }
            }
            finally {
                doneLatch.countDown()
            }
        }

        CompilerSystemProperties.COMPILE_DAEMON_VERBOSE_REPORT_PROPERTY.value = ""true""
        CompilerSystemProperties.COMPILE_DAEMON_STARTUP_TIMEOUT_PROPERTY.value = ""100000""

        val succeeded = try {
            (1..ParallelStartParams.threads).forEach { connectThread(it - 1) }
            doneLatch.await(PARALLEL_WAIT_TIMEOUT_S, TimeUnit.SECONDS)
        }
        finally {
            CompilerSystemProperties.COMPILE_DAEMON_STARTUP_TIMEOUT_PROPERTY.clear()
            CompilerSystemProperties.COMPILE_DAEMON_VERBOSE_REPORT_PROPERTY.clear()
        }

        Thread.sleep(100) // Wait for processes to finish and close log files

        val electionLogs = arrayOfNulls<String>(ParallelStartParams.threads)
        val port2logs = arrayOfNulls<Pair<Int?, File?>>(ParallelStartParams.threads)

        for (i in 0..(ParallelStartParams.threads - 1)) {
            val logContents = logFiles[i]?.readLines()
            port2logs[i] = logContents?.find { it.contains(""daemon is listening on port"") }?.split("" "")?.last()?.toIntOrNull() to logFiles[i]
            electionLogs[i] = logContents?.find { it.contains(LOG_PREFIX_ASSUMING_OTHER_DAEMONS_HAVE) }
        }

        val electionsSuccess = electionLogs.any { it != null && (it.contains(""lower prio"") || it.contains(""equal prio"")) }
        val resultsFailures = resultCodes.count { it != null && it == 0 }

        if (!succeeded || !electionsSuccess || resultsFailures > 0) {
            val msg = buildString {
                for (i in 0..ParallelStartParams.threads - 1) {
                    val daemonInfoRes = daemonInfos[i]?.first",val daemonInfo = when (daemonInfoRes) {
"backendContext.testFunsPerFile[fileExports.file]
            ?.let { definitionSet.computeTag(it) }
            ?.let {
                val suiteFunctionTag = definitionSet.computeTag(backendContext.suiteFun!!.owner) ?: error(""Expect suite function tag exists"")
                result.testEnvironment = JsIrProgramTestEnvironment(it, suiteFunctionTag)
            }

        result.computeAndSaveNameBindings(definitionSet, nameGenerator)
        result.computeAndSaveImports(definitionSet, nameGenerator)
        result.computeAndSaveDefinitions(definitionSet, fileExports)

        if (optimizeGeneratedJs) {
            optimizeFragmentByJsAst(result, staticContext)
        }

        return JsIrProgramFragments(result, exportFragment)
    }

    private fun Set<IrDeclaration>.computeTag(declaration: IrDeclaration): String? {
        // Use LEGACY here because the declaration may come from an old klib, in which its `IdSignature.CommonSignature`
        // doesn't have `description`, but only `id`. Hence, we always render the signature with `id` instead of `description`,
        // because otherwise there may be a mismatch when we're computing the tag first for the IrDeclaration deserialized from klib,
        // and then for the same declaration but constructed from a descriptor.
        //
        // The former won't have `description` in its `IdSignature`, the latter will have it,
        // which will result in different renders unless we use the LEGACY renderer.
        val tag = (backendContext.irFactory as IdSignatureRetriever).declarationSignature(declaration)?.render(IdSignatureRenderer.LEGACY)

        if (tag == null && !contains(declaration)) {
            error(""signature for ${declaration.render()} not found"")
        }

        return tag
    }

    private fun JsIrProgramFragment.computeAndSaveNameBindings(
        definitions: Set<IrDeclaration>,
        nameGenerator: JsNameLinkingNamer
    ) {
        nameGenerator.nameMap.entries.forEach { (declaration, name) ->
            definitions.computeTag(declaration)?.let { tag ->
                nameBindings[tag] = name
                if (isBuiltInClass(declaration) || checkIsFunctionInterface(declaration.symbol.signature)) {
                    optionalCrossModuleImports += tag
                }
            }
        }
    }

    private fun JsIrProgramFragment.computeAndSaveImports(
        definitions: Set<IrDeclaration>,
        nameGenerator: JsNameLinkingNamer
    ) {
        nameGenerator.imports.entries.forEach { (declaration, importExpression) ->
            val tag = definitions.computeTag(declaration) ?: error(""No tag for imported declaration ${declaration.render()}"")
            imports[tag] = importExpression
            optionalCrossModuleImports += tag
        }
    }

    private fun JsIrProgramFragment.computeAndSaveDefinitions(
        definitions: Set<IrDeclaration>,
        fileExports: IrFileExports,
    ) {",fileExports.file.declarations.forEach {
"/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.js.backend.ast

import java.io.Reader

data class JsLocation @JvmOverloads constructor(","override val file: String,"
"// !DIAGNOSTICS: -ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE -UNUSED_VALUE -UNUSED_VARIABLE -UNUSED_PARAMETER -FINAL_UPPER_BOUND
// SKIP_TXT

/*
 * KOTLIN DIAGNOSTICS SPEC TEST (NEGATIVE)
 *
 * SPEC VERSION: 0.1-296
 * MAIN LINK: expressions, try-expression -> paragraph 8 -> sentence 1
 * PRIMARY LINKS: expressions, try-expression -> paragraph 9 -> sentence 1
 * NUMBER: 1
 * DESCRIPTION: The type of the try-expression is the least upper bound of the types of the last expressions of the try body and the last expressions of all the catch blocks
 */

// FILE: TestCase1.kt
// TESTCASE NUMBER: 1
package testPackCase1

fun throwExceptionA(b: Boolean) = run { if (b) throw ExcA() }

class ExcA() : Exception()
class ExcB() : Exception()

open class A<T>(var data: T) {
    fun foo(d: A<T>) {}
}

class B<T>(data: T) : A<T>(data)

fun case1() {
    val tryVal: B<String> =
    <!INITIALIZER_TYPE_MISMATCH!>try {
        throwExceptionA(false)
        A("""")
    } catch (e: Exception) {
        B("""")
    }<!>
}

// FILE: TestCase2.kt
// TESTCASE NUMBER: 2
package testPackCase2

fun throwExceptionA(b: Boolean) = run { if (b) throw ExcA() }

class ExcA() : Exception()
class ExcB() : Exception()

open class A<T>(var data: T) {
    fun foo(d: A<T>) {}
}

class B<T>(data: T) : A<T>(data)



fun case2() {",val tryVal: A<String> =
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer

import java.io.File
import java.security.MessageDigest
import java.util.*

public object CommonizerOutputFileLayout {",internal const val maxFileNameLength = 150
"@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.ULongArray.max(): kotlin.ULong

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UShortArray.max(): kotlin.UShort

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxOrThrow"")
public fun <T : kotlin.Comparable<T>> kotlin.collections.Iterable<T>.max(): T

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxOrThrow"")
public fun kotlin.collections.Iterable<kotlin.Double>.max(): kotlin.Double

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxOrThrow"")
public fun kotlin.collections.Iterable<kotlin.Float>.max(): kotlin.Float

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <T, R : kotlin.Comparable<R>> kotlin.Array<out T>.maxBy(selector: (T) -> R): T

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.BooleanArray.maxBy(selector: (kotlin.Boolean) -> R): kotlin.Boolean

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.ByteArray.maxBy(selector: (kotlin.Byte) -> R): kotlin.Byte

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.CharArray.maxBy(selector: (kotlin.Char) -> R): kotlin.Char

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.DoubleArray.maxBy(selector: (kotlin.Double) -> R): kotlin.Double

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.FloatArray.maxBy(selector: (kotlin.Float) -> R): kotlin.Float

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.IntArray.maxBy(selector: (kotlin.Int) -> R): kotlin.Int

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.LongArray.maxBy(selector: (kotlin.Long) -> R): kotlin.Long

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow"")
public inline fun <R : kotlin.Comparable<R>> kotlin.ShortArray.maxBy(selector: (kotlin.Short) -> R): kotlin.Short

@kotlin.SinceKotlin(version = ""1.7"")
@kotlin.jvm.JvmName(name = ""maxByOrThrow-U"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun <R : kotlin.Comparable<R>> kotlin.UByteArray.maxBy(selector: (kotlin.UByte) -> R): kotlin.UByte

@kotlin.SinceKotlin(version = ""1.7"")","@kotlin.jvm.JvmName(name = ""maxByOrThrow-U"")"
"// TARGET_BACKEND: JVM
// WITH_STDLIB
// JVM_ABI_K1_K2_DIFF: KT-63914

// FILE: J.java

import java.util.*;

public interface J<T extends Number> {
    T foo(List<T> p0, Map<T, ? extends Set<T>> p1);
}

// FILE: K.kt

import kotlin.test.assertEquals

object O : J<Long> {
    override fun foo(p0: List<Long>, p1: Map<Long, out Set<Long>>): Long = 42L
}

class A : J<Long> by O

fun box(): String {
    val m = A::class.java.getDeclaredMethod(""foo"", List::class.java, Map::class.java)",assertEquals(
"// WITH_STDLIB
// CHECK_CASES_COUNT: function=bar1 count=3
// CHECK_IF_COUNT: function=bar1 count=0
// CHECK_CASES_COUNT: function=bar2 count=4
// CHECK_IF_COUNT: function=bar2 count=0

import kotlin.test.assertEquals

enum class Season {
    WINTER,
    SPRING,
    SUMMER,
    AUTUMN
}

fun bar1(x : Season) : String {
    return when (x) {
        Season.WINTER, Season.SPRING -> ""winter_spring""
        Season.SUMMER -> ""summer""
        else -> ""autumn""
    }
}

fun bar2(x : Season) : String {
    return when (x) {
        Season.WINTER, Season.SPRING -> ""winter_spring""
        Season.SUMMER -> ""summer""
        Season.AUTUMN -> ""autumn""
    }
}

fun box() : String {
    assertEquals(""winter_spring"", bar1(Season.WINTER))
    assertEquals(""winter_spring"", bar1(Season.SPRING))
    assertEquals(""summer"", bar1(Season.SUMMER))
    assertEquals(""autumn"", bar1(Season.AUTUMN))","assertEquals(""winter_spring"", bar2(Season.WINTER))"
"override fun isApplicable(subjectType: KotlinType): Boolean {
        return DescriptorUtils.isSealedClass(TypeUtils.getClassDescriptor(subjectType))
    }
}


object WhenChecker {

    private val exhaustivenessCheckers = listOf(
        WhenOnBooleanExhaustivenessChecker,
        WhenOnEnumExhaustivenessChecker,
        WhenOnSealedExhaustivenessChecker
    )

    @JvmStatic
    fun getClassIdForEnumSubject(expression: KtWhenExpression, context: BindingContext) =
        getClassIdForTypeIfEnum(whenSubjectType(expression, context))

    @JvmStatic
    fun getClassIdForTypeIfEnum(type: KotlinType?) =
        getClassDescriptorOfTypeIfEnum(type)?.classId

    @JvmStatic
    fun getClassDescriptorOfTypeIfEnum(type: KotlinType?): ClassDescriptor? {
        if (type == null) return null
        val classDescriptor = TypeUtils.getClassDescriptor(type) ?: return null
        if (classDescriptor.kind != ClassKind.ENUM_CLASS) return null

        return classDescriptor
    }

    @JvmStatic
    fun getClassDescriptorOfTypeIfSealed(type: KotlinType?): ClassDescriptor? =
        type?.let { TypeUtils.getClassDescriptor(it) }?.takeIf { DescriptorUtils.isSealedClass(it) }


    @JvmStatic
    fun whenSubjectType(expression: KtWhenExpression, context: BindingContext): KotlinType? {
        val subjectVariable = expression.subjectVariable
        val subjectExpression = expression.subjectExpression
        return when {
            subjectVariable != null -> context.get(VARIABLE, subjectVariable)?.type
            subjectExpression != null -> context.get(SMARTCAST, subjectExpression)?.defaultType ?: context.getType(subjectExpression)
            else -> null
        }
    }

    fun whenSubjectTypeWithoutSmartCasts(expression: KtWhenExpression, context: BindingContext): KotlinType? {
        val subjectVariable = expression.subjectVariable
        val subjectExpression = expression.subjectExpression
        return when {
            subjectVariable != null -> context.get(VARIABLE, subjectVariable)?.type
            subjectExpression != null -> context.getType(subjectExpression)
            else -> null
        }
    }

    @JvmStatic
    fun getEnumMissingCases(
        expression: KtWhenExpression,
        context: BindingContext,
        enumClassDescriptor: ClassDescriptor
    ) = WhenOnEnumExhaustivenessChecker.getMissingCases(expression, context, enumClassDescriptor, false)",@JvmStatic
"package hello

open class A {

    internal val z: String = ""A_O""","internal fun test() = ""A_K"""
"val `OrgGradlePluginGroup`.`groovy-gradle-plugin`: PluginDependencySpec
    get() = plugins.id(""org.gradle.groovy-gradle-plugin"")


/**
 * The `org.gradle.help-tasks` plugin implemented by [org.gradle.api.plugins.HelpTasksPlugin].
 */
internal
val `OrgGradlePluginGroup`.`help-tasks`: PluginDependencySpec
    get() = plugins.id(""org.gradle.help-tasks"")


/**
 * The `org.gradle.idea` plugin implemented by [org.gradle.plugins.ide.idea.IdeaPlugin].
 */
internal
val `OrgGradlePluginGroup`.`idea`: PluginDependencySpec
    get() = plugins.id(""org.gradle.idea"")


/**
 * The `org.gradle.ivy-publish` plugin implemented by [org.gradle.api.publish.ivy.plugins.IvyPublishPlugin].
 */
internal
val `OrgGradlePluginGroup`.`ivy-publish`: PluginDependencySpec
    get() = plugins.id(""org.gradle.ivy-publish"")


/**
 * The `org.gradle.jacoco` plugin implemented by [org.gradle.testing.jacoco.plugins.JacocoPlugin].
 */
internal
val `OrgGradlePluginGroup`.`jacoco`: PluginDependencySpec
    get() = plugins.id(""org.gradle.jacoco"")


/**
 * The `org.gradle.jacoco-report-aggregation` plugin implemented by [org.gradle.testing.jacoco.plugins.JacocoReportAggregationPlugin].
 */
internal
val `OrgGradlePluginGroup`.`jacoco-report-aggregation`: PluginDependencySpec
    get() = plugins.id(""org.gradle.jacoco-report-aggregation"")


/**
 * The `org.gradle.java` plugin implemented by [org.gradle.api.plugins.JavaPlugin].
 */
internal
val `OrgGradlePluginGroup`.`java`: PluginDependencySpec
    get() = plugins.id(""org.gradle.java"")


/**
 * The `org.gradle.java-base` plugin implemented by [org.gradle.api.plugins.JavaBasePlugin].
 */
internal
val `OrgGradlePluginGroup`.`java-base`: PluginDependencySpec
    get() = plugins.id(""org.gradle.java-base"")


/**
 * The `org.gradle.java-gradle-plugin` plugin implemented by [org.gradle.plugin.devel.plugins.JavaGradlePluginPlugin].
 */
internal
val `OrgGradlePluginGroup`.`java-gradle-plugin`: PluginDependencySpec","get() = plugins.id(""org.gradle.java-gradle-plugin"")"
"// j.u.List in JDK 8 from Kotlin POV has a supertype kotlin.collections.MutableCollection
                    // that actually has JavaAnalogue, but since JDK 21 it has j.u.SequencedCollection as a supertype
                    // so `getJavaAnalogue()` might return null, but we still should continue traversing the supertypes
                    superClassDescriptor.getJavaAnalogue() ?: superClassDescriptor
                }
            },
            object : DFS.AbstractNodeHandler<ClassDescriptor, JDKMemberStatus>() {
                override fun beforeChildren(javaClassDescriptor: ClassDescriptor): Boolean {
                    val signature = SignatureBuildingComponents.signature(javaClassDescriptor, jvmDescriptor)
                    when (signature) {
                        in HIDDEN_METHOD_SIGNATURES -> result = JDKMemberStatus.HIDDEN
                        in VISIBLE_METHOD_SIGNATURES -> result = JDKMemberStatus.VISIBLE
                        in DEPRECATED_LIST_METHODS -> result = JDKMemberStatus.DEPRECATED_LIST_METHODS
                        in DROP_LIST_METHOD_SIGNATURES -> result = JDKMemberStatus.DROP
                    }

                    return result == null
                }

                override fun result() = result ?: JDKMemberStatus.NOT_CONSIDERED
            })
    }

    private enum class JDKMemberStatus {
        HIDDEN, VISIBLE, DEPRECATED_LIST_METHODS, NOT_CONSIDERED, DROP
    }

    private fun ClassDescriptor.getJavaAnalogue(): LazyJavaClassDescriptor? {
        // Prevents recursive dependency: memberScope(Any) -> memberScope(Object) -> memberScope(Any)
        // No additional members should be added to Any
        if (KotlinBuiltIns.isAny(this)) return null

        // Optimization: only classes under kotlin.* can have Java analogues
        if (!KotlinBuiltIns.isUnderKotlinPackage(this)) return null

        val fqName = fqNameUnsafe
        if (!fqName.isSafe) return null
        val javaAnalogueFqName = JavaToKotlinClassMap.mapKotlinToJava(fqName)?.asSingleFqName() ?: return null

        return settings.ownerModuleDescriptor.resolveClassByFqName(javaAnalogueFqName, NoLookupLocation.FROM_BUILTINS) as? LazyJavaClassDescriptor
    }

    override fun getConstructors(classDescriptor: ClassDescriptor): Collection<ClassConstructorDescriptor> {
        if (classDescriptor.kind != ClassKind.CLASS || !settings.isAdditionalBuiltInsFeatureSupported) return emptyList()

        val javaAnalogueDescriptor = classDescriptor.getJavaAnalogue() ?: return emptyList()

        val defaultKotlinVersion =
            j2kClassMapper.mapJavaToKotlin(javaAnalogueDescriptor.fqNameSafe, FallbackBuiltIns.Instance) ?: return emptyList()

        val substitutor = createMappedTypeParametersSubstitution(defaultKotlinVersion, javaAnalogueDescriptor).buildSubstitutor()

        fun ConstructorDescriptor.isEffectivelyTheSameAs(javaConstructor: ConstructorDescriptor) =
            OverridingUtil.getBothWaysOverridability(this, javaConstructor.substitute(substitutor)) ==
                    OverridingUtil.OverrideCompatibilityInfo.Result.OVERRIDABLE

        return javaAnalogueDescriptor.constructors.filter { javaConstructor ->
            javaConstructor.visibility.isPublicAPI &&
                    defaultKotlinVersion.constructors.none { it.isEffectivelyTheSameAs(javaConstructor) } &&
                    !javaConstructor.isTrivialCopyConstructorFor(classDescriptor) &&
                    !KotlinBuiltIns.isDeprecated(javaConstructor) &&
                    SignatureBuildingComponents.signature(
                        javaAnalogueDescriptor,
                        javaConstructor.computeJvmDescriptor()
                    ) !in HIDDEN_CONSTRUCTOR_SIGNATURES",}.map { javaConstructor ->
"@NullableApi
        public String foobar(String x, @Nullable CharSequence y) {
            return """";
        }

        public String bar() {
            return """";
        }

        @Nullable
        public java.util.List<String> baz() {
            return null;
        }
    }
}

// FILE: main.kt
fun main(a: A, b: A.B, c: A.C) {
    a.foo("""", null)<!UNNECESSARY_SAFE_CALL!>?.<!>length
    a.foo("""", null).length
    a.foo(<!NULL_FOR_NONNULL_TYPE!>null<!>, """").length

    a.foobar(null, """")<!UNSAFE_CALL!>.<!>length
    a.foobar("""", <!NULL_FOR_NONNULL_TYPE!>null<!>)?.length

    a.bar().length
    a.bar()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.length

    a.field<!UNNECESSARY_SAFE_CALL!>?.<!>length
    a.field.length

    a.baz()<!UNSAFE_CALL!>.<!>get(0)
    a.baz()!!.get(0).get(0)
    a.baz()!!.get(0)?.get(0)

    // b
    b.foo("""", <!NULL_FOR_NONNULL_TYPE!>null<!>)?.length
    b.foo("""", <!NULL_FOR_NONNULL_TYPE!>null<!>)<!UNSAFE_CALL!>.<!>length
    b.foo(null, """")<!UNSAFE_CALL!>.<!>length

    b.foobar(<!NULL_FOR_NONNULL_TYPE!>null<!>, """").length
    b.foobar("""", null)<!UNNECESSARY_SAFE_CALL!>?.<!>length

    b.bar()<!UNSAFE_CALL!>.<!>length
    b.bar()!!.length

    b.field?.length
    b.field<!UNSAFE_CALL!>.<!>length

    b.baz()<!UNSAFE_CALL!>.<!>get(0)
    b.baz()!!.get(0).get(0)
    b.baz()!!.get(0)?.get(0)

    // c
    c.foo("""", null)<!UNNECESSARY_SAFE_CALL!>?.<!>length
    c.foo("""", null).length
    c.foo(<!NULL_FOR_NONNULL_TYPE!>null<!>, """").length

    c.foobar(null, """")<!UNSAFE_CALL!>.<!>length
    c.foobar("""", null)?.length

    c.bar().length
    c.bar()<!UNNECESSARY_NOT_NULL_ASSERTION!>!!<!>.length",c.field?.length
"typeParameters = listOfNotNull(visitorResultType as? TypeVariable, dataTP),
        modality = modality,
        override = override,
    )
}

private fun transformChildrenMethodKDoc(transformerParameter: FunctionParameter, dataParameter: FunctionParameter?, returnType: TypeRef) =
    buildString {
        append(""Recursively transforms this node's children *in place* using ["")
        append(transformerParameter.name)
        append(""].\n\n"")
        append(""Basically, executes `this.child = this.child.transform("")
        append(transformerParameter.name)
        if (dataParameter != null) {
            append("", "")
            append(dataParameter.name)
        }
        append("")` for each child of this node.\n\n"")
        append(""Does **not** run ["")
        append(transformerParameter.name)
        append(""] on this node itself.\n\n"")
        append(""@param "")
        append(transformerParameter.name)
        append("" The transformer to use for transforming the children."")
        if (dataParameter != null) {
            append(""\n@param "")
            append(dataParameter.name)
            append("" An arbitrary context to pass to each invocation of ["")
            append(transformerParameter.name)
            append(""]'s methods."")
        }
        if (returnType != StandardTypes.unit) {
            append(""\n@return `this`"")
        }
    }

fun ImportCollectingPrinter.printTransformChildrenMethod(
    element: FieldContainer<*>,
    transformerClass: ClassRef<PositionTypeParameterRef>,
    returnType: TypeRef,
    modality: Modality? = null,
    override: Boolean = false,
) {
    if (!element.hasTransformChildrenMethod) return
    println()
    val transformerParameter = FunctionParameter(""transformer"", transformerClass.withArgs(dataTP))
    if (!override) {
        printKDoc(transformChildrenMethodKDoc(transformerParameter, dataParameter, returnType))
    }
    printFunctionDeclaration(
        name = ""transformChildren"",
        parameters = listOf(transformerParameter, dataParameter),
        returnType = returnType,
        typeParameters = listOf(dataTP),
        modality = modality,
        override = override,
    )
}

fun ImportCollectingPrinter.printAcceptVoidMethod(visitorType: ClassRef<*>, treeName: String) {
    val visitorParameter = FunctionParameter(""visitor"", visitorType)
    val returnType = StandardTypes.unit
    printKDoc(acceptMethodKDoc(visitorParameter, null, returnType, treeName))
    printFunctionDeclaration(""accept"", listOf(visitorParameter), returnType)
    printBlock {","println(""accept("", visitorParameter.name, "", null)"")"
"builder.reified = typeParameter.isReified
        }

        val variance = variance(typeParameter.variance)
        if (variance != builder.variance) {
            builder.variance = variance
        }
        extension.serializeTypeParameter(typeParameter, builder)

        val upperBounds = typeParameter.upperBounds
        if (upperBounds.size == 1 && KotlinBuiltIns.isDefaultBound(upperBounds.single())) return builder

        for (upperBound in upperBounds) {
            if (useTypeTable()) {
                builder.addUpperBoundId(typeId(upperBound))
            } else {
                builder.addUpperBound(type(upperBound))
            }
        }

        return builder
    }

    fun typeId(type: KotlinType): Int = typeTable[type(type)]

    internal fun type(type: KotlinType): ProtoBuf.Type.Builder {
        val builder = ProtoBuf.Type.newBuilder()

        if (type.isError) {
            extension.serializeErrorType(type, builder)
            return builder
        }

        if (type.isFlexible()) {
            val flexibleType = type.asFlexibleType()

            val lowerBound = type(flexibleType.lowerBound)
            val upperBound = type(flexibleType.upperBound)
            extension.serializeFlexibleType(flexibleType, lowerBound, upperBound)
            if (useTypeTable()) {
                lowerBound.flexibleUpperBoundId = typeTable[upperBound]
            } else {
                lowerBound.setFlexibleUpperBound(upperBound)
            }
            return lowerBound
        }

        if (type.isSuspendFunctionType) {
            val functionType = type(transformSuspendFunctionToRuntimeFunctionType(type))
            functionType.flags = Flags.getTypeFlags(true, false)
            return functionType
        }

        when (val descriptor = type.constructor.declarationDescriptor) {
            is ClassDescriptor, is TypeAliasDescriptor -> {
                val possiblyInnerType = type.buildPossiblyInnerType() ?: error(""possiblyInnerType should not be null: $type"")
                fillFromPossiblyInnerType(builder, possiblyInnerType)
            }
            is TypeParameterDescriptor -> {
                if (descriptor.containingDeclaration === containingDeclaration) {
                    builder.typeParameterName = getSimpleNameIndex(descriptor.name)
                } else {
                    builder.typeParameter = getTypeParameterId(descriptor)
                }",if (type.unwrap() is DefinitelyNotNullType) {
"// -----------------------------------------------------------------------
    // internal implementation stuff

    // TODO: consider matching compilerId coming from outside with actual one
    //    private val selfCompilerId by lazy {
    //        CompilerId(
    //                compilerClasspath = System.getProperty(""java.class.path"")
    //                                            ?.split(File.pathSeparator)
    //                                            ?.map { File(it) }
    //                                            ?.filter { it.exists() }
    //                                            ?.map { it.absolutePath }
    //                                    ?: listOf(),
    //                compilerVersion = loadKotlinVersionFromResource()
    //        )
    //    }

    fun startDaemonElections() {
        timer.schedule(10) {
            exceptionLoggingTimerThread { initiateElections() }
        }
    }

    fun configurePeriodicActivities() {
        timer.schedule(delay = DAEMON_PERIODIC_CHECK_INTERVAL_MS, period = DAEMON_PERIODIC_CHECK_INTERVAL_MS) {
            exceptionLoggingTimerThread { periodicAndAfterSessionCheck() }
        }
        timer.schedule(delay = DAEMON_PERIODIC_SELDOM_CHECK_INTERVAL_MS + 100, period = DAEMON_PERIODIC_SELDOM_CHECK_INTERVAL_MS) {
            exceptionLoggingTimerThread { periodicSeldomCheck() }
        }
    }


    protected inline fun <R> ifAliveChecksImpl(
        minAliveness: Aliveness = Aliveness.LastSession,
        body: () -> CompileService.CallResult<R>,
    ): CompileService.CallResult<R> {
        val curState = state.alive.get()
        return when {
            curState < minAliveness.ordinal -> {
                log.info(""Cannot perform operation, requested state: ${minAliveness.name} > actual: ${curState.toAlivenessName()}"")
                CompileService.CallResult.Dying()
            }
            else -> {
                try {
                    body()
                } catch (e: Throwable) {
                    log.log(Level.SEVERE, ""Exception"", e)
                    CompileService.CallResult.Error(e)
                }
            }
        }
    }

    protected inline fun <R> withValidClientOrSessionProxy(
        sessionId: Int,
        body: (ClientOrSessionProxy<Any>?) -> CompileService.CallResult<R>,
    ): CompileService.CallResult<R> {
        val session: ClientOrSessionProxy<Any>? =
            if (sessionId == CompileService.NO_SESSION) null
            else state.sessions[sessionId] ?: return CompileService.CallResult.Error(""Unknown or invalid session $sessionId"")
        try {
            compilationsCounter.incrementAndGet()
            return body(session)",} finally {
"// Test depends on macOS-specific AppKit
// DISABLE_NATIVE: isAppleTarget=false
// DISABLE_NATIVE: targetFamily=IOS
// DISABLE_NATIVE: targetFamily=TVOS
// DISABLE_NATIVE: targetFamily=WATCHOS
import kotlinx.cinterop.alloc
import kotlinx.cinterop.memScoped
import kotlinx.cinterop.readValue
import platform.AppKit.NSEvent
import platform.AppKit.NSOpenGLPixelFormat
import platform.AppKit.NSOpenGLView
import platform.Foundation.NSRect

val sb = StringBuilder()

@OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)
class MyNSOpenGLView(
        frame: kotlinx.cinterop.CValue<NSRect>,
        pixelFormat: platform.AppKit.NSOpenGLPixelFormat?
) : NSOpenGLView(frame, pixelFormat) {

    init {
        this.resetCursorRects()
    }

    override fun acceptsFirstResponder(): Boolean = true
    override fun becomeFirstResponder(): Boolean = true

    override fun resetCursorRects() {
       sb.append(""OK"")
    }


    override fun flagsChanged(event: NSEvent) {

    }

    override fun magnifyWithEvent(event: NSEvent) {

    }

    override fun rotateWithEvent(event: NSEvent) {

    }

    override fun swipeWithEvent(event: NSEvent) {

    }

    override fun smartMagnifyWithEvent(event: NSEvent) {

    }

    override fun scrollWheel(event: NSEvent) {

    }

    override fun mouseUp(event: NSEvent): Unit = TODO()
    override fun rightMouseUp(event: NSEvent): Unit = TODO()
    override fun otherMouseUp(event: NSEvent): Unit = TODO()

    override fun mouseDown(event: NSEvent): Unit = TODO()
    override fun rightMouseDown(event: NSEvent): Unit = TODO()
    override fun otherMouseDown(event: NSEvent): Unit = TODO()",override fun mouseDragged(event: NSEvent): Unit = TODO()
"// WITH_STDLIB

@file:JvmName(""TestKt"")

package test

import kotlinx.parcelize.*
import android.os.Parcel
import android.os.Parcelable
import kotlinx.collections.immutable.*

@Parcelize
data class Test(val a: PersistentList<String>) : Parcelable

fun box() = parcelTest { parcel ->
    val first = Test(persistentListOf(""A"", ""B""))

    first.writeToParcel(parcel, 0)

    val bytes = parcel.marshall()
    parcel.unmarshall(bytes, 0, bytes.size)
    parcel.setDataPosition(0)

    val first2 = parcelableCreator<Test>().createFromParcel(parcel)",assert(first == first2)
"): List<ConeClassLikeType> {
    return SmartList<ConeClassLikeType>().also {
        klass.symbol.collectSuperTypes(it, SmartSet.create(), deep, lookupInterfaces, substituteTypes, useSiteSession, supertypeSupplier)
    }
}

fun FirClassSymbol<*>.isSubclassOf(
    ownerLookupTag: ConeClassLikeLookupTag,
    session: FirSession,
    isStrict: Boolean,
    lookupInterfaces: Boolean
): Boolean {
    lazyResolveToPhase(FirResolvePhase.SUPER_TYPES)
    return fir.isSubclassOf(ownerLookupTag, session, isStrict, SupertypeSupplier.Default, lookupInterfaces)
}

fun FirClass.isSubclassOf(
    ownerLookupTag: ConeClassLikeLookupTag,
    session: FirSession,
    isStrict: Boolean,
    supertypeSupplier: SupertypeSupplier = SupertypeSupplier.Default,
    lookupInterfaces: Boolean = true,
): Boolean {
    if (symbol.toLookupTag() == ownerLookupTag) {
        return !isStrict
    }

    return lookupSuperTypes(
        this,
        lookupInterfaces = lookupInterfaces,
        deep = true,
        session,
        substituteTypes = false,
        supertypeSupplier
    ).any { superType ->
        // Note: We just check lookupTag here, so type substitution isn't needed
        superType.lookupTag == ownerLookupTag
    }
}

fun FirClass.isThereLoopInSupertypes(session: FirSession): Boolean {
    val visitedSymbols: MutableSet<FirClassifierSymbol<*>> = SmartSet.create()
    val inProcess: MutableSet<FirClassifierSymbol<*>> = mutableSetOf()

    var isThereLoop = false

    fun dfs(current: FirClassifierSymbol<*>) {
        if (current in visitedSymbols) return
        if (!inProcess.add(current)) {
            isThereLoop = true
            return
        }

        when (val fir = current.fir) {
            is FirClass -> {
                fir.superConeTypes.forEach {
                    it.lookupTag.toSymbol(session)?.let(::dfs)
                }
            }
            is FirTypeAlias -> {
                fir.expandedConeType?.lookupTag?.toSymbol(session)?.let(::dfs)
            }
            else -> {}
        }",visitedSymbols.add(current)
"// FILE: rootPackage.kt
class Klass {
    class Nested
}",class NotImported
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_PARAMETER
// ISSUE: KT-35896

interface B<E, SC>

class Inv<T>","class Foo<T>(x: Int): B<T, Inv<T>>"
"// Object.
interface Codeable {
    fun asCode(): Int
}

val an_object = object : Codeable {
    override fun asCode() = 42
}

object Singleton {
    override fun toString() = ""I am single""
}

class Child : Base() {
    override fun fooParam(arg0: String, arg1: Int, arg2: String?) =
            println(""Child.fooParam: $arg0 $arg1 ${arg2 ?: ""null""}"")

    val roProperty: Int
        get() = 42

    var rwProperty: Int = 0
        get() = field
        set(value) { field = value + 1 }
}

// Interface.
interface I {
    fun foo(arg0: String, arg1: Int, arg2: I)
    fun fooImpl() = foo(""Hi"", 239, this)
}

open class Impl1: I {
    override fun foo(arg0: String, arg1: Int, arg2: I) {
        println(""Impl1.I: $arg0 $arg1 ${arg2::class.qualifiedName}"")
    }
}

class Impl2 : Impl1() {
    override fun foo(arg0: String, arg1: Int, arg2: I) {
        println(""Impl2.I: $arg0 $arg1 ${arg2::class.qualifiedName}"")
    }
}

inline class IC1(val value: Int)
inline class IC2(val value: String)
inline class IC3(val value: Base?)

fun useInlineClasses(ic1: IC1, ic2: IC2, ic3: IC3) {
    assert(ic1.value == 42)
    assert(ic2.value == ""bar"")
    assert(ic3.value is Base)
}

fun testNullableWithNulls(arg1: Int?, arg2: Unit?) {
    assert(arg1 == null)
    assert(arg2 == null)
}

fun setCErrorHandler(callback: CPointer<CFunction<(CPointer<ByteVar>) -> Unit>>?) {
    setUnhandledExceptionHook({
        throwable: Throwable ->
        memScoped {
            callback!!(throwable.toString().cstr.ptr)
        }",kotlin.system.exitProcess(0)
"/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")
@DeprecatedSinceKotlin(warningSince = ""1.6"")
@kotlin.internal.InlineOnly
public inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {
    nativeSort(comparison)
}

/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")
@DeprecatedSinceKotlin(warningSince = ""1.6"")
@kotlin.internal.InlineOnly
public inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {
    nativeSort(comparison)
}

/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")
@DeprecatedSinceKotlin(warningSince = ""1.6"")
@kotlin.internal.InlineOnly
public inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {
    nativeSort(comparison)
}

/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")
@DeprecatedSinceKotlin(warningSince = ""1.6"")
@kotlin.internal.InlineOnly
public inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {
    nativeSort(comparison)
}

/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")
@DeprecatedSinceKotlin(warningSince = ""1.6"")
@kotlin.internal.InlineOnly
public inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {
    nativeSort(comparison)
}

/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")
@DeprecatedSinceKotlin(warningSince = ""1.6"")
@kotlin.internal.InlineOnly
public inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {
    nativeSort(comparison)
}

/**
 * Sorts the array in-place according to the order specified by the given [comparison] function.
 */
@Deprecated(""Use other sorting functions from the Standard Library"")","@DeprecatedSinceKotlin(warningSince = ""1.6"")"
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.resolve.transformers.body.resolve

import org.jetbrains.kotlin.fir.FirCallResolver
import org.jetbrains.kotlin.fir.FirElement
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.util.PrivateForInline
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.expressions.FirLazyBlock
import org.jetbrains.kotlin.fir.expressions.FirLazyExpression
import org.jetbrains.kotlin.fir.expressions.FirStatement
import org.jetbrains.kotlin.fir.resolve.*
import org.jetbrains.kotlin.fir.resolve.calls.ResolutionContext
import org.jetbrains.kotlin.fir.resolve.calls.ResolutionStageRunner
import org.jetbrains.kotlin.fir.resolve.dfa.FirDataFlowAnalyzer
import org.jetbrains.kotlin.fir.resolve.inference.FirCallCompleter
import org.jetbrains.kotlin.fir.resolve.inference.InferenceComponents
import org.jetbrains.kotlin.fir.resolve.inference.inferenceComponents
import org.jetbrains.kotlin.fir.resolve.providers.FirSymbolProvider
import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider
import org.jetbrains.kotlin.fir.resolve.transformers.*
import org.jetbrains.kotlin.fir.scopes.FirScope",import org.jetbrains.kotlin.fir.scopes.impl.FirLocalScope
"import org.junit.jupiter.api.Tag
import org.junit.jupiter.api.TestFactory
import org.jetbrains.kotlin.konan.test.blackbox.support.group.PredefinedTestCase as TC

@Tag(""stdlib"")
@PredefinedTestCases(
    TC(
        name = ""default"",
        runnerType = TestRunnerType.DEFAULT,
        freeCompilerArgs = [
            ENABLE_MPP, STDLIB_IS_A_FRIEND, ENABLE_X_STDLIB_API, ENABLE_X_ENCODING_API, ENABLE_RANGE_UNTIL,
            ENABLE_X_FOREIGN_API, ENABLE_X_NATIVE_API, ENABLE_OBSOLETE_NATIVE_API, ENABLE_NATIVE_RUNTIME_API,
            ENABLE_OBSOLETE_WORKERS_API, ENABLE_INTERNAL_FOR_KOTLIN_NATIVE,
            ""-language-version"", ""1.9"",
            ""-api-version"", ""2.0"",
            ""-Xsuppress-api-version-greater-than-language-version-error""
        ],
        sourceLocations = [
            ""libraries/stdlib/test/**.kt"",
            ""libraries/stdlib/common/test/**.kt"",
            ""libraries/stdlib/native-wasm/test/**.kt"",
            ""kotlin-native/runtime/test/**.kt""
        ],
        ignoredTests = [DISABLED_STDLIB_TEST]
    )
)
@EnforcedProperty(property = ClassLevelProperty.EXECUTION_TIMEOUT, propertyValue = ""2m"")
@UsePartialLinkage(UsePartialLinkage.Mode.DISABLED)
class StdlibTest : AbstractNativeBlackBoxTest() {
    @TestFactory
    fun default() = dynamicTestCase(TestCaseId.Named(""default""))
}

@Tag(""stdlib"")
@Tag(""frontend-fir"")
@PredefinedTestCases(
    TC(
        name = ""default"",
        runnerType = TestRunnerType.DEFAULT,
        freeCompilerArgs = [
            ENABLE_MPP, STDLIB_IS_A_FRIEND, ENABLE_X_STDLIB_API, ENABLE_X_ENCODING_API, ENABLE_RANGE_UNTIL,
            ENABLE_X_FOREIGN_API, ENABLE_X_NATIVE_API, ENABLE_OBSOLETE_NATIVE_API, ENABLE_NATIVE_RUNTIME_API,
            ENABLE_OBSOLETE_WORKERS_API, ENABLE_INTERNAL_FOR_KOTLIN_NATIVE,
            ""-Xcommon-sources=libraries/stdlib/common/test/jsCollectionFactories.kt"",
            ""-Xcommon-sources=libraries/stdlib/common/test/testUtils.kt"",
            ""-Xcommon-sources=libraries/stdlib/test/testUtils.kt"",
            ""-Xcommon-sources=libraries/stdlib/test/text/StringEncodingTest.kt"",
        ],
        sourceLocations = [
            ""libraries/stdlib/test/**.kt"",
            ""libraries/stdlib/common/test/**.kt"",
            ""libraries/stdlib/native-wasm/test/**.kt"",
            ""kotlin-native/runtime/test/**.kt""
        ],
        ignoredTests = [DISABLED_STDLIB_TEST]
    )
)
@EnforcedProperty(property = ClassLevelProperty.EXECUTION_TIMEOUT, propertyValue = ""2m"")
@FirPipeline
@UsePartialLinkage(UsePartialLinkage.Mode.DISABLED)
class FirStdlibTest : AbstractNativeBlackBoxTest() {
    @TestFactory
    fun default() = dynamicTestCase(TestCaseId.Named(""default""))
}","private const val ENABLE_MPP = ""-Xmulti-platform"""
"val removedFqNames = removedClasses.toSet()

        for (removedClass in removedFqNames) {
            for (affectedClass in withSubtypes(removedClass, thisWithDependentCaches)) {
                changesCollector.collectSignature(affectedClass, areSubclassesAffected = false)
            }
        }

        for (cache in thisWithDependentCaches) {
            val parentsFqNames = hashSetOf<FqName>()
            val childrenFqNames = hashSetOf<FqName>()

            for (removedFqName in removedFqNames) {
                parentsFqNames.addAll(cache.supertypesMap[removedFqName].orEmpty())
                childrenFqNames.addAll(cache.subtypesMap[removedFqName].orEmpty())

                cache.supertypesMap.remove(removedFqName)
                cache.subtypesMap.remove(removedFqName)
            }

            for (child in childrenFqNames) {
                cache.supertypesMap.removeValues(child, removedFqNames)
            }

            for (parent in parentsFqNames) {
                cache.subtypesMap.removeValues(parent, removedFqNames)
            }
        }

        removedFqNames.forEach {
            classFqNameToSourceMap.remove(it)
            classAttributesMap.remove(it)
        }
    }

    protected class ClassFqNameToSourceMap(
        storageFile: File,
        icContext: IncrementalCompilationContext,
    ) : AbstractBasicMap<FqName, File>(
        storageFile,
        FqNameExternalizer.toDescriptor(),
        icContext.fileDescriptorForSourceFiles,
        icContext
    )

    override fun getComplementaryFilesRecursive(dirtyFiles: Collection<File>): Collection<File> {
        val complementaryFiles = HashSet<File>()
        val filesQueue = ArrayDeque(dirtyFiles)

        val processedClasses = HashSet<FqName>()
        val processedFiles = HashSet<File>()

        while (filesQueue.isNotEmpty()) {
            val file = filesQueue.pollFirst()
            if (processedFiles.contains(file)) {
                continue
            }
            processedFiles.add(file)
            complementaryFilesMap[file]?.forEach {
                if (complementaryFiles.add(it) && !processedFiles.contains(it)) filesQueue.add(it)
            }
            val classes2recompile = sourceToClassesMap.getFqNames(file).orEmpty()
            classes2recompile.filter { !processedClasses.contains(it) }.forEach { class2recompile ->
                processedClasses.add(class2recompile)","val sealedClasses = findSealedSupertypes(class2recompile, listOf(this))"
"/*
 * KOTLIN DIAGNOSTICS SPEC TEST (POSITIVE)
 *
 * SPEC VERSION: 0.1-100
 * MAIN LINK: expressions, constant-literals, real-literals -> paragraph 4 -> sentence 1
 * NUMBER: 4
 * DESCRIPTION: Real literals with an omitted whole-number part and underscores in a whole-number part, a fraction part and an exponent part.
 */

// TESTCASE NUMBER: 1
val value_1 = .0_0

// TESTCASE NUMBER: 2
val value_2 = .0_0f

// TESTCASE NUMBER: 3
val value_3 = .0_0e-0_0

// TESTCASE NUMBER: 4
val value_4 = .0_0e0_0F

// TESTCASE NUMBER: 5
val value_5 = .0__0F

// TESTCASE NUMBER: 6
val value_6 = .0_0E+0__0_0F

// TESTCASE NUMBER: 7
val value_7 = .0e0f

// TESTCASE NUMBER: 8
val value_8 = .0_0E0_0

// TESTCASE NUMBER: 9
val value_9 = .0e1_0F

// TESTCASE NUMBER: 10
val value_10 = .0e10__0

// TESTCASE NUMBER: 11
val value_11 = .00______00F

// TESTCASE NUMBER: 12
val value_12 = .0___9

// TESTCASE NUMBER: 13",val value_13 = .0__________________________________________________12___________________________________________________________________0F
"// EXPECTED_REACHABLE_NODES: 1284
class C {
    fun foo() {}
}

fun box(): String {
    val a: C? = C()
    val b: C? = null

    if (a?.foo() != Unit) return ""fail1: ${a?.foo()}""","if (b?.foo() != null) return ""fail2: ${b?.foo()}"""
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.klib.reader.testUtils

import org.jetbrains.kotlin.native.analysis.api.*

fun Iterable<KlibDeclarationAddress>.render() = joinToString(System.lineSeparator().repeat(2)) { it.render() }",fun KlibDeclarationAddress.render(): String {
"fun data() = arrayOf<Any>(
            arrayOf(false, false),
            arrayOf(false, true),
            arrayOf(true, false),
            arrayOf(true, true)
        )
    }

    override fun CompilerConfiguration.updateConfiguration() {
        put(
            ComposeConfiguration.FEATURE_FLAGS,
            listOf(
                FeatureFlag.StrongSkipping.featureName,
                FeatureFlag.OptimizeNonSkippingGroups.featureName,
                FeatureFlag.IntrinsicRemember.name(intrinsicRememberEnabled)
            )
        )
    }

    @Test
    fun testSingleStableParam(): Unit = verifyMemoization(
        """"""
            class Foo(val value: Int = 0)
            @Composable fun A(x: Foo) {}
        """""",
        """"""
            @Composable
            fun Test(x: Foo) {
                A(x)
            }
        """"""
    )

    @Test
    fun testSingleUnstableParam(): Unit = verifyMemoization(
        """"""
            @Composable fun A(x: Foo) {}
            class Foo(var value: Int = 0)
        """""",
        """"""
            @Composable
            fun Test(x: Foo) {
                A(x)
            }
        """"""
    )

    @Test
    fun testSingleNullableUnstableParam(): Unit = verifyMemoization(
        """"""
            @Composable fun A(x: Foo?) {}
            class Foo(var value: Int = 0)
        """""",
        """"""
            @Composable
            fun Test(x: Foo?) {
                A(x)
            }
        """"""
    )

    @Test
    fun testSingleOptionalUnstableParam(): Unit = verifyMemoization(
        """"""
            @Composable fun A(x: Foo?) {}",class Foo(var value: Int = 0)
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"", ""unused"")

package org.jetbrains.kotlin.fir.expressions.builder

import kotlin.contracts.*
import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.FirExpressionRef
import org.jetbrains.kotlin.fir.builder.FirAnnotationContainerBuilder
import org.jetbrains.kotlin.fir.builder.FirBuilderDsl
import org.jetbrains.kotlin.fir.builder.toMutableOrEmpty
import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.expressions.FirCheckedSafeCallSubject
import org.jetbrains.kotlin.fir.expressions.FirExpression
import org.jetbrains.kotlin.fir.expressions.impl.FirCheckedSafeCallSubjectImpl
import org.jetbrains.kotlin.fir.types.ConeKotlinType

@FirBuilderDsl
class FirCheckedSafeCallSubjectBuilder : FirAnnotationContainerBuilder, FirExpressionBuilder {
    override var source: KtSourceElement? = null
    override var coneTypeOrNull: ConeKotlinType? = null
    override val annotations: MutableList<FirAnnotation> = mutableListOf()
    lateinit var originalReceiverRef: FirExpressionRef<FirExpression>",override fun build(): FirCheckedSafeCallSubject {
"val project = compilation.target.project

        val processResourcesTask = target.project.tasks.named(compilation.processResourcesTaskName)

        val assembleTaskProvider = project.tasks.named(LifecycleBasePlugin.ASSEMBLE_TASK_NAME)

        compilation.binaries
            .matching { it is Executable }
            .all { binary ->
                binary as Executable

                val mode = binary.mode
                val archivesName = project.archivesName

                val webpackTask = registerSubTargetTask<KotlinWebpack>(
                    disambiguateCamelCased(
                        binary.executeTaskBaseName,
                        WEBPACK_TASK_NAME
                    ),
                    listOf(compilation)
                ) { task ->
                    task.description = ""build webpack ${mode.name.toLowerCaseAsciiOnly()} bundle""
                    val buildDirectory = project.layout.buildDirectory
                    val targetName = target.name
                    task.outputDirectory.convention(
                        binary.distribution.distributionName.flatMap {
                            buildDirectory.dir(""kotlin-webpack/$targetName/$it"")
                        }
                    ).finalizeValueOnRead()

                    task.dependsOn(binary.linkSyncTask)

                    task.commonConfigure(
                        binary = binary,
                        mode = mode,
                        inputFilesDirectory = task.project.objects.directoryProperty().fileProvider(
                            task.project.provider { binary.linkSyncTask.get().destinationDirectory.get() },
                        ),
                        entryModuleName = binary.linkTask.flatMap { it.compilerOptions.moduleName },
                        configurationActions = webpackTaskConfigurations,
                        nodeJs = nodeJs,
                        defaultArchivesName = archivesName,
                    )
                }

                val distributionTask = registerSubTargetTask<Copy>(
                    disambiguateCamelCased(
                        if (binary.mode == KotlinJsBinaryMode.PRODUCTION) """" else binary.name,
                        DISTRIBUTION_TASK_NAME
                    )
                ) { copy ->
                    copy.from(processResourcesTask)
                    copy.from(webpackTask.flatMap { it.outputDirectory })

                    if (binary.compilation.platformType == KotlinPlatformType.wasm) {
                        copy.from(
                            binary.linkSyncTask.zip(binary.linkTask) { linkSyncTask, linkTask ->
                                val moduleNameProvider = linkTask.compilerOptions.moduleName
                                linkSyncTask.destinationDirectory.zip(moduleNameProvider) { destDir, moduleName ->
                                    destDir.resolve(""$moduleName.wasm"")
                                }
                            }
                        )
                    }",copy.into(binary.distribution.outputDirectory)
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.light.classes.symbol.source

import org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators.AnalysisApiFirSourceTestConfigurator
import org.jetbrains.kotlin.light.classes.symbol.base.AbstractSymbolLightClassesEqualityByPsiTest

abstract class AbstractSymbolLightClassesEqualityByPsiForSourceTest :
    AbstractSymbolLightClassesEqualityByPsiTest(","AnalysisApiFirSourceTestConfigurator(analyseInDependentSession = false),"
"toNullableT = true
        body {
            """"""
            return filterNotNullTo(ArrayList<T>())
            """"""
        }

        specialFor(Sequences) {
            doc { ""Returns a sequence containing all elements that are not `null`."" }
            returns(""Sequence<T>"")
        }
        body(Sequences) {
            """"""
            @Suppress(""UNCHECKED_CAST"")
            return filterNot { it == null } as Sequence<T>
            """"""
        }
    }

    val f_filterNotNullTo = fn(""filterNotNullTo(destination: C)"") {
        include(Iterables, Sequences, ArraysOfObjects)
    } builder {
        doc { ""Appends all elements that are not `null` to the given [destination]."" }
        sample(""samples.collections.Collections.Filtering.filterNotNullTo"")
        returns(""C"")
        typeParam(""C : TCollection"")
        typeParam(""T : Any"")
        toNullableT = true
        body {
            """"""
            for (element in this) if (element != null) destination.add(element)
            return destination
            """"""
        }
    }

    val f_filterIsInstanceTo = fn(""filterIsInstanceTo(destination: C)"") {
        include(Iterables, Sequences, ArraysOfObjects)
    } builder {
        doc { ""Appends all elements that are instances of specified type parameter R to the given [destination]."" }
        sample(""samples.collections.Collections.Filtering.filterIsInstanceTo"")
        typeParam(""reified R"")
        typeParam(""C : MutableCollection<in R>"")
        inline()
        genericStarProjection = true
        returns(""C"")
        body {
            """"""
            for (element in this) if (element is R) destination.add(element)
            return destination
            """"""
        }
    }

    val f_filterIsInstance = fn(""filterIsInstance()"") {
        include(Iterables, Sequences, ArraysOfObjects)
    } builder {
        doc { ""Returns a list containing all elements that are instances of specified type parameter R."" }
        sample(""samples.collections.Collections.Filtering.filterIsInstance"")
        typeParam(""reified R"")
        returns(""List<@kotlin.internal.NoInfer R>"")
        inline()
        genericStarProjection = true
        body {
            """"""",return filterIsInstanceTo(ArrayList<R>())
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.lower.calls

import org.jetbrains.kotlin.ir.backend.js.JsIrBackendContext
import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder
import org.jetbrains.kotlin.ir.expressions.IrConstructorCall
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.expressions.IrFunctionAccessExpression
import org.jetbrains.kotlin.ir.util.irConstructorCall


class BuiltInConstructorCalls(val context: JsIrBackendContext) : CallsTransformer {
    val intrinsics = context.intrinsics

    override fun transformFunctionAccess(call: IrFunctionAccessExpression, doNotIntrinsify: Boolean): IrExpression =
        if (call is IrConstructorCall) {
            // Do not transform Delegation calls
            when (call.symbol) {","intrinsics.stringConstructorSymbol -> JsIrBuilder.buildString(context.irBuiltIns.stringType, """")"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.internal.properties

import org.gradle.api.Project
import org.gradle.api.plugins.ExtraPropertiesExtension
import org.gradle.api.provider.MapProperty
import org.gradle.api.provider.Property",import org.gradle.api.provider.Provider
") {
        this.candidate = candidate
        setAnalyzedResults(subResolvedAtoms)
    }

}

class EagerCallableReferenceAtom(
    atom: CallableReferenceKotlinCallArgument,
    expectedType: UnwrappedType?
) : ResolvedCallableReferenceArgumentAtom(atom, expectedType) {
    override val inputTypes: Collection<UnwrappedType> get() = emptyList()
    override val outputType: UnwrappedType? get() = null

    fun transformToPostponed(): PostponedCallableReferenceAtom = PostponedCallableReferenceAtom(this)
}

sealed class AbstractPostponedCallableReferenceAtom(
    atom: CallableReferenceKotlinCallArgument,
    expectedType: UnwrappedType?
) : ResolvedCallableReferenceArgumentAtom(atom, expectedType) {
    override val inputTypes: Collection<UnwrappedType>
        get() = extractInputOutputTypesFromCallableReferenceExpectedType(expectedType)?.inputTypes ?: listOfNotNull(expectedType)

    override val outputType: UnwrappedType?
        get() = extractInputOutputTypesFromCallableReferenceExpectedType(expectedType)?.outputType
}

class CallableReferenceWithRevisedExpectedTypeAtom(
    atom: CallableReferenceKotlinCallArgument,
    expectedType: UnwrappedType?,
) : AbstractPostponedCallableReferenceAtom(atom, expectedType)

class PostponedCallableReferenceAtom(
    eagerCallableReferenceAtom: EagerCallableReferenceAtom
) : AbstractPostponedCallableReferenceAtom(eagerCallableReferenceAtom.atom, eagerCallableReferenceAtom.expectedType),
    PostponedCallableReferenceMarker {
    override var revisedExpectedType: UnwrappedType? = null
        private set

    override fun reviseExpectedType(expectedType: KotlinTypeMarker) {
        require(expectedType is UnwrappedType)
        revisedExpectedType = expectedType
    }
}

class ResolvedCollectionLiteralAtom(
    override val atom: CollectionLiteralKotlinCallArgument,
    val expectedType: UnwrappedType?
) : ResolvedAtom() {
    init {
        setAnalyzedResults(listOf())
    }
}

sealed class CallResolutionResult(
    resultCallAtom: ResolvedCallAtom?,
    val diagnostics: List<KotlinCallDiagnostic>,
    val constraintSystem: NewConstraintSystem
) : ResolvedAtom() {
    init {
        setAnalyzedResults(listOfNotNull(resultCallAtom))
    }

    final override fun setAnalyzedResults(subResolvedAtoms: List<ResolvedAtom>) {",super.setAnalyzedResults(subResolvedAtoms)
"// TARGET_BACKEND: JVM
// WITH_REFLECT
// FILE: 1.kt",@file:JvmMultifileClass
"val factory = when {
                            isReportExpansionError && argumentTypeRef == null -> additionalUpperBoundsProvider.diagnosticForTypeAlias
                            else -> additionalUpperBoundsProvider.diagnostic
                        }
                        reporter.reportOn(argumentSource, factory, upperBound, argumentType.type, context)
                    }
                }
            }

            if (argumentType is ConeClassLikeType) {
                checkUpperBoundViolated(argumentTypeRef, argumentType, context, reporter, isIgnoreTypeParameters)
            }
        }
    }
}

fun ConeClassLikeType.fullyExpandedTypeWithSource(
    typeRef: FirTypeRef,
    useSiteSession: FirSession,
): ConeClassLikeType? {
    val typeRefAndSourcesForArguments = extractArgumentsTypeRefAndSource(typeRef) ?: return null

    // Add source information to arguments of non-expanded type, which is preserved during expansion.
    val typeArguments = typeArguments.mapIndexed { i, projection ->
        // typeRefAndSourcesForArguments can have fewer elements than there are type arguments
        // because in FIR, inner types of generic outer types have the generic arguments of the outer type added to the end of their list
        // of type arguments but there is no source for them.
        val source = typeRefAndSourcesForArguments.elementAtOrNull(i) ?: return@mapIndexed projection
        projection.withSource(source)
    }.toTypedArray()

    return withArguments(typeArguments).fullyExpandedType(useSiteSession)
}

private class SourceAttribute(private val data: FirTypeRefSource) : ConeAttribute<SourceAttribute>() {
    val source: KtSourceElement? get() = data.source
    val typeRef: FirTypeRef? get() = data.typeRef

    override fun union(other: SourceAttribute?): SourceAttribute = other ?: this
    override fun intersect(other: SourceAttribute?): SourceAttribute = other ?: this
    override fun add(other: SourceAttribute?): SourceAttribute = other ?: this

    override fun isSubtypeOf(other: SourceAttribute?): Boolean = true

    override fun toString() = ""SourceAttribute: $data""

    override val key: KClass<out SourceAttribute>
        get() = SourceAttribute::class
    override val keepInInferredDeclarationType: Boolean
        get() = false
}

private val ConeAttributes.sourceAttribute: SourceAttribute? by ConeAttributes.attributeAccessor()

fun ConeTypeProjection.withSource(source: FirTypeRefSource?): ConeTypeProjection {
    return when {
        source == null || this !is ConeKotlinTypeProjection -> this
        else -> {
            // Prefer existing source information.
            val attributes = ConeAttributes.create(listOf(SourceAttribute(source))).add(type.attributes)
            replaceType(type.withAttributes(attributes))
        }
    }
}",interface FirPlatformUpperBoundsProvider : FirSessionComponent {
"//KT-1290 Method property in constructor causes NPE

class Foo<T>(val filter: (T) -> Boolean) {
    public fun bar(tee: T) : Boolean {
        return filter(tee);
    }
}

fun foo() = Foo({ i: Int -> i < 5 }).bar(2)

fun box() : String {
    if (!foo()) return ""fail""","return ""OK"""
"fun testReleaseCompilerAgainstPreReleaseLibrarySkipPrereleaseCheck() {
        doTestPreReleaseKotlinLibrary(K2JVMCompiler(), ""library"", tmpdir, ""-Xskip-prerelease-check"")
    }

    fun testReleaseCompilerAgainstPreReleaseLibraryJsSkipPrereleaseCheck() {
        doTestPreReleaseKotlinLibrary(K2JSCompiler(), ""library"", File(tmpdir, ""usage.js""), ""-Xskip-prerelease-check"")
    }

    fun testReleaseCompilerAgainstPreReleaseLibrarySkipMetadataVersionCheck() {
        doTestPreReleaseKotlinLibrary(K2JVMCompiler(), ""library"", tmpdir, ""-Xskip-metadata-version-check"")
    }

    fun testPreReleaseCompilerAgainstPreReleaseLibraryStableLanguageVersion() {
        withPreRelease {
            val library = compileLibrary(""library"")
            val someStableReleasedVersion = LanguageVersion.entries.first { it.isStable && it >= LanguageVersion.FIRST_NON_DEPRECATED }
            compileKotlin(
                ""source.kt"", tmpdir, listOf(library), K2JVMCompiler(),
                listOf(""-language-version"", someStableReleasedVersion.versionString)
            )

            checkPreReleaseness(File(tmpdir, ""usage/SourceKt.class""), shouldBePreRelease = false)
        }
    }

    fun testPreReleaseCompilerAgainstPreReleaseLibraryLatestStable() {
        withPreRelease {
            val library = compileLibrary(""library"")
            compileKotlin(
                ""source.kt"", tmpdir, listOf(library), K2JVMCompiler(),
                listOf(""-language-version"", LanguageVersion.LATEST_STABLE.versionString)
            )

            checkPreReleaseness(File(tmpdir, ""usage/SourceKt.class""), shouldBePreRelease = true)
        }
    }

    fun testReleaseCompilerAgainstPreReleaseLibrarySkipPrereleaseCheckAllowUnstableDependencies() {
        doTestPreReleaseKotlinLibrary(K2JVMCompiler(), ""library"", tmpdir, ""-Xallow-unstable-dependencies"", ""-Xskip-prerelease-check"")
    }

    // KT-61051 K1/K2 difference on extension functions with specific extension receiver types when compiling code that has itself as a dependency
    fun testDependencyOnItself() {
        val compiledLibrary = compileLibrary(""library"")
        compileKotlin(
            ""library/sample.kt"",
            output = tmpdir,
            classpath = listOf(compiledLibrary),
        )
    }

    fun testWrongMetadataVersion() {
        doTestKotlinLibraryWithWrongMetadataVersion(""library"", null)
    }

    // This test compiles a library with a ""future"" metadata version, then intentionally inserts some gibberish to the metadata, and tries
    // to compile something against this library. It emulates the scenario when a future Kotlin version has a completely different metadata
    // format -- so different that reading it as if it's the current (protobuf-based) format would most likely result in an exception.
    // Expected result is that the compiler does NOT try to read it, and instead reports incompatible version & unresolved reference errors.
    fun testWrongMetadataVersionBadMetadata() {
        doTestKotlinLibraryWithWrongMetadataVersion(""library"", { name, value ->
            if (JvmAnnotationNames.METADATA_DATA_FIELD_NAME == name) {
                @Suppress(""UNCHECKED_CAST"")
                val strings = value as Array<String>
                strings.map { string ->",String(string.toByteArray().map { x -> x xor 42 }.toTypedArray().toByteArray())
"* will use `ObjCFoo` instead of the class name `Foo`
 *
 */
context(KtAnalysisSession, KtObjCExportSession)
fun KtClassLikeSymbol.getObjCClassOrProtocolName(): ObjCExportClassOrProtocolName {
    val resolvedObjCNameAnnotation = resolveObjCNameAnnotation()

    return ObjCExportClassOrProtocolName(
        objCName = getObjCName(resolvedObjCNameAnnotation),
        swiftName = getSwiftName(resolvedObjCNameAnnotation)
    )
}

context(KtAnalysisSession, KtObjCExportSession)
private fun KtClassLikeSymbol.getObjCName(
    resolvedObjCNameAnnotation: KtResolvedObjCNameAnnotation? = resolveObjCNameAnnotation(),
): String {
    val objCName = (resolvedObjCNameAnnotation?.objCName ?: nameOrAnonymous.asString()).toValidObjCSwiftIdentifier()

    if (resolvedObjCNameAnnotation != null && resolvedObjCNameAnnotation.isExact) {
        return objCName
    }

    getContainingSymbol()?.let { it as? KtClassLikeSymbol }?.let { containingClass ->
        return containingClass.getObjCName() + objCName.capitalizeAsciiOnly()
    }

    return buildString {
        configuration.frameworkName?.let(::append)
        getObjCModuleNamePrefix()?.let(::append)
        append(objCName)
    }
}

context(KtAnalysisSession, KtObjCExportSession)
private fun KtClassLikeSymbol.getSwiftName(
    resolvedObjCNameAnnotation: KtResolvedObjCNameAnnotation? = resolveObjCNameAnnotation(),
): String {
    val swiftName = (resolvedObjCNameAnnotation?.swiftName ?: nameOrAnonymous.asString()).toValidObjCSwiftIdentifier()
    if (resolvedObjCNameAnnotation != null && resolvedObjCNameAnnotation.isExact) {
        return swiftName
    }

    getContainingSymbol()?.let { it as? KtClassLikeSymbol }?.let { containingClass ->
        val containingClassSwiftName = containingClass.getSwiftName()
        return buildString {
            if (canBeInnerSwift()) {
                append(containingClassSwiftName)
                if (""."" !in this && containingClass.canBeOuterSwift()) {
                    // AB -> AB.C
                    append(""."")
                    append(mangleSwiftNestedClassName(swiftName))
                } else {
                    // AB -> ABC
                    // A.B -> A.BC
                    append(swiftName.capitalizeAsciiOnly())
                }
            } else {
                append(containingClassSwiftName.replaceFirst(""."", """"))
                append(swiftName.capitalizeAsciiOnly())
            }
        }
    }

    return buildString {",getObjCModuleNamePrefix()?.let(::append)
"// !DIAGNOSTICS: -UNUSED_EXPRESSION
// SKIP_TXT

/*
 * KOTLIN DIAGNOSTICS SPEC TEST (NEGATIVE)
 *
 * SPEC VERSION: 0.1-435
 * MAIN LINK: expressions, when-expression, exhaustive-when-expressions -> paragraph 2 -> sentence 11
 * NUMBER: 3
 * DESCRIPTION: Non-exhaustive when using nullable enum values.
 * HELPERS: enumClasses
 */

// TESTCASE NUMBER: 1
fun case_1(value_1: EnumClass?): String = <!NO_ELSE_IN_WHEN!>when<!>(value_1) {
    EnumClass.EAST -> """"
    EnumClass.SOUTH -> """"
    EnumClass.NORTH -> """"
    EnumClass.WEST -> """"
}

// TESTCASE NUMBER: 2
fun case_2(value_1: EnumClass?): String = <!NO_ELSE_IN_WHEN!>when<!>(value_1) {
    EnumClass.EAST -> """"
    EnumClass.SOUTH -> """"
    EnumClass.NORTH -> """"
    null -> """"
}

// TESTCASE NUMBER: 3
fun case_3(value_1: EnumClass?): String = <!NO_ELSE_IN_WHEN!>when<!>(value_1) {
    EnumClass.EAST, null, EnumClass.SOUTH, EnumClass.NORTH -> """"
}

// TESTCASE NUMBER: 4
fun case_4(value_1: EnumClassSingle): Int = <!TYPE_MISMATCH!><!NO_ELSE_IN_WHEN!>when<!>(value_1) {}<!>

// TESTCASE NUMBER: 5
fun case_5(value_1: EnumClassSingle?): String = <!NO_ELSE_IN_WHEN!>when<!>(value_1) {
    EnumClassSingle.EVERYTHING -> """"
}

// TESTCASE NUMBER: 6
fun case_6(value_1: EnumClassSingle?): String = <!NO_ELSE_IN_WHEN!>when<!>(value_1) {","null -> """""
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.importsDumper

import com.intellij.openapi.project.Project
import kotlinx.serialization.internal.LinkedHashMapSerializer
import kotlinx.serialization.internal.StringSerializer
import kotlinx.serialization.json.Json",import kotlinx.serialization.json.JsonConfiguration
"// LAMBDAS: INDY
// TARGET_BACKEND: JVM_IR
// JVM_TARGET: 1.8
// WITH_STDLIB

// CHECK_BYTECODE_TEXT
// JVM_IR_TEMPLATES
// 14 java/lang/invoke/LambdaMetafactory


fun box(): String {
    var captureMe = 0

    fun () {} // 1
    fun (a: Any, b: Any, c: Any, d: Any, e: Any, f: Any, g: Any, h: Any, i: Any, j: Any, k: Any, l: Any, m: Any, n: Any, o: Any,
         p: Any, q: Any, r: Any, s: Any, t: Any, u: Any, v: Any) = ""just enough"" // 2
    fun () = ++captureMe // 3
    fun (vararg x: Int) = x // 4

    fun Any.() {} // 5
    fun Any.(a: Any, b: Any, c: Any, d: Any, e: Any, f: Any, g: Any, h: Any, i: Any, j: Any, k: Any, l: Any, m: Any, n: Any, o: Any,
             p: Any, q: Any, r: Any, s: Any, t: Any, u: Any) = ""just enough"" // 6
    fun () = ++captureMe // 7
    fun Any.(vararg x: Int) = x // 8


    {} // 9
    { a: Any, b: Any, c: Any, d: Any, e: Any, f: Any, g: Any, h: Any, i: Any, j: Any, k: Any, l: Any, m: Any, n: Any, o: Any,
      p: Any, q: Any, r: Any, s: Any, t: Any, u: Any, v: Any -> ""just enough"" } // 10
    { ++captureMe } // 11


    fun local1() {}
    { local1() } // 12","fun local2(a: Any, b: Any, c: Any, d: Any, e: Any, f: Any, g: Any, h: Any, i: Any, j: Any, k: Any, l: Any, m: Any, n: Any, o: Any,"
"// TARGET_BACKEND: WASM
// USE_NEW_EXCEPTION_HANDLING_PROPOSAL
// TODO: remove the test when KT-66906 will be resolved
class MyString {
    var s = """"
    operator fun plus(x : String) : MyString {
        s += x
        return this
    }

    override fun toString(): String {
        return s
    }
}


fun test1() : MyString {
    var r = MyString()
    try {
        r + ""Try1""

        try {
            r + ""Try2""
            if (true)
                return r
        } finally {
            r + ""Finally2""
            if (true) {",return r
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir

import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.resolve.calls.AbstractCallInfo
import org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol
import org.jetbrains.kotlin.fir.types.*
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.name.SpecialNames.DEFAULT_NAME_FOR_COMPANION_OBJECT
import org.jetbrains.kotlin.name.StandardClassIds
import org.jetbrains.kotlin.utils.SmartList

abstract class FirLookupTrackerComponent : FirSessionComponent {

    abstract fun recordLookup(name: String, inScopes: Iterable<String>, source: KtSourceElement?, fileSource: KtSourceElement?)

    abstract fun recordLookup(name: String, inScope: String, source: KtSourceElement?, fileSource: KtSourceElement?)
}

fun FirLookupTrackerComponent.recordCallLookup(callInfo: AbstractCallInfo, inType: ConeKotlinType) {
    val classId = inType.classId ?: return
    if (classId.isLocal) return",val scopes = SmartList(classId.asFqNameString())
"when (this) {
                is List -> return if (size == 1) this[0] else null
                else -> {
                    val iterator = iterator()
                    if (!iterator.hasNext())
                        return null
                    val single = iterator.next()
                    if (iterator.hasNext())
                        return null
                    return single
                }
            }
            """"""
        }
        body(Sequences) {
            """"""
            val iterator = iterator()
            if (!iterator.hasNext())
                return null
            val single = iterator.next()
            if (iterator.hasNext())
                return null
            return single
            """"""
        }
        body(CharSequences) {
            """"""
            return if (length == 1) this[0] else null
            """"""
        }
        body(Lists, ArraysOfObjects, ArraysOfPrimitives, ArraysOfUnsigned) {
            """"""
            return if (size == 1) this[0] else null
            """"""
        }
    }

    val f_single_predicate = fn(""single(predicate: (T) -> Boolean)"") {
        includeDefault()
        include(CharSequences, ArraysOfUnsigned)
    } builder {
        inline()
        specialFor(ArraysOfUnsigned) { inlineOnly() }

        doc { ""Returns the single ${f.element} matching the given [predicate], or throws exception if there is no or more than one matching ${f.element}."" }
        returns(""T"")

        body {
            """"""
            var single: T? = null
            var found = false
            for (element in this) {
                if (predicate(element)) {
                    if (found) throw IllegalArgumentException(""${f.doc.collection.capitalize()} contains more than one matching element."")
                    single = element
                    found = true
                }
            }
            if (!found) throw NoSuchElementException(""${f.doc.collection.capitalize()} contains no ${f.doc.element} matching the predicate."")
            @Suppress(""UNCHECKED_CAST"")
            return single as T
            """"""
        }
    }","val f_singleOrNull_predicate = fn(""singleOrNull(predicate: (T) -> Boolean)"") {"
"fun Leaf() {}

            fun Example(foo: Foo) {
                foo.setContent { Leaf() }
            }
        """"""
        )
    }

    @Test
    fun testComposableReporting024x() {
        check(
            """"""
            import androidx.compose.runtime.*

            var x: (@Composable () -> Unit)? = null

            fun <!COMPOSABLE_EXPECTED!>Example<!>(content: @Composable () -> Unit) {
                x = content
                <!COMPOSABLE_INVOCATION!>content<!>()
            }
        """"""
        )
    }

    @Test
    fun testComposableReporting025() {
        check(
            """"""
            import androidx.compose.runtime.*;

            @Composable
            fun Leaf() {}

            @Composable
            fun foo() {
                listOf(1,2,3,4,5).forEach { Leaf() }
            }
        """"""
        )
    }

    @Test
    fun testComposableReporting026() {
        check(
            """"""
            import androidx.compose.runtime.*;

            @Composable
            fun Leaf() {}

            @Composable
            fun Group(content: @Composable () -> Unit) { content() }

            @Composable
            fun foo() {
                Group {
                    Leaf()
                }
            }
        """"""
        )
    }

    @Test",fun testComposableReporting027() {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin.mpp.compilationImpl

import org.jetbrains.kotlin.gradle.plugin.Kotlin2JvmSourceSetProcessor
import org.jetbrains.kotlin.gradle.plugin.KotlinCommonSourceSetProcessor
import org.jetbrains.kotlin.gradle.plugin.KotlinCompilationInfo
import org.jetbrains.kotlin.gradle.plugin.KotlinJsIrSourceSetProcessor
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinCommonCompilation
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinJvmCompilation
import org.jetbrains.kotlin.gradle.targets.js.ir.KotlinJsIrCompilation
import org.jetbrains.kotlin.gradle.tasks.KotlinTasksProvider

internal val KotlinCompilationProcessorSideEffect = KotlinCompilationSideEffect { compilation ->
    val processor = when (compilation) {","is KotlinCommonCompilation -> KotlinCommonSourceSetProcessor(KotlinCompilationInfo(compilation), KotlinTasksProvider())"
"* If enabled - the evaluator will try to get imported script from a shared container
 * only create/evaluate instances if not found, and evaluator will put newly created instances into the container
 * This allows to have a single instance of the script if it is imported several times via different import paths.
 */
val ScriptEvaluationConfigurationKeys.scriptsInstancesSharing by PropertiesCollection.key<Boolean>(false)

/**
 * Scripting host configuration
 */
val ScriptEvaluationConfigurationKeys.hostConfiguration by PropertiesCollection.key<ScriptingHostConfiguration>(isTransient = true)

/**
 * The callback that will be called on the script compilation immediately before starting the compilation
 */
val ScriptEvaluationConfigurationKeys.refineConfigurationBeforeEvaluate by PropertiesCollection.key<List<RefineEvaluationConfigurationData>>(isTransient = true)

interface ScriptExecutionWrapper<T> {
    fun invoke(block: () -> T): T
}

/**
 *  An optional user-defined wrapper which is called with the code that actually executes script body
 */
val ScriptEvaluationConfigurationKeys.scriptExecutionWrapper by PropertiesCollection.key<ScriptExecutionWrapper<*>>(isTransient = true)

/**
 * A helper to enable passing lambda directly to the scriptExecutionWrapper ""keyword""
 */
fun <T> ScriptEvaluationConfiguration.Builder.scriptExecutionWrapper(wrapper: (() -> T) -> T) {
    ScriptEvaluationConfiguration.scriptExecutionWrapper.put(object : ScriptExecutionWrapper<T> {
        override fun invoke(block: () -> T): T = wrapper(block)
    })
}

/**
 * A helper to enable scriptsInstancesSharingMap with default implementation
 */
fun ScriptEvaluationConfiguration.Builder.enableScriptsInstancesSharing() {
    this {
        scriptsInstancesSharing(true)
    }
}

/**
 * A helper to enable passing lambda directly to the refinement ""keyword""
 */
fun ScriptEvaluationConfiguration.Builder.refineConfigurationBeforeEvaluate(handler: RefineScriptEvaluationConfigurationHandler) {
    ScriptEvaluationConfiguration.refineConfigurationBeforeEvaluate.append(RefineEvaluationConfigurationData(handler))
}

/**
 * The refinement callback function signature
 */
typealias RefineScriptEvaluationConfigurationHandler =
            (ScriptEvaluationConfigurationRefinementContext) -> ResultWithDiagnostics<ScriptEvaluationConfiguration>

data class RefineEvaluationConfigurationData(
    val handler: RefineScriptEvaluationConfigurationHandler
) : Serializable {
    companion object { private const val serialVersionUID: Long = 1L }
}

fun ScriptEvaluationConfiguration.refineBeforeEvaluation(
    script: CompiledScript,
    contextData: ScriptEvaluationContextData? = null",): ResultWithDiagnostics<ScriptEvaluationConfiguration> {
"// !LANGUAGE: -ProhibitTypeParametersInClassLiteralsInAnnotationArguments

import kotlin.reflect.KClass

annotation class Ann(vararg val k: KClass<*>)

inline val <reified T> T.test",get() = @Ann(
"// WITH_STDLIB
// WORKS_WHEN_VALUE_CLASS
// LANGUAGE: +ValueClasses

OPTIONAL_JVM_INLINE_ANNOTATION
value class A(val x: String)

fun isNullVacuousLeft(s: A) = s == null
fun isNullVacuousRight(s: A) = null == s",fun isNullLeft(s: A?) = s == null
"if (<!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.equals(null)
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.propT
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.propAny
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.propNullableT
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.propNullableAny
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.funT()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.funAny()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.funNullableT()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.funNullableAny()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.equals(null)
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.propT
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.propAny
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>.propNullableT
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>.propNullableAny
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.funT()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.funAny()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>.funNullableT()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>.funNullableAny()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>

        w = if (<!SENSELESS_COMPARISON!>null != null<!>) 10 else null
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.equals(null)
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propT
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propAny
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableT
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableAny
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funT()
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funAny()
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableT()
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableAny()
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.equals(null)
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propT
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propAny
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableT
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableAny
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funT()
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funAny()
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableT()
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableAny()
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.equals(null)
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propT
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propAny
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableT
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableAny
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funT()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funAny()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableT()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableAny()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!>this.w<!>.equals(null)
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!>this.w<!>.propT
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!>this.w<!>.propAny
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>this.w<!>.propNullableT
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>this.w<!>.propNullableAny
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!>this.w<!>.funT()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!>this.w<!>.funAny()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>this.w<!>.funNullableT()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>this.w<!>.funNullableAny()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>this.w<!>

        s = null","<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Nothing?"")!>s<!>.hashCode()"
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.cfg.pseudocode

import org.jetbrains.kotlin.cfg.pseudocode.instructions.Instruction
import org.jetbrains.kotlin.cfg.pseudocode.instructions.KtElementInstruction
import org.jetbrains.kotlin.cfg.pseudocode.instructions.special.LocalFunctionDeclarationInstruction
import org.jetbrains.kotlin.cfg.pseudocode.instructions.special.SubroutineEnterInstruction
import org.jetbrains.kotlin.cfg.pseudocode.instructions.special.SubroutineExitInstruction
import org.jetbrains.kotlin.cfg.pseudocode.instructions.special.SubroutineSinkInstruction
import org.jetbrains.kotlin.psi.KtElement

interface Pseudocode {
    val correspondingElement: KtElement

    val parent: Pseudocode?

    val localDeclarations: Set<LocalFunctionDeclarationInstruction>

    val instructions: List<Instruction>

    val reversedInstructions: List<Instruction>

    val instructionsIncludingDeadCode: List<Instruction>

    val exitInstruction: SubroutineExitInstruction

    val errorInstruction: SubroutineExitInstruction",val sinkInstruction: SubroutineSinkInstruction
"enum class EnumerationBCB constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    ENTRY;
}

enum class EnumerationBCC constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    ENTRY1,
    ENTRY2;
}

enum class EnumerationBCD constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    ENTRY1,
    ENTRY2();
}

enum class EnumerationBCE constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    ENTRY1 { override fun abstractFunc() { TODO(""Not yet implemented"") } },
    ENTRY2() { override fun abstractFunc() { TODO(""Not yet implemented"") } };
    abstract fun abstractFunc()
}

enum class EnumerationBDA constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY;<!>
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
}

enum class EnumerationBDB constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY1,<!>
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY2;<!>
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
}

enum class EnumerationBDC constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY1,<!>
    ENTRY2();
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
}

enum class EnumerationBDD constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY1 { override fun abstractFunc() { TODO(""Not yet implemented"") } },<!>
    ENTRY2() { override fun abstractFunc() { TODO(""Not yet implemented"") } };
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
    abstract fun abstractFunc()
}

enum class EnumerationBEA constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY;<!>
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
    constructor() : this(UserKlass(), UserKlass())
}

enum class EnumerationBEB constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY1,<!>
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY2;<!>
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
    constructor() : this(UserKlass(), UserKlass())
}

enum class EnumerationBEC constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {
    <!ENUM_ENTRY_SHOULD_BE_INITIALIZED!>ENTRY1,<!>
    ENTRY2();
    constructor(arg: UserKlass = UserKlass()) : this(arg, UserKlass())
    constructor() : this(UserKlass(), UserKlass())
}","enum class EnumerationBED constructor(arg1: UserKlass = UserKlass(), arg2: UserKlass = UserKlass()) {"
"* DESCRIPTION: Raw data flow analysis test
 * HELPERS: classes, objects, typealiases, functions, enumClasses, interfaces, sealedClasses
 */

/*
 * TESTCASE NUMBER: 1
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-24901
 */
fun case_1(x: String?) {
    when {
        x == null -> return
    }
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>.length
}

// TESTCASE NUMBER: 2
fun case_2(x: String?) {
    when {
        x == null -> return
        else -> println(1)
    }
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>.length
}

/*
 * TESTCASE NUMBER: 3
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-24901
 */
fun case_3(x: String?) {
    when (x) {
        null -> return
    }
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>.length
}

// TESTCASE NUMBER: 4
fun case_4(x: String?) {
    when (x) {
        null -> return
        else -> println(1)
    }
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>.length
}

// TESTCASE NUMBER: 5
fun case_5(x: String?) {
    when (x) {
        null -> throw Exception()
        else -> println(1)
    }
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String? & kotlin.String"")!>x<!>.length
}

/*
 * TESTCASE NUMBER: 6
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-24901
 */",fun case_6(x: String?) {
"// MEMBER_CLASS_FILTER: org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol
package second",@Target(AnnotationTarget.TYPE)
"// Super calls to Throwable properties are not supported
// IGNORE_BACKEND: JS_IR
// IGNORE_BACKEND: JS_IR_ES6

open class Base(message: String? = null, cause: Throwable? = null) : Throwable(message, cause)

open class Base2(message: String? = null, cause: Throwable? = null): Base(message, cause)","open class Override(message: String? = null, cause: Throwable? = null) : Base2(message, cause) {"
"if (isDebugEnabled) messageCollector else MessageCollector.NONE
        val connection =
            metrics.measure(GradleBuildTime.CONNECT_TO_DAEMON) {
                GradleCompilerRunner.getDaemonConnectionImpl(
                    config.projectFiles.clientIsAliveFlagFile,
                    config.projectFiles.sessionFlagFile,
                    config.compilerFullClasspath,
                    daemonMessageCollector,
                    isDebugEnabled = isDebugEnabled,
                    daemonJvmArgs = config.compilerExecutionSettings.daemonJvmArgs
                )
            } ?: throw RuntimeException(COULD_NOT_CONNECT_TO_DAEMON_MESSAGE) // TODO: Add root cause

        val (daemon, sessionId) = connection

        if (log.isDebugEnabled) {
            daemon.getDaemonJVMOptions().takeIf { it.isGood }?.let { jvmOpts ->
                log.debug(""Kotlin compile daemon JVM options: ${jvmOpts.get().mappers.flatMap { it.toArgs(""-"") }}"")
            }
        }

        val memoryUsageBeforeBuild = daemon.getUsedMemory(withGC = false).takeIf { it.isGood }?.get()

        val targetPlatform = when (config.compilerClassName) {
            KotlinCompilerClass.JVM -> CompileService.TargetPlatform.JVM
            KotlinCompilerClass.JS -> CompileService.TargetPlatform.JS
            KotlinCompilerClass.METADATA -> CompileService.TargetPlatform.METADATA
            else -> throw IllegalArgumentException(""Unknown compiler type ${config.compilerClassName}"")
        }
        val bufferingMessageCollector = GradleBufferingMessageCollector()
        val exitCode = try {
            val res = if (isIncremental) {
                incrementalCompilationWithDaemon(daemon, sessionId, targetPlatform, bufferingMessageCollector)
            } else {
                nonIncrementalCompilationWithDaemon(daemon, sessionId, targetPlatform, bufferingMessageCollector)
            }
            bufferingMessageCollector.flush(messageCollector)
            exitCodeFromProcessExitCode(log, res.get())
        } catch (e: Throwable) {
            bufferingMessageCollector.flush(messageCollector)
            wrapAndRethrowCompilationException(KotlinCompilerExecutionStrategy.DAEMON, e)
        } finally {
            val memoryUsageAfterBuild = runCatching { daemon.getUsedMemory(withGC = false).takeIf { it.isGood }?.get() }.getOrNull()

            if (memoryUsageAfterBuild == null || memoryUsageBeforeBuild == null) {
                log.debug(""Unable to calculate memory usage"")
            } else {
                metrics.addMetric(GradleBuildPerformanceMetric.DAEMON_INCREASED_MEMORY, memoryUsageAfterBuild - memoryUsageBeforeBuild)
                metrics.addMetric(GradleBuildPerformanceMetric.DAEMON_MEMORY_USAGE, memoryUsageAfterBuild)
            }


            // todo: can we clear cache on the end of session?
            // often source of the NoSuchObjectException and UnmarshalException, probably caused by the failed/crashed/exited daemon
            // TODO: implement a proper logic to avoid remote calls in such cases
            try {
                metrics.measure(GradleBuildTime.CLEAR_JAR_CACHE) {
                    // releasing compile session implies clearing the jar cache
                    daemon.releaseCompileSession(sessionId)
                }
            } catch (e: RemoteException) {
                log.warn(""Unable to release compile session, maybe daemon is already down: $e"")
            }
        }
        log.logFinish(KotlinCompilerExecutionStrategy.DAEMON)",return exitCode
"private fun copyDefaultArgumentsFromExpectToActual(declaration: IrDeclaration) {
        declaration.acceptVoid(object : IrElementVisitorVoid {
            override fun visitElement(element: IrElement) {
                element.acceptChildrenVoid(this)
            }

            override fun visitValueParameter(declaration: IrValueParameter) {
                super.visitValueParameter(declaration)

                val defaultValue = declaration.defaultValue ?: return
                val function = declaration.parent as IrFunction

                val index = declaration.index
                assert(function.valueParameters[index] == declaration)

                if (function is IrConstructor && OptionalAnnotationUtil.isOptionalAnnotationClass(function.descriptor.constructedClass)) {
                    return
                }

                val actualForExpected = function.findActualForExpected()
                actualForExpected.valueParameters[index].defaultValue =
                        irModule.irBuiltins.irFactory.createExpressionBody(
                                defaultValue.startOffset, defaultValue.endOffset,
                                defaultValue.expression.remapExpectValueSymbols().patchDeclarationParents(actualForExpected)
                        )
            }
        })
    }

    private inline fun <reified T : IrFunction> T.findActualForExpected(): T =
            moduleIndex.functions[descriptor.findActualForExpect()] as T

    private fun IrProperty.findActualForExpected(): IrProperty =
            moduleIndex.properties[descriptor.findActualForExpect()]!!

    private fun IrClass.findActualForExpected(): IrClass =
            moduleIndex.classes[descriptor.findActualForExpect()]!!

    private fun IrEnumEntry.findActualForExpected(): IrEnumEntry =
            moduleIndex.enumEntries[descriptor.findActualForExpect()]!!

    private inline fun <reified T : MemberDescriptor> T.findActualForExpect(): T {
        if (!this.isExpect) error(this)
        return (findCompatibleActualsForExpected(module).singleOrNull() ?: error(this)) as T
    }

    private fun IrExpression.remapExpectValueSymbols(): IrExpression {
        class SymbolRemapper : DeepCopySymbolRemapper() {
            override fun getReferencedClass(symbol: IrClassSymbol) =
                    if (symbol.descriptor.isExpect)
                        symbol.owner.findActualForExpected().symbol
                    else super.getReferencedClass(symbol)

            override fun getReferencedClassifier(symbol: IrClassifierSymbol): IrClassifierSymbol = when (symbol) {
                is IrClassSymbol -> getReferencedClass(symbol)
                is IrTypeParameterSymbol -> remapExpectTypeParameter(symbol).symbol
                is IrScriptSymbol -> symbol.unexpectedSymbolKind<IrClassifierSymbol>()
            }

            override fun getReferencedConstructor(symbol: IrConstructorSymbol) =
                    if (symbol.descriptor.isExpect)
                        symbol.owner.findActualForExpected().symbol
                    else super.getReferencedConstructor(symbol)",override fun getReferencedFunction(symbol: IrFunctionSymbol): IrFunctionSymbol = when (symbol) {
"fun testEarlyReturnFromCrossInlinedLambda() = verifyGoldenComposeIrTransform(
        source = """"""
            import androidx.compose.runtime.*

            @Composable
            private fun Test(param: String?) {
                Dialog {
                    if (false) Test(param)
                }
            }
        """""",
        extra = """"""
            import androidx.compose.runtime.*

            @Composable
            internal inline fun Dialog(crossinline block: @Composable () -> Unit) {}
        """""".trimIndent(),
    )

    @Test
    fun testEarlyReturnFromWhenStatement() = verifyGoldenComposeIrTransform(
        source = """"""
            import androidx.compose.runtime.*

            @Composable
            private fun Test(param: String?) {
                val state = remember { mutableStateOf(false) }
                when (state.value) {
                    true -> return Text(text = ""true"")
                    else -> Text(text = ""false"")
                }
            }
        """""",
        extra = """"""
            import androidx.compose.runtime.*

            @Composable fun Text(text: String) {}
        """"""
    )

    @Test
    fun testComposableInAnonymousObjectDelegate() = verifyGoldenComposeIrTransform(
        """"""
            import androidx.compose.runtime.Composable

                interface A

                interface B {
                    val property: A @Composable get() = TODO()
                }

                @Composable fun Test(b: B) {
                    val a = object : A by b.property {}
                    println(a)
                }
        """"""
    )

    @Test
    fun testReturnNull() = verifyGoldenComposeIrTransform(
        source = """"""
            import androidx.compose.runtime.*

            @Composable
            fun Test(): String? {",return null
"private fun IrAnnotationContainer.hasNoLiveLiteralsAnnotation(): Boolean = annotations.any {
        it.symbol.owner == NoLiveLiteralsAnnotation.owner.primaryConstructor
    }

    private fun <T> enter(key: String, block: () -> T) = keyVisitor.enter(key, block)
    private fun <T> siblings(key: String, block: () -> T) = keyVisitor.siblings(key, block)
    private fun <T> siblings(block: () -> T) = keyVisitor.siblings(block)
    private var liveLiteralsClass: IrClass? = null
    private var liveLiteralsEnabledSymbol: IrSimpleFunctionSymbol? = null
    private var currentFile: IrFile? = null

    private fun irGetLiveLiteralsClass(startOffset: Int, endOffset: Int): IrExpression {
        return IrGetObjectValueImpl(
            startOffset = startOffset,
            endOffset = endOffset,
            type = liveLiteralsClass!!.defaultType,
            symbol = liveLiteralsClass!!.symbol
        )
    }

    private fun Name.asJvmFriendlyString(): String {
        return if (!isSpecial) identifier
        else asString().replace('<', '$').replace('>', '$').replace(' ', '-')
    }

    private fun irLiveLiteralInfoAnnotation(
        key: String,
        offset: Int
    ): IrConstructorCall = IrConstructorCallImpl(
        UNDEFINED_OFFSET,
        UNDEFINED_OFFSET,
        liveLiteralInfoAnnotation.defaultType,
        liveLiteralInfoAnnotation.constructors.single(),
        0,
        0,
        2
    ).apply {
        putValueArgument(0, irConst(key))
        putValueArgument(1, irConst(offset))
    }

    private fun irLiveLiteralFileInfoAnnotation(
        file: String
    ): IrConstructorCall = IrConstructorCallImpl(
        UNDEFINED_OFFSET,
        UNDEFINED_OFFSET,
        liveLiteralFileInfoAnnotation.defaultType,
        liveLiteralFileInfoAnnotation.constructors.single(),
        0,
        0,
        1
    ).apply {
        putValueArgument(0, irConst(file))
    }

    @OptIn(IrImplementationDetail::class)
    private fun irLiveLiteralGetter(
        key: String,
        literalValue: IrExpression,
        literalType: IrType,
        startOffset: Int
    ): IrSimpleFunction {
        val clazz = liveLiteralsClass!!
        val stateType = stateInterface.owner.typeWith(literalType).makeNullable()","val stateGetValue = stateInterface.getPropertyGetter(""value"")!!"
"name: Name,
    internal val scriptInfo: KtScriptInfo
) : ScriptDescriptor, LazyClassDescriptor(
    resolveSession,
    containingDeclaration,
    name,
    scriptInfo,
    /* isExternal = */ false
) {
    init {
        resolveSession.trace.record(BindingContext.SCRIPT, scriptInfo.script, this)
    }

    private val _resultValue: () -> ReplResultPropertyDescriptor? = resolveSession.storageManager.createNullableLazyValue {
        val expression = scriptInfo.script
            .getChildOfType<KtBlockExpression>()
            ?.getChildrenOfType<KtScriptInitializer>()?.lastOrNull()
            ?.getChildOfType<KtExpression>()

        val type = expression?.let {
            resolveSession.trace.bindingContext.getType(it)
        }

        if (type != null && !type.isUnit() && !type.isNothing()) {
            resultFieldName()?.let {
                ReplResultPropertyDescriptor(
                    it,
                    type,
                    this.thisAsReceiverParameter,
                    this,
                    expression.toSourceElement()
                )
            }
        } else null
    }

    override fun getResultValue(): ReplResultPropertyDescriptor? = _resultValue()

    fun resultFieldName(): Name? {
        // TODO: implement robust REPL/script selection
        val replSnippetId =
            scriptInfo.script.getUserData(ScriptPriorities.PRIORITY_KEY)?.toString()
        val identifier = if (replSnippetId != null) {
            // assuming repl
            scriptCompilationConfiguration()[ScriptCompilationConfiguration.repl.resultFieldPrefix]?.takeIf { it.isNotBlank() }?.let {
                ""$it$replSnippetId""
            }
        } else {
            scriptCompilationConfiguration()[ScriptCompilationConfiguration.resultField]?.takeIf { it.isNotBlank() }
        }
        return identifier?.let { Name.identifier(it) }
    }

    private val sourceElement = scriptInfo.script.toSourceElement()

    override fun getSource() = sourceElement

    private val priority: Int = ScriptPriorities.getScriptPriority(scriptInfo.script)
    private val isReplScript: Boolean = ScriptPriorities.isReplScript(scriptInfo.script)

    override fun getPriority() = priority

    val scriptCompilationConfiguration: () -> ScriptCompilationConfiguration = resolveSession.storageManager.createLazyValue {
        run {
            val containingFile = scriptInfo.script.containingKtFile",val provider = ScriptDependenciesProvider.getInstance(containingFile.project)
"}

        if (!isLocalDelegatedProperty) {
            generateAccessors()
        }
    }

    private fun generateConstructor() {
        generateMethod(""property reference init"", 0, constructor) {
            val shouldHaveBoundReferenceReceiver = closure.isForBoundCallableReference()
            val receiverIndexAndFieldInfo = generateClosureFieldsInitializationFromParameters(closure, constructorArgs)

            load(0, OBJECT_TYPE)
            val superCtorArgTypes = mutableListOf<Type>()
            if (receiverIndexAndFieldInfo != null) {
                val (receiverIndex, receiverFieldInfo) = receiverIndexAndFieldInfo
                loadBoundReferenceReceiverParameter(receiverIndex, receiverFieldInfo.fieldType, receiverFieldInfo.fieldKotlinType)
                superCtorArgTypes.add(OBJECT_TYPE)
            } else {
                assert(!shouldHaveBoundReferenceReceiver) { ""No bound reference receiver in constructor parameters: $constructorArgs"" }
            }

            if (isOptimizedPropertyReferenceSupertype(superAsmType)) {
                generateCallableReferenceDeclarationContainerClass(this, target, state)
                aconst(target.name.asString())
                generatePropertyReferenceSignature(this, target, state)
                aconst(getCallableReferenceTopLevelFlag(target))
                superCtorArgTypes.add(JAVA_CLASS_TYPE)
                superCtorArgTypes.add(JAVA_STRING_TYPE)
                superCtorArgTypes.add(JAVA_STRING_TYPE)
                superCtorArgTypes.add(Type.INT_TYPE)
            }

            invokespecial(
                superAsmType.internalName, ""<init>"",
                Type.getMethodDescriptor(Type.VOID_TYPE, *superCtorArgTypes.toTypedArray()), false
            )
        }
    }

    private fun generateAccessors() {
        val getFunction = findGetFunction(localVariableDescriptorForReference)
        val getImpl = createFakeOpenDescriptor(getFunction, classDescriptor)
        functionCodegen.generateMethod(
            JvmDeclarationOrigin.NO_ORIGIN,
            getImpl,
            PropertyReferenceGenerationStrategy(
                true,
                getFunction,
                target,
                asmType,
                boundReceiverJvmKotlinType,
                element,
                state,
                false
            )
        )

        if (!ReflectionTypes.isNumberedKMutablePropertyType(localVariableDescriptorForReference.type)) return
        val setFunction = localVariableDescriptorForReference.type.memberScope.getContributedFunctions(
            OperatorNameConventions.SET,
            NoLookupLocation.FROM_BACKEND
        ).single()
        val setImpl = createFakeOpenDescriptor(setFunction, classDescriptor)
        functionCodegen.generateMethod(","JvmDeclarationOrigin.NO_ORIGIN,"
"/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.native.interop.gen

import org.jetbrains.kotlin.konan.library.KonanLibrary
import org.jetbrains.kotlin.native.interop.indexer.*

interface Imports {
    fun getPackage(location: Location): String?

    fun isImported(headerId: HeaderId): Boolean
}


class PackageInfo(val name: String, val library: KonanLibrary)

class ImportsImpl(internal val headerIdToPackage: Map<HeaderId, PackageInfo>) : Imports {

    override fun getPackage(location: Location): String? {
        val packageInfo = headerIdToPackage[location.headerId]
                ?: return null
        accessedLibraries += packageInfo.library
        return packageInfo.name
    }

    override fun isImported(headerId: HeaderId) =
            headerId in headerIdToPackage

    private val accessedLibraries = mutableSetOf<KonanLibrary>()

    val requiredLibraries: Set<KonanLibrary>
        get() = accessedLibraries.toSet()
}

class HeaderInclusionPolicyImpl(
        private val nameGlobs: List<String>,
        private val excludeGlobs: List<String>,",) : HeaderInclusionPolicy {
"}

    protected abstract fun buildParametersForList(): List<PsiParameter>

    private val typeParamsList: PsiTypeParameterList? by lazyPub { buildTypeParameterList() }

    protected abstract fun buildTypeParameterList(): PsiTypeParameterList?

    override fun accept(visitor: PsiElementVisitor) {
        if (visitor is JavaElementVisitor) {
            visitor.visitMethod(this)
        } else {
            visitor.visitElement(this)
        }
    }

    override val isMangled: Boolean get() = checkIsMangled()

    override fun setName(name: String): PsiElement? {
        val jvmNameAnnotation = modifierList.findAnnotation(JvmFileClassUtil.JVM_NAME.asString())?.unwrapped as? KtAnnotationEntry
        val demangledName = (if (isMangled) demangleInternalName(name) else null) ?: name
        val newNameForOrigin = propertyNameByAccessor(demangledName, this) ?: demangledName
        if (newNameForOrigin == kotlinOrigin?.name) {
            jvmNameAnnotation?.delete()
            return this
        }

        val nameExpression = jvmNameAnnotation?.let { JvmFileClassUtil.getLiteralStringEntryFromAnnotation(it) }
        if (nameExpression != null) {
            nameExpression.replace(KtPsiFactory(project).createLiteralStringTemplateEntry(name))
        } else {
            val toRename = kotlinOrigin as? PsiNamedElement ?: cannotModify()
            toRename.setName(newNameForOrigin)
        }

        return this
    }

    override fun delete() {
        kotlinOrigin?.let {
            if (it.isValid) {
                it.delete()
            }
        } ?: cannotModify()
    }

    abstract override fun getModifierList(): PsiModifierList

    override fun getParameterList() = paramsList

    override fun getTypeParameterList() = typeParamsList

    override fun getTypeParameters(): Array<PsiTypeParameter> =
        typeParameterList?.typeParameters ?: PsiTypeParameter.EMPTY_ARRAY

    override fun hasTypeParameters() = typeParameters.isNotEmpty()

    abstract override fun getSignature(substitutor: PsiSubstitutor): MethodSignature

    override fun processDeclarations(
        processor: PsiScopeProcessor,
        state: ResolveState,
        lastParent: PsiElement?,
        place: PsiElement
    ): Boolean {","return typeParameters.all { processor.execute(it, state) }"
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.checkers.type

import org.jetbrains.kotlin.config.LanguageFeature
import org.jetbrains.kotlin.descriptors.annotations.AnnotationUseSiteTarget
import org.jetbrains.kotlin.descriptors.annotations.KotlinTarget
import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.getAllowedAnnotationTargets
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors
import org.jetbrains.kotlin.fir.declarations.toAnnotationClassId
import org.jetbrains.kotlin.fir.types.FirResolvedTypeRef
import org.jetbrains.kotlin.fir.types.FirTypeRef
import org.jetbrains.kotlin.fir.types.isSomeFunctionType
import org.jetbrains.kotlin.name.StandardClassIds

object FirTypeAnnotationChecker : FirTypeRefChecker(MppCheckerKind.Common) {
    override fun check(typeRef: FirTypeRef, context: CheckerContext, reporter: DiagnosticReporter) {
        if (typeRef !is FirResolvedTypeRef) return

        for (annotation in typeRef.annotations) {
            if (annotation.source == null) continue
            val useSiteTarget = annotation.useSiteTarget
            val annotationTargets = annotation.getAllowedAnnotationTargets(context.session)

            // Annotations like `@receiver:` go
            // into FirReceiverParameter, not FirTypeRef
            if (useSiteTarget != null) {
                reporter.reportOn(
                    annotation.source, FirErrors.WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET,
                    ""type usage"", useSiteTarget.renderName, context
                )
            } else if (KotlinTarget.TYPE !in annotationTargets) {
                reporter.reportOn(annotation.source, FirErrors.WRONG_ANNOTATION_TARGET, ""type usage"", context)
            }
            if (annotation.toAnnotationClassId(context.session) == StandardClassIds.Annotations.ExtensionFunctionType) {
                if (!typeRef.type.isSomeFunctionType(context.session)) {
                    if (context.languageVersionSettings.supportsFeature(LanguageFeature.ForbidExtensionFunctionTypeOnNonFunctionTypes)) {
                        reporter.reportOn(annotation.source, FirErrors.WRONG_EXTENSION_FUNCTION_TYPE, context)
                    } else {
                        reporter.reportOn(annotation.source, FirErrors.WRONG_EXTENSION_FUNCTION_TYPE_WARNING, context)
                    }

                } else if (typeRef.type.typeArguments.size <= 1) {","reporter.reportOn(annotation.source, FirErrors.WRONG_EXTENSION_FUNCTION_TYPE, context)"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.resolve.transformers.plugin

import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.containingClassLookupTag
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.expressions.FirAnnotationCall
import org.jetbrains.kotlin.fir.expressions.FirErrorAnnotationCall
import org.jetbrains.kotlin.fir.expressions.FirPropertyAccessExpression
import org.jetbrains.kotlin.fir.expressions.FirQualifiedAccessExpression
import org.jetbrains.kotlin.fir.expressions.FirResolvedQualifier
import org.jetbrains.kotlin.fir.expressions.FirStatement
import org.jetbrains.kotlin.fir.expressions.builder.buildPropertyAccessExpression
import org.jetbrains.kotlin.fir.references.FirResolvedNamedReference
import org.jetbrains.kotlin.fir.references.builder.buildErrorNamedReference
import org.jetbrains.kotlin.fir.references.builder.buildSimpleNamedReference
import org.jetbrains.kotlin.fir.references.toResolvedBaseSymbol
import org.jetbrains.kotlin.fir.resolve.ResolutionMode
import org.jetbrains.kotlin.fir.resolve.ScopeSession
import org.jetbrains.kotlin.fir.resolve.diagnostics.ConeAmbiguouslyResolvedAnnotationArgument
import org.jetbrains.kotlin.fir.resolve.transformers.ReturnTypeCalculator
import org.jetbrains.kotlin.fir.resolve.transformers.ReturnTypeCalculatorForFullBodyResolve
import org.jetbrains.kotlin.fir.resolve.transformers.body.resolve.*
import org.jetbrains.kotlin.fir.symbols.impl.FirEnumEntrySymbol
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.StandardClassIds
import org.jetbrains.kotlin.util.PrivateForInline

open class FirAnnotationArgumentsTransformer(
    session: FirSession,
    scopeSession: ScopeSession,
    resolvePhase: FirResolvePhase,
    outerBodyResolveContext: BodyResolveContext? = null,
    returnTypeCalculator: ReturnTypeCalculator = ReturnTypeCalculatorForFullBodyResolve.Default,
) : FirAbstractBodyResolveTransformerDispatcher(
    session,
    resolvePhase,
    implicitTypeOnly = false,
    scopeSession,
    outerBodyResolveContext = outerBodyResolveContext,
    returnTypeCalculator = returnTypeCalculator,
) {
    final override val expressionsTransformer: FirExpressionsResolveTransformer = FirExpressionTransformerForAnnotationArguments(this)

    private val declarationsResolveTransformerForAnnotationArguments = FirDeclarationsResolveTransformerForAnnotationArguments(this)

    private val usualDeclarationTransformer = FirDeclarationsResolveTransformer(this)

    @PrivateForInline",var isInsideAnnotationArgument: Boolean = false
"): Boolean {
    if (arguments.useJavac) {
        configuration.put(JVMConfigurationKeys.USE_JAVAC, true)
        if (arguments.compileJava) {
            configuration.put(JVMConfigurationKeys.COMPILE_JAVA, true)
        }
        return registerJavac(arguments = arguments.javacArguments)
    }

    return true
}

fun CompilerConfiguration.configureAdvancedJvmOptions(arguments: K2JVMCompilerArguments) {

    put(JVMConfigurationKeys.PARAMETERS_METADATA, arguments.javaParameters)

    val useOldBackend = arguments.useOldBackend
    val useIR = arguments.useK2 || languageVersionSettings.languageVersion.usesK2 || !useOldBackend

    messageCollector.report(LOGGING, ""Using ${if (useIR) ""JVM IR"" else ""old JVM""} backend"")

    put(JVMConfigurationKeys.IR, useIR)

    val abiStability = JvmAbiStability.fromStringOrNull(arguments.abiStability)
    if (arguments.abiStability != null) {
        if (abiStability == null) {
            messageCollector.report(
                ERROR,
                ""Unknown ABI stability mode: ${arguments.abiStability}, supported modes: ${JvmAbiStability.entries.map { it.description }}""
            )
        } else if (!useIR && abiStability == JvmAbiStability.UNSTABLE) {
            messageCollector.report(ERROR, ""-Xabi-stability=unstable is not supported in the old JVM backend"")
        } else {
            put(JVMConfigurationKeys.ABI_STABILITY, abiStability)
        }
    }

    put(JVMConfigurationKeys.DO_NOT_CLEAR_BINDING_CONTEXT, arguments.doNotClearBindingContext)
    put(JVMConfigurationKeys.DISABLE_CALL_ASSERTIONS, arguments.noCallAssertions)
    put(JVMConfigurationKeys.DISABLE_RECEIVER_ASSERTIONS, arguments.noReceiverAssertions)
    put(JVMConfigurationKeys.DISABLE_PARAM_ASSERTIONS, arguments.noParamAssertions)
    put(JVMConfigurationKeys.DISABLE_OPTIMIZATION, arguments.noOptimize)
    put(JVMConfigurationKeys.EMIT_JVM_TYPE_ANNOTATIONS, arguments.emitJvmTypeAnnotations)
    put(JVMConfigurationKeys.NO_OPTIMIZED_CALLABLE_REFERENCES, arguments.noOptimizedCallableReferences)
    put(JVMConfigurationKeys.NO_KOTLIN_NOTHING_VALUE_EXCEPTION, arguments.noKotlinNothingValueException)
    put(JVMConfigurationKeys.NO_RESET_JAR_TIMESTAMPS, arguments.noResetJarTimestamps)
    put(JVMConfigurationKeys.NO_UNIFIED_NULL_CHECKS, arguments.noUnifiedNullChecks)
    put(JVMConfigurationKeys.NO_SOURCE_DEBUG_EXTENSION, arguments.noSourceDebugExtension)

    put(JVMConfigurationKeys.SERIALIZE_IR, JvmSerializeIrMode.fromString(arguments.serializeIr))

    put(JVMConfigurationKeys.VALIDATE_IR, arguments.validateIr)
    put(JVMConfigurationKeys.VALIDATE_BYTECODE, arguments.validateBytecode)

    put(JVMConfigurationKeys.LINK_VIA_SIGNATURES, arguments.linkViaSignatures)

    put(JVMConfigurationKeys.ENABLE_DEBUG_MODE, arguments.enableDebugMode)
    put(JVMConfigurationKeys.NO_NEW_JAVA_ANNOTATION_TARGETS, arguments.noNewJavaAnnotationTargets)
    put(JVMConfigurationKeys.OLD_INNER_CLASSES_LOGIC, arguments.oldInnerClassesLogic)
    put(JVMConfigurationKeys.ENABLE_IR_INLINER, arguments.enableIrInliner)
    put(JVMConfigurationKeys.USE_INLINE_SCOPES_NUMBERS, arguments.useInlineScopesNumbers)

    val assertionsMode =
        JVMAssertionsMode.fromStringOrNull(arguments.assertionsMode)
    if (assertionsMode == null) {",messageCollector.report(
"// FIR_IDENTICAL
interface X {
    fun foo(a : Int = 1)
}

interface Y {
    fun foo(a : Int)
}

class Z : X, Y {",override fun foo(a : Int) {}
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin.mpp.external

import org.gradle.api.artifacts.ModuleVersionIdentifier
import org.gradle.api.artifacts.PublishArtifact
import org.gradle.api.component.ComponentWithCoordinates
import org.gradle.api.publish.maven.MavenPublication
import org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension
import org.jetbrains.kotlin.gradle.plugin.KotlinCompilation
import org.jetbrains.kotlin.gradle.plugin.mpp.*
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinUsageContext.MavenScope.COMPILE
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinUsageContext.MavenScope.RUNTIME
import org.jetbrains.kotlin.gradle.plugin.mpp.external.ExternalKotlinTargetComponent.TargetProvider
import org.jetbrains.kotlin.gradle.utils.dashSeparatedName
import org.jetbrains.kotlin.util.capitalizeDecapitalize.toLowerCaseAsciiOnly

internal class ExternalKotlinTargetComponent(","val targetProvider: TargetProvider,"
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.interpreter.state

import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.interpreter.IrInterpreterEnvironment
import org.jetbrains.kotlin.ir.interpreter.getOriginalPropertyByName
import org.jetbrains.kotlin.ir.interpreter.stack.Field
import org.jetbrains.kotlin.ir.interpreter.stack.Fields
import org.jetbrains.kotlin.ir.interpreter.stack.Variable
import org.jetbrains.kotlin.ir.symbols.IrSymbol
import org.jetbrains.kotlin.ir.util.isSubclassOf",import kotlin.math.min
"/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.testFramework

import java.lang.instrument.Instrumentation

@Suppress(""unused"")",object TestInstrumentationAgent {
"override fun findPrimaryConstructor(clazz: IrClassSymbol) = clazz.descriptor.unsubstitutedPrimaryConstructor?.let { symbolTable.descriptorExtension.referenceConstructor(it) }
    override fun findNoParametersConstructor(clazz: IrClassSymbol) = clazz.descriptor.constructors.singleOrNull { it.valueParameters.size == 0 }?.let { symbolTable.descriptorExtension.referenceConstructor(it) }

    override fun findNestedClass(clazz: IrClassSymbol, name: Name): IrClassSymbol? {
        val classDescriptor = clazz.descriptor.defaultType.memberScope.getContributedClassifier(name, NoLookupLocation.FROM_BUILTINS) as? ClassDescriptor
        return classDescriptor?.let {
            symbolTable.descriptorExtension.referenceClass(it)
        }
    }

    override fun getValueParameterPrimitiveBinaryType(function: IrFunctionSymbol, index: Int): PrimitiveBinaryType? {
        return function.descriptor.valueParameters[0].type.computePrimitiveBinaryTypeOrNull()
    }
}

internal class SymbolOverIrLookupUtils() : SymbolLookupUtils {
    override fun findMemberFunction(clazz: IrClassSymbol, name: Name): IrSimpleFunctionSymbol? =
            clazz.owner.findDeclaration<IrSimpleFunction> { it.name == name }?.symbol

    override fun findMemberProperty(clazz: IrClassSymbol, name: Name): IrPropertySymbol? =
            clazz.owner.findDeclaration<IrProperty> { it.name == name }?.symbol

    override fun findMemberPropertyGetter(clazz: IrClassSymbol, name: Name): IrSimpleFunctionSymbol? =
            clazz.owner.findDeclaration<IrProperty> { it.name == name }?.getter?.symbol

    override fun findPrimaryConstructor(clazz: IrClassSymbol): IrConstructorSymbol? = clazz.owner.primaryConstructor?.symbol
    override fun findNoParametersConstructor(clazz: IrClassSymbol): IrConstructorSymbol? = clazz.owner.constructors.singleOrNull { it.valueParameters.isEmpty() }?.symbol

    override fun findNestedClass(clazz: IrClassSymbol, name: Name): IrClassSymbol? {
        return clazz.owner.declarations.filterIsInstance<IrClass>().singleOrNull { it.name == name }?.symbol
    }

    override fun getName(clazz: IrClassSymbol): Name = clazz.owner.name

    override fun isExtensionReceiverClass(property: IrPropertySymbol, expected: IrClassSymbol?): Boolean {
        return property.owner.getter?.extensionReceiverParameter?.type?.classOrNull == expected
    }

    override fun isExtensionReceiverClass(function: IrFunctionSymbol, expected: IrClassSymbol?): Boolean {
        return function.owner.extensionReceiverParameter?.type?.classOrNull == expected
    }

    override fun findGetter(property: IrPropertySymbol): IrSimpleFunctionSymbol? = property.owner.getter?.symbol

    override fun isExtensionReceiverNullable(function: IrFunctionSymbol): Boolean? {
        return function.owner.extensionReceiverParameter?.type?.isMarkedNullable()
    }

    override fun getValueParametersCount(function: IrFunctionSymbol): Int = function.owner.valueParameters.size

    override fun getTypeParametersCount(function: IrFunctionSymbol): Int = function.owner.typeParameters.size

    override fun isTypeParameterUpperBoundClass(property: IrPropertySymbol, index: Int, expected: IrClassSymbol): Boolean {
        return property.owner.getter?.typeParameters?.getOrNull(index)?.superTypes?.any { it.classOrNull == expected } ?: false
    }

    override fun isValueParameterClass(function: IrFunctionSymbol, index: Int, expected: IrClassSymbol?): Boolean {
        return function.owner.valueParameters.getOrNull(index)?.type?.classOrNull == expected
    }

    override fun isReturnClass(function: IrFunctionSymbol, expected: IrClassSymbol): Boolean {
        return function.owner.returnType.classOrNull == expected
    }","override fun isValueParameterTypeArgumentClass(function: IrFunctionSymbol, index: Int, argumentIndex: Int, expected: IrClassSymbol?): Boolean {"
"// IGNORE_BACKEND: JS_IR
// IGNORE_BACKEND: JS_IR_ES6
// TODO: muted automatically, investigate should it be ran for JS or not
// IGNORE_BACKEND: JS

// WITH_STDLIB
// This is a big, ugly, semi-auto generated test.
// Use corresponding 'Small' test for debug.

import kotlin.test.*

fun fn0() {}
fun fn1(x0: Any) {}
fun fn2(x0: Any, x1: Any) {}
fun fn3(x0: Any, x1: Any, x2: Any) {}
fun fn4(x0: Any, x1: Any, x2: Any, x3: Any) {}
fun fn5(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any) {}
fun fn6(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any, x5: Any) {}
fun fn7(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any, x5: Any, x6: Any) {}
fun fn8(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any, x5: Any, x6: Any, x7: Any) {}
fun fn9(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any, x5: Any, x6: Any, x7: Any, x8: Any) {}
fun fn10(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any, x5: Any, x6: Any, x7: Any, x8: Any, x9: Any) {}","fun fn11(x0: Any, x1: Any, x2: Any, x3: Any, x4: Any, x5: Any, x6: Any, x7: Any, x8: Any, x9: Any, x10: Any) {}"
"// !DIAGNOSTICS: -UNUSED_PARAMETER

fun <K> id(x: K) = x

class A1 {
    fun <T> a1(t: T): Unit {}
    fun test1(): (String) -> Unit = A1()::a1
    fun test2(): (String) -> Unit = id(A1()::a1)
}

class A2 {
    fun <K, V> a2(key: K): V = TODO()

    fun test1(): (String) -> Unit = A2()::a2
    fun <T3> test2(): (T3) -> T3 = A2()::a2
}

class A3<T> {
    fun <V> a3(key: T): V = TODO()

    fun test1(): (T) -> Int = this::a3",fun test2(): (T) -> Unit = A3<T>()::a3
"is Float -> buildLiteralExpression(
            null, ConstantValueKind.Float, this, setType = true
        )
        is Double -> buildLiteralExpression(
            null, ConstantValueKind.Double, this, setType = true
        )
        is Boolean -> buildLiteralExpression(
            null, ConstantValueKind.Boolean, this, setType = true
        )
        is String -> buildLiteralExpression(
            null, ConstantValueKind.String, this, setType = true
        )
        is ByteArray -> toList().createArrayLiteral(session, ConstantValueKind.Byte)
        is ShortArray -> toList().createArrayLiteral(session, ConstantValueKind.Short)
        is IntArray -> toList().createArrayLiteral(session, ConstantValueKind.Int)
        is LongArray -> toList().createArrayLiteral(session, ConstantValueKind.Long)
        is CharArray -> toList().createArrayLiteral(session, ConstantValueKind.Char)
        is FloatArray -> toList().createArrayLiteral(session, ConstantValueKind.Float)
        is DoubleArray -> toList().createArrayLiteral(session, ConstantValueKind.Double)
        is BooleanArray -> toList().createArrayLiteral(session, ConstantValueKind.Boolean)
        null -> buildLiteralExpression(
            null, ConstantValueKind.Null, null, setType = true
        )

        else -> null
    }
}

private fun <T> List<T>.createArrayLiteral(session: FirSession, kind: ConstantValueKind): FirArrayLiteral {
    return buildArrayLiteral {
        argumentList = buildArgumentList {
            for (element in this@createArrayLiteral) {
                arguments += element.createConstantOrError(session)
            }
        }
        coneTypeOrNull = kind.expectedConeType(session).createArrayType()
    }
}

// For now, it's supported only for RxJava3 annotations, see KT-53041
fun extractNullabilityAnnotationOnBoundedWildcard(wildcardType: JavaWildcardType): JavaAnnotation? {
    require(wildcardType.bound != null) { ""Nullability annotations on unbounded wildcards aren't supported"" }
    return wildcardType.annotations.find { annotation -> RXJAVA3_ANNOTATIONS.any { annotation.classId?.asSingleFqName() == it } }
}

fun FirProperty.hasJvmFieldAnnotation(session: FirSession): Boolean =
    backingField?.annotations?.any { it.isJvmFieldAnnotation(session) } == true

fun FirAnnotation.isJvmFieldAnnotation(session: FirSession): Boolean =
    toAnnotationClassId(session) == JvmStandardClassIds.Annotations.JvmField

// The implementation is different from `FirAnnotationContainer.getAnnotationsByClassId` because it doesn't expand typealiases
// The reason is that some usesites do not have access to the session. For the intended use for main function detection it seems fine
// for now, but we may need to reimplement it in the future. See KT-67634
// See also the comment in the body, relevant for the use in the const evaluator.
private fun FirDeclaration.findAnnotationByClassId(classId: ClassId): FirAnnotation? {
    return annotations.firstOrNull {
        // Access to type must be through `coneTypeOrNull`.
        // Even if `JvmName` is in the list of annotations that must be resoled for compilation, we still could try to access some user
        // annotations that could be not resolved.
        it.annotationTypeRef.coneTypeOrNull?.classId == classId
    }
}

fun FirDeclaration.findJvmNameAnnotation(): FirAnnotation? = findAnnotationByClassId(JvmStandardClassIds.Annotations.JvmName)",fun FirDeclaration.findJvmStaticAnnotation(): FirAnnotation? = findAnnotationByClassId(JvmStandardClassIds.Annotations.JvmStatic)
"// SKIP_WHEN_OUT_OF_CONTENT_ROOT
// MEMBER_NAME_FILTER: something
// IS_GETTER: true
// FILE: Derived.kt",class Der<caret>ived : Base() {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.checkers.generator.diagnostics

import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.fir.checkers.generator.diagnostics.model.DiagnosticList
import org.jetbrains.kotlin.fir.checkers.generator.diagnostics.model.PositioningStrategy
import org.jetbrains.kotlin.fir.types.ConeKotlinType
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.util.PrivateForInline

@Suppress(""ClassName"", ""unused"")
@OptIn(PrivateForInline::class)
object WASM_DIAGNOSTICS_LIST : DiagnosticList(""FirWasmErrors"") {
    val ANNOTATIONS by object : DiagnosticGroup(""Annotations"") {
        val JS_MODULE_PROHIBITED_ON_VAR by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT)
        val JS_MODULE_PROHIBITED_ON_NON_EXTERNAL by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT)
        val NESTED_JS_MODULE_PROHIBITED by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT)
    }

    val EXTERNALS by object : DiagnosticGroup(""Externals"") {
        val NON_EXTERNAL_TYPE_EXTENDS_EXTERNAL_TYPE by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT) {
            parameter<ConeKotlinType>(""superType"")
        }",val EXTERNAL_TYPE_EXTENDS_NON_EXTERNAL_TYPE by error<KtElement>(PositioningStrategy.DECLARATION_SIGNATURE_OR_DEFAULT) {
"}

                if (!compileModulesUsingFrontendIrAndLightTree(
                        projectEnvironment, configuration, messageCollector, buildFile, chunk.single(), targetDescription,
                        checkSourceFiles = !arguments.allowNoSourceFiles,
                        isPrintingVersion = arguments.version,
                    )
                ) return COMPILATION_ERROR
            } else {
                val environment = createCoreEnvironment(
                    rootDisposable, configuration, messageCollector,
                    targetDescription
                ) ?: return COMPILATION_ERROR
                environment.registerJavacIfNeeded(arguments).let {
                    if (!it) return COMPILATION_ERROR
                }

                if (environment.getSourceFiles().isEmpty() && !arguments.allowNoSourceFiles && buildFile == null) {
                    if (arguments.version) return OK

                    messageCollector.report(ERROR, ""No source files"")
                    return COMPILATION_ERROR
                }

                if (!KotlinToJVMBytecodeCompiler.compileModules(environment, buildFile, chunk)) return COMPILATION_ERROR
            }
            return OK
        } catch (e: CompilationException) {
            messageCollector.report(
                EXCEPTION,
                OutputMessageUtil.renderException(e),
                MessageUtil.psiElementToMessageLocation(e.element)
            )
            return INTERNAL_ERROR
        }
    }

    override fun MutableList<String>.addPlatformOptions(arguments: K2JVMCompilerArguments) {
        if (arguments.scriptTemplates?.isNotEmpty() == true) {
            add(""plugin:kotlin.scripting:script-templates=${arguments.scriptTemplates!!.joinToString("","")}"")
        }
        if (arguments.scriptResolverEnvironment?.isNotEmpty() == true) {
            add(
                ""plugin:kotlin.scripting:script-resolver-environment=${arguments.scriptResolverEnvironment!!.joinToString(
                    "",""
                )}""
            )
        }
    }

    private fun createCoreEnvironment(
        rootDisposable: Disposable,
        configuration: CompilerConfiguration,
        messageCollector: MessageCollector,
        targetDescription: String
    ): KotlinCoreEnvironment? {
        if (messageCollector.hasErrors()) return null

        val environment = KotlinCoreEnvironment.createForProduction(rootDisposable, configuration, EnvironmentConfigFiles.JVM_CONFIG_FILES)

        val sourceFiles = environment.getSourceFiles()
        configuration[CLIConfigurationKeys.PERF_MANAGER]?.notifyCompilerInitialized(
            sourceFiles.size, environment.countLinesOfCode(sourceFiles), targetDescription
        )",return if (messageCollector.hasErrors()) null else environment
"}

internal class KtUltraLightParameterForSource(
    name: String,
    override val kotlinOrigin: KtParameter,
    support: KtUltraLightSupport,
    method: KtUltraLightMethod,
    containingDeclaration: KtCallableDeclaration
) : KtAbstractUltraLightParameterForDeclaration(name, kotlinOrigin, support, method, containingDeclaration) {

    override fun tryGetKotlinType(): KotlinType? = kotlinOrigin.getKotlinType()

    override fun isVarArgs(): Boolean = kotlinOrigin.isVarArg && method.parameterList.parameters.last() == this

    override fun setName(@NonNls name: String): PsiElement {
        kotlinOrigin.setName(name)
        return this
    }

    override val givenAnnotations: List<KtLightAbstractAnnotation>?
        get() {
            return if (kotlinOrigin.hasValOrVar()) {
                val entriesWithoutJvmField = kotlinOrigin.annotationEntries.filter { it.shortName?.identifier != ""JvmField"" }
                entriesWithoutJvmField.toLightAnnotations(this, null) +
                        entriesWithoutJvmField.toLightAnnotations(this, AnnotationUseSiteTarget.CONSTRUCTOR_PARAMETER)
            } else {
                kotlinOrigin.annotationEntries.toLightAnnotations(this, null)
            }
        }

    override fun getStartOffsetInParent(): Int = kotlinOrigin.startOffsetInParent
    override fun isWritable(): Boolean = kotlinOrigin.isWritable
    override fun getNavigationElement(): PsiElement = kotlinOrigin.navigationElement
    override fun getContainingFile(): PsiFile = parent.containingFile
    override fun getPresentation(): ItemPresentation? = kotlinOrigin.let { ItemPresentationProviders.getItemPresentation(it) }
    override fun findElementAt(offset: Int): PsiElement? = kotlinOrigin.findElementAt(offset)
}

internal class KtUltraLightParameterForSetterParameter(
    name: String,
    // KtProperty or KtParameter from primary constructor
    private val property: KtDeclaration,
    support: KtUltraLightSupport,
    method: KtUltraLightMethod,
    containingDeclaration: KtCallableDeclaration
) : KtAbstractUltraLightParameterForDeclaration(name, null, support, method, containingDeclaration) {

    override fun tryGetKotlinType(): KotlinType? = property.getKotlinType()

    override val givenAnnotations: List<KtLightAbstractAnnotation>?
        get() = property.annotationEntries.toLightAnnotations(this, AnnotationUseSiteTarget.SETTER_PARAMETER)

    override fun isVarArgs(): Boolean = false

    override fun equals(other: Any?): Boolean = other === this ||
            other is KtUltraLightParameterForSetterParameter &&
            other.name == this.name &&
            other.property == this.property

    override fun hashCode(): Int = name.hashCode()
}

internal class KtUltraLightReceiverParameter(
    containingDeclaration: KtCallableDeclaration,
    support: KtUltraLightSupport,",method: KtUltraLightMethod
"private val fileToDebugInfoMap = mutableMapOf<Int, IrArrayFileReader?>()
    override fun debugInfo(index: Int, fileIndex: Int): ByteArray? {
        val dataReader = fileToDebugInfoMap.getOrPut(fileIndex) {
            val fileDirectory = directories[fileIndex]
            access.realFiles {
                it.irDebugInfo(fileDirectory).let { diFile ->
                    if (diFile.exists) {
                        IrArrayFileReader(diFile)
                    } else null
                }
            }

        }
        return dataReader?.tableItemBytes(index)
    }

    override fun file(index: Int): ByteArray {
        return access.realFiles {
            it.irFile(directories[index]).readBytes()
        }
    }

    override fun fileCount(): Int {
        return directories.size
    }

    override fun types(fileIndex: Int): ByteArray {
        TODO(""Not yet implemented"")
    }

    override fun signatures(fileIndex: Int): ByteArray {
        TODO(""Not yet implemented"")
    }

    override fun strings(fileIndex: Int): ByteArray {
        TODO(""Not yet implemented"")
    }

    override fun declarations(fileIndex: Int): ByteArray {
        TODO(""Not yet implemented"")
    }

    override fun bodies(fileIndex: Int): ByteArray {
        TODO(""Not yet implemented"")
    }
}

class KotlinLibraryImpl(
    val base: BaseKotlinLibraryImpl,
    val metadata: MetadataLibraryImpl,
    val ir: IrLibraryImpl
) : KotlinLibrary,
    BaseKotlinLibrary by base,
    MetadataLibrary by metadata,
    IrLibrary by ir {
    override fun toString(): String = buildString {
        append(""name "")
        append(base.libraryName)
        append("", "")
        append(""file: "")
        append(base.libraryFile.path)
        append("", "")
        append(""version: "")
        append(base.versions)
        if (isInterop) {","append("", interop: true, "")"
"var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }
    return maxValue
}

/**
 * Returns the largest value among all values produced by [selector] function
 * applied to each element in the array or `null` if there are no elements.
 * 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.internal.InlineOnly
public inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {
    if (isEmpty()) return null
    var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }
    return maxValue
}

/**
 * Returns the largest value among all values produced by [selector] function
 * applied to each element in the array or `null` if there are no elements.
 * 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.internal.InlineOnly
public inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {
    if (isEmpty()) return null
    var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }
    return maxValue
}

/**
 * Returns the largest value among all values produced by [selector] function
 * applied to each element in the array or `null` if there are no elements.
 * 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.internal.InlineOnly
public inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {
    if (isEmpty()) return null
    var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }",return maxValue
"// LANGUAGE: +MultiPlatformProjects
// IGNORE_BACKEND_K1: JVM, JVM_IR, JS, JS_IR, JS_IR_ES6, WASM
// DUMP_IR

// MODULE: common
// FILE: common.kt

open class A {
    internal open fun foo1() = ""A::foo1""
    internal open fun foo2() = ""A::foo2""
    internal open fun foo3() = ""A::foo3""
}

expect open class B() : A {
    internal override fun foo1(): String
    internal override fun foo2(): String
}

open class C : B() {
    internal override fun foo1() = ""C::foo1""
}


// MODULE: main()()(common)
// FILE: main.kt

actual open class B actual constructor() : A() {
    internal actual override fun foo1() = ""B::foo1""
    internal actual override fun foo2() = ""B::foo2""
}",fun box() : String {
"// IGNORE_FIR
// DONT_TARGET_EXACT_BACKEND: JS
// EXPECTED_REACHABLE_NODES: 1283
// RUN_PLAIN_BOX_FUNCTION
// INFER_MAIN_MODULE

// MODULE: lib1
// FILE: lib1.kt",@JsExport
"val classLoader = URLClassLoader(classpath.map { it.toURI().toURL() }.toTypedArray(), parentClassLoader)
        this.annotationProcessingClassLoader = classLoader

        val processors = if (options.processors.isNotEmpty()) {
            logger.info(""Annotation processor class names are set, skip AP discovery"")
            options.processors.mapNotNull { tryLoadProcessor(it, classLoader) }
        } else {
            logger.info(""Need to discovery annotation processors in the AP classpath"")
            doLoadProcessors(classpath, classLoader)
        }

        if (processors.isEmpty()) {
            logger.info(""No annotation processors available, aborting"")
        } else {
            logger.info { ""Annotation processors: "" + processors.joinToString { it::class.java.canonicalName } }
        }

        return LoadedProcessors(wrapInIncrementalProcessor(processors, classpath), classLoader)
    }

    private fun wrapInIncrementalProcessor(processors: List<Processor>, classpath: Iterable<File>): List<IncrementalProcessor> {
        if (options.incrementalCache == null) {
            return processors.map { IncrementalProcessor(it, DeclaredProcType.NON_INCREMENTAL, logger) }
        }

        val processorNames = processors.map {it.javaClass.name}.toSet()

        val processorsInfo: Map<String, DeclaredProcType> = getIncrementalProcessorsFromClasspath(processorNames, classpath)

        val nonIncremental = processorNames.filter { !processorsInfo.containsKey(it) }
        return processors.map {
            val procType = processorsInfo[it.javaClass.name]?.let {
                if (nonIncremental.isEmpty()) {
                    it
                } else {
                    DeclaredProcType.INCREMENTAL_BUT_OTHER_APS_ARE_NOT
                }
            } ?: DeclaredProcType.NON_INCREMENTAL
            IncrementalProcessor(it, procType, logger)
        }
    }

    open fun doLoadProcessors(classpath: LinkedHashSet<File>, classLoader: ClassLoader): List<Processor> {
        val processorNames = mutableSetOf<String>()

        fun processSingleInput(input: InputStream) {
            val lines = input.bufferedReader().lineSequence()
            lines.forEach { line ->
                val processedLine = line.substringBefore(""#"").trim()
                if (processedLine.isNotEmpty()) {
                    processorNames.add(processedLine)
                }
            }
        }
        // Do not use ServiceLoader as it uses JarFileFactory cache which is not cleared
        // properly. This may cause issues on Windows.
        // Previously, JarFileFactory caches were manually cleaned, but that caused race conditions,
        // as JarFileFactory was shared between concurrent runs in the same class loader.
        // See https://youtrack.jetbrains.com/issue/KT-34604 for more details. Similar issue
        // is also https://youtrack.jetbrains.com/issue/KT-22513.
        val serviceFile = ""META-INF/services/javax.annotation.processing.Processor""
        for (file in classpath) {
            when {
                file.isDirectory -> {
                    file.resolve(serviceFile).takeIf { it.isFile }?.let {",processSingleInput(it.inputStream())
"object C {
  var myIntProp: Int = 1
  var myByteProp: Byte = 2
  var myLongProp: Long = 3L
  var myShortProp: Short = 4
  var myDoubleProp: Double = 5.6
  var myFloatProp: Float = 7.8f
  var myBooleanProp: Boolean = true
  var myCharProp: Char = '9'

  init {
    myIntProp = 0
    myByteProp = 0
    myLongProp = 0L
    myShortProp = 0
    myDoubleProp = 0.0
    myFloatProp = 0.0f
    myBooleanProp = false
    myCharProp = '\u0000'
  }
}

fun box(): String {
  if (C.myIntProp != 0) return ""fail Int""
  if (C.myByteProp != 0.toByte()) return ""fail Byte""
  if (C.myLongProp != 0L) return ""fail Long""
  if (C.myShortProp != 0.toShort()) return ""fail Short""
  if (C.myDoubleProp != 0.0) return ""fail Double""
  if (C.myFloatProp != 0.0f) return ""fail Float""
  if (C.myBooleanProp != false) return ""fail Boolean""
  if (C.myCharProp != '\u0000') return ""fail Char""","return ""OK"""
"// No termination is going on here. But that's the closest location to other unhandled exception hook tests.
// KIND: REGULAR
// OUTPUT_REGEX: .*an error.*
import kotlin.test.*

import kotlin.native.concurrent.*

@Test",fun testExecuteStart() {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.load.java.structure.impl.source

import com.intellij.openapi.project.Project
import com.intellij.psi.*

abstract class JavaElementSourceFactory {
    abstract fun <PSI : PsiElement> createPsiSource(psi: PSI): JavaElementPsiSource<PSI>
    abstract fun <TYPE : PsiType> createTypeSource(type: TYPE): JavaElementTypeSource<TYPE>
    abstract fun <TYPE : PsiType> createVariableReturnTypeSource(psiVariableSource: JavaElementPsiSource<out PsiVariable>): JavaElementTypeSource<TYPE>
    abstract fun <TYPE : PsiType> createMethodReturnTypeSource(psiMethodSource: JavaElementPsiSource<out PsiMethod>): JavaElementTypeSource<TYPE>

    abstract fun <TYPE : PsiType> createTypeParameterUpperBoundTypeSource(
        psiTypeParameterSource: JavaElementPsiSource<out PsiTypeParameter>,
        boundIndex: Int,
    ): JavaElementTypeSource<TYPE>

    abstract fun createSuperTypeSource(
        psiTypeParameterSource: JavaElementPsiSource<out PsiClass>,
        superTypeIndex: Int,
    ): JavaElementTypeSource<PsiClassType>

    abstract fun <TYPE : PsiType> createExpressionTypeSource(psiExpressionSource: JavaElementPsiSource<out PsiExpression>): JavaElementTypeSource<TYPE>

    /**
     * @see com.intellij.psi.PsiClass.getPermitsListTypes
     */
    abstract fun createPermittedTypeSource(
        psiTypeParameterSource: JavaElementPsiSource<out PsiClass>,
        permittedTypeIndex: Int,
    ): JavaElementTypeSource<PsiClassType>

    companion object {
        @JvmStatic
        fun getInstance(project: Project): JavaElementSourceFactory {
            return project.getService(JavaElementSourceFactory::class.java)
        }
    }
}

class JavaFixedElementSourceFactory : JavaElementSourceFactory() {
    override fun <PSI : PsiElement> createPsiSource(psi: PSI): JavaElementPsiSource<PSI> {
        return JavaElementPsiSourceWithFixedPsi(psi)
    }",override fun <TYPE : PsiType> createTypeSource(type: TYPE): JavaElementTypeSource<TYPE> {
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.renderer

import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.isCatchParameter
import org.jetbrains.kotlin.util.capitalizeDecapitalize.toLowerCaseAsciiOnly

open class FirDeclarationRenderer(
    private val localVariablePrefix: String = ""l"",
) {

    internal lateinit var components: FirRendererComponents
    protected val printer: FirPrinter get() = components.printer
    private val resolvePhaseRenderer: FirResolvePhaseRenderer? get() = components.resolvePhaseRenderer
    private val typeRenderer: ConeTypeRenderer get() = components.typeRenderer

    fun render(declaration: FirDeclaration) {
        renderPhaseAndAttributes(declaration)
        if (declaration is FirConstructor) {
            declaration.dispatchReceiverType?.let {
                typeRenderer.render(it)
                printer.print(""."")
            }
            if (declaration is FirErrorPrimaryConstructor) {
                printer.print(""error_"")
            }
            printer.print(""constructor"")
            return
        }
        printer.print(
            when (declaration) {","is FirRegularClass -> declaration.classKind.name.toLowerCaseAsciiOnly().replace(""_"", "" "")"
"}
            // TODO what should the default message be?
            roots.size == 1 && original.getValueArgument(0)!!.type.isBoolean() -> irString(""Assertion failed"")
            else -> null
        }
    }

    private fun findDelegates(function: IrFunction): List<FunctionDelegate> {
        val values = function.valueParameters
        if (values.isEmpty()) return emptyList()

        // Java static functions require searching by class
        val parentClassFunctions = (
                function.parentClassId
                    ?.let { context.referenceClass(it) }
                    ?.functions ?: emptySequence()
                )
            .filter { it.owner.kotlinFqName == function.kotlinFqName }
            .toList()
        val possible = (context.referenceFunctions(function.callableId) + parentClassFunctions)
            .distinct()

        return possible.mapNotNull { overload ->
            // Dispatch receivers must always match exactly
            if (function.dispatchReceiverParameter?.type != overload.owner.dispatchReceiverParameter?.type) {
                return@mapNotNull null
            }

            // Extension receiver may only be assignable
            if (!function.extensionReceiverParameter?.type.isAssignableTo(overload.owner.extensionReceiverParameter?.type)) {
                return@mapNotNull null
            }

            val parameters = overload.owner.valueParameters
            if (parameters.size !in values.size..values.size + 1) return@mapNotNull null
            if (!parameters.zip(values).all { (param, value) -> value.type.isAssignableTo(param.type) }) {
                return@mapNotNull null
            }

            val messageParameter = parameters.last()
            return@mapNotNull when {
                isStringSupertype(messageParameter.type) -> SimpleFunctionDelegate(overload, messageParameter)
                isStringFunction(messageParameter.type) -> LambdaFunctionDelegate(overload, messageParameter)
                isStringJavaSupplierFunction(messageParameter.type) ->
                    SamConversionLambdaFunctionDelegate(overload, messageParameter)
                else -> null
            }
        }
    }

    private fun isStringFunction(type: IrType): Boolean =
        type.isFunctionOrKFunction() && type is IrSimpleType && (type.arguments.size == 1 && isStringSupertype(type.arguments.first()))

    private fun isStringJavaSupplierFunction(type: IrType): Boolean {
        val javaSupplier = context.referenceClass(ClassId.topLevel(FqName(""java.util.function.Supplier"")))
        return javaSupplier != null && type.isSubtypeOfClass(javaSupplier) &&
                type is IrSimpleType && (type.arguments.size == 1 && isStringSupertype(type.arguments.first()))
    }

    private fun isStringSupertype(argument: IrTypeArgument): Boolean =
        argument is IrTypeProjection && isStringSupertype(argument.type)

    private fun isStringSupertype(type: IrType): Boolean =
        context.irBuiltIns.stringType.isSubtypeOf(type, irTypeSystemContext)",private fun IrType?.isAssignableTo(type: IrType?): Boolean {
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.test.framework.services

import com.intellij.openapi.util.Key",import org.jetbrains.kotlin.analysis.providers.ForeignValueProviderService
"// DONT_TARGET_EXACT_BACKEND: JS
// ES_MODULES
// SPLIT_PER_MODULE
// EXPECTED_REACHABLE_NODES: 1287
// MODULE: lib
// FILE: lib.kt

package lib

fun foo() = 23

external fun bar(): Int = definedExternally

inline fun baz() = 99

inline fun callFoo() = foo()

inline fun buzz(): Int {
    val o = object {
        fun f() = 111
    }
    return o.f()
}

// FILE: lib.js

function bar() {
    return 42;
}

// MODULE: main(lib)
// FILE: main.kt

package main

fun box(): String {
    val a = lib.foo()
    if (a != 23) return ""fail: simple function: $a""

    val b = lib.bar()
    if (b != 42) return ""fail: native function: $b""

    val c = lib.baz()
    if (c != 99) return ""fail: inline function: $c""

    val d = lib.buzz()
    if (d != 111) return ""fail: inline function with object expression: $d""",val e = lib.callFoo()
"fun collectErrorCandidatesForFunction(
    scopeTower: ImplicitScopeTower,
    name: Name,
    explicitReceiver: DetailedReceiver?
): Collection<ErrorCandidate<*>> {
    val context = ErrorCandidateContext(scopeTower, name, explicitReceiver)
    context.asClassifierCall(asFunction = true)
    return context.result
}

fun collectErrorCandidatesForVariable(
    scopeTower: ImplicitScopeTower,
    name: Name,
    explicitReceiver: DetailedReceiver?
): Collection<ErrorCandidate<*>> {
    val context = ErrorCandidateContext(scopeTower, name, explicitReceiver)
    context.asClassifierCall(asFunction = false)
    return context.result
}

private class ErrorCandidateContext(
    val scopeTower: ImplicitScopeTower,
    val name: Name,
    val explicitReceiver: DetailedReceiver?
) {
    val result = SmartList<ErrorCandidate<*>>()

    fun add(errorCandidate: ErrorCandidate<*>) {
        result.add(errorCandidate)
    }
}

private fun ErrorCandidateContext.asClassifierCall(asFunction: Boolean) {
    val classifier =
        when (explicitReceiver) {
            is ReceiverValueWithSmartCastInfo -> {
                explicitReceiver.receiverValue.type.memberScope.getContributedClassifier(name, scopeTower.location)
            }
            is QualifierReceiver -> {
                explicitReceiver.staticScope.getContributedClassifier(name, scopeTower.location)
            }
            else -> scopeTower.lexicalScope.findClassifier(name, scopeTower.location)
        } ?: return

    val kind = getWrongResolutionToClassifier(classifier, asFunction) ?: return

    add(ErrorCandidate.Classifier(classifier, kind))
}

private fun ErrorCandidateContext.getWrongResolutionToClassifier(
    classifier: ClassifierDescriptor,
    asFunction: Boolean
): WrongResolutionToClassifier? =
    when (classifier) {
        is TypeAliasDescriptor -> classifier.classDescriptor?.let { getWrongResolutionToClassifier(it, asFunction) }

        is TypeParameterDescriptor -> if (asFunction) TYPE_PARAMETER_AS_FUNCTION else TYPE_PARAMETER_AS_VALUE

        is ClassDescriptor -> {
            when (classifier.kind) {
                ClassKind.INTERFACE -> if (asFunction) INTERFACE_AS_FUNCTION else INTERFACE_AS_VALUE

                ClassKind.OBJECT -> if (asFunction) OBJECT_AS_FUNCTION else null",ClassKind.CLASS -> when {
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.fir.components

import org.jetbrains.kotlin.analysis.api.components.KtDiagnosticCheckerFilter
import org.jetbrains.kotlin.analysis.api.components.KtDiagnosticProvider
import org.jetbrains.kotlin.analysis.api.diagnostics.KtDiagnosticWithPsi
import org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession
import org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken
import org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.DiagnosticCheckerFilter
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.collectDiagnosticsForFile
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.getDiagnostics
import org.jetbrains.kotlin.psi.KtElement
import org.jetbrains.kotlin.psi.KtFile

internal class KtFirDiagnosticProvider(
    override val analysisSession: KtFirAnalysisSession,
    override val token: KtLifetimeToken,
) : KtDiagnosticProvider(), KtFirAnalysisSessionComponent {

    override fun getDiagnosticsForElement(
        element: KtElement,
        filter: KtDiagnosticCheckerFilter
    ): Collection<KtDiagnosticWithPsi<*>> {
        return element.getDiagnostics(firResolveSession, filter.asLLFilter()).map { it.asKtDiagnostic() }
    }

    override fun collectDiagnosticsForFile(ktFile: KtFile, filter: KtDiagnosticCheckerFilter): Collection<KtDiagnosticWithPsi<*>> =
        ktFile.collectDiagnosticsForFile(firResolveSession, filter.asLLFilter()).map { it.asKtDiagnostic() }",private fun KtDiagnosticCheckerFilter.asLLFilter() = when (this) {
"// IGNORE_BACKEND: JS

fun jsNullUndefinedHashCode() {","assertEquals(js(""null"").unsafeCast<Any>().hashCode(), js(""null"").unsafeCast<Any>().hashCode())"
"check(::x5.getter, annotationExists = true)
        check(::x6.getter, annotationExists = true)

        check(::x7.getter, annotationExists = false)

        check(::x8.getter, annotationExists = true)
        check(::x8.setter, annotationExists = false)

        check(::x9.getter, annotationExists = true)
        check(::x9.setter, annotationExists = true)
    }
}

private class EffetivelyPrivate private constructor(
    @get:Ann val x0: Int,
    @get:Ann protected val x1: Int,
    @get:Ann internal val x2: Int
) {
    companion object {
        fun test() {
            EffetivelyPrivate(0, 0, 0).test()
        }
    }

    private class Nested {
        @get:Ann
        val fofo = 0
    }

    fun test() {
        check(::x0.getter, annotationExists = true)
        check(::x1.getter, annotationExists = true)
        check(::x2.getter, annotationExists = true)

        check(Nested::fofo.getter, annotationExists = true)
    }
}

class Statics {
    companion object {
        @JvmField
        @get:Ann
        val x0 = """"

        @get:Ann
        const val x1 = """"

        @JvmStatic
        @AnnRepeat
        @get:Ann
        @set:Ann
        @setparam:Ann
        var x2 = """"

        @JvmStatic
        @get:Ann
        private val x3 = """"

        @get:Ann
        val x4 = """"
    }

    fun test() {
        check(::x0.getter, annotationExists = false)","check(::x1.getter, annotationExists = false)"
"""extension_shadowed_by_member"",
    ""redundant_projection"",
    ""RemoveRedundantBackticks"",
    ""ObjectPropertyName"",
    ""deprecation""
)
@file:org.gradle.api.Generated

/* ktlint-disable */

package gradle.kotlin.dsl.accessors._c8feb92ae88f9e0cc4f1c07aacfeaaf1


import org.gradle.api.Action
import org.gradle.api.Incubating
import org.gradle.api.NamedDomainObjectProvider
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurablePublishArtifact
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.Dependency
import org.gradle.api.artifacts.DependencyConstraint
import org.gradle.api.artifacts.ExternalModuleDependency
import org.gradle.api.artifacts.ModuleDependency
import org.gradle.api.artifacts.PublishArtifact
import org.gradle.api.artifacts.dsl.ArtifactHandler
import org.gradle.api.artifacts.dsl.DependencyConstraintHandler
import org.gradle.api.artifacts.dsl.DependencyHandler
import org.gradle.api.provider.Provider
import org.gradle.api.provider.ProviderConvertible
import org.gradle.api.tasks.TaskContainer
import org.gradle.api.tasks.TaskProvider

import org.gradle.kotlin.dsl.*
import org.gradle.kotlin.dsl.accessors.runtime.*


/**
 * Adds a dependency to the 'kotlinCompilerClasspath' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`kotlinCompilerClasspath`(dependencyNotation: Any): Dependency? =
    add(""kotlinCompilerClasspath"", dependencyNotation)

/**
 * Adds a dependency to the 'kotlinCompilerClasspath' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`kotlinCompilerClasspath`(
    dependencyNotation: String,
    dependencyConfiguration: Action<ExternalModuleDependency>
): ExternalModuleDependency = addDependencyTo(
    this, ""kotlinCompilerClasspath"", dependencyNotation, dependencyConfiguration",) as ExternalModuleDependency
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package org.jetbrains.kotlin.fir.plugin.generators
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.load.java

import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.util.capitalizeDecapitalize.capitalizeAsciiOnly

object JvmAbi {
    const val DEFAULT_IMPLS_CLASS_NAME = ""DefaultImpls""
    const val ERASED_INLINE_CONSTRUCTOR_NAME = ""constructor""

    @JvmField
    val JVM_FIELD_ANNOTATION_FQ_NAME = FqName(""kotlin.jvm.JvmField"")
    @JvmField
    val JVM_FIELD_ANNOTATION_CLASS_ID = ClassId.topLevel(JVM_FIELD_ANNOTATION_FQ_NAME)

    /**
     * Warning: use DEFAULT_IMPLS_CLASS_NAME and TypeMappingConfiguration.innerClassNameFactory when possible.
     * This is false for KAPT3 mode.
     */
    const val DEFAULT_IMPLS_SUFFIX = ""$$DEFAULT_IMPLS_CLASS_NAME""

    const val DEFAULT_PARAMS_IMPL_SUFFIX = ""\$default""

    private const val GET_PREFIX = ""get""
    private const val IS_PREFIX = ""is""
    private const val SET_PREFIX = ""set""

    const val DELEGATED_PROPERTY_NAME_SUFFIX = ""\$delegate""
    const val DELEGATED_PROPERTIES_ARRAY_NAME = ""$\$delegatedProperties""
    const val DELEGATE_SUPER_FIELD_PREFIX = ""$\$delegate_""
    private const val ANNOTATIONS_SUFFIX = ""\$annotations""
    const val ANNOTATED_PROPERTY_METHOD_NAME_SUFFIX = ANNOTATIONS_SUFFIX
    private const val ANNOTATED_TYPEALIAS_METHOD_NAME_SUFFIX = ANNOTATIONS_SUFFIX

    const val INSTANCE_FIELD = ""INSTANCE""
    const val HIDDEN_INSTANCE_FIELD = ""$$$INSTANCE_FIELD""

    val REFLECTION_FACTORY_IMPL = ClassId.topLevel(FqName(""kotlin.reflect.jvm.internal.ReflectionFactoryImpl""))

    const val LOCAL_VARIABLE_NAME_PREFIX_INLINE_ARGUMENT = ""\$i\$a$""
    const val LOCAL_VARIABLE_NAME_PREFIX_INLINE_FUNCTION = ""\$i\$f$""

    const val IMPL_SUFFIX_FOR_INLINE_CLASS_MEMBERS = ""-impl""

    const val REPEATABLE_ANNOTATION_CONTAINER_NAME = ""Container""
    val REPEATABLE_ANNOTATION_CONTAINER_META_ANNOTATION = ClassId.fromString(""kotlin/jvm/internal/RepeatableContainer"")

    /**
     * @param baseName JVM name of the property getter since Kotlin 1.4, or Kotlin name of the property otherwise.
     */",@JvmStatic
"build(""assemble"") {
                assertTasksUpToDate("":app:kaptGenerateStubsKotlin"")
                assertTasksExecuted(
                    "":lib:compileKotlin"",
                    "":app:kaptKotlin""
                )
            }

            // enable discovery
            subProject(""app"").buildGradle.modify {
                it.replace(
                    ""kapt.includeCompileClasspath = true"",
                    ""kapt.includeCompileClasspath = false""
                )
            }
            build(""assemble"") {
                assertTasksUpToDate("":lib:compileKotlin"")
                assertTasksExecuted(
                    "":app:kaptGenerateStubsKotlin"",
                    "":app:kaptKotlin""
                )
            }

            libClassKt.modify { it.checkedReplace(replacement1, replacement2) }
            build(""assemble"") {
                assertTasksExecuted("":lib:compileKotlin"")
                assertTasksUpToDate("":app:kaptKotlin"", "":app:kaptGenerateStubsKotlin"")
            }
        }
    }

    @DisplayName(""KT19179 and KT37241: kapt is not skipped and does not generate stubs for non-existent entries"")
    @GradleTest
    open fun testKt19179andKt37241(gradleVersion: GradleVersion) {
        project(""kt19179"".withPrefix, gradleVersion) {

            build(""build"") {
                val processorSubproject = subProject(""processor"")
                processorSubproject
                    .assertFileInProjectExists(""build/tmp/kapt3/classes/main/META-INF/services/javax.annotation.processing.Processor"")

                val processorJar = processorSubproject.projectPath.resolve(""build/libs/processor.jar"")
                assertFileExists(processorJar)

                val zip = ZipFile(processorJar.toFile())
                @Suppress(""ConvertTryFinallyToUseCall"")
                try {
                    assert(zip.getEntry(""META-INF/services/javax.annotation.processing.Processor"") != null) {
                        ""Generated annotation processor jar file does not contain processor service entry!""
                    }
                } finally {
                    zip.close()
                }

                assertTasksExecuted(
                    "":processor:kaptGenerateStubsKotlin"",
                    "":processor:kaptKotlin"",
                    "":app:kaptGenerateStubsKotlin"",
                    "":app:kaptKotlin""
                )

                // Test for KT-37241, check the that non-existent classpath entry is filtered out:
                assertOutputDoesNotContain(""Classpath entry points to a non-existent location"")
            }","val testKt = subProject(""app"").kotlinSourcesDir().resolve(""Test.kt"")"
"): Boolean {
        // KT-13934: reference to companion object member via class name
        if (candidate.containingDeclaration.isCompanionObject() && kotlinCall.lhsResult is LHSResult.Type) return true

        if (callableReferenceAdaptation == null) return false

        return hasNonTrivialAdaptation(callableReferenceAdaptation)
    }

    private fun hasNonTrivialAdaptation(callableReferenceAdaptation: CallableReferenceAdaptation) =
        callableReferenceAdaptation.defaults != 0 ||
                callableReferenceAdaptation.suspendConversionStrategy != SuspendConversionStrategy.NO_CONVERSION ||
                callableReferenceAdaptation.coercionStrategy != CoercionStrategy.NO_COERCION ||
                callableReferenceAdaptation.mappedArguments.values.any { it is ResolvedCallArgument.VarargArgument }

    private fun getCallableReferenceAdaptation(
        descriptor: FunctionDescriptor,
        expectedType: UnwrappedType?,
        unboundReceiverCount: Int,
        builtins: KotlinBuiltIns
    ): CallableReferenceAdaptation? {
        if (expectedType == null || TypeUtils.noExpectedType(expectedType)) return null

        // Do not adapt references against KCallable type as it's impossible to map defaults/vararg to absent parameters of KCallable
        if (ReflectionTypes.hasKCallableTypeFqName(expectedType)) return null

        val inputOutputTypes = extractInputOutputTypesFromCallableReferenceExpectedType(expectedType) ?: return null

        val expectedArgumentCount = inputOutputTypes.inputTypes.size - unboundReceiverCount
        if (expectedArgumentCount < 0) return null

        val fakeArguments = createFakeArgumentsForReference(descriptor, expectedArgumentCount, inputOutputTypes, unboundReceiverCount)
        val argumentMapping =
            callComponents.argumentsToParametersMapper.mapArguments(fakeArguments, externalArgument = null, descriptor = descriptor)

        @OptIn(ApplicabilityDetail::class)
        if (argumentMapping.diagnostics.any { !it.candidateApplicability.isSuccess }) return null

        /**
         * (A, B, C) -> Unit
         * fun foo(a: A, b: B = B(), vararg c: C)
         */
        var defaults = 0
        var varargMappingState = VarargMappingState.UNMAPPED
        val mappedArguments = linkedMapOf<ValueParameterDescriptor, ResolvedCallArgument>()
        val mappedVarargElements = linkedMapOf<ValueParameterDescriptor, MutableList<KotlinCallArgument>>()
        val mappedArgumentTypes = arrayOfNulls<KotlinType?>(fakeArguments.size)

        for ((valueParameter, resolvedArgument) in argumentMapping.parameterToCallArgumentMap) {
            for (fakeArgument in resolvedArgument.arguments) {
                val index = (fakeArgument as FakeKotlinCallArgumentForCallableReference).index
                val substitutedParameter = descriptor.valueParameters.getOrNull(valueParameter.index) ?: continue

                val mappedArgument: KotlinType?
                if (substitutedParameter.isVararg) {
                    val (varargType, newVarargMappingState) = varargParameterTypeByExpectedParameter(
                        inputOutputTypes.inputTypes[index + unboundReceiverCount],
                        substitutedParameter,
                        varargMappingState,
                        builtins
                    )
                    varargMappingState = newVarargMappingState
                    mappedArgument = varargType

                    when (newVarargMappingState) {",VarargMappingState.MAPPED_WITH_ARRAY -> {
"// FIR_IDENTICAL
// FILE: a/x.java
package a;

public class x {

    public static final int I = 42;
    public static final int I1 = 42;
    public static final int I2 = I + I1;

}

// FILE: b/y.java
package b;

import static a.x.I;

public class y {
    public static final int O = I;
}

// FILE: b/z.java
package b;

import static a.x.*;",public class z {
"@Test
    fun code() {
        val codes = listOf(48, 65, 122, 946, '+'.code, 'Ö'.code, 0xFFFC)
        val chars = ""0Azβ+Ö\uFFFC""
        assertEquals(codes, chars.map { it.code })
        assertEquals(0, Char.MIN_VALUE.code)
        assertEquals(0xFFFF, Char.MAX_VALUE.code)
    }

    @Test
    fun digitToInt() {
        fun testEquals(expected: Int, receiver: Char, radix: Int) {
            if (radix == 10) {
                assertEquals(expected, receiver.digitToInt())
                assertEquals(expected, receiver.digitToIntOrNull())
            }
            assertEquals(expected, receiver.digitToInt(radix))
            assertEquals(expected, receiver.digitToIntOrNull(radix))
        }

        fun testFails(receiver: Char, radix: Int) {
            if (radix == 10) {
                assertFails { receiver.digitToInt() }
                assertEquals(null, receiver.digitToIntOrNull())
            }
            assertFails { receiver.digitToInt(radix) }
            assertEquals(null, receiver.digitToIntOrNull(radix))
        }

        for (char in '0'..'9') {
            val digit = char - '0'

            for (radix in (digit + 1).coerceAtLeast(2)..36) {
                testEquals(digit, char, radix)
            }
            for (radix in 2..digit) {
                testFails(char, radix)
            }
        }

        val letterRanges = listOf('A'..'Z', '\uFF21'..'\uFF3A')

        for (range in letterRanges) {
            for (char in range) {
                val digit = 10 + (char - range.first)
                val lower = char.lowercaseChar()

                for (radix in digit + 1..36) {
                    testEquals(digit, char, radix)
                    testEquals(digit, lower, radix)
                }
                for (radix in 2..digit) {
                    testFails(char, radix)
                    testFails(lower, radix)
                }
            }
        }

        assertFails { '0'.digitToInt(radix = 37) }
        assertFails { '0'.digitToIntOrNull(radix = 37) }
        assertFails { '0'.digitToInt(radix = 1) }
        assertFails { '0'.digitToIntOrNull(radix = 1) }

        testFails('0' - 1, radix = 10)","testFails('9' + 1, radix = 10)"
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.lower

import org.jetbrains.kotlin.backend.common.lower.optimizations.PropertyAccessorInlineLowering
import org.jetbrains.kotlin.ir.backend.js.JsIrBackendContext
import org.jetbrains.kotlin.ir.declarations.IrDeclaration
import org.jetbrains.kotlin.ir.declarations.IrProperty
import org.jetbrains.kotlin.ir.util.fileOrNull
import org.jetbrains.kotlin.ir.util.isTopLevel

class JsPropertyAccessorInlineLowering(
    val context: JsIrBackendContext
) : PropertyAccessorInlineLowering(context) {
    override fun IrProperty.isSafeToInline(accessContainer: IrDeclaration): Boolean {
        if (!isSafeToInlineInClosedWorld())
            return false

        // Member properties could be safely inlined, because initialization processed via parent declaration
        if (!isTopLevel && !context.incrementalCacheEnabled)
            return true

        // Just undefined value
        if (symbol == context.intrinsics.void) {
            return true
        }

        // TODO: teach the deserializer to load constant property initializers
        val accessFile = accessContainer.fileOrNull ?: return false
        val file = fileOrNull ?: return false",return accessFile == file
"import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.expressions.FirExpression
import org.jetbrains.kotlin.fir.expressions.builder.buildExpressionStub
import org.jetbrains.kotlin.fir.resolve.defaultType
import org.jetbrains.kotlin.fir.resolve.transformers.setLazyPublishedVisibility
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.fir.symbols.impl.*
import org.jetbrains.kotlin.fir.toEffectiveVisibility
import org.jetbrains.kotlin.fir.types.*
import org.jetbrains.kotlin.fir.types.builder.buildResolvedTypeRef
import org.jetbrains.kotlin.fir.types.impl.ConeClassLikeTypeImpl
import org.jetbrains.kotlin.fir.types.impl.ConeTypeParameterTypeImpl
import org.jetbrains.kotlin.fir.types.impl.FirImplicitUnitTypeRef
import org.jetbrains.kotlin.metadata.ProtoBuf
import org.jetbrains.kotlin.metadata.deserialization.*
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.StandardClassIds
import org.jetbrains.kotlin.protobuf.MessageLite
import org.jetbrains.kotlin.serialization.deserialization.ProtoEnumFlags
import org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedContainerSource
import org.jetbrains.kotlin.serialization.deserialization.getName

class FirDeserializationContext(
    val nameResolver: NameResolver,
    val typeTable: TypeTable,
    val versionRequirementTable: VersionRequirementTable,
    val moduleData: FirModuleData,
    val packageFqName: FqName,
    val relativeClassName: FqName?,
    val typeDeserializer: FirTypeDeserializer,
    val annotationDeserializer: AbstractAnnotationDeserializer,
    val constDeserializer: FirConstDeserializer,
    val containerSource: DeserializedContainerSource?,
    val outerClassSymbol: FirRegularClassSymbol?,
    val outerTypeParameters: List<FirTypeParameterSymbol>
) {
    val session: FirSession = moduleData.session

    val allTypeParameters: List<FirTypeParameterSymbol> =
        typeDeserializer.ownTypeParameters + outerTypeParameters

    fun childContext(
        typeParameterProtos: List<ProtoBuf.TypeParameter>,
        containingDeclarationSymbol: FirBasedSymbol<*>,
        nameResolver: NameResolver = this.nameResolver,
        typeTable: TypeTable = this.typeTable,
        relativeClassName: FqName? = this.relativeClassName,
        containerSource: DeserializedContainerSource? = this.containerSource,
        outerClassSymbol: FirRegularClassSymbol? = this.outerClassSymbol,
        annotationDeserializer: AbstractAnnotationDeserializer = this.annotationDeserializer,
        constDeserializer: FirConstDeserializer = this.constDeserializer,
        capturesTypeParameters: Boolean = true,
    ): FirDeserializationContext = FirDeserializationContext(
        nameResolver,
        typeTable,
        versionRequirementTable,
        moduleData,
        packageFqName,
        relativeClassName,
        typeDeserializer.forChildContext(
            typeParameterProtos, containingDeclarationSymbol, nameResolver, typeTable, annotationDeserializer
        ),
        annotationDeserializer,","constDeserializer,"
"//      {   // SAFE_CALL
            //          val tmp = <safe_receiver>
            //          when {
            //              tmp == null -> null
            //              else -> <safe_call_result>
            //          }
            //      }
            val safeCallBlock = safeCallInfo.block
            val startOffset = safeCallBlock.startOffset
            val endOffset = safeCallBlock.endOffset
            val safeCallType = safeCallBlock.type
            val safeCallTmpVal = safeCallInfo.tmpVal

            val tmpValInitializer = safeCallTmpVal.initializer
            if (tmpValInitializer is IrBlock && tmpValInitializer.origin == JvmLoweredStatementOrigin.FOLDED_SAFE_CALL) {
                // Chained safe call.
                // If <safe_receiver> is a FOLDED_SAFE_CALL form, rewrite safe call to:
                //      {   // FOLDED_SAFE_CALL
                //          when {
                //              <safe_receiver_condition> && { val tmp = <safe_receiver_result>; tmp != null } ->
                //                  <safe_call_result>
                //              else ->
                //                  null
                //          }
                //      }
                //    where
                //      <safe_receiver> =
                //          {   // FOLDED_SAFE_CALL
                //              when {
                //                  <safe_receiver_condition> -> <safe_receiver_result>
                //                  else -> null
                //              }
                //          }
                val foldedBlock: IrBlock = tmpValInitializer
                val foldedWhen = foldedBlock.statements[0] as IrWhen
                val safeReceiverCondition = foldedWhen.branches[0].condition
                val safeReceiverResult = foldedWhen.branches[0].result
                safeCallTmpVal.initializer = safeReceiverResult
                safeCallTmpVal.type = safeReceiverResult.type
                val foldedConditionPart =
                    IrCompositeImpl(
                        startOffset, endOffset, context.irBuiltIns.booleanType, null,
                        listOf<IrStatement>(
                            safeCallTmpVal,
                            irValNotNull(startOffset, endOffset, safeCallTmpVal)
                        )
                    )
                foldedBlock.type = safeCallType
                foldedWhen.type = safeCallType
                foldedWhen.branches[0].condition = irAndAnd(safeReceiverCondition, foldedConditionPart)
                foldedWhen.branches[0].result = safeCallInfo.ifNotNullBranch.result
                return foldedBlock
            } else {
                // Simple safe call.
                // If <safe_receiver> itself is not a FOLDED_SAFE_CALL form, rewrite safe call to:
                //      {   // FOLDED_SAFE_CALL
                //          when {
                //              { val tmp = <safe_receiver>; tmp != null } ->
                //                  <safe_call_result>
                //              else ->
                //                  null
                //          }
                //      }

                val foldedCondition =",IrCompositeImpl(
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See native/swift/sir/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"", ""unused"")

package org.jetbrains.kotlin.sir.builder

import kotlin.contracts.*
import org.jetbrains.kotlin.sir.*
import org.jetbrains.kotlin.sir.impl.SirInitImpl",@SirBuilderDsl
"// FIR_IDENTICAL
// !LANGUAGE: -RepeatableAnnotations
// FULL_JDK
// FILE: Runtime.java",import java.lang.annotation.*;
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package org.jetbrains.kotlin.fir.resolve
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.light.classes.symbol.annotations

import com.intellij.psi.*
import com.intellij.psi.impl.light.LightIdentifier
import org.jetbrains.kotlin.asJava.classes.cannotModify
import org.jetbrains.kotlin.asJava.classes.lazyPub
import org.jetbrains.kotlin.asJava.elements.KtLightElementBase
import org.jetbrains.kotlin.light.classes.symbol.toAnnotationMemberValue
import org.jetbrains.kotlin.psi.KtElement

internal class SymbolNameValuePairForAnnotationArgument(
    private val constantValue: AnnotationArgument,
    parent: PsiAnnotationParameterList,
) : KtLightElementBase(parent), PsiNameValuePair {

    override val kotlinOrigin: KtElement? get() = constantValue.value.sourcePsi

    private val _value by lazyPub {
        constantValue.value.toAnnotationMemberValue(this)
    }

    override fun setValue(newValue: PsiAnnotationMemberValue) = cannotModify()

    private val _nameIdentifier: PsiIdentifier by lazyPub {
        LightIdentifier(manager, constantValue.name.asString())
    }

    override fun getNameIdentifier(): PsiIdentifier = _nameIdentifier

    override fun getValue(): PsiAnnotationMemberValue? = _value

    override fun getLiteralValue(): String? = (value as? PsiLiteralExpression)?.value?.toString()

    override fun getName(): String = constantValue.name.asString()",override fun accept(visitor: PsiElementVisitor) {
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.interpreter.intrinsics

import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.interpreter.*
import org.jetbrains.kotlin.ir.interpreter.exceptions.handleUserException
import org.jetbrains.kotlin.ir.interpreter.exceptions.stop
import org.jetbrains.kotlin.ir.interpreter.exceptions.withExceptionHandler
import org.jetbrains.kotlin.ir.interpreter.state.*
import org.jetbrains.kotlin.ir.interpreter.state.reflection.KFunctionState
import org.jetbrains.kotlin.ir.interpreter.state.reflection.KPropertyState
import org.jetbrains.kotlin.ir.interpreter.state.reflection.KTypeState
import org.jetbrains.kotlin.ir.types.*
import org.jetbrains.kotlin.ir.types.impl.buildSimpleType
import org.jetbrains.kotlin.ir.types.impl.makeTypeProjection
import org.jetbrains.kotlin.ir.util.toIrConst
import org.jetbrains.kotlin.types.Variance
import java.util.*

internal sealed class IntrinsicBase {
    abstract fun getListOfAcceptableFunctions(): List<String>","abstract fun evaluate(irFunction: IrFunction, environment: IrInterpreterEnvironment)"
"// DIAGNOSTICS: -UNUSED_EXPRESSION

fun ifExpr() = try {
    if (true) 2
    <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 2
} catch (e: Exception) {
    if (true) 3
    <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 3
} catch (e: Throwable) {
    if (true) 4
    <!INVALID_IF_AS_EXPRESSION!>if<!> (true) 4
} finally {
    if (true) 5
    if (true) 5
}

fun ifBlock() = try {
    if (true) {
        2
    }
    <!INVALID_IF_AS_EXPRESSION!>if<!> (true) {
        2
    }
} catch (e: Exception) {
    if (true) {
        3
    }
    <!INVALID_IF_AS_EXPRESSION!>if<!> (true) {
        3
    }
} catch (e: Throwable) {
    if (true) {
        4
    }
    <!INVALID_IF_AS_EXPRESSION!>if<!> (true) {
        4
    }
} finally {
    if (true) {
        5
    }
    if (true) {
        5
    }
}

fun whenExpr() = try {
    when {
        true -> 2
    }
    <!NO_ELSE_IN_WHEN!>when<!> {
        true -> 2
    }
} catch (e: Exception) {
    when {
        true -> 3
    }
    <!NO_ELSE_IN_WHEN!>when<!> {
        true -> 3
    }
} catch (e: Throwable) {
    when {
        true -> 4
    }
    <!NO_ELSE_IN_WHEN!>when<!> {",true -> 4
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.calls.checkers

import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.descriptors.PropertyDescriptor",import org.jetbrains.kotlin.diagnostics.Errors
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin.mpp.compilationImpl

import org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet
import org.jetbrains.kotlin.gradle.plugin.sources.internal
import org.jetbrains.kotlin.gradle.utils.MutableObservableSet
import org.jetbrains.kotlin.gradle.utils.MutableObservableSetImpl
import org.jetbrains.kotlin.gradle.utils.ObservableSet

internal fun KotlinCompilationSourceSetsContainer(
    defaultSourceSet: KotlinSourceSet
): KotlinCompilationSourceSetsContainer {
    return DefaultKotlinCompilationSourceSetsContainer(defaultSourceSet)
}

internal interface KotlinCompilationSourceSetsContainer {
    val defaultSourceSet: KotlinSourceSet
    val kotlinSourceSets: ObservableSet<KotlinSourceSet>
    val allKotlinSourceSets: ObservableSet<KotlinSourceSet>",fun source(sourceSet: KotlinSourceSet)
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.targets.js.yarn

import org.gradle.api.Plugin
import org.gradle.api.Project
import org.jetbrains.kotlin.gradle.targets.js.MultiplePluginDeclarationDetector
import org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootPlugin
import org.jetbrains.kotlin.gradle.targets.js.nodejs.NodeJsRootPlugin.Companion.kotlinNodeJsExtension
import org.jetbrains.kotlin.gradle.targets.js.npm.LockCopyTask
import org.jetbrains.kotlin.gradle.targets.js.npm.tasks.KotlinNpmInstallTask
import org.jetbrains.kotlin.gradle.tasks.CleanDataTask
import org.jetbrains.kotlin.gradle.tasks.registerTask
import org.jetbrains.kotlin.gradle.utils.detachedResolvable

open class YarnPlugin : Plugin<Project> {
    override fun apply(project: Project): Unit = project.run {
        MultiplePluginDeclarationDetector.detect(project)

        check(project == project.rootProject) {
            ""YarnPlugin can be applied only to root project""
        }

        val yarnRootExtension = this.extensions.create(YarnRootExtension.YARN, YarnRootExtension::class.java, this)
        NodeJsRootPlugin.apply(project)
        val nodeJs = this.kotlinNodeJsExtension
        val nodeJsTaskProviders = this.kotlinNodeJsExtension

        yarnRootExtension.platform.value(nodeJs.platform)
            .disallowChanges()

        nodeJs.packageManagerExtension.set(
            yarnRootExtension
        )

        val setupTask = registerTask<YarnSetupTask>(YarnSetupTask.NAME) {
            it.dependsOn(nodeJsTaskProviders.nodeJsSetupTaskProvider)

            it.group = NodeJsRootPlugin.TASKS_GROUP_NAME
            it.description = ""Download and install a local yarn version""

            it.configuration = provider {
                this.project.configurations.detachedResolvable(this.project.dependencies.create(it.ivyDependency))
                    .also { conf -> conf.isTransitive = false }
            }
        }

        val kotlinNpmInstall = tasks.named(KotlinNpmInstallTask.NAME)",kotlinNpmInstall.configure {
"// FIR_IDENTICAL
// WITH_STDLIB
// MODULE: m1-common
// FILE: common.kt
import kotlin.reflect.KClass

annotation class Ann(val clazz: KClass<*>)

@Ann(LinkToExpectInnerClass.Inner::class)
expect class LinkToExpectInnerClass {
    object Inner
}

expect class WillBeTypealiased

@Ann(WillBeTypealiased::class)
expect fun linkToExpectClassWhichWillBeTypealiased()

@Ann(WillBeTypealiased::class)
expect fun linkToExpectClassWhichWillBeTypealiased2()

// MODULE: m1-jvm()()(m1-common)
// FILE: jvm.kt
@Ann(LinkToExpectInnerClass.Inner::class)
actual class LinkToExpectInnerClass {
    actual object Inner
}

actual typealias WillBeTypealiased = Any

@Ann(WillBeTypealiased::class)
actual fun linkToExpectClassWhichWillBeTypealiased() {}

@Ann(Any::class)",actual fun linkToExpectClassWhichWillBeTypealiased2() {}
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.konan.test.blackbox.support.compilation

import org.jetbrains.kotlin.cli.common.ExitCode",import org.jetbrains.kotlin.konan.properties.resolvablePropertyList
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.components

import com.intellij.psi.PsiElement
import com.intellij.psi.PsiType
import org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion
import org.jetbrains.kotlin.analysis.api.types.KtType
import org.jetbrains.kotlin.analysis.api.types.KtTypeMappingMode

public abstract class KtPsiTypeProvider : KtAnalysisSessionComponent() {
    public abstract fun asPsiType(
        type: KtType,
        useSitePosition: PsiElement,
        allowErrorTypes: Boolean,
        mode: KtTypeMappingMode,
        isAnnotationMethod: Boolean,
        suppressWildcards: Boolean?,
        preserveAnnotations: Boolean,
    ): PsiType?

    public abstract fun asKtType(
        psiType: PsiType,
        useSitePosition: PsiElement,",): KtType?
"var modifier = PsiModifier.FINAL
            project.applyCompilerPlugins {
                modifier = it.interceptModalityBuilding(declaration, descriptor, modifier)
            }
            return modifier == PsiModifier.FINAL
        }

        private fun hasModifier(name: String): Boolean {
            if (name == PsiModifier.PUBLIC || name == PsiModifier.PROTECTED || name == PsiModifier.PRIVATE) {
                if (forcePrivate || declaration.isPrivate() || accessedProperty?.isPrivate() == true) {
                    return name == PsiModifier.PRIVATE
                }
                if (declaration.hasModifier(PROTECTED_KEYWORD) ||
                    accessedProperty?.hasModifier(PROTECTED_KEYWORD) == true ||
                    (declaration is KtConstructor<*> && containingClassIsSealed)
                ) {
                    return name == PsiModifier.PROTECTED
                }

                if (outerDeclaration.hasModifier(OVERRIDE_KEYWORD)) {
                    when ((outerDeclaration.resolve() as? CallableDescriptor)?.visibility) {
                        DescriptorVisibilities.PUBLIC -> return name == PsiModifier.PUBLIC
                        DescriptorVisibilities.PRIVATE -> return name == PsiModifier.PRIVATE
                        DescriptorVisibilities.PROTECTED -> return name == PsiModifier.PROTECTED
                    }
                }

                return name == PsiModifier.PUBLIC
            }

            return when (name) {
                PsiModifier.FINAL ->
                    !forceNonFinal && !containingClass.isInterface && outerDeclaration !is KtConstructor<*> && isFinal(outerDeclaration)

                PsiModifier.ABSTRACT -> containingClass.isInterface || outerDeclaration.hasModifier(ABSTRACT_KEYWORD)
                PsiModifier.STATIC ->
                    forceStatic || containingClassIsNamedObject && (outerDeclaration.isJvmStatic(support) || declaration.isJvmStatic(support))

                PsiModifier.STRICTFP -> declaration is KtFunction && declaration.hasAnnotation(STRICTFP_ANNOTATION_FQ_NAME)
                PsiModifier.SYNCHRONIZED -> declaration is KtFunction && declaration.hasAnnotation(SYNCHRONIZED_ANNOTATION_FQ_NAME)
                PsiModifier.NATIVE -> declaration is KtFunction && declaration.hasModifier(EXTERNAL_KEYWORD)
                else -> false
            }
        }

        private fun KtDeclaration.isPrivate() =
            hasModifier(PRIVATE_KEYWORD) || isInlineOnly()

        private fun KtDeclaration.isInlineOnly(): Boolean {
            if (this !is KtCallableDeclaration || !hasModifier(INLINE_KEYWORD)) return false
            if (annotationEntries.isEmpty()) return false

            val descriptor = resolve() as? CallableMemberDescriptor ?: return false

            return descriptor.isInlineOnly()
        }
    }

    private fun lightMethod(
        name: String,
        declaration: KtDeclaration,
        forceStatic: Boolean,
        forcePrivate: Boolean = false,
        forceNonFinal: Boolean = false,
    ): LightMethodBuilder {",val accessedProperty = if (declaration is KtPropertyAccessor) declaration.property else null
"// IGNORE_BACKEND_K2: JVM_IR, JS_IR, JS_IR_ES6, NATIVE, WASM
// FIR status: expect/actual in the same module (ACTUAL_WITHOUT_EXPECT)
// !LANGUAGE: +MultiPlatformProjects
// !OPT_IN: kotlin.ExperimentalMultiplatform
// WITH_STDLIB
// MODULE: library
// FILE: expected.kt

package a

@OptionalExpectation
expect annotation class A(val x: Int)

@OptionalExpectation
expect annotation class B(val s: String) {
    @OptionalExpectation
    annotation class C(val a: Boolean)
}

// FILE: actual.kt

package a

actual annotation class A(actual val x: Int)

// MODULE: main(library)
// FILE: main.kt

@file:Suppress(""OPTIONAL_DECLARATION_USAGE_IN_NON_COMMON_SOURCE"") // TODO: support common sources in the test infrastructure",package usage
"print("": "")
        val type = declaration.backingField?.type
            ?: declaration.getter?.returnType
            ?: error(""Couldn't find return type"")
        print(type.renderSrc())
        declaration.backingField?.let { field ->
            field.initializer?.let { initializer ->
                print("" = "")
                initializer.print()
            }
        }
        indented {
            declaration.getter?.scoped {
                if (it.origin != IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR) {
                    println()
                    it.printAnnotations()
                    println()
                    println(""get() {"")
                    indented {
                        it.body?.accept(this, null)
                    }
                    println()
                    println(""}"")
                }
            }
            declaration.setter?.scoped {
                if (it.origin != IrDeclarationOrigin.DEFAULT_PROPERTY_ACCESSOR) {
                    println()
                    it.printAnnotations()
                    println(""set(value) {"")
                    indented {
                        it.body?.accept(this, null)
                    }
                    println()
                    println(""}"")
                }
            }
        }
    }

    private var printIntsAsBinary = false
    fun <T> withIntsAsBinaryLiterals(block: () -> T): T {
        val prev = printIntsAsBinary
        try {
            printIntsAsBinary = true
            return block()
        } finally {
            printIntsAsBinary = prev
        }
    }

    private fun intAsBinaryString(value: Int): String {
        if (value == 0) return ""0""
        var current = if (value >= 0) value else value.inv()
        var result = """"
        while (current != 0 || result.length % 4 != 0) {
            val nextBit = current and 1 != 0
            current = current ushr 1
            result = ""${if (nextBit) ""1"" else ""0""}$result""
        }
        return ""0b$result"" + if (value < 0) "".inv()"" else """"
    }

    override fun visitConst(expression: IrConst<*>) {
        val result = when (expression.kind) {","is IrConstKind.Null -> ""${expression.value}"""
"// JSPECIFY_STATE: warn
// LANGUAGE: +JavaTypeParameterDefaultRepresentationWithDNN
// DIAGNOSTICS: -UNUSED_PARAMETER

// FILE: NullMarkedType.java

import org.jspecify.annotations.*;

@NullMarked
public class NullMarkedType {",public static class TargetType<
"@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedIterable"")
@kotlin.internal.InlineOnly
public inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {
    return flatMapIndexedTo(ArrayList<R>(), transform)
}

/**
 * Returns a single list of all elements yielded from results of [transform] function being invoked on each element
 * and its index in the original array.
 * 
 * @sample samples.collections.Collections.Transformations.flatMapIndexed
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedIterable"")
@kotlin.internal.InlineOnly
public inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {
    return flatMapIndexedTo(ArrayList<R>(), transform)
}

/**
 * Returns a single list of all elements yielded from results of [transform] function being invoked on each element
 * and its index in the original array.
 * 
 * @sample samples.collections.Collections.Transformations.flatMapIndexed
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedIterable"")
@kotlin.internal.InlineOnly
public inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {
    return flatMapIndexedTo(ArrayList<R>(), transform)
}

/**
 * Returns a single list of all elements yielded from results of [transform] function being invoked on each element
 * and its index in the original array.
 * 
 * @sample samples.collections.Collections.Transformations.flatMapIndexed
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedSequence"")
@kotlin.internal.InlineOnly
public inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {
    return flatMapIndexedTo(ArrayList<R>(), transform)
}

/**
 * Appends all elements yielded from results of [transform] function being invoked on each element
 * and its index in the original array, to the given [destination].
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedIterableTo"")
@kotlin.internal.InlineOnly
public inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {
    var index = 0
    for (element in this) {","val list = transform(index++, element)"
"public <T> void foo2(@Nullable T a) {}

    public <T> @Nullable T bar2() { return null; }

    public <T> void foo3(@Nullable JavaBox<T> a) {}

    public <T> @Nullable JavaBox<T> bar3() { return null; }

    public <T> void foo4(@NotNull JavaBox<T> a) {}

    public <T> @NotNull JavaBox<T> bar4() { return null; }

    public <T> void foo5(@Nullable JavaBox<@Nullable T> a) {}

    public <T> @Nullable JavaBox<@Nullable T> bar5() { return null; }

    public <T> void foo6(@NotNull JavaBox<@NotNull T> a) {}

    public <T> @NotNull JavaBox<@NotNull T> bar6() { return null; }

    public <T extends @NotNull Object> void foo7(T a) {}

    public <T extends @NotNull Object> T bar7() { return null; }

    public <T extends @Nullable Object> void foo8(T a) {}

    public <T extends @Nullable Object> T bar8() { return null; }

    public <T extends @Nullable Object> void foo9(JavaBox<T> a) {}

    public <T extends @Nullable Object> JavaBox<T> bar9() { return null; }

    public <T extends @NotNull Object> void foo10(JavaBox<T> a) {}

    public <T extends @NotNull Object> JavaBox<T> bar10() { return null; }
}

// FILE: JavaBox.java
public class JavaBox<T> {
    public JavaBox(T b) {
        a = b;
    }
    public T a;
}

// FILE: Test.kt
fun genericFunWithAnnotations(x: GenericFunWithAnnotation) {
    x.foo("""")
    x.foo(<!NULL_FOR_NONNULL_TYPE!>null<!>)
    takeString(x.bar())

    x.foo2("""")
    x.foo2(null)
    takeString(<!TYPE_MISMATCH!>x.bar2()<!>)

    x.<!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>foo3<!>(null)
    x.foo3<String>(null)
    x.foo3<String?>(null)
    x.foo3(JavaBox(null))
    x.foo3<String>(JavaBox(null))
    x.foo3<String?>(JavaBox(null))
    x.foo3(JavaBox(""""))
    takeString(x.<!NEW_INFERENCE_NO_INFORMATION_FOR_PARAMETER!>bar3<!>()?.<!DEBUG_INFO_MISSING_UNRESOLVED!>a<!>)",x.foo4(JavaBox(null))
"// !LANGUAGE: +OverloadResolutionByLambdaReturnType
// ALLOW_KOTLIN_PACKAGE
// !DIAGNOSTICS: -UNUSED_PARAMETER -UNUSED_VARIABLE -UNUSED_EXPRESSION
// ISSUE: KT-11265

// FILE: OverloadResolutionByLambdaReturnType.kt

package kotlin

annotation class OverloadResolutionByLambdaReturnType

// FILE: main.kt

import kotlin.OverloadResolutionByLambdaReturnType

@OverloadResolutionByLambdaReturnType
fun create(f: (Int) -> Int): Int = 1
fun create(f: (Int) -> String): String = """"

fun takeString(s: String) {}
fun takeInt(s: Int) {}

fun test_1() {
    val x = create { """" }
    takeString(x)
}

fun test_2() {
    val x = create { 1 }
    takeInt(x)
}

fun test_3() {
    val x = create { <!ARGUMENT_TYPE_MISMATCH!>1.0<!> }
}

@OverloadResolutionByLambdaReturnType","fun <K> create(x: K, f: (K) -> Int): Int = 1"
"+isFakeOverrideField()
        +referencedSymbolList(""overriddenSymbols"", s) {
            skipInIrFactory()
        }
    }
    val memberWithContainerSource: Element by element(Declaration) {
        parent(declarationWithName)

        +field(""containerSource"", type<DeserializedContainerSource>(), nullable = true, mutable = false) {
            useFieldInIrFactory(defaultValue = ""null"")
        }
    }
    val valueDeclaration: Element by element(Declaration) {
        parent(declarationWithName)
        parent(symbolOwner)

        +descriptor(""ValueDescriptor"")
        +declaredSymbol(valueSymbolType)
        +field(""type"", irTypeType)
    }
    val valueParameter: Element by element(Declaration) {
        needTransformMethod()

        parent(declarationBase)
        parent(valueDeclaration)

        +descriptor(""ParameterDescriptor"")
        +field(""isAssignable"", boolean, mutable = false)
        +declaredSymbol(valueParameterSymbolType)
        +field(""index"", int)
        +field(""varargElementType"", irTypeType, nullable = true)
        +field(""isCrossinline"", boolean)
        +field(""isNoinline"", boolean)
        +field(""isHidden"", boolean) {
            kDoc = """"""
            If `true`, the value parameter does not participate in [${idSignatureType.render()}] computation.

            This is a workaround that is needed for better support of compiler plugins.
            Suppose you have the following code and some IR plugin that adds a value parameter to functions
            marked with the `@PluginMarker` annotation.
            ```kotlin
            @PluginMarker
            fun foo(defined: Int) { /* ... */ }
            ```

            Suppose that after applying the plugin the function is changed to:
            ```kotlin
            @PluginMarker
            fun foo(defined: Int, ${'$'}extra: String) { /* ... */ }
            ```

            If a compiler plugin adds parameters to an [${function.render()}],
            the representations of the function in the frontend and in the backend may diverge, potentially causing signature mismatch and
            linkage errors (see [KT-40980](https://youtrack.jetbrains.com/issue/KT-40980)).
            We wouldn't want IR plugins to affect the frontend representation, since in an IDE you'd want to be able to see those
            declarations in their original form (without the `${'$'}extra` parameter).

            To fix this problem, [$name] was introduced.
            
            TODO: consider dropping [$name] if it isn't used by any known plugin.
            """""".trimIndent()
        }
        +field(""defaultValue"", expressionBody, nullable = true)
    }
    val `class`: Element by element(Declaration) {",parent(declarationBase)
"/**
 * Returns the last element matching the given [predicate].
 * 
 * @throws NoSuchElementException if no such element is found.
 * 
 * @sample samples.collections.Collections.Elements.last
 */
public inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {
    for (index in this.indices.reversed()) {
        val element = this[index]
        if (predicate(element)) return element
    }
    throw NoSuchElementException(""Array contains no element matching the predicate."")
}

/**
 * Returns the last element matching the given [predicate].
 * 
 * @throws NoSuchElementException if no such element is found.
 * 
 * @sample samples.collections.Collections.Elements.last
 */
public inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {
    for (index in this.indices.reversed()) {
        val element = this[index]
        if (predicate(element)) return element
    }
    throw NoSuchElementException(""Array contains no element matching the predicate."")
}

/**
 * Returns the last element matching the given [predicate].
 * 
 * @throws NoSuchElementException if no such element is found.
 * 
 * @sample samples.collections.Collections.Elements.last
 */
public inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {
    for (index in this.indices.reversed()) {
        val element = this[index]
        if (predicate(element)) return element
    }
    throw NoSuchElementException(""Array contains no element matching the predicate."")
}

/**
 * Returns the last element matching the given [predicate].
 * 
 * @throws NoSuchElementException if no such element is found.
 * 
 * @sample samples.collections.Collections.Elements.last
 */
public inline fun CharArray.last(predicate: (Char) -> Boolean): Char {
    for (index in this.indices.reversed()) {
        val element = this[index]
        if (predicate(element)) return element
    }
    throw NoSuchElementException(""Array contains no element matching the predicate."")
}

/**
 * Returns last index of [element], or -1 if the array does not contain element.
 */
public fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {
    if (element == null) {",for (index in indices.reversed()) {
"infix fun UserKlass.testDifferencesInInfixModifierPresenceReverse(arg: UserKlass) {}
    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) fun UserKlass.testDifferencesInInfixModifierPresenceReverse(arg: UserKlass) {}


    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) operator fun UserKlassA.unaryPlus() {}
    operator fun UserKlassA.unaryPlus() {}

    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) operator fun UserKlassB.unaryPlus() {}
    fun UserKlassB.unaryPlus() {}

    operator fun UserKlassB.unaryMinus() {}
    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) fun UserKlassB.unaryMinus() {}


    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) tailrec fun testIdenticalPresenceOfTailrecModifier() {}
    tailrec fun testIdenticalPresenceOfTailrecModifier() {}

    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) tailrec fun testDifferencesInTailrecModifierPresence() {}
    fun testDifferencesInTailrecModifierPresence() {}

    tailrec fun testDifferencesInTailrecModifierPresenceReverse() {}
    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) fun testDifferencesInTailrecModifierPresenceReverse() {}


    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) private fun testIdenticalPrivateVisibility() {}
    private fun testIdenticalPrivateVisibility() {}

    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) internal fun testIdenticalInternalVisibility() {}
    internal fun testIdenticalInternalVisibility() {}

    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) private fun testDifferencesInPrivateAndPublicVisibilities() {}
    public fun testDifferencesInPrivateAndPublicVisibilities() {}

    private fun testDifferencesInPrivateAndPublicVisibilitiesReverse() {}
    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) public fun testDifferencesInPrivateAndPublicVisibilitiesReverse() {}

    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) internal fun testDifferencesInInternalAndPublicVisibilities() {}
    public fun testDifferencesInInternalAndPublicVisibilities() {}

    internal fun testDifferencesInInternalAndPublicVisibilitiesReverse() {}
    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) public fun testDifferencesInInternalAndPublicVisibilitiesReverse() {}

    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) private fun testDifferencesInPrivateAndInternalVisibilities() {}
    internal fun testDifferencesInPrivateAndInternalVisibilities() {}

    private fun testDifferencesInPrivateAndInternalVisibilitiesReverse() {}
    @Deprecated(message = """", level = DeprecationLevel.HIDDEN) internal fun testDifferencesInPrivateAndInternalVisibilitiesReverse() {}


}


open class Invariant<T>


class UserKlass
class UserKlassA
class UserKlassB
typealias SameUserKlass = UserKlass
typealias SameUserKlassA = UserKlassA
typealias SameUserKlassB = UserKlassB


val defaultArgument = UserKlass()",val defaultArgumentA = UserKlass()
"// TARGET_BACKEND: JVM
// This test checks that JVM-specific static initialization behavior is preserved in JVM_IR.

var testObjectInit = false
var testClassCompanionInit = false
var testInterfaceCompanionInit = false

fun use(x: Int) {}

object TestObject {
    init {
        testObjectInit = true
    }
    const val x = 42
}

fun getTestObject() = TestObject

class TestClassCompanion {
    companion object {
        init {
            testClassCompanionInit = true
        }
        const val x = 42
    }
}

fun getTestClassCompanion() = TestClassCompanion

class TestInterfaceCompanion {
    companion object {
        init {
            testInterfaceCompanionInit = true
        }
        const val x = 42
    }
}

fun getInterfaceCompanion() = TestInterfaceCompanion

fun box(): String {
    use(TestObject.x)
    if (testObjectInit)
        throw Exception(""use(TestObject.x)"")

    use((TestObject).x)
    if (testObjectInit)
        throw Exception(""use((TestObject).x)"")

    use(getTestObject().x)
    if (!testObjectInit)
        throw Exception(""use(getTestObject().x)"")

    use(TestClassCompanion.x)
    if (testClassCompanionInit)
        throw Exception(""use(TestClassCompanion.x)"")

    use((TestClassCompanion).x)
    if (testClassCompanionInit)
        throw Exception(""use((TestClassCompanion).x)"")",use(getTestClassCompanion().x)
"package org.jetbrains.ring

import kotlin.native.concurrent.*
import kotlin.concurrent.*
import org.jetbrains.benchmarksLauncher.Blackhole
import org.jetbrains.benchmarksLauncher.Random

data class Pos(val i: Int, val j: Int)

data class Cell(val isAlive: Boolean = false)

class Generation(private val width: Int, private val height: Int) {
    val cells = Array(height) { _ -> Array(width) { _ -> Cell() } }

    fun evolve(): Generation {
        val newGen = Generation(width, height)

        for (i in 0 until height) {
            for (j in 0 until width) {
                val neighborhood = mutableListOf<Pos>()
                for (di in -1..1) {",for (dj in -1..1) {
"select({ x, y -> x.inv() + y.toByte() }, id { x: Int, y -> y.toByte() }, id { x, y: Number -> x.inv() })

    // Inferring lambda parameter types by other specified lambda parameters; expected type is a functional type with type variables in parameter types
    takeLambdas({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Nothing"")!>it<!> }, { x: Int -> }, { x: Nothing -> x })
    takeLambdas({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Nothing"")!>it<!> }, { } as (Int) -> Unit, { x: Nothing -> x })
    takeLambdas({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Nothing"")!>it<!> }, { } as (Nothing) -> Unit, { x: Int -> x })
    takeLambdas({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Nothing"")!>it<!> }, { } as (Int) -> Unit, { } as (Nothing) -> Unit)

    // Inferring lambda parameter types by other specified lambda parameters; expected type is a functional type with type variables in parameter types; dependent type parameters
    takeLambdasWithDirectlyDependentTypeParameters({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> }, { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> }, { x: Int -> x })
    takeLambdasWithDirectlyDependentTypeParameters({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> }, { x: Number -> x }, { x: Int -> x })
    takeLambdasWithInverselyDependentTypeParameters({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> }, { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> }, { x: Int -> x })
    /*
     * Interesting test case: variable can be fixed to different types randomly (`Int` or `Number`; it depends on variable fixation order)
     * if in `TypeVariableDependencyInformationProvider` `hashSet` instead of `linkedSet` for `deepTypeVariableDependencies` and `shallowTypeVariableDependencies` will be used
     */
    takeLambdasWithInverselyDependentTypeParameters({ <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>it<!> }, { x: Number -> x }, { x: Int -> x })

    // Inferring lambda parameter types by subtypes of functional type
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int, kotlin.String, kotlin.Float) -> kotlin.Float"")!>select(A2(), { a, b, c -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>a<!>; <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String"")!>b<!>; <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float"")!>c<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Number) -> java.io.Serializable"")!>select(A3(), { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>it<!> }, { a -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>a<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction<kotlin.Any>"")!>select(A3(), <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>)<!>
    // Should be error as `A3::foo1` is `KFunction2`, but the remaining arguments are `KFuncion1` or `Function1`
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(A3(), <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>, { <!CANNOT_INFER_PARAMETER_TYPE!>a<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>a<!> }, { <!CANNOT_INFER_PARAMETER_TYPE!>it<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>it<!> })<!>
    // It's OK because `A3::foo2` is from companion of `A3`
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int) -> kotlin.Any"")!>select(A3(), <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction1<kotlin.Int, kotlin.Unit>"")!>A3::foo2<!>, { a -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>a<!> }, { it -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int) -> {Comparable<*> & java.io.Serializable}"")!>select(A4(), { x: Number -> """" })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int, kotlin.Int) -> {Comparable<*> & java.io.Serializable}"")!>select(A5<Int, Int>(), { x: Number, y: Int -> """" })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int, kotlin.String, kotlin.Float) -> kotlin.Float"")!>select(A2(), id { a, b, c -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>a<!>; <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String"")!>b<!>; <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float"")!>c<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Number) -> java.io.Serializable"")!>select(id(A3()), { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>it<!> }, { a -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>a<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction<kotlin.Any>"")!>select(A3(), id(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>))<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(A3(), <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>, id { <!CANNOT_INFER_PARAMETER_TYPE!>a<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>a<!> }, { <!CANNOT_INFER_PARAMETER_TYPE!>it<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>it<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(A3(), <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>, { <!CANNOT_INFER_PARAMETER_TYPE!>a<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>a<!> }, id { <!CANNOT_INFER_PARAMETER_TYPE!>it<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>it<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(id(A3()), id(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>), { <!CANNOT_INFER_PARAMETER_TYPE!>a<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>a<!> }, { <!CANNOT_INFER_PARAMETER_TYPE!>it<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>it<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(id(A3()), id(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>), { <!CANNOT_INFER_PARAMETER_TYPE!>a<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>a<!> }, id { <!CANNOT_INFER_PARAMETER_TYPE!>it<!> -> <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE, DEBUG_INFO_EXPRESSION_TYPE(""[Error type: Cannot infer a lambda parameter type]"")!>it<!> })<!>
    // If lambdas' parameters are specified explicitly, we don't report an error, because there is proper CST – Function<Unit>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(id(A3()), id(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>), { a: Number -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>a<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select(id(A3()), id(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.reflect.KFunction2<A3, kotlin.Int, kotlin.Unit>"")!>A3::foo1<!>), id { a: Number -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>a<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int) -> kotlin.Number"")!>select(A4(), id { x: Number -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>x<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int, kotlin.Int) -> {Comparable<*> & Number}"")!>select(id(A5<Int, Int>()), id { x: Number, y: Int -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>x<!>;<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>y<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Int, kotlin.Int) -> {Comparable<*> & Number}"")!>select(id(A5<Int, Int>()), id { x, y -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>x<!>;<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>y<!> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.Number, kotlin.Int) -> {Comparable<*> & Number}"")!>select(id(<!DEBUG_INFO_EXPRESSION_TYPE(""A5<kotlin.Number, kotlin.Int>"")!>A5()<!>), id { x: Number, y: Int -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>x<!>;<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>y<!> })<!>
    val x55: Function2<Number, Int, Float> = select(id(A5()), id { x, y -> <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number"")!>x<!>;<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>y<!>; 1f })

    // Diffrerent lambda's parameters with proper CST
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function1<*, kotlin.Unit>"")!>select({ x: Int -> }, { x: String -> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Unit>"")!>select({ x: Int -> }, { x: Int, y: Number -> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function1<*, kotlin.Unit>"")!>select(id { x: Int -> }, { x: String -> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Unit>"")!>select({ x: Int -> }, id { x: Int, y: Number -> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function1<*, kotlin.Unit>"")!>select(id { x: Int -> }, id { x: String -> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Unit>"")!>select(id { x: Int -> }, id { x: Int, y: Number -> })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function1<*, {Comparable<*> & java.io.Serializable}>"")!>select({ x: Int -> 1 }, { x: String -> """" })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<{Comparable<*> & Number}>"")!>select({ x: Int -> 1 }, { x: Int, y: Number -> 1f })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function1<*, Inv<out {Comparable<*> & java.io.Serializable}>>"")!>select(id { x: Int -> Inv(10) }, { x: String -> Inv("""") })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Any>"")!>select({ x: Int -> TODO() }, id { x: Int, y: Number -> Any() })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function1<*, kotlin.String?>"")!>select(id { x: Int -> null }, id { x: String -> """" })<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Function<kotlin.Int>"")!>select(id { x: Int -> 10 }, id { x: Int, y: Number -> TODO() })<!>
    val x68: String.(String) -> String = select(id { x: String, y: String -> ""10"" }, id { x: String, y: String -> ""TODO()"" })

    // Anonymous functions
    val x69: (C) -> Unit = selectB({ it }, { }, id(fun (x) { <!DEBUG_INFO_EXPRESSION_TYPE(""A"")!>x<!> }))
    select(id1(fun(it) { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!>.inv() }), id1 { x: Number -> TODO() }, id1(id2(::takeInt)))
    select(id(fun (it) { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!> }), id(id<(Int) -> Unit> { x: Number -> Unit }))
    select(id(fun (it) { <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int"")!>it<!>.inv() }), id<(Int) -> Unit> { })
    val x70: (Int) -> Unit = selectNumber(id(fun (it) { }), id {}, id {})","val x71: String.() -> Unit = select(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.String.() -> kotlin.Unit"")!>id(fun String.() { })<!>, <!DEBUG_INFO_EXPRESSION_TYPE(""(kotlin.String) -> kotlin.Unit"")!>id(fun(x: String) {})<!>)"
"private val codegen: ExpressionCodegen,
    override val callElement: KtElement,
    private val functionDescriptor: FunctionDescriptor
) : SourceCompilerForInline {
    override val state
        get() = codegen.state

    private val additionalInnerClasses = mutableListOf<ClassDescriptor>()

    val context = getContext(
        functionDescriptor,
        functionDescriptor,
        codegen.state,
        DescriptorToSourceUtils.descriptorToDeclaration(functionDescriptor)?.containingFile as? KtFile,
        additionalInnerClasses
    ) as MethodContext

    override val callElementText: String by lazy { callElement.text }

    override val inlineCallSiteInfo: InlineCallSiteInfo
        get() {
            var context = codegen.getContext()
            var parentCodegen = codegen.parentCodegen
            while (context is InlineLambdaContext) {
                val closureContext = context.getParentContext()
                assert(closureContext is ClosureContext) { ""Parent context of inline lambda should be closure context"" }
                assert(closureContext.parentContext is MethodContext) { ""Closure context should appear in method context"" }
                context = closureContext.parentContext as MethodContext
                assert(parentCodegen is FakeMemberCodegen) { ""Parent codegen of inlined lambda should be FakeMemberCodegen"" }
                parentCodegen = (parentCodegen as FakeMemberCodegen).delegate
            }

            val signature = codegen.state.typeMapper.mapSignatureSkipGeneric(context.functionDescriptor, context.contextKind)
            return InlineCallSiteInfo(
                parentCodegen.className,
                signature.asmMethod,
                context.functionDescriptor.getInlineCallSiteVisibility(),
                callElement.containingFile?.virtualFile?.let { File(it.path) },
                CodegenUtil.getLineNumberForElement(callElement, false) ?: 0
            )
        }

    override val sourceMapper
        get() = codegen.parentCodegen.orCreateSourceMapper

    override fun generateLambdaBody(lambdaInfo: ExpressionLambda, reifiedTypeParameters: ReifiedTypeParametersUsages): SMAPAndMethodNode {
        require(lambdaInfo is PsiExpressionLambda)
        val invokeMethodDescriptor = lambdaInfo.invokeMethodDescriptor
        val jvmMethodSignature = state.typeMapper.mapSignatureSkipGeneric(invokeMethodDescriptor)
        val asmMethod = jvmMethodSignature.asmMethod
        val methodNode = MethodNode(
            Opcodes.API_VERSION, DescriptorAsmUtil.getMethodAsmFlags(invokeMethodDescriptor, OwnerKind.IMPLEMENTATION, state),
            asmMethod.name, asmMethod.descriptor, null, null
        )
        val adapter = wrapWithMaxLocalCalc(methodNode)
        val closureContext = when {
            lambdaInfo.isPropertyReference ->
                codegen.getContext().intoAnonymousClass(lambdaInfo.classDescriptor, codegen, OwnerKind.IMPLEMENTATION)
            invokeMethodDescriptor.isSuspend ->
                codegen.getContext().intoCoroutineClosure(
                    getOrCreateJvmSuspendFunctionView(invokeMethodDescriptor, state), invokeMethodDescriptor, codegen, state.typeMapper
                )
            else -> codegen.getContext().intoClosure(invokeMethodDescriptor, codegen, state.typeMapper)
        }
        val context = closureContext.intoInlinedLambda(invokeMethodDescriptor, lambdaInfo.isCrossInline, lambdaInfo.isPropertyReference)",val smap = generateMethodBody(
"// SKIP_WHEN_OUT_OF_CONTENT_ROOT
// MODULE: topmost
// MODULE_KIND: LibraryBinary
// FILE: topmost.kt",package org.example
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package kotlin.metadata.jvm

import kotlin.metadata.*
import kotlin.metadata.jvm.internal.JvmReadUtils.readModuleMetadataImpl
import kotlin.metadata.jvm.internal.JvmReadUtils.throwIfNotCompatible
import kotlin.metadata.jvm.internal.wrapIntoMetadataExceptionWhenNeeded
import org.jetbrains.kotlin.metadata.jvm.JvmModuleProtoBuf
import org.jetbrains.kotlin.metadata.jvm.deserialization.ModuleMapping
import org.jetbrains.kotlin.metadata.jvm.deserialization.PackageParts
import org.jetbrains.kotlin.metadata.jvm.deserialization.serializeToByteArray
import org.jetbrains.kotlin.metadata.jvm.deserialization.JvmMetadataVersion as CompilerMetadataVersion

/**
 * Represents the parsed metadata of a Kotlin JVM module file.
 *
 * To create an instance of [KotlinModuleMetadata], load the contents of the `.kotlin_module` file into a byte array
 * and call [KotlinModuleMetadata.read]. Then it is possible to get the result in the form of [KmModule] with [KotlinModuleMetadata.kmModule].
 *
 * `.kotlin_module` file is produced per Kotlin compilation, and contains auxiliary information, such as a map of all single- and multi-file facades ([KmModule.packageParts]),
 *  and `@OptionalExpectation` declarations ([KmModule.optionalAnnotationClasses]).
 */
@UnstableMetadataApi
public class KotlinModuleMetadata public constructor(
    /**
     * [KmModule] representation of this metadata.
     *
     * Returns the same (mutable) [KmModule] instance every time.
     */
    public var kmModule: KmModule,

    /**
     * Version of this metadata.
     */
    public var version: JvmMetadataVersion,
) {
    /**
     * Encodes and writes this metadata of the Kotlin module file.
     *
     * This method encodes all available data, including [version].
     *
     * @throws IllegalArgumentException if [kmModule] is not correct and cannot be written or if [version] is not supported for writing.
     */
    public fun write(): ByteArray {
        val b = JvmModuleProtoBuf.Module.newBuilder()
        kmModule.packageParts.forEach { (fqName, packageParts) ->",PackageParts(fqName).apply {
"/**
 * Returns `true` if given function is *static* as defined in [staticCFunction].
 */
private fun isStatic(function: Function<*>): Boolean {
    // TODO: revise
    try {
        with(function.javaClass.getDeclaredField(""INSTANCE"")) {
            if (!java.lang.reflect.Modifier.isStatic(modifiers) || !java.lang.reflect.Modifier.isFinal(modifiers)) {
                return false
            }

            isAccessible = true // TODO: undo

            return get(null) == function

            // If the class has static final ""INSTANCE"" field, and only the value of this field is accepted,
            // then each class is handled at most once, so these checks prevent memory leaks.
        }
    } catch (e: NoSuchFieldException) {
        return false
    }
}

internal data class FunctionSpec(val functionClass: Class<*>, val returnType: KType, val parameterTypes: List<KType>)

@Suppress(""UNCHECKED_CAST"")
@PublishedApi
internal fun <F : Function<*>> staticCFunctionImpl(function: F, returnType: KType, vararg parameterTypes: KType): CPointer<CFunction<F>> {
    val spec = FunctionSpec(function.javaClass, returnType, parameterTypes.asList())
    return caches.createdStaticFunctions.computeIfAbsent(spec) {
        createStaticCFunction(function, spec)
    } as CPointer<CFunction<F>>
}

private val invokeMethods = (0 .. 22).map { arity ->
    Class.forName(""kotlin.jvm.functions.Function$arity"").getMethod(""invoke"",
            *Array<Class<*>>(arity) { java.lang.Object::class.java })
}

private fun createStaticCFunctionImpl(
        returnType: CType<Any?>,
        paramTypes: List<CType<*>>,
        function: Function<*>
): NativePtr {
    val ffiCif = ffiCreateCif(returnType.ffiType, paramTypes.map { it.ffiType })

    val arity = paramTypes.size
    val pt = paramTypes.toTypedArray()

    @Suppress(""UNCHECKED_CAST"")
    val impl: FfiClosureImpl = when (arity) {
        0 -> {
            val f = function as () -> Any?
            ffiClosureImpl(returnType) { _ ->
                f()
            }
        }
        1 -> {
            val f = function as (Any?) -> Any?
            ffiClosureImpl(returnType) { args ->
                f(pt.read(args, 0))
            }
        }
        2 -> {","val f = function as (Any?, Any?) -> Any?"
"open class Base() {
    val plain = 239
    public val read : Int
      get() = 239

    public var readwrite : Int = 0
      get() = field + 1
      set(n : Int) {
        field = n
      }
}

interface Abstract {}

class Derived1() : Base(), Abstract {}
class Derived2() : Abstract, Base() {}

fun code(s : Base) : Int {
    if (s.plain != 239) return 1
    if (s.read != 239) return 2
    s.readwrite = 238
    if (s.readwrite != 239) return 3
    return 0
}

fun test(s : Base) : Boolean = code(s) == 0

fun box() : String {
    if (!test(Base())) return ""Fail #1""
    if (!test(Derived1())) return ""Fail #2""
    if (!test(Derived2())) return ""Fail #3""","return ""OK"""
"// EXPECTED_REACHABLE_NODES: 1286
package foo

// CHECK_NOT_CALLED: abs

inline fun abs(a: Int): Int {
    if (a < 0) {
        return a * -1
    } else {
        return a
    }
}

val r1 = abs(1)
val r2 = abs(-2)
val r3 = abs(3)
val r4 = abs(-4)

fun box(): String {
    assertEquals(1, r1)","assertEquals(2, r2)"
"loadedInProjectPath = projectPath

            val ext = project.rootProject.extensions.getByType(ExtraPropertiesExtension::class.java)

            if (!ext.has(loadedInProjectsPropertyName)) {
                ext.set(loadedInProjectsPropertyName, projectPath)
                onRegister()
            } else {
                ext.set(loadedInProjectsPropertyName, (ext.get(loadedInProjectsPropertyName) as String) + "";"" + loadedInProjectPath)
            }
        }
    }

    fun isInMultipleProjects(
        project: Project,
        kotlinPluginVersion: String? = null
    ): Boolean {
        require(trackPluginVersionsSeparately == (kotlinPluginVersion != null))
        return getAffectedProjects(project, kotlinPluginVersion)?.let {
            it.size > 1
        } ?: false
    }

    fun getAffectedProjects(
        project: Project,
        kotlinPluginVersion: String? = null
    ): List<String>? {
        require(trackPluginVersionsSeparately == (kotlinPluginVersion != null))

        val ext = getExt(project)

        val propertyName = getPropertyName(kotlinPluginVersion)

        if (!ext.has(propertyName)) {
            return null
        }

        return (ext.get(propertyName) as String).split("";"")
    }

    private fun getExt(project: Project): ExtraPropertiesExtension {
        return project.rootProject.extensions.getByType(ExtraPropertiesExtension::class.java)
    }

    private fun getPropertyName(version: String?): String {
        return listOfNotNull(
            ""kotlin"",
            ""plugin"",
            ""loaded"",
            ""in"",
            ""projects"",
            version
        )
            .joinToString(""."")
    }
}

const val MULTIPLE_KOTLIN_PLUGINS_LOADED_WARNING: String =
    ""The Kotlin Gradle plugin was loaded multiple times in different subprojects, which is not supported and may break the build. \n"" +

            ""This might happen in subprojects that apply the Kotlin plugins with the Gradle 'plugins { ... }' DSL if they specify "" +
            ""explicit versions, even if the versions are equal.\n"" +

            ""Please add the Kotlin plugin to the common parent project or the root project, then remove the versions in the subprojects.\n"" +","""If the parent project does not need the plugin, add 'apply false' to the plugin line.\n"" +"
"val analysisResult = if (doErrorCheck) {
                val codeLineForErrorCheck = nextCodeLine(code, lineCounter)

                var res: ReplAnalyzerResult?
                val timeMillis = measureTimeMillis {
                    res = compiler.analyze(codeLineForErrorCheck, SourceCode.Position(0, 0), newCompilationConfiguration).valueOrNull()
                }

                loggingInfo?.analyze?.writeValue(timeMillis)

                res
            } else {
                null
            } ?: ReplAnalyzerResult()

            val errorsSequence = analysisResult[ReplAnalyzerResult.analysisDiagnostics]!!
            val resultType = analysisResult[ReplAnalyzerResult.renderedResultType]

            if (doCompile) {
                val codeLineForCompilation = nextCodeLine(code, lineCounter)
                val compilationResult: ResultWithDiagnostics<LinkedSnippet<KJvmCompiledScript>>
                val timeMillis = measureTimeMillis {
                    compilationResult = compiler.compile(codeLineForCompilation, newCompilationConfiguration)
                }
                if (compilationResult is ResultWithDiagnostics.Failure) {
                    System.err.println(compilationResult.reports.joinToString(""\n"", ""Compilation failed:\n"") { it.toString() })
                }

                loggingInfo?.compile?.writeValue(timeMillis)
            }

            ActualResult(completionRes, errorsSequence.toList(), resultType).asSuccess()
        }
    }
}

private fun <T> checkLists(index: Int, checkName: String, expected: List<T>, actual: List<T>, options: ExpectedOptions<T>) {
    when (options.mode) {
        ComparisonType.EQUALS -> Assert.assertEquals(
            ""#$index ($checkName): Expected $expected, got $actual"",
            expected,
            actual
        )
        ComparisonType.INCLUDES -> Assert.assertTrue(
            ""#$index ($checkName): Expected $actual to include $expected"",
            actual.containsAll(expected)
        )
        ComparisonType.COMPARE_SIZE -> Assert.assertEquals(
            ""#$index ($checkName): Expected list size to be equal to ${options.size}, but was ${actual.size}"",
            options.size,
            actual.size
        )
        ComparisonType.CUSTOM -> options.checkFunction!!(actual)
        ComparisonType.DONT_CHECK -> {
        }
    }
}

private suspend fun checkEvaluateInRepl(
    compilationConfiguration: ScriptCompilationConfiguration,
    testData: List<Pair<RunRequest, ExpectedResult>>
) {
    val (snippets, expected) = testData.unzip()
    val expectedIter = expected.iterator()","evaluateInRepl(compilationConfiguration, snippets, AtomicInteger()).forEachIndexed { index, res ->"
"}
            storage.maxTypeDepthFromInitialConstraints = beforeMaxTypeDepthFromInitialConstraints
            storage.errors.trimToSize(beforeErrorsCount)
            storage.missedConstraints.trimToSize(beforeMissedConstraintsCount)
            storage.constraintsFromAllForkPoints.trimToSize(beforeConstraintsFromAllForks)

            val addedInitialConstraints = storage.initialConstraints.subList(
                beforeInitialConstraintCount,
                storage.initialConstraints.size
            )

            for (variableWithConstraint in storage.notFixedTypeVariables.values) {
                val sinceIndexToRemoveConstraints =
                    beforeConstraintCountByVariables[variableWithConstraint.typeVariable.freshTypeConstructor()]
                if (sinceIndexToRemoveConstraints != null) {
                    variableWithConstraint.removeLastConstraints(sinceIndexToRemoveConstraints)
                }
            }

            addedInitialConstraints.clear() // remove constraint from storage.initialConstraints
            closeTransaction(beforeState, beforeTypeVariablesTransactionSize)
        }
    }

    override fun prepareTransaction(): ConstraintSystemTransaction {
        checkState(State.BUILDING, State.COMPLETION, State.TRANSACTION)
        return TransactionState(
            beforeState = state,
            beforeInitialConstraintCount = storage.initialConstraints.size,
            beforeErrorsCount = storage.errors.size,
            beforeMaxTypeDepthFromInitialConstraints = storage.maxTypeDepthFromInitialConstraints,
            beforeTypeVariablesTransactionSize = typeVariablesTransaction.size,
            beforeMissedConstraintsCount = storage.missedConstraints.size,
            beforeConstraintCountByVariables = storage.notFixedTypeVariables.mapValues { it.value.rawConstraintsCount },
            beforeConstraintsFromAllForks = storage.constraintsFromAllForkPoints.size,
        ).also {
            state = State.TRANSACTION
        }
    }

    // ConstraintSystemBuilder, KotlinConstraintSystemCompleter.Context
    override val hasContradiction: Boolean
        get() = storage.hasContradiction.also {
            checkState(
                State.FREEZED,
                State.BUILDING,
                State.COMPLETION,
                State.TRANSACTION
            )
        }

    fun addOuterSystem(outerSystem: ConstraintStorage) {
        require(!storage.usesOuterCs)

        storage.usesOuterCs = true
        storage.outerSystemVariablesPrefixSize = outerSystem.allTypeVariables.size
        @OptIn(AssertionsOnly::class)
        storage.outerCS = outerSystem

        addOtherSystem(outerSystem, isAddingOuter = true)
    }

    @K2Only
    fun setBaseSystem(baseSystem: ConstraintStorage) {
        require(storage.allTypeVariables.isEmpty())",storage.usesOuterCs = baseSystem.usesOuterCs
"import org.jetbrains.kotlin.test.frontend.classic.ClassicFrontend2ClassicBackendConverter
import org.jetbrains.kotlin.test.frontend.classic.ClassicFrontend2IrConverter
import org.jetbrains.kotlin.test.frontend.classic.ClassicFrontendFacade
import org.jetbrains.kotlin.test.frontend.classic.ClassicFrontendOutputArtifact
import org.jetbrains.kotlin.test.frontend.fir.Fir2IrResultsConverter
import org.jetbrains.kotlin.test.frontend.fir.FirFrontendFacade
import org.jetbrains.kotlin.test.frontend.fir.FirOutputArtifact
import org.jetbrains.kotlin.test.model.*
import org.jetbrains.kotlin.test.runners.AbstractKotlinCompilerWithTargetBackendTest
import org.jetbrains.kotlin.test.services.SplittingModuleTransformerForBoxTests
import org.jetbrains.kotlin.utils.bind


@OptIn(TestInfrastructureInternals::class)
abstract class AbstractCompileKotlinAgainstInlineKotlinTestBase<R : ResultingArtifact.FrontendOutput<R>, I : ResultingArtifact.BackendInput<I>>(
    val targetFrontend: FrontendKind<R>,
    targetBackend: TargetBackend
) : AbstractKotlinCompilerWithTargetBackendTest(targetBackend) {
    abstract val frontendFacade: Constructor<FrontendFacade<R>>
    abstract val frontendToBackendConverter: Constructor<Frontend2BackendConverter<R, I>>
    abstract val backendFacade: Constructor<BackendFacade<I, BinaryArtifacts.Jvm>>
    open val directiveToSuppressTest: ValueDirective<TargetBackend> = IGNORE_BACKEND_MULTI_MODULE

    override fun TestConfigurationBuilder.configuration() {
        commonConfigurationForTest(targetFrontend, frontendFacade, frontendToBackendConverter, backendFacade)
        useInlineHandlers()
        configureCommonHandlersForBoxTest()
        useModuleStructureTransformers(
            SplittingModuleTransformerForBoxTests()
        )
        useAfterAnalysisCheckers(::BlackBoxCodegenSuppressor.bind(directiveToSuppressTest))
    }
}

open class AbstractCompileKotlinAgainstInlineKotlinTest :
    AbstractCompileKotlinAgainstInlineKotlinTestBase<ClassicFrontendOutputArtifact, ClassicBackendInput>(
        FrontendKinds.ClassicFrontend,
        TargetBackend.JVM
    ) {
    override val frontendFacade: Constructor<FrontendFacade<ClassicFrontendOutputArtifact>>
        get() = ::ClassicFrontendFacade

    override val frontendToBackendConverter: Constructor<Frontend2BackendConverter<ClassicFrontendOutputArtifact, ClassicBackendInput>>
        get() = ::ClassicFrontend2ClassicBackendConverter

    override val backendFacade: Constructor<BackendFacade<ClassicBackendInput, BinaryArtifacts.Jvm>>
        get() = ::ClassicJvmBackendFacade
}

open class AbstractIrCompileKotlinAgainstInlineKotlinTest(targetBackend: TargetBackend = TargetBackend.JVM_IR) :
    AbstractCompileKotlinAgainstInlineKotlinTestBase<ClassicFrontendOutputArtifact, IrBackendInput>(
        FrontendKinds.ClassicFrontend,
        targetBackend
    ) {
    override val frontendFacade: Constructor<FrontendFacade<ClassicFrontendOutputArtifact>>
        get() = ::ClassicFrontendFacade

    override val frontendToBackendConverter: Constructor<Frontend2BackendConverter<ClassicFrontendOutputArtifact, IrBackendInput>>
        get() = ::ClassicFrontend2IrConverter

    override val backendFacade: Constructor<BackendFacade<IrBackendInput, BinaryArtifacts.Jvm>>
        get() = ::JvmIrBackendFacade
}

private fun TestConfigurationBuilder.configureForSerialization() {",defaultDirectives {
"reporter,
                    when (context.session.languageVersionSettings.supportsFeature(LanguageFeature.ProhibitUseSiteGetTargetAnnotations)) {
                        true -> FirErrors.INAPPLICABLE_TARGET_ON_PROPERTY
                        false -> FirErrors.INAPPLICABLE_TARGET_ON_PROPERTY_WARNING
                    }
                )
            }
            FIELD -> {
                if (annotated is FirBackingField) {
                    val propertySymbol = annotated.propertySymbol
                    if (propertySymbol.delegateFieldSymbol != null && !propertySymbol.hasBackingField) {
                        reporter.reportOn(annotation.source, FirErrors.INAPPLICABLE_TARGET_PROPERTY_HAS_NO_BACKING_FIELD, context)
                    }
                }
            }
            PROPERTY_DELEGATE_FIELD -> {
                if (annotated is FirBackingField && annotated.propertySymbol.delegateFieldSymbol == null) {
                    reporter.reportOn(annotation.source, FirErrors.INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE, context)
                }
            }
            PROPERTY_SETTER,
            SETTER_PARAMETER -> {
                if (!checkPropertyGetter(annotated, annotation, target, context, reporter, FirErrors.INAPPLICABLE_TARGET_ON_PROPERTY) &&
                    !annotated.isVar
                ) {
                    reporter.reportOn(annotation.source, FirErrors.INAPPLICABLE_TARGET_PROPERTY_IMMUTABLE, target.renderName, context)
                }
            }
            CONSTRUCTOR_PARAMETER -> when {
                annotated is FirValueParameter -> {
                    val container = context.containingDeclarations.lastOrNull()
                    if (container is FirConstructor && container.isPrimary) {
                        if (annotated.source?.hasValOrVar() != true) {
                            reporter.reportOn(annotation.source, FirErrors.REDUNDANT_ANNOTATION_TARGET, target.renderName, context)
                        }
                    } else {
                        reporter.reportOn(annotation.source, FirErrors.INAPPLICABLE_PARAM_TARGET, context)
                    }
                }
                else -> reporter.reportOn(annotation.source, FirErrors.INAPPLICABLE_PARAM_TARGET, context)
            }
            FILE -> {
                // NB: report once?
                if (annotated !is FirFile) {
                    reporter.reportOn(annotation.source, FirErrors.INAPPLICABLE_FILE_TARGET, context)
                }
            }
            RECEIVER -> {
                // NB: report once?
                // annotation with use-site target `receiver` can be only on type reference, but not on declaration
                reporter.reportOn(
                    annotation.source, FirErrors.WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET, ""declaration"", target.renderName, context
                )
            }
        }
    }

    @OptIn(ExperimentalContracts::class)
    private fun checkPropertyGetter(
        annotated: FirAnnotationContainer,
        annotation: FirAnnotation,
        target: AnnotationUseSiteTarget,
        context: CheckerContext,
        reporter: DiagnosticReporter,
        diagnostic: KtDiagnosticFactory1<String>",): Boolean {
"""""""
                        dependencies {
                            implementation(""org.jetbrains.kotlin:kotlin-stdlib-js"")
                        }
                        """""".trimIndent().also { added = it }
            }

            build(""assemble"") {
                assertTasksUpToDate("":compileKotlinJs"")
            }

            buildGradleKts.modify {
                val replaced = it.replace(added!!, """")
                replaced + ""\n"" +
                        """"""
                        dependencies {
                            implementation(""org.jetbrains.kotlin:kotlin-dom-api-compat"")
                        }
                        """""".trimIndent().also { added = it }
            }

            build(""assemble"") {
                assertTasksUpToDate("":compileKotlinJs"")
            }

            buildGradleKts.modify {
                val replaced = it.replace(added!!, """")
                replaced + ""\n"" +
                        """"""
                        dependencies {
                            implementation(""org.jetbrains.kotlin:kotlin-stdlib-js"")
                            implementation(""org.jetbrains.kotlin:kotlin-dom-api-compat"")
                        }
                        """""".trimIndent().also { added = it }
            }

            build(""assemble"") {
                assertTasksUpToDate("":compileKotlinJs"")
            }
        }
    }

    @DisplayName(""Kotlin/JS DOM API automatically not added as dependency with disabled adding of stdlib"")
    @GradleTest
    fun testJsDomApiCompatWithDisabledAddingStdlib(gradleVersion: GradleVersion) {
        project(""kotlin-js-dom-api-compat"", gradleVersion) {
            var added: String? = null

            gradleProperties.modify {
                it + ""\n"" +
                        """"""
                        kotlin.stdlib.default.dependency=false
                        """""".trimIndent()
            }

            build(""assemble"") {
                assertTasksExecuted("":compileKotlinJs"")
            }

            buildGradleKts.modify {
                it + ""\n"" +
                        """"""
                        dependencies {
                            implementation(""org.jetbrains.kotlin:kotlin-stdlib-js"")
                        }",""""""".trimIndent().also { added = it }"
"// if the rhs is 0, that means that none of the parameters ended up getting used
                // in the body of the function which means we can simplify the expression quite a
                // bit. In this case we just care about if the low bit is non-zero
                if (rhs == 0) {
                    irNotEqual(
                        irAnd(
                            irGet(param),
                            irConst(1)
                        ),
                        irConst(0)
                    )
                } else {
                    // $dirty and (0b 101 ... 101 1) != (0b 001 ... 001 0)
                    irNotEqual(
                        irAnd(
                            irGet(param),
                            irConst(lhs or 0b1)
                        ),
                        irConst(rhs or 0b0)
                    )
                }
            }
            return if (expressions.size == 1)
                expressions.single()
            else
                expressions.reduce { lhs, rhs -> irOrOr(lhs, rhs) }
        }

        override fun irCopyToTemporary(
            nameHint: String?,
            isVar: Boolean,
            exactName: Boolean
        ): IrChangedBitMaskVariable {
            used = true
            val temps = params.mapIndexed { index, param ->
                IrVariableImpl(
                    UNDEFINED_OFFSET,
                    UNDEFINED_OFFSET,
                    // We label ""dirty"" as a defined variable instead of a temporary, so that it
                    // is properly stored in the locals table and discoverable by debuggers. The
                    // dirty variable encodes information that could be useful for tooling to
                    // interpret.
                    IrDeclarationOrigin.DEFINED,
                    IrVariableSymbolImpl(),
                    Name.identifier(if (index == 0) ""\$dirty"" else ""\$dirty$index""),
                    param.type,
                    isVar,
                    isConst = false,
                    isLateinit = false
                ).apply {
                    parent = currentFunctionScope.function.parent
                    initializer = irGet(param)
                }
            }
            return IrChangedBitMaskVariableImpl(temps, count)
        }

        override fun putAsValueArgumentInWithLowBit(
            fn: IrFunctionAccessExpression,
            startIndex: Int,
            lowBit: Boolean
        ) {
            used = true
            params.fastForEachIndexed { index, param ->",fn.putValueArgument(
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.psi2ir.generators

import org.jetbrains.kotlin.backend.common.CodegenUtil
import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.UNDEFINED_OFFSET
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.descriptors.IrImplementingDelegateDescriptorImpl
import org.jetbrains.kotlin.ir.expressions.IrBlockBody
import org.jetbrains.kotlin.ir.expressions.impl.IrCallImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrGetFieldImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrGetValueImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrReturnImpl
import org.jetbrains.kotlin.ir.expressions.typeParametersCount
import org.jetbrains.kotlin.ir.symbols.IrClassSymbol
import org.jetbrains.kotlin.ir.symbols.impl.IrFieldSymbolImpl
import org.jetbrains.kotlin.ir.types.IrSimpleType
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.psi.KtClassOrObject
import org.jetbrains.kotlin.psi.KtDelegatedSuperTypeEntry
import org.jetbrains.kotlin.psi.KtEnumEntry
import org.jetbrains.kotlin.psi.KtPureClassOrObject
import org.jetbrains.kotlin.psi.psiUtil.endOffset
import org.jetbrains.kotlin.psi.psiUtil.pureEndOffset
import org.jetbrains.kotlin.psi.psiUtil.pureStartOffset
import org.jetbrains.kotlin.psi.psiUtil.startOffsetSkippingComments
import org.jetbrains.kotlin.psi.synthetics.SyntheticClassOrObjectDescriptor
import org.jetbrains.kotlin.psi.synthetics.findClassDescriptor
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.DelegationResolver
import org.jetbrains.kotlin.resolve.DescriptorUtils
import org.jetbrains.kotlin.resolve.descriptorUtil.propertyIfAccessor
import org.jetbrains.kotlin.resolve.descriptorUtil.setSingleOverridden
import org.jetbrains.kotlin.resolve.scopes.DescriptorKindFilter
import org.jetbrains.kotlin.resolve.scopes.MemberScope
import org.jetbrains.kotlin.types.KotlinType
import org.jetbrains.kotlin.types.TypeProjectionImpl
import org.jetbrains.kotlin.types.TypeSubstitutor
import org.jetbrains.kotlin.types.error.ErrorTypeKind
import org.jetbrains.kotlin.types.error.ErrorUtils.createErrorType
import org.jetbrains.kotlin.utils.newHashMapWithExpectedSize

@ObsoleteDescriptorBasedAPI
internal class ClassGenerator(
    declarationGenerator: DeclarationGenerator
) : DeclarationGeneratorExtension(declarationGenerator) {","fun generateClass(ktClassOrObject: KtPureClassOrObject, visibility_: DescriptorVisibility? = null): IrClass {"
"expect(1, { listOf(1).minOrNull() })
        expect(2, { listOf(2, 3).minOrNull() })
        expect(2000000000000, { listOf(3000000000000, 2000000000000).minOrNull() })
        expect('a', { listOf('a', 'b').minOrNull() })
        expect(""a"", { listOf(""a"", ""b"").minOrNull() })
        expect(null, { listOf<Int>().asSequence().minOrNull() })
        expect(2, { listOf(2, 3).asSequence().minOrNull() })

        assertIsNegativeZero(listOf(0.0, -0.0).shuffled().minOrNull()!!)
        assertIsNegativeZero(listOf(0.0F, -0.0F).shuffled().minOrNull()!!.toDouble())
    }

    @Test fun max() {
        expect(null, { listOf<Int>().maxOrNull() })
        expect(1, { listOf(1).maxOrNull() })
        expect(3, { listOf(2, 3).maxOrNull() })
        expect(3000000000000, { listOf(3000000000000, 2000000000000).maxOrNull() })
        expect('b', { listOf('a', 'b').maxOrNull() })
        expect(""b"", { listOf(""a"", ""b"").maxOrNull() })
        expect(null, { listOf<Int>().asSequence().maxOrNull() })
        expect(3, { listOf(2, 3).asSequence().maxOrNull() })

        assertIsPositiveZero(listOf(0.0, -0.0).shuffled().maxOrNull()!!)
        assertIsPositiveZero(listOf(0.0F, -0.0F).shuffled().maxOrNull()!!.toDouble())
    }

    @Test fun minWithOrNull() {
        expect(null, { listOf<Int>().minWithOrNull(naturalOrder()) })
        expect(1, { listOf(1).minWithOrNull(naturalOrder()) })
        expect(""a"", { listOf(""a"", ""B"").minWithOrNull(STRING_CASE_INSENSITIVE_ORDER) })
        expect(""a"", { listOf(""a"", ""B"").asSequence().minWithOrNull(STRING_CASE_INSENSITIVE_ORDER) })
    }

    @Test fun maxWithOrNull() {
        expect(null, { listOf<Int>().maxWithOrNull(naturalOrder()) })
        expect(1, { listOf(1).maxWithOrNull(naturalOrder()) })
        expect(""B"", { listOf(""a"", ""B"").maxWithOrNull(STRING_CASE_INSENSITIVE_ORDER) })
        expect(""B"", { listOf(""a"", ""B"").asSequence().maxWithOrNull(STRING_CASE_INSENSITIVE_ORDER) })
    }

    @Test fun minByOrNull() {
        expect(null, { listOf<Int>().minByOrNull { it } })
        expect(1, { listOf(1).minByOrNull { it } })
        expect(3, { listOf(2, 3).minByOrNull { -it } })
        expect('a', { listOf('a', 'b').minByOrNull { ""x$it"" } })
        expect(""b"", { listOf(""b"", ""abc"").minByOrNull { it.length } })
        expect(null, { listOf<Int>().asSequence().minByOrNull { it } })
        expect(3, { listOf(2, 3).asSequence().minByOrNull { -it } })
    }

    @Test fun maxByOrNull() {
        expect(null, { listOf<Int>().maxByOrNull { it } })
        expect(1, { listOf(1).maxByOrNull { it } })
        expect(2, { listOf(2, 3).maxByOrNull { -it } })
        expect('b', { listOf('a', 'b').maxByOrNull { ""x$it"" } })
        expect(""abc"", { listOf(""b"", ""abc"").maxByOrNull { it.length } })
        expect(null, { listOf<Int>().asSequence().maxByOrNull { it } })
        expect(2, { listOf(2, 3).asSequence().maxByOrNull { -it } })
    }

    @Test fun minByOrNullEvaluateOnce() {
        var c = 0
        expect(1, { listOf(5, 4, 3, 2, 1).minByOrNull { c++; it * it } })
        assertEquals(5, c)
        c = 0","expect(1, { listOf(5, 4, 3, 2, 1).asSequence().minByOrNull { c++; it * it } })"
"}
        copy.excludeFromJsExport(session)
        return listOf(copy.symbol)
    }

    private fun generateSerializerFactoryVararg(
        owner: FirClassSymbol<*>,
        callableId: CallableId,
        original: FirSimpleFunction
    ): FirNamedFunctionSymbol =
        createMemberFunction(owner, SerializationPluginKey, callableId.callableName, original.returnTypeRef.coneType) {
            val vpo = original.valueParameters.single()
            valueParameter(vpo.name, vpo.returnTypeRef.coneType, vpo.isCrossinline, vpo.isNoinline, vpo.isVararg, vpo.defaultValue != null)
        }.apply {
            excludeFromJsExport(session)
        }.symbol

    private fun generateSerializerGetterInCompanion(
        owner: FirClassSymbol<*>,
        serializableClassSymbol: FirClassSymbol<*>,
        callableId: CallableId
    ): FirNamedFunctionSymbol {
        val function = createMemberFunction(
            owner,
            SerializationPluginKey,
            callableId.callableName,
            returnTypeProvider = { typeParameters ->
                val parametersAsArguments = typeParameters.map { it.toConeType() }.toTypedArray<ConeTypeProjection>()
                kSerializerId.constructClassLikeType(
                    arrayOf(serializableClassSymbol.constructType(parametersAsArguments, false)),
                    isNullable = false
                )
            }
        ) {
            serializableClassSymbol.typeParameterSymbols.forEachIndexed { i, typeParameterSymbol ->
                typeParameter(typeParameterSymbol.name)
                valueParameter(
                    Name.identifier(""${SerialEntityNames.typeArgPrefix}$i""),
                    { typeParameters ->
                        kSerializerId.constructClassLikeType(arrayOf(typeParameters[i].toConeType()), false)
                    }
                )
            }
        }

        function.excludeFromJsExport(session)

        return function.symbol
    }

    override fun generateProperties(callableId: CallableId, context: MemberGenerationContext?): List<FirPropertySymbol> {
        val owner = context?.owner ?: return emptyList()
        if (!owner.isSerializer) return emptyList()
        if (callableId.callableName != SerialEntityNames.SERIAL_DESC_FIELD_NAME) return emptyList()

        val target = getFromSupertype(callableId, owner) { it.getProperties(callableId.callableName).filterIsInstance<FirPropertySymbol>() }
        val property = createMemberProperty(
            owner,
            SerializationPluginKey,
            callableId.callableName,
            target.resolvedReturnType
        )

        property.excludeFromJsExport(session)",return listOf(property.symbol)
"// SPLIT_PER_MODULE
// EXPECTED_REACHABLE_NODES: 1287
// MODULE: lib
// FILE: lib.kt
package lib

val foo = 23

val boo: Int
    get() = 42

external val bar: Int = definedExternally

external val far: Int
    get() = definedExternally

// TODO: annotations like this are not serialized properly. Uncomment after KT-14529 gets fixed
/*
val fuzz: Int
    @JsName(""getBuzz"") get() = 55
    */

inline fun fetchFoo() = foo

@JsName(""fee"")
val tee = 2525

// FILE: lib.js

var bar = 99",var far = 111
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.asJava.elements

import com.intellij.psi.PsiAnnotation
import com.intellij.psi.PsiElement
import com.intellij.psi.PsiModifierList
import com.intellij.psi.PsiModifierListOwner
import com.intellij.util.IncorrectOperationException
import org.jetbrains.kotlin.asJava.classes.lazyPub
import org.jetbrains.kotlin.psi.KtModifierList
import org.jetbrains.kotlin.psi.KtModifierListOwner

abstract class KtLightModifierList<out T : KtLightElement<KtModifierListOwner, PsiModifierListOwner>>(
    protected val owner: T
) : KtLightElementBase(owner), PsiModifierList, KtLightElement<KtModifierList, PsiModifierList> {
    private val _annotations by lazyPub {
        val annotations = computeAnnotations()
        annotationsFilter?.let(annotations::filter) ?: annotations
    }

    protected open val annotationsFilter: ((KtLightAbstractAnnotation) -> Boolean)? = null

    override val kotlinOrigin: KtModifierList?
        get() = owner.kotlinOrigin?.modifierList

    override fun getParent() = owner

    override fun hasExplicitModifier(name: String) = hasModifierProperty(name)

    private fun throwInvalidOperation(): Nothing = throw IncorrectOperationException()

    override fun setModifierProperty(name: String, value: Boolean): Unit = throwInvalidOperation()

    override fun checkSetModifierProperty(name: String, value: Boolean): Unit = throwInvalidOperation()

    override fun addAnnotation(qualifiedName: String): PsiAnnotation = throwInvalidOperation()

    override fun getApplicableAnnotations(): Array<out PsiAnnotation> = annotations

    override fun getAnnotations(): Array<out PsiAnnotation> = _annotations.toTypedArray()",override fun findAnnotation(qualifiedName: String) = _annotations.firstOrNull { it.fqNameMatches(qualifiedName) }
"fun test5(): String {
    val foo: (Any) -> String = ({ b: Any ->
        val a: (Any) -> String = ::baz
        a(b)
    })::cux
    return foo(3)
}

inline fun <reified T, K, reified S> bak(value1: T, value2: K, value3: S): String = ""OK"" + value1 + value2 + value3

fun test6(): String {
    val f: (Any, Int, String) -> String = ::bak
    return f(1, 37, ""joo"")
}

inline fun <reified T, K> bal(value1: Array<K>, value2: Array<T>): String = ""OK"" + value1.joinToString() + value2.joinToString()

fun test7(): String {
    val f: (Array<Any>, Array<Int>) -> String = ::bal
    return f(arrayOf(""mer"", ""nas""), arrayOf(73, 37))
}

class E<T>
public inline fun <reified T> E<T>.foo(value: T): String = ""OK"" + value

class F<T1> {
    inline fun <reified T2> foo(x: T1, y: T2): Any? = ""OK"" + x + y
}

inline fun <reified T, K> bam(value1: K?, value2: T?): String = ""OK"" + value1.toString() + value2.toString()

fun <T> test10(): String {
    val f: (T?, String?) -> String = ::bam
    return f(null, ""abc"")
}

inline fun <T> test11Impl() : String {
    val f: (T?, String?) -> String = ::bam
    return f(null, ""def"")
}

fun <T> test11() = test11Impl<T>()


fun box(): String {
    val test1 = test()
    if (test1 != ""OK1"") return ""fail1: $test1""
    val test2 = test2()
    if (test2 != ""123OK"") return ""fail2: $test2""
    val test3 = test3()
    if (test3 != ""321OK"") return ""fail3: $test3""
    val test4 = test4()
    if (test4 != ""OK456"") return ""fail4: $test4""
    val test5 = test5()
    if (test5 != ""OK3"") return ""fail5: $test5""
    val test6 = test6()
    if (test6 != ""OK137joo"") return ""fail6: $test6""
    val test7 = test7()
    if (test7 != ""OKmer, nas73, 37"") return ""fail7: $test7""
    val test8 = E<Int>().foo(56)
    if (test8 != ""OK56"") return ""fail8: $test8""
    val test9 = F<Int>().foo(65, ""hello"")
    if (test9 != ""OK65hello"") return ""fail9: $test9""
    val test10 = test10<Int>()
    if (test10 != ""OKnullabc"") return ""fail10: $test10""",val test11 = test11<Int>()
"private inner class ProjectStepsExecutor(
        private val projectInfo: ProjectInfo,
        private val moduleInfos: Map<String, ModuleInfo>,
        private val testDir: File,
        private val sourceDir: File,
        private val buildDir: File,
        private val jsDir: File,
    ) {
        private inner class TestStepInfo(
            val moduleName: String,
            val modulePath: String,
            val friends: List<String>,
            val expectedFileStats: Map<String, Set<String>>,
            val expectedDTS: ExpectedFile?,
        )

        private inner class ExpectedFile(val name: String, val content: String)

        private fun setupTestStep(projStep: ProjectInfo.ProjectBuildStep, module: String): TestStepInfo {
            val projStepId = projStep.id
            val moduleTestDir = File(testDir, module)
            val moduleSourceDir = File(sourceDir, module)
            val moduleInfo = moduleInfos[module] ?: error(""No module info found for $module"")
            val moduleStep = moduleInfo.steps.getValue(projStepId)
            for (modification in moduleStep.modifications) {
                modification.execute(moduleTestDir, moduleSourceDir) {}
            }

            val outputKlibFile = resolveModuleArtifact(module, buildDir)

            val friends = mutableListOf<File>()
            if (moduleStep.rebuildKlib) {
                val dependencies = mutableListOf(File(STDLIB_KLIB), File(KOTLIN_TEST_KLIB))
                for (dep in moduleStep.dependencies) {
                    val klibFile = resolveModuleArtifact(dep.moduleName, buildDir)
                    dependencies += klibFile
                    if (dep.isFriend) {
                        friends += klibFile
                    }
                }
                val configuration = createConfiguration(module, projStep.language, projectInfo.moduleKind)
                configuration.enableKlibRelativePaths(moduleSourceDir)
                outputKlibFile.delete()
                buildKlib(configuration, module, moduleSourceDir, dependencies, friends, outputKlibFile)
            }

            val dtsFile = moduleStep.expectedDTS.ifNotEmpty {
                moduleTestDir.resolve(singleOrNull() ?: error(""$module module may generate only one d.ts at step $projStepId""))
            }
            return TestStepInfo(
                module.safeModuleName,
                outputKlibFile.canonicalPath,
                friends.map { it.canonicalPath },
                moduleStep.expectedFileStats,
                dtsFile?.let { ExpectedFile(moduleStep.expectedDTS.single(), it.readText()) }
            )
        }

        private fun verifyCacheUpdateStats(stepId: Int, stats: KotlinSourceFileMap<EnumSet<DirtyFileState>>, testInfo: List<TestStepInfo>) {
            val gotStats = stats.filter { it.key.path != STDLIB_KLIB && it.key.path != KOTLIN_TEST_KLIB }

            val checkedLibs = mutableSetOf<KotlinLibraryFile>()

            for (info in testInfo) {
                val libFile = KotlinLibraryFile(info.modulePath)",val updateStatus = gotStats[libFile] ?: emptyMap()
"// WITH_STDLIB
// WORKS_WHEN_VALUE_CLASS
// LANGUAGE: +ValueClasses

OPTIONAL_JVM_INLINE_ANNOTATION",value class UInt(private val u: Int) {
"* 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.internal.InlineOnly
public inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {
    if (isEmpty()) return null
    var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }
    return maxValue
}

/**
 * Returns the largest value among all values produced by [selector] function
 * applied to each element in the array or `null` if there are no elements.
 * 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.internal.InlineOnly
public inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {
    if (isEmpty()) return null
    var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }
    return maxValue
}

/**
 * Returns the largest value among all values produced by [selector] function
 * applied to each element in the array or `null` if there are no elements.
 * 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.internal.InlineOnly
public inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {
    if (isEmpty()) return null
    var maxValue = selector(this[0])
    for (i in 1..lastIndex) {
        val v = selector(this[i])
        maxValue = maxOf(maxValue, v)
    }
    return maxValue
}

/**
 * Returns the largest value among all values produced by [selector] function
 * applied to each element in the array or `null` if there are no elements.
 * 
 * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)",@OverloadResolutionByLambdaReturnType
"fun main(args: Array<<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Anno<!> String>) {}

annotation class Anno

fun Int.train(args: Array<<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Anno<!> String>) {}

fun Int.plane(<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@receiver:Anno<!> args: Array<String>) {}

fun vein(args: Array<<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@file:Anno<!> String>) {}

fun rain(args: Array<<!WRONG_ANNOTATION_TARGET!>@Anno<!> String>) {}

fun <!WRONG_ANNOTATION_TARGET!>@Anno<!> Int.strain() {}

fun @receiver:Anno Int.drain() {}",fun <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@file:Anno<!> Int.brain() {}
"synthetic = true
                        callee.name?.let { sideEffects = it.sideEffects }
                    }
                    qualifier = fqn.extractToTemporary()
                    qualifier = Namer.getFunctionCallRef(qualifier)
                    arguments.add(0, receiverTmp)
                    matchedIndices = matchedIndices.map { it + 1 }
                }
                else {
                    qualifier = qualifier.extractToTemporary()
                }
            }
        }

        processByIndices(arguments, matchedIndices)
    }

    private fun processByIndices(elements: MutableList<JsExpression>, matchedIndices: List<Int>) {
        var prev = 0
        for (curr in matchedIndices) {
            for (i in prev..curr-1) {
                val arg = elements[i]
                if (arg !in containsNodeWithSideEffect) continue

                elements[i] = arg.extractToTemporary()
            }

            elements[curr] = accept(elements[curr])
            prev = curr
        }
    }

    inline
    private fun <T> withNewAdditionalStatements(fn: ()->T): T {
        val backup = additionalStatements
        additionalStatements = SmartList<JsStatement>()
        val result = fn()
        additionalStatements = backup
        return result
    }

    private fun addStatement(statement: JsStatement) =
            additionalStatements.add(statement)

    private fun addStatements(statements: List<JsStatement>) =
            additionalStatements.addAll(statements)

    private fun addStatements(index: Int, statements: List<JsStatement>) =
            additionalStatements.addAll(index, statements)

    private fun JsExpression.extractToTemporary(): JsExpression {
        val tmp = Temporary(this)
        addStatement(tmp.variable)
        return tmp.nameRef
    }

    private inner class Temporary(val value: JsExpression? = null, val sourceInfo: Any? = null) {
        val name: JsName = JsScope.declareTemporary()

        val variable: JsVars = newVar(name, value).apply {
            synthetic = true
            name.staticRef = value
            source = sourceInfo ?: value?.source
        }",val nameRef: JsExpression
"// WITH_STDLIB

@file:JvmName(""TestKt"")
package test

import kotlinx.parcelize.*
import android.os.Parcel
import android.os.Parcelable

enum class Color {
    BLACK, WHITE
}

@Parcelize
data class Test(val name: String, val color: Color) : Parcelable

fun box() = parcelTest { parcel ->
    val test = Test(""John"", Color.WHITE)
    test.writeToParcel(parcel, 0)

    val bytes = parcel.marshall()
    parcel.unmarshall(bytes, 0, bytes.size)
    parcel.setDataPosition(0)

    val test2 = parcelableCreator<Test>().createFromParcel(parcel)",assert(test == test2)
"eliminateDeadDeclarations(allModules, backendContext, dceDumpNameCache)
            }

            dumpDeclarationIrSizesIfNeed(arguments.irDceDumpDeclarationIrSizesToFile, allModules, dceDumpNameCache)

            val res = compileWasm(
                allModules = allModules,
                backendContext = backendContext,
                typeScriptFragment = typeScriptFragment,
                baseFileName = outputName,
                emitNameSection = arguments.wasmDebug,
                allowIncompleteImplementations = arguments.irDce,
                    generateWat = configuration.get(WasmConfigurationKeys.WASM_GENERATE_WAT, false),
                generateSourceMaps = generateSourceMaps,
            )
            performanceManager?.notifyIRGenerationFinished()
            performanceManager?.notifyGenerationFinished()

            writeCompilationResult(
                result = res,
                dir = outputDir,
                fileNameBase = outputName,
            )

            return OK
        } else {
            if (arguments.irDceDumpReachabilityInfoToFile != null) {
                messageCollector.report(STRONG_WARNING, ""Dumping the reachability info to file is supported only for Kotlin/Wasm."")
            }
            if (arguments.irDceDumpDeclarationIrSizesToFile != null) {
                messageCollector.report(STRONG_WARNING, ""Dumping the size of declarations to file is supported only for Kotlin/Wasm."")
            }
        }

        val start = System.currentTimeMillis()

        try {
            val ir2JsTransformer = Ir2JsTransformer(arguments, module, phaseConfig, messageCollector, mainCallArguments)
            val outputs = ir2JsTransformer.compileAndTransformIrNew()

            messageCollector.report(INFO, ""Executable production duration: ${System.currentTimeMillis() - start}ms"")

            outputs.writeAll(outputDir, outputName, arguments.dtsStrategy, moduleName, moduleKind)
        } catch (e: CompilationException) {
            messageCollector.report(
                ERROR,
                e.stackTraceToString(),
                CompilerMessageLocation.create(
                    path = e.path,
                    line = e.line,
                    column = e.column,
                    lineContent = e.content
                )
            )
            return INTERNAL_ERROR
        }

        return OK
    }

    private fun produceSourceModule(
        configuration: CompilerConfiguration,
        environmentForJS: KotlinCoreEnvironment,
        libraries: List<String>,
        friendLibraries: List<String>,","arguments: K2JSCompilerArguments,"
"// Auto-generated by GenerateInRangeExpressionTestData. Do not edit!
// WITH_STDLIB



val range0 = 1L until 3L
val range1 = 3L until 1L

val element0 = (-1).toByte()
val element1 = (-1).toShort()
val element2 = -1
val element3 = -1L
val element4 = 0.toByte()
val element5 = 0.toShort()
val element6 = 0
val element7 = 0L
val element8 = 1.toByte()
val element9 = 1.toShort()
val element10 = 1
val element11 = 1L
val element12 = 2.toByte()
val element13 = 2.toShort()
val element14 = 2",val element15 = 2L
"// !LANGUAGE: +ProhibitAssigningSingleElementsToVarargsInNamedForm

annotation class Ann1(vararg val a: String = [])
annotation class Ann2(vararg val a: Int = [1, 2])
annotation class Ann3(vararg val a: Float = [1f])
annotation class Ann4(vararg val a: String = [""/""])

annotation class Ann5(vararg val a: Ann4 = [])
annotation class Ann6(vararg val a: Ann4 = [Ann4(*[""a"", ""b""])])","annotation class Ann7(vararg val a: Long = [1L, <!NULL_FOR_NONNULL_TYPE!>null<!>, <!ARGUMENT_TYPE_MISMATCH!>""""<!>])"
"@Test
    fun testInnerClass() = checkApi(
        """"""
            interface A {
                fun b() {}
            }
            class C {
                val foo = 1
                inner class D : A {
                    override fun b() {
                        print(foo)
                    }
                }
            }
        """""",
    )

    @Test
    fun testFunInterfaces() = checkApi(
        """"""
            fun interface A {
                fun compute(value: Int): Unit
            }
            fun Example(a: A) {
                a.compute(123)
            }
            fun Usage() {
                Example { it -> it + 1 }
            }
        """""",
    )

    @Test
    fun testComposableFunInterfaces() = checkApi(
        """"""
            fun interface A {
                @Composable fun compute(value: Int): Unit
            }
            fun Example(a: A) {
                Example { it -> a.compute(it) }
            }
        """""",
    )

    @Test
    fun testFunInterfacesInComposableCall() = checkApi(
        """"""
            fun interface MeasurePolicy {
                fun compute(value: Int): Unit
            }

            @NonRestartableComposable
            @Composable fun Text() {
                Layout { value ->
                    println(value)
                }
            }

            @Composable inline fun Layout(policy: MeasurePolicy) {
                policy.compute(0)
            }
        """""",
    )",@Test
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.kapt3.base.incremental

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import java.io.File
import java.util.zip.ZipEntry
import java.util.zip.ZipOutputStream

class IncrementalProcessorDiscoveryTest {

    private val markerFileContent = """"""
                    Input1Processor1,AGGREGATING
                    Input1Processor2,ISOLATING
                    Input1Processor3,DYNAMIC
                    Input1Processor4,UNKNOWN
                    Input1Processor5 this is malformed input
            """""".trimIndent()

    @Test
    fun locateInJars(@TempDir tmp: File) {
        val inputJar = tmp.resolve(""inputJar.jar"")",ZipOutputStream(inputJar.outputStream()).use {
"package properties

@Target(
    AnnotationTarget.TYPE,
    AnnotationTarget.PROPERTY,
    AnnotationTarget.VALUE_PARAMETER,
    AnnotationTarget.FIELD,
    AnnotationTarget.PROPERTY_SETTER,
    AnnotationTarget.PROPERTY_GETTER,
)
annotation class Anno(val position: String)
const val constant = 0

class MyClass(
    @property:Anno(""property $constant"")
    @get:Anno(""get $constant"")
    @set:Anno(""set $constant"")
    @setparam:Anno(""set $constant"")
    @field:Anno(""field $constant"")
    @param:Anno(""param $constant"")","var pr<caret>operty: @Anno(""parameter type: $constant"") List<@Anno(""nested parameter type: $constant"") List<@Anno(""nested nested parameter type: $constant"") Int>>,"
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package templates

import templates.DocExtensions.collection
import templates.Family.*
import templates.Ordering.appendStableSortNote
import templates.Ordering.stableSortNote

object ArrayOps : TemplateGroupBase() {

    init {
        defaultBuilder {
            specialFor(ArraysOfUnsigned) {
                sinceAtLeast(""1.3"")
                annotation(""@ExperimentalUnsignedTypes"")
            }
        }
    }

    val f_isEmpty = fn(""isEmpty()"") {
        include(ArraysOfObjects, ArraysOfPrimitives)
    } builder {",inlineOnly()
"// FIR_IDENTICAL
// ISSUE: KT-67810
// DIAGNOSTICS: -NOTHING_TO_INLINE
// WITH_STDLIB

@Retention(AnnotationRetention.SOURCE)
internal annotation class A(val value: Value) {
    enum class Value {
        X, Y
    }
}

@A(A.Value.X)",inline fun foo() {
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.expressions.impl

import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.declarations.FirAnonymousFunction
import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.expressions.FirAnonymousFunctionExpression
import org.jetbrains.kotlin.fir.expressions.RawFirApi
import org.jetbrains.kotlin.fir.expressions.UnresolvedExpressionTypeAccess
import org.jetbrains.kotlin.fir.types.ConeKotlinType
import org.jetbrains.kotlin.fir.types.coneTypeOrNull
import org.jetbrains.kotlin.fir.visitors.FirTransformer
import org.jetbrains.kotlin.fir.visitors.FirVisitor
import org.jetbrains.kotlin.utils.addToStdlib.shouldNotBeCalled

@OptIn(UnresolvedExpressionTypeAccess::class)
internal class FirAnonymousFunctionExpressionImpl(
    override val source: KtSourceElement?,
    override var anonymousFunction: FirAnonymousFunction,
    override var isTrailingLambda: Boolean,
) : FirAnonymousFunctionExpression() {

    @UnresolvedExpressionTypeAccess
    override val coneTypeOrNull: ConeKotlinType?
        get() = anonymousFunction.typeRef.coneTypeOrNull

    override val annotations: List<FirAnnotation>",get() = anonymousFunction.annotations
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.dependencies

import org.gradle.api.Plugin",import org.gradle.api.Project
"}
    }

    private val changedUntrackedJavaClasses = mutableSetOf<ClassId>()

    private var javaFilesProcessor =
        if (!usePreciseJavaTracking)
            ChangedJavaFilesProcessor(reporter) { psiFileProvider.javaFile(it) }
        else
            null

    override fun calculateSourcesToCompile(
        caches: IncrementalJvmCachesManager,
        changedFiles: ChangedFiles.Known,
        args: K2JVMCompilerArguments,
        messageCollector: MessageCollector,
        classpathAbiSnapshots: Map<String, AbiSnapshot>
    ): CompilationMode {
        return try {
            calculateSourcesToCompileImpl(caches, changedFiles, args, messageCollector, classpathAbiSnapshots, icFeatures.withAbiSnapshot)
        } finally {
            this.messageCollector.flush(messageCollector)
            this.messageCollector.clear()
        }
    }

    //TODO can't use the same way as for build-history files because abi-snapshot for all dependencies should be stored into last-build
    // and not only changed one
    // (but possibly we dont need to read it all and may be it is possible to update only those who was changed)
    override fun setupJarDependencies(args: K2JVMCompilerArguments, reporter: BuildReporter<GradleBuildTime, GradleBuildPerformanceMetric>): Map<String, AbiSnapshot> {
        //fill abiSnapshots
        val abiSnapshots = HashMap<String, AbiSnapshot>()
        args.classpathAsList
            .filter { it.extension.equals(""jar"", ignoreCase = true) }
            .forEach {
                modulesApiHistory.abiSnapshot(it).let { result ->
                    if (result is Either.Success<Set<File>>) {
                        result.value.forEach { file ->
                            if (file.exists()) {
                                abiSnapshots[it.absolutePath] = AbiSnapshotImpl.read(file)
                            } else {
                                // FIXME: We should throw an exception here
                                reporter.warn { ""Snapshot file does not exist: ${file.path}. Continue anyway."" }
                            }
                        }
                    }
                }
            }
        return abiSnapshots
    }

    // There are 2 steps where we need to load the current classpath snapshot and shrink it:
    //   - Before classpath diffing when `classpathChanges` is ToBeComputedByIncrementalCompiler (see `calculateSourcesToCompileImpl`)
    //   - After compilation (see `performWorkAfterSuccessfulCompilation`)
    // To avoid duplicated work, we store the snapshots after the first step for reuse (if the first step is executed).
    private var currentClasspathSnapshot: List<AccessibleClassSnapshot>? = null
    private var shrunkCurrentClasspathAgainstPreviousLookups: List<AccessibleClassSnapshot>? = null

    private fun calculateSourcesToCompileImpl(
        caches: IncrementalJvmCachesManager,
        changedFiles: ChangedFiles.Known,
        args: K2JVMCompilerArguments,
        messageCollector: MessageCollector,
        abiSnapshots: Map<String, AbiSnapshot>,
        withAbiSnapshot: Boolean",): CompilationMode {
"val layoutPaths = File(path)
            .listFiles { file -> file.name.startsWith(""layout"") && file.isDirectory }!!
            .map { ""$path${it.name}/"" }
        myEnvironment = createTestEnvironment(configuration, layoutPaths)
    }

    fun doCompileAgainstAndroidSdkTest(path: String) {
        createAndroidAPIEnvironment(path)
        doMultiFileTest(path)
    }

    fun doFakeInvocationTest(path: String) {
        if (needsInvocationTest(path)) {
            createFakeAndroidEnvironment(path)
            doMultiFileTest(path, getFakeFiles(path))
        }
    }

    override fun getClassPathURLs(): Array<URL> {
        return myEnvironment.configuration.jvmClasspathRoots.map { it.toURI().toURL() }.toTypedArray()
    }

    private fun getFakeFiles(path: String): Collection<String> {
        return FileUtil.findFilesByMask(Pattern.compile(""^Fake.*\\.kt$""), File(path.replace(getTestName(true), """")))
            .map { relativePath(it) }
    }

    private fun needsInvocationTest(path: String): Boolean {
        return FileUtil.findFilesByMask(Pattern.compile(""^0.kt$""), File(path)).isNotEmpty()
    }

    override fun codegenTestBasePath(): String {
        return ""plugins/android-extensions/android-extensions-compiler/testData/codegen/""
    }

    private fun doMultiFileTest(path: String, additionalFiles: Collection<String>? = null) {
        val files = mutableListOf<String>()
        FileUtil.processFilesRecursively(File(path)) { file ->
            when (file!!.name) {
                ""1.kt"" -> {
                    if (additionalFiles == null) files.add(relativePath(file))
                }
                ""0.kt"" -> {
                    if (additionalFiles != null) files.add(relativePath(file))
                }
                else -> {
                    if (file.name.endsWith("".kt"")) files.add(relativePath(file))
                }
            }
            true
        }

        for (file in File(""plugins/android-extensions/android-extensions-runtime/src"").walk()) {
            if (file.extension == ""kt"") files += relativePath(file.absoluteFile)
        }

        files.sort()
        if (additionalFiles != null) {
            files.addAll(additionalFiles)
        }
        myFiles = CodegenTestFiles.create(
            myEnvironment!!.project,
            ArrayUtil.toStringArray(files),
            KtTestUtil.getHomeDirectory() + ""/plugins/android-extensions/android-extensions-compiler/testData""
        )",blackBox(true)
"incrementalCache.updateSourceFileMetadata(srcFile, updatedHeader)
                }
            }
        }

        fun buildAndCommitCacheArtifacts(loadedIr: LoadedJsIr): Map<KotlinLibraryFile, IncrementalCacheArtifact> {
            removedIncrementalCaches.forEach {
                if (!it.cacheDir.deleteRecursively()) {
                    icError(""can not delete cache directory ${it.cacheDir.absolutePath}"")
                }
            }

            val stubbedSignatures = loadedIr.collectSymbolsReplacedWithStubs().mapNotNullTo(hashSetOf()) { it.signature }
            return libraryDependencies.keys.associate { library ->
                val libFile = KotlinLibraryFile(library)
                val incrementalCache = getLibIncrementalCache(libFile)
                val providers = loadedIr.getSignatureProvidersForLib(libFile)
                val signatureToIndexMapping = providers.associate { it.srcFile to it.getSignatureToIndexMapping() }

                val cacheArtifact = incrementalCache.buildAndCommitCacheArtifact(signatureToIndexMapping, stubbedSignatures)

                val libFragment = loadedIr.loadedFragments[libFile] ?: notFoundIcError(""loaded fragment"", libFile)
                val sourceNames = loadedIr.getIrFileNames(libFragment)
                val sourceFilesFromCache = cacheArtifact.getSourceFiles()
                for (irFile in libFragment.files) {
                    val srcName = sourceNames[irFile] ?: notFoundIcError(""source file name"", libFile, irFile)
                    if (srcName !in sourceFilesFromCache) {
                        // IC doesn't support cases when extra IrFiles (which don't exist in klib) are added into IrModuleFragment
                        icError(""file ${irFile.fileEntry.name} is absent in incremental cache and klib"", libFile)
                    }
                }

                libFile to cacheArtifact
            }
        }
    }

    private fun commitCacheAndBuildModuleArtifacts(
        incrementalCacheArtifacts: Map<KotlinLibraryFile, IncrementalCacheArtifact>,
        moduleNames: Map<KotlinLibraryFile, String>,
        rebuiltFileFragments: KotlinSourceFileMap<JsIrProgramFragments>
    ): List<ModuleArtifact> = stopwatch.measure(""Incremental cache - committing artifacts"") {
        incrementalCacheArtifacts.map { (libFile, incrementalCacheArtifact) ->
            incrementalCacheArtifact.buildModuleArtifactAndCommitCache(
                moduleName = moduleNames[libFile] ?: notFoundIcError(""module name"", libFile),
                rebuiltFileFragments = rebuiltFileFragments[libFile] ?: emptyMap()
            )
        }
    }

    private fun compileDirtyFiles(
        compilerForIC: JsIrCompilerICInterface,
        loadedIr: LoadedJsIr,
        dirtyFiles: Map<KotlinLibraryFile, Set<KotlinSourceFile>>
    ): MutableList<Triple<KotlinLibraryFile, KotlinSourceFile, () -> JsIrProgramFragments>> =
        stopwatch.measure(""Processing IR - lowering"") {
            val dirtyFilesForCompiling = mutableListOf<IrFile>()
            val dirtyFilesForRestoring = mutableListOf<Pair<KotlinLibraryFile, KotlinSourceFile>>()
            for ((libFile, libFragment) in loadedIr.loadedFragments) {
                val dirtySrcFiles = dirtyFiles[libFile] ?: continue
                val sourceNames = loadedIr.getIrFileNames(libFragment)
                for (irFile in libFragment.files) {
                    val srcFile = sourceNames[irFile] ?: notFoundIcError(""source file name"", libFile, irFile)
                    if (srcFile in dirtySrcFiles) {
                        dirtyFilesForCompiling += irFile",dirtyFilesForRestoring += libFile to srcFile
"// TARGET_BACKEND: JVM

// WITH_STDLIB

package foo

import kotlin.reflect.KClass

class A<T>
class B<T, Y, U>

class TestRaw {",val a1: A<Nothing> = A()
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.native

import org.gradle.util.GradleVersion
import org.jetbrains.kotlin.gradle.testbase.*
import org.jetbrains.kotlin.konan.target.HostManager
import org.jetbrains.kotlin.konan.target.KonanTarget
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.condition.OS
import kotlin.test.fail

@OsCondition(supportedOn = [OS.MAC], enabledOnCI = [OS.MAC])
@DisplayName(""Tests for Apple Silicon builds"")
@NativeGradlePluginTests",class AppleSiliconIT : KGPBaseTest() {
"val CDATA_SECTION_NODE: Short
        val ENTITY_REFERENCE_NODE: Short
        val ENTITY_NODE: Short
        val PROCESSING_INSTRUCTION_NODE: Short
        val COMMENT_NODE: Short
        val DOCUMENT_NODE: Short
        val DOCUMENT_TYPE_NODE: Short
        val DOCUMENT_FRAGMENT_NODE: Short
        val NOTATION_NODE: Short
        val DOCUMENT_POSITION_DISCONNECTED: Short
        val DOCUMENT_POSITION_PRECEDING: Short
        val DOCUMENT_POSITION_FOLLOWING: Short
        val DOCUMENT_POSITION_CONTAINS: Short
        val DOCUMENT_POSITION_CONTAINED_BY: Short
        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short
    }
}

/**
 * Exposes the JavaScript [SVGDescElement](https://developer.mozilla.org/en/docs/Web/API/SVGDescElement) to Kotlin
 */
public external abstract class SVGDescElement : SVGElement, JsAny {
    companion object {
        val ELEMENT_NODE: Short
        val ATTRIBUTE_NODE: Short
        val TEXT_NODE: Short
        val CDATA_SECTION_NODE: Short
        val ENTITY_REFERENCE_NODE: Short
        val ENTITY_NODE: Short
        val PROCESSING_INSTRUCTION_NODE: Short
        val COMMENT_NODE: Short
        val DOCUMENT_NODE: Short
        val DOCUMENT_TYPE_NODE: Short
        val DOCUMENT_FRAGMENT_NODE: Short
        val NOTATION_NODE: Short
        val DOCUMENT_POSITION_DISCONNECTED: Short
        val DOCUMENT_POSITION_PRECEDING: Short
        val DOCUMENT_POSITION_FOLLOWING: Short
        val DOCUMENT_POSITION_CONTAINS: Short
        val DOCUMENT_POSITION_CONTAINED_BY: Short
        val DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: Short
    }
}

/**
 * Exposes the JavaScript [SVGMetadataElement](https://developer.mozilla.org/en/docs/Web/API/SVGMetadataElement) to Kotlin
 */
public external abstract class SVGMetadataElement : SVGElement, JsAny {
    companion object {
        val ELEMENT_NODE: Short
        val ATTRIBUTE_NODE: Short
        val TEXT_NODE: Short
        val CDATA_SECTION_NODE: Short
        val ENTITY_REFERENCE_NODE: Short
        val ENTITY_NODE: Short
        val PROCESSING_INSTRUCTION_NODE: Short
        val COMMENT_NODE: Short
        val DOCUMENT_NODE: Short
        val DOCUMENT_TYPE_NODE: Short
        val DOCUMENT_FRAGMENT_NODE: Short
        val NOTATION_NODE: Short
        val DOCUMENT_POSITION_DISCONNECTED: Short
        val DOCUMENT_POSITION_PRECEDING: Short
        val DOCUMENT_POSITION_FOLLOWING: Short
        val DOCUMENT_POSITION_CONTAINS: Short",val DOCUMENT_POSITION_CONTAINED_BY: Short
"fun foo(x: String): String? = x

fun calc(x: String?): Int {
    // Smart cast because of x!! in receiver
    foo(x!!)?.subSequence(0, <!DEBUG_INFO_SMARTCAST!>x<!>.length)?.length
    // Smart cast because of x!! in receiver",return <!DEBUG_INFO_SMARTCAST!>x<!>.length
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

package org.jetbrains.kotlin.fir.declarations

import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.FirElement
import org.jetbrains.kotlin.fir.FirModuleData
import org.jetbrains.kotlin.fir.expressions.FirAnnotation",import org.jetbrains.kotlin.fir.references.FirControlFlowGraphReference
"// !DIAGNOSTICS: -UNUSED_EXPRESSION

import kotlin.reflect.KProperty

class Delegate() {
    @Deprecated(""text"")
    operator fun getValue(instance: Any, property: KProperty<*>) : Int = 1

    @Deprecated(""text"")
    operator fun setValue(instance: Any, property: KProperty<*>, value: Int) {}
}

class Delegate2() {
    operator fun getValue(instance: Any, property: KProperty<*>) : Int = 1
    operator fun setValue(instance: Any, property: KProperty<*>, value: Int) {}
}",class DelegateProvider() {
"}

    @Test
    @TestMetadata(""withSpaces.kt"")
    fun testWithSpaces() {
        val srcDir = interopDir.resolve(""withSpaces"")
        val mapfile = buildDir.resolve(""cutom map.map"").also { it.delete() }
        val mapOption = when {
            targets.testTarget.family.isAppleFamily -> ""-map \""${buildDir.absolutePath}/cutom map.map\""""
            targets.testTarget.family == Family.MINGW -> ""\""-Wl,--Map,${buildDir.absolutePath}/cutom map.map\""""
            else -> ""--Map \""${buildDir.absolutePath}/cutom map.map\""""
        }
        val withSpacesDef = buildDir.resolve(""withSpaces.def"").also {
            it.printWriter().use {
                it.println(
                    """"""
                    headers = stdio.h ""${srcDir.absolutePath}/custom headers/custom.h""
                    linkerOpts = $mapOption
                    ---
    
                    int customCompare(const char* str1, const char* str2) {
                        return custom_strcmp(str1, str2);
                    }
                """""".trimIndent()
                )
            }
        }

        val (testCase, success) = compileDefAndKtToExecutable(
            testName = ""withSpaces"",
            defFile = withSpacesDef,
            ktFiles = listOf(srcDir.resolve(""withSpaces.kt"")),
            freeCompilerArgs = TestCompilerArgs(""-opt-in=kotlinx.cinterop.ExperimentalForeignApi""),
            extras = TestCase.NoTestRunnerExtras(""main""),
        )

        val testExecutable = TestExecutable(
            success.resultingArtifact,
            success.loggedData,
            listOf(TestName(""interop_objc_tests""))
        )
        runExecutableAndVerify(testCase, testExecutable)
        assertTrue(mapfile.exists())
    }

    private fun compileDefAndKtToExecutable(
        testName: String,
        defFile: File,
        ktFiles: Collection<File>,
        freeCompilerArgs: TestCompilerArgs,
        extras: TestCase.Extras,
        checks: TestRunChecks = TestRunChecks.Default(testRunSettings.get<Timeouts>().executionTimeout),
    ): Pair<TestCase, TestCompilationResult.Success<out TestCompilationArtifact.Executable>> {
        val cinteropModule = TestModule.Exclusive(""cinterop"", emptySet(), emptySet(), emptySet())
        cinteropModule.files += TestFile.createCommitted(defFile, cinteropModule)

        val ktModule = TestModule.Exclusive(""main"", setOf(""cinterop""), emptySet(), emptySet())
        ktFiles.forEach { ktModule.files += TestFile.createCommitted(it, ktModule) }

        val testKind = when (extras) {
            is TestCase.NoTestRunnerExtras -> TestKind.STANDALONE_NO_TR
            is TestCase.WithTestRunnerExtras -> TestKind.STANDALONE
        }
        val testCase = TestCase(
            id = TestCaseId.Named(testName),","kind = testKind,"
"}
    <!UNREACHABLE_CODE!>println(""1"")<!>
}

// TESTCASE NUMBER: 2
fun case_2() {
    funWithAtLeastOnceCallsInPlace {
        throw Exception()
    }
    <!UNREACHABLE_CODE!>println(""1"")<!>
}

// TESTCASE NUMBER: 3
fun case_3() {
    funWithExactlyOnceCallsInPlace {
        return
    }
    <!UNREACHABLE_CODE!>println(""1"")<!>
}

// TESTCASE NUMBER: 4
fun case_4() {
    funWithAtLeastOnceCallsInPlace {
        return
    }
    <!UNREACHABLE_CODE!>println(""1"")<!>
}

// TESTCASE NUMBER: 5
fun case_5(args: Array<String>) {
    fun nestedFun_1() {
        funWithAtLeastOnceCallsInPlace {
            return@nestedFun_1
        }
        <!UNREACHABLE_CODE!>println(""1"")<!>
    }
    fun nestedFun_2() {
        args.forEach {
            funWithAtLeastOnceCallsInPlace {
                return@forEach
            }
            <!UNREACHABLE_CODE!>println(""1"")<!>
        }
    }
    fun nestedFun_3() {
        fun nestedFun_4() {
            funWithAtLeastOnceCallsInPlace {
                return@nestedFun_4
            }
            <!UNREACHABLE_CODE!>println(""1"")<!>
        }
        println(""1"")
    }
}

// TESTCASE NUMBER: 6
fun case_6(args: Array<String>) {
    args.forEach {
        funWithExactlyOnceCallsInPlace {
            return@forEach
        }
        <!UNREACHABLE_CODE!>println(""1"")<!>
    }
    args.forEach {
        fun nestedFun_1() {",funWithExactlyOnceCallsInPlace {
"filterOutShadowedDescriptors(flag)
                    }
                }
                expect {
                    completions.size = expectedSize
                }
            }
    }

    @Test
    fun testImplicitExtensions() = test {
        run {
            code = """"""
                class A {
                    fun String.foooo() = 42
                }
            """""".trimIndent()
            doCompile
        }
        run {
            code = """"""
                with(A()) {
                    with(""bar"") {
                        foo
                    }
                }
            """""".trimIndent()
            cursor = code.indexOf(""foo"") + 3
            expect {
                completions.mode = ComparisonType.EQUALS
                addCompletion(""foooo()"", ""foooo()"", ""Int"", ""method"")
            }
        }
    }

    @Test
    fun testDefaultImports() = test {
        run(setupDefaultImportsCompletionRun)
    }

    @Test
    fun testImportCompletion() = test {
        run {
            code = """"""
                import kotl
            """""".trimIndent()
            cursor = 11
            expect {
                completions.mode = ComparisonType.INCLUDES
                addCompletion(""kotlin"", ""kotlin"", ""package kotlin"", ""package"")
            }
        }
    }

    @Test
    fun testProtectedInheritedMemberCompletion() = test {
        run {
            code = """"""
                open class Base {
                    private val xyz1: Float = 7.0f
                    protected val xyz2: Int = 42
                    internal val xyz3: String = """"
                    public val xyz4: Byte = 8
                }
            """""".trimIndent()",doCompile
"class A

class B

private fun Any.test(): Int = when {
    this is A && <expr>a</expr> -> 10",this is B && b -> 2
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.backend.konan.objcexport

import org.jetbrains.kotlin.backend.konan.InternalKotlinNativeApi

sealed interface ObjCExportName {
    val swiftName: String
    val objCName: String
}

interface ObjCExportClassOrProtocolName : ObjCExportName {
    val binaryName: String
}

interface ObjCExportPropertyName : ObjCExportName

interface ObjCExportFunctionName : ObjCExportName

interface ObjCExportFileName : ObjCExportName

fun ObjCExportClassOrProtocolName(
    swiftName: String,
    objCName: String,","binaryName: String = objCName,"
"@Serializable(NestedEnumWithCustomSerializer::class)
    enum class NestedEnumWithCustom {
        A,
        B,
    }

    @Serializable(NestedEnumWithCustomClSerializer::class)
    enum class NestedEnumWithCustomCl {
        A,
        B,
    }

    enum class NestedEnumWithContextual {
        A,
        B,
    }

    enum class NestedEnumWithUseContextual {
        A,
        B,
    }

    enum class NestedEnumWithUse {
        A,
        B,
    }

}

class Outer {
}

object EnumWithCustomSerializer: ToDoSerializer<EnumWithCustom>(""custom|EnumWithCustom"")
object NestedEnumWithCustomSerializer: ToDoSerializer<Container.NestedEnumWithCustom>(""custom|Container.NestedEnumWithCustom"")
class EnumWithCustomClSerializer: ToDoSerializer<EnumWithCustomCl>(""custom|EnumWithCustomCl"")
class NestedEnumWithCustomClSerializer: ToDoSerializer<Container.NestedEnumWithCustomCl>(""custom|Container.NestedEnumWithCustomCl"")

object EnumWithContextualSerializer: ToDoSerializer<EnumWithContextual>(""contextual|EnumWithContextual"")
object NestedEnumWithContextualSerializer: ToDoSerializer<Container.NestedEnumWithContextual>(""contextual|Container.NestedEnumWithContextual"")
object EnumWithUseContextualSerializer: ToDoSerializer<EnumWithUseContextual>(""contextual|EnumWithUseContextual"")
object NestedEnumWithUseContextualSerializer: ToDoSerializer<Container.NestedEnumWithUseContextual>(""contextual|Container.NestedEnumWithUseContextual"")

class EnumWithUseSerializer: ToDoSerializer<EnumWithUse>(""useSerializer|EnumWithUse"")
class NestedEnumWithUseSerializer: ToDoSerializer<Container.NestedEnumWithUse>(""useSerializer|Container.NestedEnumWithUse"")

@kotlinx.serialization.SerialInfo
@Target(AnnotationTarget.CLASS, AnnotationTarget.PROPERTY)
annotation class Extra(val value: String)

fun box(): String {
    val module = SerializersModule {
        contextual(EnumWithContextualSerializer)
        contextual(NestedEnumWithContextualSerializer)
        contextual(EnumWithUseContextualSerializer)
        contextual(NestedEnumWithUseContextualSerializer)
    }
    
    serializer<EnumWithDef>().checkElements(""A"", ""B"")
    serializer<Container.NestedEnumWithDef>().checkElements(""A"", ""B"")
    serializer<Enum>().checkElements(""A"", ""B"")
    serializer<Container.NestedEnum>().checkElements(""A"", ""B"")
    serializer<EnumWithCustom>().checkElements(""A"", ""B"")
    serializer<Container.NestedEnumWithCustom>().checkElements(""A"", ""B"")
    serializer<EnumWithCustomCl>().checkElements(""A"", ""B"")","serializer<Container.NestedEnumWithCustomCl>().checkElements(""A"", ""B"")"
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.jvm.checkers.declaration

import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext",import org.jetbrains.kotlin.fir.analysis.checkers.declaration.FirSimpleFunctionChecker
"// FIR_IDENTICAL
// JSPECIFY_STATE: strict
// DIAGNOSTICS: -UNUSED_PARAMETER

// FILE: NullUnmarkedType.java

import org.jspecify.annotations.*;

@NullUnmarked
public interface NullUnmarkedType {

    @NullMarked
    public interface NullMarkedType {
        public String unannotatedProduce();
        public void unannotatedConsume(String arg);
    }

    public interface UnannotatedType {
        @NullMarked
        public String nullMarkedProduce();
        @NullMarked
        public void nullMarkedConsume(String arg);
    }

}

// FILE: NullUnmarkedTypeWithNullMarkedConstructor.java

import org.jspecify.annotations.*;

@NullUnmarked
public class NullUnmarkedTypeWithNullMarkedConstructor {
    @NullMarked
    public NullUnmarkedTypeWithNullMarkedConstructor(String arg) {}
}

// FILE: kotlin.kt

interface TestA: NullUnmarkedType.NullMarkedType {
    // jspecify_nullness_mismatch
    override fun unannotatedProduce(): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>String?<!>
}

interface TestB: NullUnmarkedType.UnannotatedType {
    // jspecify_nullness_mismatch
    override fun nullMarkedProduce(): <!RETURN_TYPE_MISMATCH_ON_OVERRIDE!>String?<!>
}",fun test(
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin

import com.android.build.gradle.BaseExtension
import org.gradle.api.Named
import org.gradle.api.NamedDomainObjectContainer
import org.gradle.api.Project
import org.gradle.api.file.SourceDirectorySet
import org.gradle.api.model.ObjectFactory
import org.gradle.tooling.provider.model.ToolingModelBuilderRegistry
import org.jetbrains.kotlin.gradle.plugin.internal.*
import org.jetbrains.kotlin.gradle.targets.js.nodejs.UnameExecutor
import javax.inject.Inject

private const val PLUGIN_VARIANT_NAME = ""gradle74""

open class KotlinPluginWrapper @Inject constructor(
    registry: ToolingModelBuilderRegistry
) : AbstractKotlinPluginWrapper(registry) {

    override val pluginVariant: String = PLUGIN_VARIANT_NAME

    override fun apply(project: Project) {
        project.registerVariantImplementations()
        super.apply(project)
    }
}

open class KotlinCommonPluginWrapper @Inject constructor(
    registry: ToolingModelBuilderRegistry
) : AbstractKotlinCommonPluginWrapper(registry) {

    override val pluginVariant: String = PLUGIN_VARIANT_NAME

    override fun apply(project: Project) {
        project.registerVariantImplementations()
        super.apply(project)
    }
}",open class KotlinAndroidPluginWrapper @Inject constructor(
"""""
    }
    val ret4 = build {
        emit(1)
        emit(null)
        val x = get()
        if (x == null) {
            x.hashCode()
        }

        """"
    }
    val ret401 = build {
        emit(1)
        emit(null)
        val x = get()
        if (x == null) {
            x.equals("""")
        }

        """"
    }
    val ret402 = build {
        emit(1)
        emit(null)
        val x = get()
        if (x == null) {
            x.<!NONE_APPLICABLE!>toString<!>("""")
        }

        """"
    }
    val ret403 = build {
        emit(1)
        emit(null)
        val x = get()
        if (x == null) {
            x.test()
        }

        """"
    }
    val ret404 = build {
        emit(1)
        emit(null)
        val x = get()
        if (x === null) {
            x.hashCode()
        }

        """"
    }
    val ret405 = build {
        emit(1)
        emit(null)
        val x = get()
        if (x === null) {
            x.equals("""")
        }

        """"
    }
    val ret406 = build {
        emit(1)",emit(null)
"/*
 * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.platform.wasm

import org.jetbrains.kotlin.platform.TargetPlatform
import org.jetbrains.kotlin.platform.toTargetPlatform
import org.jetbrains.kotlin.platform.WasmPlatform as CoreWasmPlatform

abstract class WasmPlatform(platformName: String) : CoreWasmPlatform(platformName) {
    override val oldFashionedDescription: String
        get() = ""Wasm""
}

object WasmPlatformUnspecifiedTarget : WasmPlatform(""Wasm"") {
    override val targetName: String
        get() = ""general""
}

class WasmPlatformWithTarget(val target: WasmTarget) : WasmPlatform(target.alias) {
    override val targetName: String
        get() = target.name
}

object WasmPlatforms {
    private val platforms: Map<WasmTarget, TargetPlatform> =
        WasmTarget.entries.associateWith { WasmPlatformWithTarget(it).toTargetPlatform() }

    @Suppress(""DEPRECATION_ERROR"")
    val unspecifiedWasmPlatform: TargetPlatform
        get() = Default

    val wasmJs = platforms[WasmTarget.JS]!!
    val wasmWasi = platforms[WasmTarget.WASI]!!",fun wasmPlatformByTargetVersion(targetVersion: WasmTarget): TargetPlatform =
"private fun maybeGetAptCacheFromFile(): IncrementalAptCache {

        return if (aptCacheFile.exists()) {
            try {
                ObjectInputStream(BufferedInputStream(aptCacheFile.inputStream())).use {
                    it.readObject() as IncrementalAptCache
                }
            } catch (e: Throwable) {
                // cache corrupt
                IncrementalAptCache()
            }
        } else {
            IncrementalAptCache()
        }
    }

    private fun maybeGetJavaCacheFromFile(): JavaClassCache {
        return if (javaCacheFile.exists()) {
            try {
                ObjectInputStream(BufferedInputStream(javaCacheFile.inputStream())).use {
                    it.readObject() as JavaClassCache
                }
            } catch (e: Throwable) {
                JavaClassCache()
            }
        } else {
            JavaClassCache()
        }
    }

    override fun close() {
        if (closed) return

        with(javaCacheFile) {
            delete()
            parentFile.mkdirs()
            ObjectOutputStream(BufferedOutputStream(outputStream())).use {
                it.writeObject(javaCache)
            }
        }

        with(aptCacheFile) {
            delete()
            parentFile.mkdirs()
            ObjectOutputStream(BufferedOutputStream(outputStream())).use {
                it.writeObject(aptCache)
            }
        }

        closed = true
    }
}

sealed class SourcesToReprocess {
    class Incremental(
        val toReprocess: List<File>,
        val dirtyTypes: Set<String>,
        val unchangedAggregatedTypes: List<String>
    ) : SourcesToReprocess()

    object FullRebuild : SourcesToReprocess()
}

/** Returns if specified root dirs have at least [required] number of class files. */
private fun checkMinNumberOfClassFiles(roots: List<File>, required: Int): Boolean {",var currentlyMissing = required
"/*
 * Copyright 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package androidx.compose.compiler.plugins.kotlin

import org.jetbrains.kotlin.config.CompilerConfiguration
import org.junit.Assume.assumeFalse
import org.junit.Assume.assumeTrue
import org.junit.Ignore
import org.junit.Test",class LiveLiteralV2TransformTests(useFir: Boolean) : AbstractLiveLiteralTransformTests(useFir) {
"// !CHECK_TYPE

fun foo(s : String?, b : Boolean) {
    if (s == null) return

    val s1 = if (b) """" else s
    s1 checkType { _<String>() }

    val s2 = s",s2 checkType { _<String>() }
"// FIR_IDENTICAL
// FILE: J.java",public interface J {
"// SKIP_KT_DUMP
// FIR_IDENTICAL
// TARGET_BACKEND: JVM
// FULL_JDK
// WITH_STDLIB

// FILE: Java1.java
import java.util.*;
public class Java1 {
    public void foo(List<? extends Number> a) { }
    public List<? extends Number> bar(){
        return null;
    }
    public void foo2(List<? super Number> a) { }
    public List<? super Number> bar2(){
        return null;
    }

    public void foo3(List<?> a) {}
    public List<?> bar3(){
        return null;
    }
}

// FILE: Java2.java
public class Java2 extends Java1 { }

// FILE: Java3.java
import java.util.ArrayList;
import java.util.List;

public class Java3 extends Java1 {
    @Override
    public void foo(List<? extends Number> a) { }
    @Override
    public List<? extends Number> bar(){
        return new ArrayList<Integer>(1);
    }
    @Override
    public void foo2(List<? super Number> a) { }
    @Override
    public List<? super Number> bar2(){
        return new ArrayList<Number>(1);
    }
    @Override",public void foo3(List<?> a) {}
"// FIR_IDENTICAL
import kotlinx.cinterop.*

@Suppress(""DEPRECATION"")",fun bar(x: Float) = x.signExtend<Int>()
"import org.gradle.api.tasks.TaskContainer
import org.gradle.api.tasks.TaskProvider

import org.gradle.kotlin.dsl.*
import org.gradle.kotlin.dsl.accessors.runtime.*


/**
 * Adds a dependency to the 'testCompileOnly' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`testCompileOnly`(dependencyNotation: Any): Dependency? =
    add(""testCompileOnly"", dependencyNotation)

/**
 * Adds a dependency to the 'testCompileOnly' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`testCompileOnly`(
    dependencyNotation: String,
    dependencyConfiguration: Action<ExternalModuleDependency>
): ExternalModuleDependency = addDependencyTo(
    this, ""testCompileOnly"", dependencyNotation, dependencyConfiguration
) as ExternalModuleDependency

/**
 * Adds a dependency to the 'testCompileOnly' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`testCompileOnly`(
    dependencyNotation: Provider<*>,
    dependencyConfiguration: Action<ExternalModuleDependency>
): Unit = addConfiguredDependencyTo(
    this, ""testCompileOnly"", dependencyNotation, dependencyConfiguration
)

/**
 * Adds a dependency to the 'testCompileOnly' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`testCompileOnly`(
    dependencyNotation: ProviderConvertible<*>,",dependencyConfiguration: Action<ExternalModuleDependency>
"import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.js.backend.ast.*
import org.jetbrains.kotlin.js.translate.context.Namer
import org.jetbrains.kotlin.js.translate.context.TranslationContext
import org.jetbrains.kotlin.js.translate.general.AbstractTranslator
import org.jetbrains.kotlin.js.translate.utils.JsAstUtils
import org.jetbrains.kotlin.resolve.DescriptorUtils
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameSafe

class EnumTranslator(
        context: TranslationContext,
        val descriptor: ClassDescriptor,
        val entries: List<ClassDescriptor>,
        private val psi: PsiElement
) : AbstractTranslator(context) {
    fun generateStandardMethods() {
        generateValuesFunction()
        generateValueOfFunction()
    }

    private fun generateValuesFunction() {
        val function = createFunction(DescriptorUtils.getFunctionByName(descriptor.staticScope, StandardNames.ENUM_VALUES))

        val values = entries.map {
            JsInvocation(JsAstUtils.pureFqn(context().getNameForObjectInstance(it), null)).source(psi)
        }
        function.body.statements += JsReturn(JsArrayLiteral(values).source(psi)).apply { source = psi }
    }

    private fun generateValueOfFunction() {
        val function = createFunction(DescriptorUtils.getFunctionByName(descriptor.staticScope, StandardNames.ENUM_VALUE_OF))

        val nameParam = JsScope.declareTemporaryName(""name"")
        function.parameters += JsParameter(nameParam)

        val clauses = entries.map { entry ->
            JsCase().apply {
                caseExpression = JsStringLiteral(entry.name.asString()).source(psi)
                statements += JsReturn(JsInvocation(JsAstUtils.pureFqn(context().getNameForObjectInstance(entry), null)).source(psi))
                        .apply { source = psi }
                source = psi
            }
        }

        val message = JsBinaryOperation(JsBinaryOperator.ADD,
                                        JsStringLiteral(""No enum constant ${descriptor.fqNameSafe}.""),
                                        nameParam.makeRef())
        val throwFunction = context().getReferenceToIntrinsic(Namer.THROW_ILLEGAL_ARGUMENT_EXCEPTION_FUN_NAME)
        val throwStatement = JsExpressionStatement(JsInvocation(throwFunction, message).source(psi))

        if (clauses.isNotEmpty()) {
            val defaultCase = JsDefault().apply {
                statements += throwStatement
                source = psi
            }
            function.body.statements += JsSwitch(nameParam.makeRef().source(psi), clauses + defaultCase).apply { source = psi }
        }
        else {
            function.body.statements += throwStatement
        }
    }

    private fun createFunction(functionDescriptor: FunctionDescriptor): JsFunction {
        val function = context().getFunctionObject(functionDescriptor)",function.name = context().getInnerNameForDescriptor(functionDescriptor)
"/*
 * Copyright 2000-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve

import com.google.common.collect.Lists
import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.builtins.StandardNames
import org.jetbrains.kotlin.config.LanguageFeature
import org.jetbrains.kotlin.config.LanguageVersionSettings
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.descriptors.PropertyDescriptor
import org.jetbrains.kotlin.descriptors.VariableAccessorDescriptor
import org.jetbrains.kotlin.descriptors.VariableDescriptorWithAccessors
import org.jetbrains.kotlin.diagnostics.Errors.*
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.renderer.DescriptorRenderer
import org.jetbrains.kotlin.resolve.BindingContext.*
import org.jetbrains.kotlin.resolve.calls.util.getCall
import org.jetbrains.kotlin.resolve.calls.util.getCalleeExpressionIfAny
import org.jetbrains.kotlin.resolve.calls.util.getResolvedCall
import org.jetbrains.kotlin.resolve.calls.checkers.OperatorCallChecker
import org.jetbrains.kotlin.resolve.calls.components.InferenceSession
import org.jetbrains.kotlin.resolve.calls.components.PostponedArgumentsAnalyzer
import org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext
import org.jetbrains.kotlin.resolve.calls.context.CheckArgumentTypesMode
import org.jetbrains.kotlin.resolve.calls.context.ContextDependency
import org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem
import org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystemCompleter
import org.jetbrains.kotlin.resolve.calls.inference.components.EmptySubstitutor
import org.jetbrains.kotlin.resolve.calls.inference.components.KotlinConstraintSystemCompleter
import org.jetbrains.kotlin.resolve.calls.inference.components.NewTypeSubstitutorByConstructorMap
import org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind.FROM_COMPLETER
import org.jetbrains.kotlin.resolve.calls.inference.model.TypeVariableTypeConstructor
import org.jetbrains.kotlin.resolve.calls.inference.toHandle
import org.jetbrains.kotlin.resolve.calls.model.KotlinCallComponents
import org.jetbrains.kotlin.resolve.calls.model.ResolvedCall
import org.jetbrains.kotlin.resolve.calls.model.resultCallAtom
import org.jetbrains.kotlin.resolve.calls.results.OverloadResolutionResults
import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo
import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory
import org.jetbrains.kotlin.resolve.calls.tower.PSICallResolver
import org.jetbrains.kotlin.resolve.calls.util.CallMaker
import org.jetbrains.kotlin.resolve.constants.IntegerLiteralTypeConstructor
import org.jetbrains.kotlin.resolve.scopes.LexicalScope",import org.jetbrains.kotlin.resolve.scopes.ScopeUtils
"// TARGET_BACKEND: JVM
// WITH_REFLECT

import kotlin.test.assertEquals

var global = S("""")

inline class S(val x: String?) {
    var nonNullTest: S
        get() = S(""${global.x}$x"")
        set(value) {
            global = S(""${value.x}$x"")
        }

    var nullableTest: S?
        get() = S(""${global.x}$x"")
        set(value) {
            global = S(""${value!!.x}$x"")
        }
}

inline class Z(val x: Int) {
    var nonNullTest: S
        get() = S(""${global.x}$x"")
        set(value) {
            global = S(""${value.x}$x"")
        }

    var nullableTest: S?
        get() = S(""${global.x}$x"")
        set(value) {
            global = S(""${value!!.x}$x"")
        }
}

inline class A(val x: Any) {
    var nonNullTest: S
        get() = S(""${global.x}$x"")
        set(value) {","global = S(""${value.x}$x"")"
"// WITH_STDLIB

@file:JvmName(""TestKt"")
package test

import kotlinx.android.parcel.*
import android.os.Parcel
import android.os.Parcelable

@Parcelize
data class Test(
        val a: Map<String, String>,
        val b: Map<String?, String>,
        val c: Map<String, String?>,
        val d: Map<String, Map<Int, String>>,
        val e: Map<Int?, List<String>>,
        val f: Map<Boolean, Boolean>,
        val g: Map<String, Map<String, Map<String, String>>>
) : Parcelable

fun box() = parcelTest { parcel ->
    val first = Test(
            a = mapOf(""A"" to ""B"", ""C"" to ""D""),
            b = mapOf(""A"" to ""B"", null to ""D"", ""E"" to ""F""),
            c = mapOf(""A"" to null, ""C"" to ""D""),
            d = mapOf(""A"" to mapOf(1 to """", 2 to ""x"")),
            e = mapOf(1 to listOf("""", """"), null to listOf()),
            f = mapOf(true to false, false to true),
            g = mapOf(""A"" to mapOf(""B"" to mapOf(""C"" to ""D"", ""E"" to ""F"")))
    )

    first.writeToParcel(parcel, 0)",val bytes = parcel.marshall()
"funT()
            funAny()
            funNullableT()
            funNullableAny()
            ip1test1()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.ip1test1()
        }
        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>also<!> {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.ip1test1()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>it<!>.funNullableAny()
        }
    }
}

/*
 * TESTCASE NUMBER: 17
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28785
 */
fun <T: InterfaceWithTypeParameter1<in T>?> T.case_17() {
    if (this != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T""), DEBUG_INFO_SMARTCAST!>this<!>.ip1test1()

        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>equals<!>(this)
        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>ip1test1<!>()
        <!DEBUG_INFO_IMPLICIT_RECEIVER_SMARTCAST!>apply<!> {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>
            equals(null)
            propT
            propAny
            propNullableT
            propNullableAny
            funT()
            funAny()
            funNullableT()
            funNullableAny()
            ip1test1()","<!DEBUG_INFO_EXPRESSION_TYPE(""T & Any""), DEBUG_INFO_EXPRESSION_TYPE(""T & Any"")!>this<!>.equals(null)"
"// FIR_IDENTICAL
fun foo(init: A.() -> Unit) { }

class A {
    var x: Int = 0
    companion object {
        val f = foo() {
            x = 1
        }
    }
}

class B(val a: String) {
    fun f() = 0
    companion object   {
        fun B.bar() = a + f()
    }
}

open class C {
    fun bar() {}
}

class E: C() {

    class D {",init {
"// SKIP_INLINE_CHECK_IN: inlineFun$default
// FILE: 1.kt
// CHECK_CONTAINS_NO_CALLS: test TARGET_BACKENDS=JS",package test
"// WITH_STDLIB

enum class TestEnum1 {
    TEST1, TEST2
}

enum class TestEnum2(val x: Int) {
    TEST1(1),
    TEST2(2),
    TEST3(3) {}
}

enum class TestEnum3 {
    TEST {
        override fun foo() {
            println(""Hello, world!"")
        }
    }
    ;
    abstract fun foo()
}

enum class TestEnum4(val x: Int) {
    TEST1(1) {
        override fun foo() {
            println(TEST1)
        }
    },
    TEST2(2) {
        val z: Int
        init {
            z = x
        }
        override fun foo() {
            println(TEST2)
        }
    }
    ;
    abstract fun foo()
}",enum class TestEnum5(val x: Int = 0) {
"assertNull(extras0[key])
        assertEquals(1, extras1[key])

        val extras2 = extras1 + (key withValue 2)
        assertNull(extras0[key])
        assertEquals(1, extras1[key])
        assertEquals(2, extras2[key])
    }

    @Test
    fun `test - key equality`() {
        assertEquals(extrasKeyOf<Int>(), extrasKeyOf<Int>())
        assertEquals(extrasKeyOf<List<String>>(), extrasKeyOf<List<String>>())
        assertEquals(extrasKeyOf<Int>(""a""), extrasKeyOf<Int>(""a""))
        assertNotEquals<Extras.Key<*>>(extrasKeyOf<Int>(), extrasKeyOf<String>())
        assertNotEquals<Extras.Key<*>>(extrasKeyOf<Int>(""a""), extrasKeyOf<Int>())
        assertNotEquals<Extras.Key<*>>(extrasKeyOf<Int>(""a""), extrasKeyOf<Int>(""b""))
    }

    @Test
    fun `test - add two extras`() {
        val keyA = extrasKeyOf<Int>(""a"")
        val keyB = extrasKeyOf<Int>(""b"")
        val keyC = extrasKeyOf<Int>(""c"")
        val keyD = extrasKeyOf<Int>()
        val keyE = extrasKeyOf<Int>()

        val extras1 = extrasOf(
            keyA withValue 0,
            keyB withValue 1,
            keyC withValue 2,
            keyD withValue 3
        )

        val extras2 = extrasOf(
            keyC withValue 4,
            keyE withValue 5
        )

        val combinedExtras = extras1 + extras2

        assertEquals(
            extrasOf(
                keyA withValue 0,
                keyB withValue 1,
                keyC withValue 4,
                keyE withValue 5
            ),
            combinedExtras
        )
    }

    @Test
    fun `test - mutable extras - remove`() {
        val extras = mutableExtrasOf(
            extrasKeyOf<String>() withValue ""2"",
            extrasKeyOf<String>(""other"") withValue ""4"",
            extrasKeyOf<Int>() withValue 1,
            extrasKeyOf<Int>(""cash"") withValue 1
        )

        extras.remove(extrasKeyOf<Int>(""sunny""))
        assertEquals(1, extras[extrasKeyOf<Int>(""cash"")])

        assertEquals(1, extras.remove(extrasKeyOf<Int>(""cash"")))","assertNull(extras[extrasKeyOf<Int>(""cash"")])"
"// FIR_IDENTICAL
// FIR_DUMP
package second",fun main() {
"/**
     * Creates a new array of the specified [size], where each element is calculated by calling the specified
     * [init] function.
     *
     * The function [init] is called for each array element sequentially starting from the first one.
     * It should return the value for an array element given its index.
     *
     * @throws RuntimeException if the specified [size] is negative.
     */
    public inline constructor(size: Int, init: (Int) -> Float)

    /**
     * Returns the array element at the given [index].  This method can be called using the index operator.
     *
     * If the [index] is out of bounds of this array, throws an [IndexOutOfBoundsException].
     */
    public operator fun get(index: Int): Float {
        rangeCheck(index, storage.len())
        return storage.get(index)
    }

    /**
     * Sets the element at the given [index] to the given [value]. This method can be called using the index operator.
     *
     * If the [index] is out of bounds of this array, throws an [IndexOutOfBoundsException].
     */
    public operator fun set(index: Int, value: Float) {
        rangeCheck(index, storage.len())
        storage.set(index, value)
    }

    /** Returns the number of elements in the array. */
    public val size: Int
        get() = storage.len()

    /** Creates an iterator over the elements of the array. */
    public operator fun iterator(): FloatIterator = floatArrayIterator(this)
}

internal fun floatArrayIterator(array: FloatArray) = object : FloatIterator() {
    var index = 0
    override fun hasNext() = index != array.size
    override fun nextFloat() = if (index != array.size) array[index++] else throw NoSuchElementException(""$index"")
}

internal inline fun createFloatArray(size: Int, init: (Int) -> Float): FloatArray {
    if (size < 0) throw IllegalArgumentException(""Negative array size"")
    val result = WasmFloatArray(size)
    result.fill(size, init)
    return FloatArray(result)
}

/**
 * An array of doubles.
 * @constructor Creates a new array of the specified [size], with all elements initialized to zero.
 * @throws RuntimeException if the specified [size] is negative.
 */
public class DoubleArray(size: Int) {
    internal val storage: WasmDoubleArray

    init {
        if (size < 0) throw IllegalArgumentException(""Negative array size"")
        storage = WasmDoubleArray(size)
    }",@WasmPrimitiveConstructor
".map { prop ->
                val declaresDefaultValue = prop.declaresDefaultValue()
                SerializableProperty(
                    prop,
                    primaryConstructorProperties[prop] ?: false,
                    prop.hasBackingField(bindingContext) || (prop is DeserializedPropertyDescriptor && prop.backingField != null) // workaround for TODO in .hasBackingField
                            // workaround for overridden getter (val) and getter+setter (var) - in this case hasBackingField returning false
                            // but initializer presents only for property with backing field
                            || declaresDefaultValue,
                    declaresDefaultValue
                )
            }
            .filterNot { it.transient }
            .partition { primaryConstructorProperties.contains(it.descriptor) }
            .run {
                val supers = serializableClass.getSuperClassNotAny()
                if (supers == null || !supers.shouldHaveInternalSerializer)
                    first + second
                else
                    SerializableProperties(supers, bindingContext).serializableProperties + first + second
            }
            .let { restoreCorrectOrderFromClassProtoExtension(serializableClass, it) }

        isExternallySerializable =
            serializableClass.isInternallySerializableEnum() || primaryConstructorParameters.size == primaryConstructorProperties.size

    }

    override val serializableConstructorProperties: List<SerializableProperty> =
        serializableProperties.asSequence()
            .filter { primaryConstructorProperties.contains(it.descriptor) }
            .toList()

    override val serializableStandaloneProperties: List<SerializableProperty> =
        serializableProperties.minus(serializableConstructorProperties)

    val size = serializableProperties.size
    operator fun get(index: Int) = serializableProperties[index]
    operator fun iterator() = serializableProperties.iterator()

    val primaryConstructorWithDefaults = serializableClass.unsubstitutedPrimaryConstructor
        ?.original?.valueParameters?.any { it.declaresDefaultValue() } ?: false
}

fun PropertyDescriptor.declaresDefaultValue(): Boolean {
    when (val declaration = this.source.getPsi()) {
        is KtDeclarationWithInitializer -> return declaration.initializer != null
        is KtParameter -> return declaration.defaultValue != null
        is Any -> return false // Not-null check
    }
    // PSI is null, property is from another module
    if (this !is DeserializedPropertyDescriptor) return false
    val myClassCtor = (this.containingDeclaration as? ClassDescriptor)?.unsubstitutedPrimaryConstructor ?: return false
    // If property is a constructor parameter, check parameter default value
    // (serializable classes always have parameters-as-properties, so no name clash here)
    if (myClassCtor.valueParameters.find { it.name == this.name }?.declaresDefaultValue() == true) return true
    // If it is a body property, then it is likely to have initializer when getter is not specified
    // note this approach is not working well if we have smth like `get() = field`, but such cases on cross-module boundaries
    // should be very marginal. If we want to solve them, we need to add protobuf metadata extension.
    if (getter?.isDefault == true) return true
    return false
}

fun BindingContext.serializablePropertiesFor(
    classDescriptor: ClassDescriptor,",serializationDescriptorSerializer: SerializationDescriptorSerializerPlugin? = null
"if (presenceArray[i] >= 0 && valuesArray!![i] == value)
                return i
        }
        return TOMBSTONE
    }

    internal fun addKey(key: K): Int {
        checkIsMutable()
        retry@ while (true) {
            var hash = hash(key)
            // put is allowed to grow maxProbeDistance with some limits (resize hash on reaching limits)
            val tentativeMaxProbeDistance = (maxProbeDistance * 2).coerceAtMost(hashSize / 2)
            var probeDistance = 0
            while (true) {
                val index = hashArray[hash]
                if (index <= 0) { // claim or reuse hash slot
                    if (length >= capacity) {
                        ensureExtraCapacity(1)
                        continue@retry
                    }
                    val putIndex = length++
                    keysArray[putIndex] = key
                    presenceArray[putIndex] = hash
                    hashArray[hash] = putIndex + 1
                    _size++
                    registerModification()
                    if (probeDistance > maxProbeDistance) maxProbeDistance = probeDistance
                    return putIndex
                }
                if (keysArray[index - 1] == key) {
                    return -index
                }
                if (++probeDistance > tentativeMaxProbeDistance) {
                    rehash(hashSize * 2) // cannot find room even with extra ""tentativeMaxProbeDistance"" -- grow hash
                    continue@retry
                }
                if (hash-- == 0) hash = hashSize - 1
            }
        }
    }

    internal fun removeKey(key: K): Boolean {
        checkIsMutable()
        val index = findKey(key)
        if (index < 0) return false
        removeEntryAt(index)
        return true
    }

    private fun removeEntryAt(index: Int) {
        keysArray.resetAt(index)
        valuesArray?.resetAt(index)
        removeHashAt(presenceArray[index])
        presenceArray[index] = TOMBSTONE
        _size--
        registerModification()
    }

    private fun removeHashAt(removedHash: Int) {
        var hash = removedHash
        var hole = removedHash // will try to patch the hole in hash array
        var probeDistance = 0
        var patchAttemptsLeft = (maxProbeDistance * 2).coerceAtMost(hashSize / 2) // don't spend too much effort
        while (true) {
            if (hash-- == 0) hash = hashSize - 1",if (++probeDistance > maxProbeDistance) {
"}

    if (hasExtension(JavaClassProtoBuf.isPackagePrivateConstructor)) {
        hashCode = 31 * hashCode + getExtension(JavaClassProtoBuf.isPackagePrivateConstructor).hashCode()
    }

    for(i in 0..getExtensionCount(BuiltInsProtoBuf.constructorAnnotation) - 1) {
        hashCode = 31 * hashCode + getExtension(BuiltInsProtoBuf.constructorAnnotation, i).hashCode(stringIndexes, fqNameIndexes, typeById)
    }

    for(i in 0..getExtensionCount(KlibMetadataProtoBuf.constructorAnnotation) - 1) {
        hashCode = 31 * hashCode + getExtension(KlibMetadataProtoBuf.constructorAnnotation, i).hashCode(stringIndexes, fqNameIndexes, typeById)
    }

    return hashCode
}

fun ProtoBuf.EnumEntry.hashCode(stringIndexes: (Int) -> Int, fqNameIndexes: (Int) -> Int, typeById: (Int) -> ProtoBuf.Type): Int {
    var hashCode = 1

    if (hasName()) {
        hashCode = 31 * hashCode + stringIndexes(name)
    }

    for(i in 0..getExtensionCount(JsProtoBuf.enumEntryAnnotation) - 1) {
        hashCode = 31 * hashCode + getExtension(JsProtoBuf.enumEntryAnnotation, i).hashCode(stringIndexes, fqNameIndexes, typeById)
    }

    for(i in 0..getExtensionCount(BuiltInsProtoBuf.enumEntryAnnotation) - 1) {
        hashCode = 31 * hashCode + getExtension(BuiltInsProtoBuf.enumEntryAnnotation, i).hashCode(stringIndexes, fqNameIndexes, typeById)
    }

    for(i in 0..getExtensionCount(KlibMetadataProtoBuf.enumEntryAnnotation) - 1) {
        hashCode = 31 * hashCode + getExtension(KlibMetadataProtoBuf.enumEntryAnnotation, i).hashCode(stringIndexes, fqNameIndexes, typeById)
    }

    if (hasExtension(KlibMetadataProtoBuf.enumEntryOrdinal)) {
        hashCode = 31 * hashCode + getExtension(KlibMetadataProtoBuf.enumEntryOrdinal)
    }

    return hashCode
}

fun ProtoBuf.Annotation.hashCode(stringIndexes: (Int) -> Int, fqNameIndexes: (Int) -> Int, typeById: (Int) -> ProtoBuf.Type): Int {
    var hashCode = 1

    hashCode = 31 * hashCode + fqNameIndexes(id)

    for(i in 0..argumentCount - 1) {
        hashCode = 31 * hashCode + getArgument(i).hashCode(stringIndexes, fqNameIndexes, typeById)
    }

    return hashCode
}

fun ProtoBuf.ValueParameter.hashCode(stringIndexes: (Int) -> Int, fqNameIndexes: (Int) -> Int, typeById: (Int) -> ProtoBuf.Type): Int {
    var hashCode = 1

    if (hasFlags()) {
        hashCode = 31 * hashCode + flags
    }

    hashCode = 31 * hashCode + stringIndexes(name)

    if (hasType()) {","hashCode = 31 * hashCode + type.hashCode(stringIndexes, fqNameIndexes, typeById)"
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.wasm.checkers.declaration

import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.declaration.FirClassChecker
import org.jetbrains.kotlin.fir.analysis.checkers.toClassLikeSymbol
import org.jetbrains.kotlin.fir.analysis.diagnostics.wasm.FirWasmErrors
import org.jetbrains.kotlin.fir.declarations.FirClass
import org.jetbrains.kotlin.fir.declarations.fullyExpandedClass
import org.jetbrains.kotlin.fir.declarations.utils.isEffectivelyExternal
import org.jetbrains.kotlin.fir.declarations.utils.isExpect
import org.jetbrains.kotlin.fir.types.coneType
import org.jetbrains.kotlin.name.StandardClassIds

sealed class FirWasmExternalInheritanceChecker(mppKind: MppCheckerKind) : FirClassChecker(mppKind) {
    object Regular : FirWasmExternalInheritanceChecker(MppCheckerKind.Platform) {
        override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {
            if (declaration.isExpect) return
            super.check(declaration, context, reporter)
        }
    }

    object ForExpectClass : FirWasmExternalInheritanceChecker(MppCheckerKind.Common) {
        override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {
            if (!declaration.isExpect) return
            super.check(declaration, context, reporter)
        }
    }

    override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {
        val session = context.session
        val isCurrentClassExternal = declaration.symbol.isEffectivelyExternal(session)
        for (superTypeRef in declaration.superTypeRefs) {
            val superClass = (superTypeRef.toClassLikeSymbol(session)?.fullyExpandedClass(session) ?: continue)
            if (superClass.classId == StandardClassIds.Any) continue  // External classes can extend Any

            val isSuperClassExternal = superClass.isEffectivelyExternal(session)
            if (!isCurrentClassExternal && isSuperClassExternal) {
                reporter.reportOn(","declaration.source,"
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.jps.statistic

import org.jetbrains.jps.ModuleChunk
import org.jetbrains.jps.incremental.CompileContext
import org.jetbrains.kotlin.build.report.metrics.BuildMetricsReporter
import org.jetbrains.kotlin.build.report.metrics.BuildMetricsReporterImpl
import org.jetbrains.kotlin.build.report.metrics.JpsBuildPerformanceMetric
import org.jetbrains.kotlin.build.report.metrics.JpsBuildTime
import org.jetbrains.kotlin.build.report.statistics.BuildDataType
import org.jetbrains.kotlin.build.report.statistics.StatTag
import org.jetbrains.kotlin.compilerRunner.JpsCompilationResult
import java.net.InetAddress
import java.util.*
import kotlin.collections.ArrayList

class JpsBuilderMetricReporterImpl(
    chunk: ModuleChunk,
    private val reporter: BuildMetricsReporterImpl<JpsBuildTime, JpsBuildPerformanceMetric>,
    private val label: String? = null,
    private val kotlinVersion: String = ""kotlin_version""
) :","JpsBuilderMetricReporter, BuildMetricsReporter<JpsBuildTime, JpsBuildPerformanceMetric> by reporter {"
"/*
 * KOTLIN CODEGEN BOX SPEC TEST (POSITIVE)
 *
 * SPEC VERSION: 0.1-300
 * MAIN LINK: expressions, constant-literals, boolean-literals -> paragraph 1 -> sentence 2
 * NUMBER: 14
 * DESCRIPTION: The use of Boolean literals as the identifier (with backtick) in the typeParameter.
 * NOTE: this test data is generated by FeatureInteractionTestDataGenerator. DO NOT MODIFY CODE MANUALLY!
 * HELPERS: reflect
 */

package org.jetbrains.`true`

open class `false` {
    val x1 = false
}
open class `true`<T> {
    val x1 = true
}

typealias A<`false`> = `true`<`false`>

class B<`true`, `false`> {
    val x1: `true` = `true`<`false`>() as `true`
    val x2: A<`false`> = `true`<`true`>() as A<`false`>
    val x3: `false` = `false`() as `false`
}

fun <`true`: Number> f1(): Boolean {
    val x1: `true` = 10 as `true`
    return false
}

inline fun <reified `false`, reified `true` : Any> `false`.f2() = true

val <`false`> `false`.x1: `true`<Int>
    get() = `true`<Int>()

fun box(): String? {
    val b = B<`true`<`false`>, `false`>()

    if (!null.x1.x1) return null
    if (!b.x1.x1 || !b.x2.x1 || b.x3.x1) return null
    if (f1<Byte>()) return null
    if (!0.f2<Int, `false`>()) return null
    if (!(-1).x1.x1) return null

    if (!checkCallableTypeParameter(Any::x1, ""false"")) return null
    if (!checkClassTypeParameters(B::class, listOf(""false"", ""true""))) return null
    if (!checkTypeProperties(B::class, listOf(
            Pair(""x1"", ""`true`""),
            Pair(""x2"", ""org.jetbrains.`true`.A<`false`> /* = org.jetbrains.`true`.`true`<`false`> */""),","Pair(""x3"", ""`false`"")"
"@Sample
    fun lowercase() {
        assertPrints(""Iced frappé!"".lowercase(), ""iced frappé!"")
    }

    @Sample
    fun lowercaseLocale() {
        assertPrints(""KOTLIN"".lowercase(), ""kotlin"")
        val turkishLocale = Locale.forLanguageTag(""tr"")
        assertPrints(""KOTLIN"".lowercase(turkishLocale), ""kotlın"")
    }

    @Sample
    fun uppercase() {
        assertPrints(""Iced frappé!"".uppercase(), ""ICED FRAPPÉ!"")
    }

    @Sample
    fun uppercaseLocale() {
        assertPrints(""Kotlin"".uppercase(), ""KOTLIN"")
        val turkishLocale = Locale.forLanguageTag(""tr"")
        assertPrints(""Kotlin"".uppercase(turkishLocale), ""KOTLİN"")
    }

    @Sample
    fun padStart() {
        val padWithSpace = ""125"".padStart(5)
        assertPrints(""'$padWithSpace'"", ""'  125'"")

        val padWithChar = ""a"".padStart(5, '.')
        assertPrints(""'$padWithChar'"", ""'....a'"")

        // string is returned as is, when its length is greater than the specified
        val noPadding = ""abcde"".padStart(3)
        assertPrints(""'$noPadding'"", ""'abcde'"")
    }

    @Sample
    fun padEnd() {
        val padWithSpace = ""125"".padEnd(5)
        assertPrints(""'$padWithSpace'"", ""'125  '"")

        val padWithChar = ""a"".padEnd(5, '.')
        assertPrints(""'$padWithChar'"", ""'a....'"")

        // string is returned as is, when its length is greater than the specified
        val noPadding = ""abcde"".padEnd(3)
        assertPrints(""'$noPadding'"", ""'abcde'"")
    }

    @Sample
    fun clearStringBuilder() {
        val builder = StringBuilder()
        builder.append(""content"").append(1)
        assertPrints(builder, ""content1"")

        builder.clear()
        assertPrints(builder, """")
    }

    @Sample
    fun stringIfEmpty() {
        val empty = """"",val emptyOrNull: String? = empty.ifEmpty { null }
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlinx.atomicfu.compiler.backend.native

import org.jetbrains.kotlin.descriptors.DescriptorVisibilities
import org.jetbrains.kotlin.ir.UNDEFINED_OFFSET
import org.jetbrains.kotlin.ir.builders.*
import org.jetbrains.kotlin.ir.builders.declarations.addValueParameter
import org.jetbrains.kotlin.ir.builders.declarations.buildFun
import org.jetbrains.kotlin.ir.declarations.IrProperty
import org.jetbrains.kotlin.ir.declarations.IrValueParameter",import org.jetbrains.kotlin.ir.declarations.createBlockBody
"val typeParameterPsi = DescriptorToSourceUtils.getSourceFromDescriptor(typeParameter)
            if (typeParameterPsi is KtTypeParameter) {
                trace.report(TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER.on(typeParameterPsi))
            }
        }
    }

    private fun checkMemberProperty(
        property: KtProperty,
        propertyDescriptor: PropertyDescriptor,
        classDescriptor: ClassDescriptor
    ) {
        val modifierList = property.modifierList

        if (modifierList != null) {
            if (modifierList.hasModifier(KtTokens.ABSTRACT_KEYWORD)) {
                //has abstract modifier
                if (!classCanHaveAbstractDeclaration(classDescriptor)) {
                    trace.report(ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS.on(property, property.name ?: """", classDescriptor))
                    return
                }
            } else if (classDescriptor.kind == ClassKind.INTERFACE &&
                modifierList.hasModifier(KtTokens.OPEN_KEYWORD) &&
                propertyDescriptor.modality == Modality.ABSTRACT
            ) {
                trace.report(REDUNDANT_OPEN_IN_INTERFACE.on(property))
            }
        }

        if (propertyDescriptor.modality == Modality.ABSTRACT) {
            property.initializer?.let { trace.report(ABSTRACT_PROPERTY_WITH_INITIALIZER.on(it)) }
            property.delegate?.let { trace.report(ABSTRACT_DELEGATED_PROPERTY.on(it)) }
            val getter = property.getter
            if (getter != null && getter.hasBody()) {
                trace.report(ABSTRACT_PROPERTY_WITH_GETTER.on(getter))
            }
            val setter = property.setter
            if (setter != null && setter.hasBody()) {
                trace.report(ABSTRACT_PROPERTY_WITH_SETTER.on(setter))
            }
        }
    }

    private fun checkPropertyInitializer(property: KtProperty, propertyDescriptor: PropertyDescriptor) {
        val hasAnyAccessorImplementation = propertyDescriptor.hasAnyAccessorImplementation()

        val containingDeclaration = propertyDescriptor.containingDeclaration
        val inInterface = DescriptorUtils.isInterface(containingDeclaration)
        if (propertyDescriptor.modality == Modality.ABSTRACT) {
            if (!property.hasDelegateExpressionOrInitializer() && property.typeReference == null) {
                trace.report(PROPERTY_WITH_NO_TYPE_NO_INITIALIZER.on(property))
            }
            if (inInterface && property.hasModifier(KtTokens.PRIVATE_KEYWORD) && !property.hasModifier(KtTokens.ABSTRACT_KEYWORD)) {
                trace.report(PRIVATE_PROPERTY_IN_INTERFACE.on(property))
            }
            return
        }

        val backingFieldRequired = trace.bindingContext.get(BACKING_FIELD_REQUIRED, propertyDescriptor) ?: false
        if (inInterface && backingFieldRequired && hasAnyAccessorImplementation) {
            trace.report(BACKING_FIELD_IN_INTERFACE.on(property))
        }

        val initializer = property.initializer
        val delegate = property.delegate",val isExpect = propertyDescriptor.isExpect
"context.checkReceiver(
                candidateCall,
                candidateCall.resultingDescriptor.dispatchReceiverParameter, candidateCall.dispatchReceiver,
                candidateCall.explicitReceiverKind.isDispatchReceiver,
                // for the invocation 'foo(1)' where foo is a variable of function type we should mark 'foo' if there is unsafe call error
                implicitInvokeCheck = context.call is CallForImplicitInvoke,
                isDispatchReceiver = true
            )
        )

        if (!context.isDebuggerContext
            && candidateCall.dispatchReceiver != null
            // Do not report error if it's already reported when checked without receiver
            && context.isCandidateVisible(receiverArgument = DescriptorVisibilities.ALWAYS_SUITABLE_RECEIVER, smartCastType = null)) {
            resultStatus = resultStatus.combine(
                context.checkVisibilityWithDispatchReceiver(
                    candidateCall.dispatchReceiver, candidateCall.smartCastDispatchReceiverType
                )
            )
        }

        return resultStatus
    }

    private fun <D : CallableDescriptor> CallCandidateResolutionContext<D>.checkReceiver(
        candidateCall: MutableResolvedCall<D>,
        receiverParameter: ReceiverParameterDescriptor?,
        receiverArgument: ReceiverValue?,
        isExplicitReceiver: Boolean,
        implicitInvokeCheck: Boolean,
        isDispatchReceiver: Boolean
    ): ResolutionStatus {
        if (receiverParameter == null || receiverArgument == null) return SUCCESS
        val candidateDescriptor = candidateCall.candidateDescriptor
        if (TypeUtils.dependsOnTypeParameters(receiverParameter.type, candidateDescriptor.typeParameters)) return SUCCESS

        // Here we know that receiver is OK ignoring nullability and check that nullability is OK too
        // Doing it simply as full subtyping check (receiverValueType <: receiverParameterType)
        val call = candidateCall.call
        val safeAccess = isExplicitReceiver && !implicitInvokeCheck && call.isSemanticallyEquivalentToSafeCall
        val expectedReceiverParameterType = if (safeAccess) TypeUtils.makeNullable(receiverParameter.type) else receiverParameter.type

        val smartCastSubtypingResult = smartCastManager.getSmartCastReceiverResult(receiverArgument, expectedReceiverParameterType, this)
        if (smartCastSubtypingResult == null) {
            tracing.wrongReceiverType(
                trace, receiverParameter, receiverArgument,
                this.replaceCallPosition(CallPosition.ExtensionReceiverPosition(candidateCall))
            )
            return OTHER_ERROR
        }

        val notNullReceiverExpected = smartCastSubtypingResult != SmartCastManager.ReceiverSmartCastResult.OK
        val smartCastNeeded =
            notNullReceiverExpected || !isCandidateVisibleOrExtensionReceiver(receiverArgument, null, isDispatchReceiver)
        var reportUnsafeCall = false

        var nullableImplicitInvokeReceiver = false
        var receiverArgumentType = receiverArgument.type
        if (implicitInvokeCheck && call is CallForImplicitInvoke && call.isSafeCall()) {
            val outerCallReceiver = call.outerCall.explicitReceiver
            if (outerCallReceiver != call.explicitReceiver && outerCallReceiver is ReceiverValue) {
                val outerReceiverDataFlowValue = dataFlowValueFactory.createDataFlowValue(outerCallReceiver, this)
                val outerReceiverNullability = dataFlowInfo.getStableNullability(outerReceiverDataFlowValue)
                if (outerReceiverNullability.canBeNull() && !TypeUtils.isNullableType(expectedReceiverParameterType)) {
                    nullableImplicitInvokeReceiver = true",receiverArgumentType = TypeUtils.makeNullable(receiverArgumentType)
"// FIR_IDENTICAL
// WITH_STDLIB
// FULL_JDK
// FILE: User.java
import lombok.Builder;
import lombok.Data;
import lombok.Singular;

@Builder
@Data
public class User {
    @Singular private java.util.List<String> names;
    @Singular private java.util.Map<Integer, Integer> pairs;
}

// FILE: UserWithoutNull.java
import lombok.Builder;
import lombok.Data;
import lombok.Singular;

@Builder
@Data
public class UserWithoutNull {
    @Singular(ignoreNullCollections = false) private java.util.List<String> names;
    @Singular(ignoreNullCollections = false) private java.util.Map<Integer, Integer> pairs;
}

// FILE: UserWithNull.java
import lombok.Builder;
import lombok.Data;
import lombok.Singular;

@Builder
@Data
public class UserWithNull {
    @Singular(ignoreNullCollections = true) private java.util.List<String> names;
    @Singular(ignoreNullCollections = true) private java.util.Map<Integer, Integer> pairs;
}

// FILE: test.kt
fun test_1() {
    User.builder()
        .name(""User"")
        .name(null)
        .names(listOf(""other""))
        .names(listOf(null))
        .names(<!NULL_FOR_NONNULL_TYPE!>null<!>)
        .pair(null, 1)
        .pair(1, null)
        .pairs(mapOf(1 to 1))
        .pairs(mapOf(null to 1))
        .pairs(mapOf(1 to null))
        .pairs(mapOf(null to null))
        .pairs(<!NULL_FOR_NONNULL_TYPE!>null<!>)
}",fun test_2() {
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"", ""unused"")

package org.jetbrains.kotlin.fir.expressions.builder

import kotlin.contracts.*
import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.builder.FirAnnotationContainerBuilder
import org.jetbrains.kotlin.fir.builder.FirBuilderDsl
import org.jetbrains.kotlin.fir.builder.toMutableOrEmpty",import org.jetbrains.kotlin.fir.expressions.FirAnnotation
")
        map.put(RESERVED_MEMBER_INSIDE_VALUE_CLASS, ""Member name ''{0}'' is reserved for future releases."", TO_STRING)
        map.put(
            RESERVED_MEMBER_FROM_INTERFACE_INSIDE_VALUE_CLASS,
            ""Member name ''{1}'' is reserved for future releases but is implemented in supertype ''{0}''."",
            TO_STRING,
            TO_STRING,
        )
        map.put(TYPE_ARGUMENT_ON_TYPED_VALUE_CLASS_EQUALS, ""Type arguments for typed value class equals must all be star projections."")
        map.put(INNER_CLASS_INSIDE_VALUE_CLASS, ""Value class cannot have inner classes."")
        map.put(VALUE_CLASS_CANNOT_BE_CLONEABLE, ""Value class cannot be 'Cloneable'."")
        map.put(VALUE_CLASS_CANNOT_HAVE_CONTEXT_RECEIVERS, ""Value classes cannot have context receivers."")
        map.put(
            ANNOTATION_ON_ILLEGAL_MULTI_FIELD_VALUE_CLASS_TYPED_TARGET,
            ""Annotations on {0} of multi-field value class type are not supported."",
            STRING
        )


        // Inline
        map.put(
            DECLARATION_CANT_BE_INLINED,
            ""'inline' modifier on virtual members is prohibited. Only private or final members can be inlined.""
        )
        map.put(
            DECLARATION_CANT_BE_INLINED_DEPRECATION,
            ""'inline' modifier on virtual members is prohibited. Only private or final members can be inlined.""
        )
        map.put(OVERRIDE_BY_INLINE, ""Override by an inline function."")
        map.put(REIFIED_TYPE_PARAMETER_IN_OVERRIDE, ""Override by a function with reified type parameter."")
        map.put(INLINE_PROPERTY_WITH_BACKING_FIELD, ""Inline property cannot have a backing field."")
        map.put(INLINE_PROPERTY_WITH_BACKING_FIELD_DEPRECATION, ""Inline property cannot have a backing field."")

        // Overrides
        map.put(NOTHING_TO_OVERRIDE, ""''{0}'' overrides nothing."", DECLARATION_NAME)

        map.put(
            CANNOT_OVERRIDE_INVISIBLE_MEMBER,
            ""''{0}'' has no access to ''{1}'', so it cannot override it."",
            FQ_NAMES_IN_TYPES,
            FQ_NAMES_IN_TYPES
        )

        val multipleDefaultsMessage = ""More than one function overridden by ''{0}'' declares a default value for ''{1}'': {2}""
        val multipleDefaultsNotAllowed = ""As the compiler can not make sure these values agree, this is not allowed.""
        map.put(
            MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES,
            multipleDefaultsMessage + multipleDefaultsNotAllowed,
            NAME,
            SYMBOL,
            CALLABLES_FQ_NAMES,
        )
        map.put(
            MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_WHEN_NO_EXPLICIT_OVERRIDE,
            multipleDefaultsMessage + multipleDefaultsNotAllowed,
            NAME,
            SYMBOL,
            CALLABLES_FQ_NAMES,
        )
        val multipleDefaultsDiscouraged = ""As the compiler can not make sure these values agree, this will be prohibited in the future."" +
                "" See: https://youtrack.jetbrains.com/issue/KT-36188""
        map.put(
            MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_DEPRECATION,
            multipleDefaultsMessage + multipleDefaultsDiscouraged,
            NAME,","SYMBOL,"
"package org.jetbrains.kotlin

import java.nio.file.Path
import java.nio.file.Paths
import java.util.regex.Matcher
import java.util.regex.Pattern

private const val MODULE_DELIMITER = "",\\s*""
// These patterns are copies from
// kotlin/compiler/tests-common/tests/org/jetbrains/kotlin/test/TestFiles.java
// kotlin/compiler/tests-common/tests/org/jetbrains/kotlin/test/KotlinTestUtils.java
private val MODULE_PATTERN: Pattern = Pattern.compile(""//\\s*MODULE:\\s*([^()\\n]+)(?:\\(([^()]+(?:"" +
        MODULE_DELIMITER + ""[^()]+)*)\\))?\\s*(?:\\(([^()]+(?:"" + MODULE_DELIMITER + ""[^()]+)*)\\))?\n"")
private val FILE_PATTERN = Pattern.compile(""//\\s*FILE:\\s*(.*)\n"")

private val DIRECTIVE_PATTERN = Pattern.compile(""^//\\s*[!]?([A-Z_]+)(:[ \\t]*(.*))?$"", Pattern.MULTILINE)

/**
 * Creates test files from the given source file that may contain different test directives.
 *
 * @return list of test files [TestFile] to be compiled
 */
fun buildCompileList(
        source: Path,
        outputDirectory: String,
        defaultModule: TestModule = TestModule.default()): List<TestFile> {
    val result = mutableListOf<TestFile>()
    val srcFile = source.toFile()
    // Remove diagnostic parameters in external tests.
    val srcText = srcFile.readText().replace(Regex(""<!.*?!>(.*?)<!>"")) { match -> match.groupValues[1] }

    var supportModule: TestModule? = if (srcText.contains(""// WITH_COROUTINES"")) TestModule.support() else null

    val moduleMatcher = MODULE_PATTERN.matcher(srcText)
    val fileMatcher = FILE_PATTERN.matcher(srcText)
    var nextModuleExists = moduleMatcher.find()
    var nextFileExists = fileMatcher.find()

    if (!nextModuleExists && !nextFileExists) {
        // There is only one file in the input
        if (supportModule != null) defaultModule.dependencies.add(supportModule.name)
        result.add(TestFile(srcFile.name, ""$outputDirectory/${srcFile.name}"", srcText, defaultModule))
    } else {
        // There are several files
        var processedChars = 0
        var module: TestModule = defaultModule

        while (nextModuleExists || nextFileExists) {
            if (nextModuleExists) {
                var moduleName = moduleMatcher.group(1)
                val moduleDependencies = moduleMatcher.group(2)
                val moduleFriends = moduleMatcher.group(3)

                if (moduleName != null) {
                    moduleName = moduleName.trim { it <= ' ' }
                    val dependencies = mutableListOf<String>().apply {
                        addAll(moduleDependencies.parseModuleList()
                                .map { if (it != ""support"") ""${srcFile.name}.$it"" else it }
                        )
                    }
                    module = TestModule(
                            ""${srcFile.name}.$moduleName"",
                            dependencies,
                            mutableListOf<String>().apply {","addAll(moduleFriends.parseModuleList().map { ""${srcFile.name}.$it"" })"
"// MODULE: m1-common
// FILE: common.kt

expect class E01
expect class E02()
expect open class E03

expect class E04 {
    constructor()
}

expect class E05(e: E01)
expect class E06 {
    constructor(e: E02)
}

expect interface I01

expect class M01 {
    fun foo()
}

expect enum class ENUM01

expect annotation class ANNO01

// MODULE: m2-jvm()()(m1-common)
// FILE: jvm.kt

object ActualObject {",fun foo() {}
"// WITH_STDLIB
// FULL_JDK
// TARGET_BACKEND: JVM_IR
// IGNORE_BACKEND: JVM
// IGNORE_BACKEND: ANDROID
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*

fun blackhole(vararg a: Any?) {}

val spilledVariables = mutableSetOf<Pair<String, String>>()

var c: Continuation<Unit>? = null

suspend fun saveSpilledVariables() = suspendCoroutineUninterceptedOrReturn<Unit> { continuation ->
    spilledVariables.clear()
    for (field in continuation.javaClass.declaredFields) {
        if (field.name != ""label"" && (field.name.length != 3 || field.name[1] != '$')) continue
        field.isAccessible = true
        val fieldValue = when (val obj = field.get(continuation)) {
            is Array<*> -> obj.joinToString(prefix = ""["", postfix = ""]"")
            else -> obj
        }
        spilledVariables += field.name to ""$fieldValue""
    }
    c = continuation
    COROUTINE_SUSPENDED
}

suspend fun test() {
    var a: String? = ""a""
    saveSpilledVariables()
    blackhole(a)
    a = null
    saveSpilledVariables()
    blackhole(a)
}

fun builder(c: suspend () -> Unit) {
    c.startCoroutine(Continuation(EmptyCoroutineContext) {
        it.getOrThrow()
    })
}

fun box(): String {
    builder {
        test()
    }

    val continuationName = ""Continuation at NullCleanupKt\$box\$1.invokeSuspend(nullCleanup.kt:47)""
    if (spilledVariables != setOf(""label"" to ""1"", ""L$0"" to continuationName, ""L$1"" to ""a"")) return ""FAIL 1: $spilledVariables""
    c?.resume(Unit)
    if (spilledVariables != setOf(""label"" to ""2"", ""L$0"" to continuationName, ""L$1"" to ""[a]"")) return ""FAIL 2: $spilledVariables""",c?.resume(Unit)
"//          when {
                    //              <safe_call_condition> && { val tmp = <safe_call_result>; tmp != null } ->
                    //                  tmp
                    //              <rhs_safe_call_condition> ->
                    //                  <rhs_safe_call_result>
                    //              else ->
                    //                  null
                    //          }
                    //      }

                    val safeCallWhen = elvisLhs.statements[0] as IrWhen
                    val safeCallCondition = safeCallWhen.branches[0].condition
                    val safeCallResult = safeCallWhen.branches[0].result
                    elvisTmpVal.initializer = safeCallResult
                    elvisTmpVal.type = safeCallResult.type
                    val foldedConditionPart =
                        IrCompositeImpl(
                            startOffset, endOffset, context.irBuiltIns.booleanType, null,
                            listOf<IrStatement>(
                                elvisTmpVal,
                                irValNotNull(startOffset, endOffset, elvisTmpVal)
                            )
                        )
                    val branches = ArrayList<IrBranch>()
                    branches.add(
                        IrBranchImpl(
                            startOffset, endOffset,
                            irAndAnd(safeCallCondition, foldedConditionPart),
                            IrGetValueImpl(startOffset, endOffset, elvisTmpVal.symbol)
                        )
                    )
                    val elvisRhs = elvisInfo.elvisRhs
                    if (elvisRhs.isFoldedSafeCallWithNonNullResult()) {
                        val rhsInnerWhen = (elvisRhs as IrBlock).statements[0] as IrWhen
                        branches.addAll(rhsInnerWhen.branches)
                    } else {
                        branches.add(IrBranchImpl(startOffset, endOffset, irTrue(startOffset, endOffset), elvisInfo.elvisRhs))
                    }
                    return IrWhenImpl(startOffset, endOffset, elvisType, JvmLoweredStatementOrigin.FOLDED_ELVIS, branches)
                        .wrapWithBlock(JvmLoweredStatementOrigin.FOLDED_ELVIS)
                }
                elvisLhs is IrBlock && elvisLhs.origin == JvmLoweredStatementOrigin.FOLDED_ELVIS -> {
                    // Append branches to the inner elvis:
                    //      val t = { // FOLDED_ELVIS
                    //          when {
                    //              ... <innerElvisBranches> ...
                    //              else -> <innerElvisRhs>
                    //          }
                    //      }
                    //      when {
                    //          t == null -> <outerElvisRhs>
                    //          else -> t
                    //      }
                    //  =>
                    //      { // FOLDED_ELVIS
                    //          when {
                    //              ... <innerElvisBranches> ...
                    //              { val t = <innerElvisRhs>; t != null } -> t
                    //              else -> <outerElvisRhs>
                    //          }
                    //      }
                    // TODO maybe we can do somewhat better if we analyze innerElvisRhs as well
                    val innerElvisWhen = elvisLhs.statements[0] as IrWhen
                    val innerElvisLastBranch = innerElvisWhen.branches.last()
                    val innerElvisRhs = innerElvisLastBranch.result",elvisTmpVal.initializer = innerElvisRhs
"fun testR3xE5() {
    // with possible local optimizations
    if (0.toShort() in emptyObjectArray.indices != range3.contains(0.toShort())) throw AssertionError()
    if (0.toShort() !in emptyObjectArray.indices != !range3.contains(0.toShort())) throw AssertionError()
    if (!(0.toShort() in emptyObjectArray.indices) != !range3.contains(0.toShort())) throw AssertionError()
    if (!(0.toShort() !in emptyObjectArray.indices) != range3.contains(0.toShort())) throw AssertionError()
    // no local optimizations
    if (element5 in emptyObjectArray.indices != range3.contains(element5)) throw AssertionError()
    if (element5 !in emptyObjectArray.indices != !range3.contains(element5)) throw AssertionError()
    if (!(element5 in emptyObjectArray.indices) != !range3.contains(element5)) throw AssertionError()
    if (!(element5 !in emptyObjectArray.indices) != range3.contains(element5)) throw AssertionError()
}

fun testR3xE6() {
    // with possible local optimizations
    if (0 in emptyObjectArray.indices != range3.contains(0)) throw AssertionError()
    if (0 !in emptyObjectArray.indices != !range3.contains(0)) throw AssertionError()
    if (!(0 in emptyObjectArray.indices) != !range3.contains(0)) throw AssertionError()
    if (!(0 !in emptyObjectArray.indices) != range3.contains(0)) throw AssertionError()
    // no local optimizations
    if (element6 in emptyObjectArray.indices != range3.contains(element6)) throw AssertionError()
    if (element6 !in emptyObjectArray.indices != !range3.contains(element6)) throw AssertionError()
    if (!(element6 in emptyObjectArray.indices) != !range3.contains(element6)) throw AssertionError()
    if (!(element6 !in emptyObjectArray.indices) != range3.contains(element6)) throw AssertionError()
}

fun testR3xE7() {
    // with possible local optimizations
    if (0L in emptyObjectArray.indices != range3.contains(0L)) throw AssertionError()
    if (0L !in emptyObjectArray.indices != !range3.contains(0L)) throw AssertionError()
    if (!(0L in emptyObjectArray.indices) != !range3.contains(0L)) throw AssertionError()
    if (!(0L !in emptyObjectArray.indices) != range3.contains(0L)) throw AssertionError()
    // no local optimizations
    if (element7 in emptyObjectArray.indices != range3.contains(element7)) throw AssertionError()
    if (element7 !in emptyObjectArray.indices != !range3.contains(element7)) throw AssertionError()
    if (!(element7 in emptyObjectArray.indices) != !range3.contains(element7)) throw AssertionError()
    if (!(element7 !in emptyObjectArray.indices) != range3.contains(element7)) throw AssertionError()
}

fun testR3xE8() {
    // with possible local optimizations
    if (1.toByte() in emptyObjectArray.indices != range3.contains(1.toByte())) throw AssertionError()
    if (1.toByte() !in emptyObjectArray.indices != !range3.contains(1.toByte())) throw AssertionError()
    if (!(1.toByte() in emptyObjectArray.indices) != !range3.contains(1.toByte())) throw AssertionError()
    if (!(1.toByte() !in emptyObjectArray.indices) != range3.contains(1.toByte())) throw AssertionError()
    // no local optimizations
    if (element8 in emptyObjectArray.indices != range3.contains(element8)) throw AssertionError()
    if (element8 !in emptyObjectArray.indices != !range3.contains(element8)) throw AssertionError()
    if (!(element8 in emptyObjectArray.indices) != !range3.contains(element8)) throw AssertionError()
    if (!(element8 !in emptyObjectArray.indices) != range3.contains(element8)) throw AssertionError()
}

fun testR3xE9() {
    // with possible local optimizations
    if (1.toShort() in emptyObjectArray.indices != range3.contains(1.toShort())) throw AssertionError()
    if (1.toShort() !in emptyObjectArray.indices != !range3.contains(1.toShort())) throw AssertionError()
    if (!(1.toShort() in emptyObjectArray.indices) != !range3.contains(1.toShort())) throw AssertionError()
    if (!(1.toShort() !in emptyObjectArray.indices) != range3.contains(1.toShort())) throw AssertionError()
    // no local optimizations
    if (element9 in emptyObjectArray.indices != range3.contains(element9)) throw AssertionError()
    if (element9 !in emptyObjectArray.indices != !range3.contains(element9)) throw AssertionError()
    if (!(element9 in emptyObjectArray.indices) != !range3.contains(element9)) throw AssertionError()
    if (!(element9 !in emptyObjectArray.indices) != range3.contains(element9)) throw AssertionError()
}",fun testR3xE10() {
"}
                default(field) {
                    value = ""emptyList()""
                    this.withGetter = withGetter
                }
            }
        }

        /**
         * Allows to configure the default value of [field] in this implementation class.
         *
         * See the [DefaultValueContext] documentation for description of its DSL methods.
         */
        fun default(field: String, init: DefaultValueContext.() -> Unit) {
            DefaultValueContext(fieldContainer[field]).apply(init).applyConfiguration()
        }

        /**
         * Specifies that for each field in the [fields] list its getter should be delegated to the [delegate]'s property of the same name.
         *
         * For example, `delegateFields(listOf(""foo"", ""bar""), ""myDelegate"")` will result in generating the following properties in
         * the implementation class (provided that there are fields with names ""foo"" and ""bar"" in this implementation):
         * ```kotlin
         * val foo: Foo
         *     get() = myDelegate.foo
         *
         * val bar: Bar
         *     get() = myDelegate.bar
         * ```
         */
        fun delegateFields(fields: List<String>, delegate: String) {
            for (field in fields) {
                default(field) {
                    this.delegate = delegate
                }
            }
        }


        /**
         * A DSL for configuring a field's default value.
         */
        inner class DefaultValueContext(private val field: Field) {

            /**
             * The default value of this field in the implementation class. Can be arbitrary code.
             *
             * Use [additionalImports] if the default value uses types/functions that are not otherwise imported.
             */
            var value: String? = null

            /**
             * The name of the field to which to delegate this field's getter.
             *
             * For example, setting [delegate] to `""myDelegate""` will result in generating the following in
             * the implementation class (provided that we're configuring the field `foo`):
             * ```kotlin
             * val foo: Foo
             *     get() = myDelegate.foo
             * ```
             *
             * If [delegateCall] is not null, then instead of calling `foo` on `myDelegate`, the value of [delegateCall] will be used to
             * generate the call.
             */
            var delegate: String? = null",set(value) {
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_PARAMETER

object RemAndRemAssign {
    operator fun rem(x: Int) = RemAndRemAssign
}

operator fun RemAndRemAssign.remAssign(x: Int) {}

fun test() {",var c = RemAndRemAssign
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.ic

import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.expressions.IrCall",import org.jetbrains.kotlin.ir.expressions.IrFunctionReference
"buildResolvedTypeRef {
            this.source = source
            this.type = type
        }
    } else {
        buildErrorTypeRef {
            this.source = source
            this.type = type
            this.diagnostic = diagnostic
        }
    }
}

fun createFunctionType(
    kind: FunctionTypeKind,
    parameters: List<ConeKotlinType>,
    receiverType: ConeKotlinType?,
    rawReturnType: ConeKotlinType,
    contextReceivers: List<ConeKotlinType> = emptyList(),
): ConeLookupTagBasedType {
    val receiverAndParameterTypes =
        buildList {
            addAll(contextReceivers)
            addIfNotNull(receiverType)
            addAll(parameters)
            add(rawReturnType)
        }

    val functionTypeId = ClassId(kind.packageFqName, kind.numberedClassName(receiverAndParameterTypes.size - 1))
    val attributes = when {
        contextReceivers.isNotEmpty() -> ConeAttributes.create(
            buildList {
                add(CompilerConeAttributes.ContextFunctionTypeParams(contextReceivers.size))
                if (receiverType != null) {
                    add(CompilerConeAttributes.ExtensionFunctionType)
                }
            }
        )
        receiverType != null -> ConeAttributes.WithExtensionFunctionType
        else -> ConeAttributes.Empty
    }
    return ConeClassLikeTypeImpl(
        functionTypeId.toLookupTag(),
        receiverAndParameterTypes.toTypedArray(),
        isNullable = false,
        attributes = attributes
    )
}

fun createKPropertyType(
    receiverType: ConeKotlinType?,
    rawReturnType: ConeKotlinType,
    isMutable: Boolean,
): ConeLookupTagBasedType {
    val arguments = if (receiverType != null) listOf(receiverType, rawReturnType) else listOf(rawReturnType)
    val classId = StandardClassIds.reflectByName(""K${if (isMutable) ""Mutable"" else """"}Property${arguments.size - 1}"")
    return ConeClassLikeTypeImpl(classId.toLookupTag(), arguments.toTypedArray(), isNullable = false)
}

fun BodyResolveComponents.buildResolvedQualifierForClass(
    regularClass: FirClassLikeSymbol<*>,
    sourceElement: KtSourceElement?,
    // Note: we need type arguments here, see e.g. testIncompleteConstructorCall in diagnostic group
    typeArgumentsForQualifier: List<FirTypeProjection> = emptyList(),
    diagnostic: ConeDiagnostic? = null,","nonFatalDiagnostics: List<ConeDiagnostic> = emptyList(),"
"class A(val result: String)

fun a(body: A.() -> String): String {
    val r = A(""OK"")
    return r.body()
}

object C {
    private fun A.f() = result

    val g = a {
        f()
    }
}",fun box() = C.g
"// WITH_STDLIB
// WITH_COROUTINES

import helpers.*
import kotlin.coroutines.*

fun builder(c: suspend () -> Unit) {
    c.startCoroutine(EmptyContinuation)
}

@Suppress(""UNSUPPORTED_FEATURE"")
inline class IC(val s: Any)

var c: Continuation<Any>? = null

suspend fun <T> suspendMe(): T = suspendCoroutine {
    @Suppress(""UNCHECKED_CAST"")
    c = it as Continuation<Any>
}

interface IBar {
    suspend fun bar(): Any
}

class Test() : IBar {

    override suspend fun bar(): IC = suspendMe()

    suspend fun test1(): String {
        val b: IBar = this
        return (b.bar() as IC).s as String
    }

    suspend fun test2(): String = bar().s as String
}


fun box(): String {
    var result = ""FAIL 1""
    builder {
        result = Test().test1()
    }
    c?.resume(IC(""OK""))
    if (result != ""OK"") return ""FAIL 1 $result""

    result = ""FAIL2 ""
    builder {
        result = Test().test2()
    }","c?.resume(IC(""OK""))"
"<!DEBUG_INFO_SMARTCAST!>ins<!>.read();
      <!DEBUG_INFO_SMARTCAST!>out<!>.println();
    }
  }

  if (out != null && ins != null) {
    <!DEBUG_INFO_SMARTCAST!>ins<!>.read();
    <!DEBUG_INFO_SMARTCAST!>out<!>.println();
  }

  if (out == null) {
    <!DEBUG_INFO_CONSTANT!>out<!>?.println()
  } else {
    <!DEBUG_INFO_SMARTCAST!>out<!>.println()
  }

  if (out != null && ins != null || out != null) {
    ins?.read();
    ins<!UNSAFE_CALL!>.<!>read();
    <!DEBUG_INFO_SMARTCAST!>out<!>.println();
  }

  if (out == null || <!DEBUG_INFO_SMARTCAST!>out<!>.println(0) == Unit) {
    out?.println(1)
    out<!UNSAFE_CALL!>.<!>println(1)
  }
  else {
    <!DEBUG_INFO_SMARTCAST!>out<!>.println(2)
  }

  if (out != null && <!DEBUG_INFO_SMARTCAST!>out<!>.println() == Unit) {
    <!DEBUG_INFO_SMARTCAST!>out<!>.println();
  }
  else {
    out?.println();
  }

  if (out == null || <!DEBUG_INFO_SMARTCAST!>out<!>.println() == Unit) {
    out?.println();
  }
  else {
    <!DEBUG_INFO_SMARTCAST!>out<!>.println();
  }

  if (1 == 2 || out != null && <!DEBUG_INFO_SMARTCAST!>out<!>.println(1) == Unit) {
    out?.println(2);
    out<!UNSAFE_CALL!>.<!>println(2);
  }
  else {
    out?.println(3)
    out<!UNSAFE_CALL!>.<!>println(3)
  }

  out?.println()
  ins?.read()

  if (ins != null) {
    <!DEBUG_INFO_SMARTCAST!>ins<!>.read()
    out?.println()
    if (out != null) {
      <!DEBUG_INFO_SMARTCAST!>ins<!>.read();
      <!DEBUG_INFO_SMARTCAST!>out<!>.println();
    }
  }",if (out != null && ins != null) {
"// EXPECTED_REACHABLE_NODES: 1265
// RUN_PLAIN_BOX_FUNCTION
// INFER_MAIN_MODULE
// SKIP_MINIFICATION
// SKIP_NODE_JS
// SKIP_DCE_DRIVEN

// MODULE: exportProtectedMembers
// FILE: lib.kt

@JsExport
open class Foo protected constructor() {
    protected fun bar(): String = ""protected method""

    private var _baz: String = ""baz""

    protected var baz: String
        get() = _baz
        set(value) {
            _baz = value
        }

    protected val bazReadOnly: String
        get() = _baz

    protected val quux: String = ""quux""

    protected var quuz: String = ""quuz""

    protected class NestedClass {
        val prop: String = ""nested class property""
    }",protected object NestedObject {
"val header1: String,
    val header2: String,
) : ComparisonReport {

    private val membersDiffList = ArrayList<DiffEntry>()

    private val propertyDiffs = ArrayList<NamedDiffEntry>()

    private val constructorReports = ArrayList<MetadataPropertyReport>()
    private val functionReports = ArrayList<MetadataPropertyReport>()
    private val propertyReports = ArrayList<MetadataPropertyReport>()
    private val typeAliasReports = ArrayList<MetadataPropertyReport>()
    private val localDelegatedPropertyReport = ArrayList<MetadataPropertyReport>()

    override fun isEmpty() =
        membersDiffList.isEmpty()
                && propertyDiffs.isEmpty()
                && propertyReports.areAllEmpty()
                && constructorReports.areAllEmpty()
                && functionReports.areAllEmpty()
                && typeAliasReports.areAllEmpty()
                && localDelegatedPropertyReport.areAllEmpty()

    override fun writeAsHtml(output: PrintWriter) {
        if (isEmpty()) return

        output.tag(""h2"", ""CLASS METADATA $classInternalName"")

        output.listDiff(header1, header2, membersDiffList)
        output.propertyDiffTable(header1, header2, propertyDiffs)

        for (report in listOf(
            constructorReports,
            functionReports,
            propertyReports,
            typeAliasReports,
            localDelegatedPropertyReport
        ).flatten()) {
            report.writeAsHtml(output)
        }
    }


    fun constructorReport(id: String) = MetadataPropertyReport(""CONSTRUCTOR $id"", header1, header2).also { constructorReports.add(it) }

    fun functionReport(id: String) = MetadataPropertyReport(""FUNCTION $id"", header1, header2).also { functionReports.add(it) }

    fun propertyReport(id: String) = MetadataPropertyReport(""PROPERTY $id"", header1, header2).also { propertyReports.add(it) }

    fun typeAliasReport(id: String) = MetadataPropertyReport(""TYPE ALIAS $id"", header1, header2).also { typeAliasReports.add(it) }

    fun localDelegatedPropertyReport(id: String) =
        MetadataPropertyReport(""LOCAL DELEGATED PROPERTY $id"", header1, header2).also { localDelegatedPropertyReport.add(it) }

    fun addMembersListDiffs(diffs: List<ListEntryDiff>) {
        for (diff in diffs) {
            membersDiffList.add(diff.toDiffEntry())
        }
    }

    fun addPropertyDiff(diff: NamedDiffEntry) {
        propertyDiffs.add(diff)
    }

    fun TextTreeBuilderContext.appendClassMetadataReport() {",if (isNotEmpty()) {
"// FILE: KotlinFile.kt
class KotlinClass {
    public fun getSomething(): Int = 1
}

fun foo(javaClass: JavaClass, kotlinClass: KotlinClass) {
    useInt(javaClass.getSomething())
    useInt(javaClass.something)",<!VAL_REASSIGNMENT!>javaClass.something<!> = 1
"// WITH_STDLIB
// WORKS_WHEN_VALUE_CLASS
// LANGUAGE: +ValueClasses
// IGNORE_BACKEND: JVM
// FILE: 1.kt

val f: F = F { value -> Z(value) }",fun box(): String =
"// EXPECTED_REACHABLE_NODES: 1284
// MODULE_KIND: AMD
// FILE: a.kt
@file:JsModule(""a"")
package a

external class A {
    fun foo(): String
}

external fun bar(): Int

external val prop: Int

// FILE: b.kt
@file:JsModule(""b"")
package b",external class A {
"// ISSUE: KT-49263
// CHECK_TYPE_WITH_EXACT",fun test() {
"* @see withJumpingLockImpl
     * @see tryJumpingLock
     * @see jumpingUnlock
     */
    private val jumpingResolutionStatesStack = JumpingResolutionStatesStack()

    /**
     * Locks an a [FirElementWithResolveState] to resolve from `toPhase - 1` to [toPhase] and
     * then updates the [FirElementWithResolveState.resolveState] to a
     * [toPhase] if no exceptions were found during [actionUnderLock].
     *
     * If [FirElementWithResolveState] is already at least at [toPhase], does nothing.
     *
     * ### Happy path:
     *  1. Marks [FirElementWithResolveState] as in a process of resolve
     *  2. Performs the resolve by calling [actionUnderLock]
     *  3. Updates the resolve phase to [toPhase] if there is no exceptions
     *  4. Notifies other threads waiting on the same lock that this thread already resolved the declaration,
     *  so other threads can continue its execution
     *
     *  ### Cycle handling
     *  During step 1 we can realize someone already set [FirInProcessOfResolvingToJumpingPhaseState]
     *  for the current [FirElementWithResolveState], so there is a room for a possible deadlock.
     *
     *  The requirement for the deadlock is not empty [jumpingResolutionStatesStack] as we should already hold another lock.
     *  Otherwise, we can just wait on the [latch][FirInProcessOfResolvingToJumpingPhaseState.latch].
     *
     *  In the case of not empty [jumpingResolutionStatesStack], we have the following algorithm:
     *  1. Set [waitingFor][FirInProcessOfResolvingToJumpingPhaseState.waitingFor] for the previous state
     *  as we have an intention to take the next lock
     *  2. Iterate over all [waitingFor][FirInProcessOfResolvingToJumpingPhaseState.waitingFor] recursively
     *  to detect the possible cycle
     *  3. Execute [actionOnCycle] without the lock in the case of cycle or waining on
     *  the [latch][FirInProcessOfResolvingToJumpingPhaseState.latch] to try to take the lock again later
     *
     * @param actionUnderLock will be executed once under the lock if [this] is not yet resolved to [toPhase] phase and there are no cycles
     * @param actionOnCycle will be executed once without the lock if [this] is not yet resolved to [toPhase] phase and a resolution cycle is found
     *
     *  @see withJumpingLock
     */
    private fun FirElementWithResolveState.withJumpingLockImpl(
        toPhase: FirResolvePhase,
        actionUnderLock: () -> Unit,
        actionOnCycle: () -> Unit,
    ) {
        while (true) {
            checkCanceled()

            @OptIn(ResolveStateAccess::class)
            val currentState = resolveState
            if (currentState.resolvePhase >= toPhase) {
                // already resolved by some other thread
                return
            }

            when (currentState) {
                is FirResolvedToPhaseState -> {
                    if (!tryJumpingLock(toPhase, currentState)) continue

                    var exceptionOccurred = false
                    try {
                        actionUnderLock()
                    } catch (e: Throwable) {
                        exceptionOccurred = true
                        throw e",} finally {
"compilerSettings = settings
            fn()
        } finally {
            compilerSettings = old
        }
    }

    companion object {
        @Volatile
        private var _jpsCompileServiceSession: CompileServiceSession? = null

        @TestOnly
        fun shutdownDaemon() {
            _jpsCompileServiceSession?.let {
                try {
                    it.compileService.shutdown()
                } catch (_: Throwable) {
                }
            }
            _jpsCompileServiceSession = null
        }

        fun releaseCompileServiceSession() {
            _jpsCompileServiceSession?.let {
                try {
                    it.compileService.releaseCompileSession(it.sessionId)
                } catch (_: Throwable) {
                }
            }
            _jpsCompileServiceSession = null
        }

        @Synchronized
        private fun getOrCreateDaemonConnection(newConnection: () -> CompileServiceSession?): CompileServiceSession? {
            // TODO: consider adding state ""ping"" to the daemon interface
            if (_jpsCompileServiceSession == null || _jpsCompileServiceSession!!.compileService.getDaemonOptions() !is CompileService.CallResult.Good<DaemonOptions>) {
                releaseCompileServiceSession()
                _jpsCompileServiceSession = newConnection()
            }

            return _jpsCompileServiceSession
        }

        const val FAIL_ON_FALLBACK_PROPERTY = ""test.kotlin.jps.compiler.runner.fail.on.fallback""
    }

    fun classesFqNamesByFiles(
        environment: JpsCompilerEnvironment,
        files: Set<File>,
    ): Set<String> = withDaemonOrFallback(
        withDaemon = {
            doWithDaemon(environment) { sessionId, daemon ->
                daemon.classesFqNamesByFiles(
                    sessionId,
                    files.toSet() // convert to standard HashSet to avoid serialization issues
                )
            }
        },
        fallback = {
            CompilerRunnerUtil.invokeClassesFqNames(environment, files)
        }
    )

    fun runK2MetadataCompiler(
        commonArguments: CommonCompilerArguments,","k2MetadataArguments: K2MetadataCompilerArguments,"
"try {
            writeOutput(environment.configuration, generationState.factory, null)
            return true
        } finally {
            generationState.destroy()
        }
    }

    private fun repeatAnalysisIfNeeded(result: AnalysisResult?, environment: KotlinCoreEnvironment): AnalysisResult? {
        if (result is AnalysisResult.RetryWithAdditionalRoots) {
            val configuration = environment.configuration

            val oldReadOnlyValue = configuration.isReadOnly
            configuration.isReadOnly = false
            configuration.addJavaSourceRoots(result.additionalJavaRoots)
            configuration.isReadOnly = oldReadOnlyValue

            if (result.addToEnvironment) {
                environment.updateClasspath(result.additionalJavaRoots.map { JavaSourceRoot(it, null) })
            }

            if (result.additionalClassPathRoots.isNotEmpty()) {
                environment.updateClasspath(result.additionalClassPathRoots.map { JvmClasspathRoot(it, false) })
            }

            if (result.additionalKotlinRoots.isNotEmpty()) {
                environment.addKotlinSourceRoots(result.additionalKotlinRoots)
            }

            KotlinJavaPsiFacade.getInstance(environment.project).clearPackageCaches()

            val javaClassesTracker = configuration[JAVA_CLASSES_TRACKER]
            javaClassesTracker?.clear()

            val lookupTracker = configuration[LOOKUP_TRACKER]
            lookupTracker?.clear()

            // Clear all diagnostic messages
            configuration[CLIConfigurationKeys.MESSAGE_COLLECTOR_KEY]?.clear()

            // Repeat analysis with additional source roots generated by compiler plugins.
            return repeatAnalysisIfNeeded(analyze(environment), environment)
        }

        return result
    }

    @Suppress(""MemberVisibilityCanBePrivate"") // Used in ExecuteKotlinScriptMojo
    fun analyzeAndGenerate(environment: KotlinCoreEnvironment): GenerationState? {
        val result = repeatAnalysisIfNeeded(analyze(environment), environment) ?: return null

        if (!result.shouldGenerateCode) return null

        result.throwIfError()

        val (codegenFactory, backendInput) = convertToIr(environment, result)
        val diagnosticsReporter = DiagnosticReporterFactory.createReporter()
        val input = runLowerings(
            environment, environment.configuration, result.moduleDescriptor, result.bindingContext,
            environment.getSourceFiles(), null, codegenFactory, backendInput, diagnosticsReporter
        )
        return runCodegen(input, input.state, codegenFactory, diagnosticsReporter, environment.configuration)
    }

    private fun convertToIr(environment: KotlinCoreEnvironment, result: AnalysisResult): Pair<CodegenFactory, CodegenFactory.BackendInput> {",val configuration = environment.configuration
"fun test1()<!> {}

        fun Any.test2() {}
        fun test2(x: Any) = x

        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}
        <!CONFLICTING_OVERLOADS!>@Deprecated(""test3"", level = DeprecationLevel.HIDDEN)
        fun Any.test3()<!> {}

        <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0
        <!CONFLICTING_OVERLOADS!>@Deprecated(""test4"", level = DeprecationLevel.HIDDEN)
        fun test4(): String<!> = """"

        class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {
            <!CONFLICTING_OVERLOADS!>constructor()<!>: this(0)
        }
        <!CONFLICTING_OVERLOADS!>@Deprecated(""Test5"", level = DeprecationLevel.HIDDEN)
        fun Test5()<!> {}
        <!CONFLICTING_OVERLOADS!>@Deprecated(""Test5"", level = DeprecationLevel.HIDDEN)
        fun Test5(x: Int)<!> = x
    }
}

class Test {
    init {
        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}
        <!CONFLICTING_OVERLOADS!>@Deprecated(""test1"", level = DeprecationLevel.HIDDEN)
        fun test1()<!> {}

        fun Any.test2() {}
        fun test2(x: Any) = x

        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}
        <!CONFLICTING_OVERLOADS!>@Deprecated(""test3"", level = DeprecationLevel.HIDDEN)
        fun Any.test3()<!> {}

        <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0
        <!CONFLICTING_OVERLOADS!>@Deprecated(""test4"", level = DeprecationLevel.HIDDEN)
        fun test4(): String<!> = """"

        class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {
            <!CONFLICTING_OVERLOADS!>constructor()<!>: this(0)
        }
        <!CONFLICTING_OVERLOADS!>@Deprecated(""Test5"", level = DeprecationLevel.HIDDEN)
        fun Test5()<!> {}
        <!CONFLICTING_OVERLOADS!>@Deprecated(""Test5"", level = DeprecationLevel.HIDDEN)
        fun Test5(x: Int)<!> = x
    }

    fun test() {
        <!CONFLICTING_OVERLOADS!>fun test1()<!> {}
        <!CONFLICTING_OVERLOADS!>@Deprecated(""test1"", level = DeprecationLevel.HIDDEN)
        fun test1()<!> {}

        fun Any.test2() {}
        fun test2(x: Any) = x

        <!CONFLICTING_OVERLOADS!>fun Any.test3()<!> {}
        <!CONFLICTING_OVERLOADS!>@Deprecated(""test3"", level = DeprecationLevel.HIDDEN)
        fun Any.test3()<!> {}

        <!CONFLICTING_OVERLOADS!>fun test4(): Int<!> = 0
        <!CONFLICTING_OVERLOADS!>@Deprecated(""test4"", level = DeprecationLevel.HIDDEN)
        fun test4(): String<!> = """"",class Test5<!CONFLICTING_OVERLOADS!>(val x: Int)<!> {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.fir.symbols

import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.analysis.api.KtAnalysisApiInternals
import org.jetbrains.kotlin.analysis.api.fir.KtFirAnalysisSession
import org.jetbrains.kotlin.analysis.api.fir.annotations.KtFirAnnotationListForDeclaration
import org.jetbrains.kotlin.analysis.api.fir.findPsi
import org.jetbrains.kotlin.analysis.api.fir.symbols.pointers.createOwnerPointer
import org.jetbrains.kotlin.analysis.api.fir.utils.cached
import org.jetbrains.kotlin.analysis.api.impl.base.symbols.pointers.KtPropertyGetterSymbolPointer
import org.jetbrains.kotlin.analysis.api.lifetime.KtLifetimeToken
import org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion
import org.jetbrains.kotlin.analysis.api.symbols.KtPropertyGetterSymbol
import org.jetbrains.kotlin.analysis.api.symbols.KtReceiverParameterSymbol",import org.jetbrains.kotlin.analysis.api.symbols.KtValueParameterSymbol
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.scopes

import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.resolvedTypeFromPrototype
import org.jetbrains.kotlin.fir.types.ConeKotlinType
import org.jetbrains.kotlin.fir.types.FirResolvedTypeRef
import org.jetbrains.kotlin.fir.types.FirTypeRef
import org.jetbrains.kotlin.fir.types.coneTypeOrNull

/**
 * A utility class that, depending on the implementation, calculates the return type of callable copies,
 * (substitution/intersection overrides, delegated members, and enhanced Java declarations) and returns it.
 *
 * See [FirDeclarationAttributes.deferredCallableCopyReturnType].
 */
abstract class CallableCopyTypeCalculator {
    /**
     * Returns the [FirTypeRef] for [FirCallableDeclaration.returnTypeRef] of the [declaration].
     *
     * Depending on the implementation, this call might invoke a deferred computation of the return type
     * (see [FirDeclarationAttributes.deferredCallableCopyReturnType]).
     *
     * A return value of `null` signifies that the calculation has failed or that no deferred computation was stored
     * and the return type could not be resolved ordinarily.
     */
    abstract fun computeReturnType(declaration: FirCallableDeclaration): FirTypeRef?

    fun computeReturnTypeOrNull(declaration: FirCallableDeclaration): ConeKotlinType? {
        return computeReturnType(declaration)?.coneTypeOrNull
    }

    /**
     * Doesn't perform any calculation and returns [FirCallableDeclaration.returnTypeRef].
     */
    object DoNothing : CallableCopyTypeCalculator() {
        override fun computeReturnType(declaration: FirCallableDeclaration): FirTypeRef {
            return declaration.returnTypeRef
        }
    }

    /**
     * If necessary, runs the computation saved in [FirDeclarationAttributes.deferredCallableCopyReturnType] and returns a [FirResolvedTypeRef].
     */
    abstract class DeferredCallableCopyTypeCalculator : CallableCopyTypeCalculator() {
        override fun computeReturnType(declaration: FirCallableDeclaration): FirResolvedTypeRef? {
            val callableCopyDeferredTypeCalculation = declaration.attributes.deferredCallableCopyReturnType
                ?: return declaration.getResolvedTypeRef()

            // TODO: drop synchronized in KT-60385
            synchronized(callableCopyDeferredTypeCalculation) {
                if (declaration.attributes.deferredCallableCopyReturnType == null) {
                    return declaration.returnTypeRef as FirResolvedTypeRef
                }

                val returnType = callableCopyDeferredTypeCalculation.computeReturnType(this) ?: return null
                val returnTypeRef = declaration.returnTypeRef.resolvedTypeFromPrototype(returnType)

                declaration.replaceReturnTypeRef(returnTypeRef)
                if (declaration is FirProperty) {
                    declaration.getter?.replaceReturnTypeRef(returnTypeRef)",declaration.setter?.valueParameters?.firstOrNull()?.replaceReturnTypeRef(returnTypeRef)
"override fun visitDelegatingConstructorCall(expression: IrDelegatingConstructorCall, data: Nothing?) {
        visitDelegatingConstructorCall(expression)
    }

    fun visitDelegatingConstructorCall(expression: IrDelegatingConstructorCall) {
        visitFunctionAccess(expression)
    }

    override fun visitDynamicExpression(expression: IrDynamicExpression, data: Nothing?) {
        visitDynamicExpression(expression)
    }

    fun visitDynamicExpression(expression: IrDynamicExpression) {
        visitExpression(expression)
    }

    override fun visitDynamicOperatorExpression(expression: IrDynamicOperatorExpression, data: Nothing?) {
        visitDynamicOperatorExpression(expression)
    }

    fun visitDynamicOperatorExpression(expression: IrDynamicOperatorExpression) {
        visitDynamicExpression(expression)
    }

    override fun visitDynamicMemberExpression(expression: IrDynamicMemberExpression, data: Nothing?) {
        visitDynamicMemberExpression(expression)
    }

    fun visitDynamicMemberExpression(expression: IrDynamicMemberExpression) {
        visitDynamicExpression(expression)
    }

    override fun visitEnumConstructorCall(expression: IrEnumConstructorCall, data: Nothing?) {
        visitEnumConstructorCall(expression)
    }

    fun visitEnumConstructorCall(expression: IrEnumConstructorCall) {
        visitFunctionAccess(expression)
    }

    override fun visitErrorExpression(expression: IrErrorExpression, data: Nothing?) {
        visitErrorExpression(expression)
    }

    fun visitErrorExpression(expression: IrErrorExpression) {
        visitExpression(expression)
    }

    override fun visitErrorCallExpression(expression: IrErrorCallExpression, data: Nothing?) {
        visitErrorCallExpression(expression)
    }

    fun visitErrorCallExpression(expression: IrErrorCallExpression) {
        visitErrorExpression(expression)
    }

    override fun visitFieldAccess(expression: IrFieldAccessExpression, data: Nothing?) {
        visitFieldAccess(expression)
    }

    fun visitFieldAccess(expression: IrFieldAccessExpression) {
        visitDeclarationReference(expression)
    }","override fun visitGetField(expression: IrGetField, data: Nothing?) {"
"// TARGET_BACKEND: JVM

// FILE: JavaClass.java

public class JavaClass extends A {
    public String test() {
        return ""Java"";
    }
}

// FILE: test.kt

open class A {
    internal open fun test(): String = ""Kotlin""
}

fun box(): String {","if (A().test() != ""Kotlin"") return ""fail 1: ${A().test()}"""
"if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit? & kotlin.Unit"")!>y<!>.funNullableAny()
        if (this.y != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit? & kotlin.Unit"")!>y<!>
        if (y != null) this.y.equals(null)
        if (y != null) this.y.propT
        if (y != null) this.y.propAny
        if (y != null) this.y.propNullableT
        if (y != null) this.y.propNullableAny
        if (y != null) this.y.funT()
        if (y != null) this.y.funAny()
        if (y != null) this.y.funNullableT()
        if (y != null) this.y.funNullableAny()
        if (y != null) this.y
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit? & kotlin.Unit"")!>y<!>.equals(null)
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit? & kotlin.Unit"")!>y<!>.propT
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit? & kotlin.Unit"")!>y<!>.propAny
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit? & kotlin.Unit"")!>y<!>.propNullableT
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit? & kotlin.Unit"")!>y<!>.propNullableAny
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit? & kotlin.Unit"")!>y<!>.funT()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit? & kotlin.Unit"")!>y<!>.funAny()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit? & kotlin.Unit"")!>y<!>.funNullableT()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit? & kotlin.Unit"")!>y<!>.funNullableAny()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit? & kotlin.Unit"")!>y<!>
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) this.y.equals(null)
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) this.y.propT
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) this.y.propAny
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) this.y.propNullableT
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) this.y.propNullableAny
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) this.y.funT()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) this.y.funAny()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) this.y.funNullableT()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) this.y.funNullableAny()
        if (y != null || <!SENSELESS_COMPARISON!>this.y != null<!>) this.y

        if (z != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int? & kotlin.Int"")!>z<!>.equals(null)

        if (z != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int? & kotlin.Int"")!>z<!>.propT

        if (z != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int? & kotlin.Int"")!>z<!>.propAny

        if (z != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int? & kotlin.Int"")!>z<!>.propNullableT

        if (z != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int? & kotlin.Int"")!>z<!>.propNullableAny

        if (z != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int? & kotlin.Int"")!>z<!>.funT()

        if (z != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int? & kotlin.Int"")!>z<!>.funAny()

        if (z != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int? & kotlin.Int"")!>z<!>.funNullableT()

        if (z != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int? & kotlin.Int"")!>z<!>.funNullableAny()
        if (z != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int? & kotlin.Int"")!>z<!>
        if (this.z != null) this.z.equals(null)
        if (this.z != null) this.z.propT
        if (this.z != null) this.z.propAny
        if (this.z != null) this.z.propNullableT
        if (this.z != null) this.z.propNullableAny
        if (this.z != null) this.z.funT()
        if (this.z != null) this.z.funAny()
        if (this.z != null) this.z.funNullableT()
        if (this.z != null) this.z.funNullableAny()
        if (this.z != null) this.z
        if (z != null) this.z.equals(null)
        if (z != null) this.z.propT
        if (z != null) this.z.propAny
        if (z != null) this.z.propNullableT",if (z != null) this.z.propNullableAny
"// LANGUAGE: +MultiPlatformProjects
// ISSUE: KT-57963
// MODULE: common
// TARGET_PLATFORM: Common
// FILE: common.kt

@file:Ann

@Target(
    AnnotationTarget.FILE,
    AnnotationTarget.CLASS,
    AnnotationTarget.FUNCTION,
    AnnotationTarget.PROPERTY,
    AnnotationTarget.FIELD,
    AnnotationTarget.PROPERTY_GETTER,
    AnnotationTarget.PROPERTY_SETTER,
    AnnotationTarget.TYPE_PARAMETER,
    AnnotationTarget.VALUE_PARAMETER,
    AnnotationTarget.TYPEALIAS,
    AnnotationTarget.LOCAL_VARIABLE
)
expect annotation class Ann constructor()

@Ann
class C<@Ann T> {
    fun ok() = ""OK""
}

@Ann
fun f(@Ann p: TA): TA {
    @Ann
    var localVar = p
    return p
}

@field:Ann
@get:Ann",@set:Ann
"package com.example

class SomeClass {",companion object CompanionObject {
"if (getter != null && getter.hasBody()) {
                trace.report(ABSTRACT_PROPERTY_WITH_GETTER.on(getter))
            }
            val setter = property.setter
            if (setter != null && setter.hasBody()) {
                trace.report(ABSTRACT_PROPERTY_WITH_SETTER.on(setter))
            }
        }
    }

    private fun checkPropertyInitializer(property: KtProperty, propertyDescriptor: PropertyDescriptor) {
        val hasAnyAccessorImplementation = propertyDescriptor.hasAnyAccessorImplementation()

        val containingDeclaration = propertyDescriptor.containingDeclaration
        val inInterface = DescriptorUtils.isInterface(containingDeclaration)
        if (propertyDescriptor.modality == Modality.ABSTRACT) {
            if (!property.hasDelegateExpressionOrInitializer() && property.typeReference == null) {
                trace.report(PROPERTY_WITH_NO_TYPE_NO_INITIALIZER.on(property))
            }
            if (inInterface && property.hasModifier(KtTokens.PRIVATE_KEYWORD) && !property.hasModifier(KtTokens.ABSTRACT_KEYWORD)) {
                trace.report(PRIVATE_PROPERTY_IN_INTERFACE.on(property))
            }
            return
        }

        val backingFieldRequired = trace.bindingContext.get(BACKING_FIELD_REQUIRED, propertyDescriptor) ?: false
        if (inInterface && backingFieldRequired && hasAnyAccessorImplementation) {
            trace.report(BACKING_FIELD_IN_INTERFACE.on(property))
        }

        val initializer = property.initializer
        val delegate = property.delegate
        val isExpect = propertyDescriptor.isExpect
        if (initializer != null) {
            when {
                inInterface -> trace.report(PROPERTY_INITIALIZER_IN_INTERFACE.on(initializer))
                isExpect -> trace.report(EXPECTED_PROPERTY_INITIALIZER.on(initializer))
                !backingFieldRequired -> trace.report(PROPERTY_INITIALIZER_NO_BACKING_FIELD.on(initializer))
                property.receiverTypeReference != null -> trace.report(EXTENSION_PROPERTY_WITH_BACKING_FIELD.on(initializer))
                property.contextReceivers.isNotEmpty() -> trace.report(CONTEXT_RECEIVERS_WITH_BACKING_FIELD.on(initializer))
            }
        } else if (delegate != null) {
            if (inInterface) {
                trace.report(DELEGATED_PROPERTY_IN_INTERFACE.on(delegate))
            } else if (isExpect) {
                trace.report(EXPECTED_DELEGATED_PROPERTY.on(delegate))
            } else if (property.receiverTypeReference != null) {
                val delegatedPropertyResolvedCall = trace.get(DELEGATED_PROPERTY_RESOLVED_CALL, propertyDescriptor.getter)
                val provideDelegateResolvedCall = trace.get(PROVIDE_DELEGATE_RESOLVED_CALL, propertyDescriptor)
                val delegateType = provideDelegateResolvedCall?.resultingDescriptor?.returnType
                    ?: delegate.expression?.let { trace.getType(it) } ?: return

                val delegateClassDescriptor =
                    delegateType.lowerIfFlexible().unwrap().constructor.declarationDescriptor.let {
                        it as? ClassDescriptor ?: (it as? TypeAliasDescriptor)?.expandedType?.constructor?.declarationDescriptor
                    } as? ClassDescriptor ?: return
                val delegateClassScope by lazy { delegateClassDescriptor.unsubstitutedMemberScope }
                val dispatchReceiverType = delegatedPropertyResolvedCall?.dispatchReceiver?.type
                val extensionReceiverType = delegatedPropertyResolvedCall?.extensionReceiver?.type
                val usedParameter = propertyDescriptor.typeParameters.find { typeParameter ->
                    dispatchReceiverType?.contains { it.constructor == typeParameter.typeConstructor } == true ||
                            extensionReceiverType?.contains { it.constructor == typeParameter.typeConstructor } == true
                }
                if (usedParameter != null) {
                    var propertyWithTypeParameterTypeFound = false",val names = delegateClassScope.getVariableNames()
"/*
 * Copyright 2010-2023 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the LICENSE file.
 */
@file:OptIn(ExperimentalForeignApi::class)",package kotlin.native.internal
"fun box(): String {
    return if (call(10, Int::calc) == 5) ""OK"" else ""fail""
}

val Int.calc: Int
    get() = this / 2","inline fun call(p: Int, s: (Int) -> Int): Int {"
"import kotlin.reflect.KProperty

@Retention(AnnotationRetention.SOURCE)
@Repeatable
annotation class RepeatableAnn
annotation class Ann

class CustomDelegate {
    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name
}

public class A(@param:Ann <!REPEATED_ANNOTATION!>@Ann<!> val x: Int, @param: RepeatableAnn @Ann val y: Int) {

    @field:Ann @property:Ann @RepeatableAnn @property:RepeatableAnn
    val a: Int = 0

    @Ann @field:Ann <!REPEATED_ANNOTATION!>@property:Ann<!>
    val b: Int = 0

    @field:RepeatableAnn @field:RepeatableAnn
    val c: Int = 0

    @property:RepeatableAnn @RepeatableAnn
    val d: Int = 0

    @property:RepeatableAnn @RepeatableAnn @delegate:RepeatableAnn
    val e: String by CustomDelegate()

    @property:Ann @delegate:Ann
    val f: String by CustomDelegate()

    @Ann @delegate:Ann
    val g: String by CustomDelegate()

    @Ann @field:Ann
    val h: String = """"

    @property:Ann @field:Ann
    val i: String = """"
}","@Target(AnnotationTarget.FIELD, AnnotationTarget.PROPERTY)"
"package transitiveStory.bottomActual.mppBeginning

val moduleName = ""top-mpp""
val commonInt = 42
expect val sourceSetName: String

expect open class BottomActualDeclarations() {
    val simpleVal: Int

    companion object Compainon {
        val inTheCompanionOfBottomActualDeclarations: String
    }
}

fun regularTLfunInTheBottomActualCommmon(s: String): String {
    return ""I'm a function at the top level of a file in `commonMain` source set of module $moduleName."" +
            ""This is the message I've got: \n`$s`""
}

// shouldn't be resolved
/*
fun bottActualApiCaller(k: KotlinApiContainer, s: JavaApiContainer) {
    // val first = privateKotlinDeclaration
}*/

internal val tlInternalInCommon = 42

// has a child in jsJvm18Main
open class Outer {",private val a = 1
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_PARAMETER, -EXTENSION_SHADOWED_BY_MEMBER

class Example {
    operator infix fun plus(other: Example) = 0
    fun minus(other: Example) = 0

    operator infix fun times(other: Example) = 0
    fun div(other: Example) = 0
}

fun Example.plus(other: Example) = """"
operator infix fun Example.minus(other: Example) = """"

operator infix fun Example.times(other: Example) = """"
fun Example.div(other: Example) = """"

fun a() {
    val a = Example()
    val b = Example()

    a + b
    a - b
    a * b
    a <!OPERATOR_MODIFIER_REQUIRED!>/<!> b

    a plus b
    a minus b",a times b
"// This test depends on line numbers.
// TARGET_BACKEND: JVM
// WITH_STDLIB
// FULL_JDK
package test

fun testProperLineNumberAfterInline(): String {
    var exceptionCount = 0;
    try {
        fail(inlineFun(),
             ""12"")
    }
    catch(e: AssertionError) {
        val entry = (e as java.lang.Throwable).getStackTrace()!!.get(1)
        val actual = ""${entry.getFileName()}:${entry.getLineNumber()}""
        if (""simpleCallWithParams.kt:10"" != actual) {
            return ""fail 1: ${actual}""
        }
        exceptionCount++
    }

    try {
        fail(""12"",
             inlineFun())
    }
    catch(e: AssertionError) {
        val entry = e.stackTrace!![1]
        val actual = ""${entry.getFileName()}:${entry.getLineNumber()}""
        if (""simpleCallWithParams.kt:23"" != actual) {","return ""fail 2: ${actual}"""
"package lib

interface I1 {
    fun i1() {}
}

interface I2 {
    fun i2() {}
}

interface I3 : I2, I1

open class C {
    fun c() {}
}

open class G<T> {
    fun g() {}
}

private val o1 = object { fun foo() {} }
private val o2 = object : I1 {}
private val o3 = object : I1, I2 {}
private val o4 = object : I3 {}
private val o5 = object : C() {}
private val o6 = object : C(), I1, I2 {}
private val o7 = object : C(), I3 {}
private val o8 = object : G<Int>() {}
private val o9 = object : G<Int>(), I1, I2 {}
private val o10 = object : G<Int>(), I3 {}

private val o11 = object {
    inner class D {
        fun df() {}
    }
    fun d(): D = D()
}.d()

private val o12 = {
    class L {
        fun l() {}
    }
    L()
}()

private val o13 = {
    class L {
        inner class L1 {
            inner class L2 {
                fun l2() {}
            }
        }
    }

    L().L1().L2()
}()

fun fn() {
    o1.foo()
    o2.i1()
    o3.i1()
    o3.i2()",o4.i1()
"// ISSUE: KT-43936
// WITH_STDLIB

import FooOperation.*

interface Operation<T>

class FooOperation(val foo: String) : Operation<Boom> {","@Suppress(""test"")"
"@kotlin.internal.InlineOnly
public inline operator fun kotlin.FloatArray.component1(): kotlin.Float

@kotlin.internal.InlineOnly
public inline operator fun kotlin.IntArray.component1(): kotlin.Int

@kotlin.internal.InlineOnly
public inline operator fun kotlin.LongArray.component1(): kotlin.Long

@kotlin.internal.InlineOnly
public inline operator fun kotlin.ShortArray.component1(): kotlin.Short

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline operator fun kotlin.UByteArray.component1(): kotlin.UByte

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline operator fun kotlin.UIntArray.component1(): kotlin.UInt

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline operator fun kotlin.ULongArray.component1(): kotlin.ULong

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline operator fun kotlin.UShortArray.component1(): kotlin.UShort

@kotlin.internal.InlineOnly
public inline operator fun <T> kotlin.collections.List<T>.component1(): T

@kotlin.internal.InlineOnly
public inline operator fun <K, V> kotlin.collections.Map.Entry<K, V>.component1(): K

@kotlin.internal.InlineOnly
public inline operator fun <T> kotlin.Array<out T>.component2(): T

@kotlin.internal.InlineOnly
public inline operator fun kotlin.BooleanArray.component2(): kotlin.Boolean

@kotlin.internal.InlineOnly
public inline operator fun kotlin.ByteArray.component2(): kotlin.Byte

@kotlin.internal.InlineOnly
public inline operator fun kotlin.CharArray.component2(): kotlin.Char

@kotlin.internal.InlineOnly
public inline operator fun kotlin.DoubleArray.component2(): kotlin.Double

@kotlin.internal.InlineOnly
public inline operator fun kotlin.FloatArray.component2(): kotlin.Float

@kotlin.internal.InlineOnly
public inline operator fun kotlin.IntArray.component2(): kotlin.Int

@kotlin.internal.InlineOnly
public inline operator fun kotlin.LongArray.component2(): kotlin.Long

@kotlin.internal.InlineOnly
public inline operator fun kotlin.ShortArray.component2(): kotlin.Short","@kotlin.SinceKotlin(version = ""1.3"")"
"val resolvedTypes: Int,
        val errorTypes: Int,
        val implicitTypes: Int,
        val errorFunctionCallTypes: Int,
        val errorQualifiedAccessTypes: Int,
        val fileCount: Int,
        val totalLines: Int,
        val errorTypesReports: Map<String, ErrorTypeReport>,
        val timePerTransformer: Map<String, Measure>
    ) {
        val totalTypes: Int = unresolvedTypes + resolvedTypes
        val goodTypes: Int = resolvedTypes - errorTypes - implicitTypes
        val uniqueErrorTypes: Int = errorTypesReports.size

        val totalMeasure = Measure().apply {
            with(timePerTransformer.values) {
                time = sumByLong { it.time }
                user = sumByLong { it.user }
                cpu = sumByLong { it.cpu }
                gcTime = sumByLong { it.gcTime }
                gcCollections = sumOf { it.gcCollections }
                files = map { it.files }.average().toInt()
            }
        }

        val totalTime: Long get() = totalMeasure.time
    }

    data class Measure(
        var time: Long = 0,
        var user: Long = 0,
        var cpu: Long = 0,
        var gcTime: Long = 0,
        var gcCollections: Int = 0,
        var files: Int = 0,
        var vmCounters: VMCounters = VMCounters()
    )

    val timePerTransformer = mutableMapOf<KClass<*>, Measure>()
    var resolvedTypes = 0
    var errorTypes = 0
    var unresolvedTypes = 0
    var errorFunctionCallTypes = 0
    var errorQualifiedAccessTypes = 0
    var implicitTypes = 0
    var fileCount = 0
    var totalTime = 0L
    var totalLines = 0


    private val fails = mutableListOf<FailureInfo>()
    val hasFiles get() = fails.isNotEmpty()

    private val errorTypesReports = mutableMapOf<String, ErrorTypeReport>()

    fun buildFiles(
        builder: PsiRawFirBuilder,
        files: Collection<KtPsiSourceFile>
    ): List<FirFile> {
        listener?.before()
        return files.map { sourceFile ->
            val file = sourceFile.psiFile as KtFile
            val before = vmStateSnapshot()
            val firFile: FirFile
            val time = measureNanoTime {",firFile = builder.buildFirFile(file)
"*     }
 *
 * in Kotlin, but a different signature
 *
 *     interface java.util.Collection<T> {
 *         fun contains(element: java.lang.Object): Boolean
 *         ...
 *     }
 *
 * in Java. In particular, the Java version is not type-safe: it requires us to implement the method
 * given arbitrary objects, even though we know based on the types that our collection can only contain
 * members of type `T`. This is why we have to introduce type-safe wrappers into Kotlin collection classes.
 * In the example above, we produce:
 *
 *    abstract class A : java.util.Collection, I {
 *        ...
 *        fun contains(element: java.lang.Object): Boolean {
 *            if (element !is Int) return false
 *            return contains(element as Int)
 *        }
 *
 *        fun contains(o: Int): Boolean = false
 *    }
 *
 * Similarly, the naming conventions sometimes differ between the Java interfaces and their Kotlin counterparts.
 * Sticking with the example above, we find that `java.util.Collection` contains a method `fun size(): Int`,
 * which maps to a Kotlin property `val size: Int`. The latter is compiled to a method `fun getSize(): Int` and
 * we introduce a bridge to map calls from `size()` to `getSize()`.
 *
 * Finally, while bridges due to type erasure are marked as synthetic, we need special bridges to be visible to
 * the Java compiler. After all, special bridges are the implementation methods for some Java interfaces. If
 * they were synthetic, they would be invisible to javac and it would complain that a Kotlin collection implementation
 * class does not implement all of its interfaces. Similarly, special bridges should be final, since otherwise
 * a user coming from Java might override their implementation, leading to the Kotlin and Java collection
 * implementations getting out of sync.
 *
 * In the other direction, it is possible that a user would reimplement a Kotlin collection in Java.
 * In order to guarantee binary compatibility, we remap all calls to Kotlin collection methods to
 * their Java equivalents instead.
 *
 * Apart from these complications, bridge generation is conceptually simple: For a given Kotlin method we
 * generate bridges for all overridden methods with different signatures, unless a final method with
 * the same signature already exists in a superclass. We only diverge from this idea to match the behavior of
 * the JVM backend in a few corner cases.
 */
@PhaseDescription(
    name = ""Bridge"",
    description = ""Generate bridges"",
    prerequisite = [JvmInlineClassLowering::class, InheritedDefaultMethodsOnClassesLowering::class]
)
internal class BridgeLowering(val context: JvmBackendContext) : ClassLoweringPass {
    // Represents a synthetic bridge to `overridden` with a precomputed signature
    private class Bridge(
        val overridden: IrSimpleFunction,
        val signature: Method,
        val overriddenSymbols: MutableList<IrSimpleFunctionSymbol> = mutableListOf()
    )

    override fun lower(irClass: IrClass) {
        // Bridges in DefaultImpls classes are handled in InterfaceLowering.
        if (irClass.origin == JvmLoweredDeclarationOrigin.DEFAULT_IMPLS || irClass.isAnnotationClass) return

        val bridgeTargets = irClass.functions.filterTo(SmartList()) { it.isPotentialBridgeTarget() }
        if (bridgeTargets.isEmpty()) return","bridgeTargets.forEach { createBridges(irClass, it) }"
"open class MainFileCachedInfo(moduleArtifact: ModuleArtifact, fileArtifact: SrcFileArtifact, moduleHeader: JsIrModuleHeader? = null) :
            SerializableCachedFileInfo(moduleArtifact, fileArtifact, moduleHeader) {
            var mainFunctionTag: String? = null
            var testEnvironment: JsIrProgramTestEnvironment? = null
            var exportFileCachedInfo: ExportFileCachedInfo? = null

            val jsFileArtifact by lazy(LazyThreadSafetyMode.NONE) { getArtifactWithName(CACHED_FILE_JS) }
            val moduleHeaderArtifact by lazy(LazyThreadSafetyMode.NONE) { getArtifactWithName(JS_MODULE_HEADER) }
            val sourceMapFileArtifact by lazy(LazyThreadSafetyMode.NONE) { getArtifactWithName(CACHED_FILE_JS_MAP) }

            class Merged(private val cachedFileInfos: List<MainFileCachedInfo>) :
                MainFileCachedInfo(cachedFileInfos.first().moduleArtifact, cachedFileInfos.first().fileArtifact) {
                override fun loadJsIrModule(): JsIrModule = cachedFileInfos.map { it.loadJsIrModule() }.merge()

                override val filePrefix by lazy(LazyThreadSafetyMode.NONE) {
                    val hash = cachedFileInfos.map { it.fileArtifact.srcFilePath }.sorted().joinToString().cityHash64()
                    fileArtifact.srcFilePath.run { ""${substringAfterLast('/')}.$hash.merged"" }
                }

                init {
                    assert(cachedFileInfos.size > 1) { ""Merge is unnecessary"" }
                    var isModified = false

                    for (info in cachedFileInfos) {
                        if (!info.fileArtifact.isModified()) {
                            isModified = true
                        }
                        info.testEnvironment?.let { testEnvironment = it }
                    }

                    val mainAndExportHeaders = when {
                        isModified -> cachedFileInfos.asSequence().map { it.fileArtifact.loadJsIrModuleHeaders(moduleArtifact) }
                        else -> cachedFileInfos.asSequence().map { LoadedJsIrModuleHeaders(it.mainFunctionTag, it.jsIrHeader, it.exportFileCachedInfo?.jsIrHeader) }
                    }

                    val mainHeaders = mutableListOf<JsIrModuleHeader>()
                    val exportHeaders = mutableListOf<JsIrModuleHeader>()

                    for (loadedIrModuleHeaders in mainAndExportHeaders) {
                        mainHeaders.add(loadedIrModuleHeaders.mainHeader)

                        loadedIrModuleHeaders.exportHeader
                            ?.let { exportHeaders.add(it) }

                        loadedIrModuleHeaders.mainFunctionTag
                            .takeIf { mainFunctionTag == null }
                            ?.let { mainFunctionTag = it }
                    }

                    jsIrHeader = mainHeaders.merge()
                    exportFileCachedInfo = exportHeaders.takeIf { it.isNotEmpty() }?.let {
                        ExportFileCachedInfo.Merged(
                            filePrefix,
                            it.merge(),
                            cachedFileInfos.mapNotNull(MainFileCachedInfo::exportFileCachedInfo)
                        )
                    }
                }
            }
        }

        open class ExportFileCachedInfo(
            moduleArtifact: ModuleArtifact,
            fileArtifact: SrcFileArtifact,
            moduleHeader: JsIrModuleHeader? = null,",var tsDeclarationsHash: Long? = null
"/**
 * Returns the sum of all values produced by [selector] function applied to each element in the array.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@Suppress(""INAPPLICABLE_JVM_NAME"")
@kotlin.jvm.JvmName(""sumOfLong"")
@ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun UShortArray.sumOf(selector: (UShort) -> Long): Long {
    var sum: Long = 0.toLong()
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the array.
 */
@SinceKotlin(""1.5"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@Suppress(""INAPPLICABLE_JVM_NAME"")
@kotlin.jvm.JvmName(""sumOfUInt"")
@ExperimentalUnsignedTypes
@WasExperimental(ExperimentalUnsignedTypes::class)
@kotlin.internal.InlineOnly
public inline fun UIntArray.sumOf(selector: (UInt) -> UInt): UInt {
    var sum: UInt = 0.toUInt()
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the array.
 */
@SinceKotlin(""1.5"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@Suppress(""INAPPLICABLE_JVM_NAME"")
@kotlin.jvm.JvmName(""sumOfUInt"")
@ExperimentalUnsignedTypes
@WasExperimental(ExperimentalUnsignedTypes::class)
@kotlin.internal.InlineOnly
public inline fun ULongArray.sumOf(selector: (ULong) -> UInt): UInt {
    var sum: UInt = 0.toUInt()
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the array.
 */
@SinceKotlin(""1.5"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@Suppress(""INAPPLICABLE_JVM_NAME"")
@kotlin.jvm.JvmName(""sumOfUInt"")
@ExperimentalUnsignedTypes",@WasExperimental(ExperimentalUnsignedTypes::class)
"// FIR_DUMP
// ISSUE: KT-48799

class C {
    val v1: String
        @Deprecated("""", level = DeprecationLevel.HIDDEN)
        get() = """"

    @Deprecated("""", level = DeprecationLevel.HIDDEN)
    val v2 = """"

    var v3: String
        @Deprecated("""", level = DeprecationLevel.HIDDEN)
        get() = """"
        set(value) {}

    var v4: String
        get() = """"
        @Deprecated("""", level = DeprecationLevel.HIDDEN)
        set(value) {
        }

    var v5: String
        @Deprecated("""", level = DeprecationLevel.HIDDEN)
        get() = """"
        @Deprecated("""", level = DeprecationLevel.HIDDEN)
        set(value) {
        }

    @Deprecated("""", level = DeprecationLevel.HIDDEN)
    var v6: String
        get() = """"
        set(value) {}
}

val v1: String = """"
val v2: String = """"
var v3: String = """"
var v4: String = """"
var v5: String = """"
var v6: String = """"

fun test(c: C) {",with (c) {
"// EXPECTED_REACHABLE_NODES: 1281
// MODULE: lib
// FILE: lib1.kt

inline fun foo() = ""OK""","inline fun bar(x: String) = ""($x)"""
"// DONT_TARGET_EXACT_BACKEND: JVM
// DONT_TARGET_EXACT_BACKEND: JS
fun <T> T.id() = this

const val trueVal = <!EVALUATED(""true"")!>true<!>
const val falseVal = <!EVALUATED(""false"")!>false<!>

const val not1 = trueVal.<!EVALUATED(""false"")!>not()<!>
const val not2 = falseVal.<!EVALUATED(""true"")!>not()<!>

const val and1 = trueVal.<!EVALUATED(""true"")!>and(trueVal)<!>
const val and2 = trueVal.<!EVALUATED(""false"")!>and(falseVal)<!>
const val and3 = falseVal.<!EVALUATED(""false"")!>and(trueVal)<!>
const val and4 = falseVal.<!EVALUATED(""false"")!>and(falseVal)<!>

const val or1 = trueVal.<!EVALUATED(""true"")!>or(trueVal)<!>
const val or2 = trueVal.<!EVALUATED(""true"")!>or(falseVal)<!>
const val or3 = falseVal.<!EVALUATED(""true"")!>or(trueVal)<!>
const val or4 = falseVal.<!EVALUATED(""false"")!>or(falseVal)<!>

const val xor1 = trueVal.<!EVALUATED(""false"")!>xor(trueVal)<!>
const val xor2 = trueVal.<!EVALUATED(""true"")!>xor(falseVal)<!>
const val xor3 = falseVal.<!EVALUATED(""true"")!>xor(trueVal)<!>
const val xor4 = falseVal.<!EVALUATED(""false"")!>xor(falseVal)<!>

const val compareTo1 = trueVal.<!EVALUATED(""0"")!>compareTo(trueVal)<!>
const val compareTo2 = trueVal.<!EVALUATED(""1"")!>compareTo(falseVal)<!>
const val compareTo3 = falseVal.<!EVALUATED(""-1"")!>compareTo(trueVal)<!>
const val compareTo4 = falseVal.<!EVALUATED(""0"")!>compareTo(falseVal)<!>

const val equals1 = <!EVALUATED(""true"")!>trueVal == trueVal<!>
const val equals2 = <!EVALUATED(""false"")!>trueVal == falseVal<!>
const val equals3 = <!EVALUATED(""false"")!>falseVal == trueVal<!>
const val equals4 = <!EVALUATED(""true"")!>falseVal == falseVal<!>

const val toString1 = trueVal.<!EVALUATED(""true"")!>toString()<!>
const val toString2 = falseVal.<!EVALUATED(""false"")!>toString()<!>

// STOP_EVALUATION_CHECKS
fun box(): String {
    if (not1.id() != false)  return ""Fail 1.1""
    if (not2.id() != true)   return ""Fail 1.2""

    if (and1.id() != true)   return ""Fail 2.1""
    if (and2.id() != false)  return ""Fail 2.2""
    if (and3.id() != false)  return ""Fail 2.3""
    if (and4.id() != false)  return ""Fail 2.4""

    if (or1.id() != true)    return ""Fail 3.1""
    if (or2.id() != true)    return ""Fail 3.2""
    if (or3.id() != true)    return ""Fail 3.3""
    if (or4.id() != false)   return ""Fail 3.4""

    if (xor1.id() != false)  return ""Fail 4.1""
    if (xor2.id() != true)   return ""Fail 4.2""
    if (xor3.id() != true)   return ""Fail 4.3""","if (xor4.id() != false)  return ""Fail 4.4"""
"JvmSerializeIrMode.Companion::fromString,
    )
}

private sealed class PatternWithExtractor<E : Any> {
    abstract val configurationKey: CompilerConfigurationKey<E>
    abstract val pattern: Pattern

    abstract fun extract(matcher: Matcher): E
}

private class ValuePatternWithExtractor<E : Any>(
    val directive: String,
    override val configurationKey: CompilerConfigurationKey<E>,
    val extractor: (String) -> E?
) : PatternWithExtractor<E>() {
    override val pattern: Pattern = Pattern.compile(""$directive=([a-zA-Z_0-9-]*)"")

    override fun extract(matcher: Matcher): E {
        val stringValue = matcher.group(1)
        return extractor(stringValue) ?: error(""Wrong $directive value: $stringValue"")
    }
}

private class BooleanPatternWithExtractor(
    val directive: String,
    override val configurationKey: CompilerConfigurationKey<Boolean>
) : PatternWithExtractor<Boolean>() {
    override val pattern: Pattern = Pattern.compile(directive)

    override fun extract(matcher: Matcher): Boolean {
        return true
    }
}

private fun <E : Any> MutableList<PatternWithExtractor<*>>.createPattern(
    directive: String,
    configurationKey: CompilerConfigurationKey<E>,
    extractor: (String) -> E?,
): PatternWithExtractor<E> {
    return ValuePatternWithExtractor(directive, configurationKey, extractor).also { this += it }
}

private fun MutableList<PatternWithExtractor<*>>.createPattern(
    directive: String,
    configurationKey: CompilerConfigurationKey<Boolean>
): PatternWithExtractor<Boolean> {
    return BooleanPatternWithExtractor(directive, configurationKey).also { this += it }
}

private val FLAG_CLASSES: List<Class<*>> = listOf(
    CLIConfigurationKeys::class.java,
    JVMConfigurationKeys::class.java
)

private val FLAG_NAMESPACE_TO_CLASS: Map<String, Class<*>> = mapOf(
    ""CLI"" to CLIConfigurationKeys::class.java,
    ""JVM"" to JVMConfigurationKeys::class.java
)

fun parseAnalysisFlags(rawFlags: List<String>): Map<CompilerConfigurationKey<*>, Any> {
    val result = mutableMapOf<CompilerConfigurationKey<*>, Any>()

    @Suppress(""unused"")
    for (flag in rawFlags) {",var m = BOOLEAN_FLAG_PATTERN.matcher(flag)
"* Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:JvmName(""JvmIdePlatformUtil"")
@file:Suppress(""DEPRECATION_ERROR"", ""DeprecatedCallableAddReplaceWith"")

package org.jetbrains.kotlin.platform.impl

import org.jetbrains.kotlin.cli.common.arguments.CommonCompilerArguments
import org.jetbrains.kotlin.cli.common.arguments.K2JVMCompilerArguments
import org.jetbrains.kotlin.config.JvmTarget
import org.jetbrains.kotlin.platform.IdePlatform
import org.jetbrains.kotlin.platform.IdePlatformKind
import org.jetbrains.kotlin.platform.TargetPlatform
import org.jetbrains.kotlin.platform.jvm.JvmPlatforms
import org.jetbrains.kotlin.platform.jvm.isJvm

object JvmIdePlatformKind : IdePlatformKind() {
    override fun supportsTargetPlatform(platform: TargetPlatform): Boolean = platform.isJvm()

    private val jvmTargetDescriptionMap by lazy {
        JvmTarget.values().associateBy { it.description }
    }

    override fun platformByCompilerArguments(arguments: CommonCompilerArguments): TargetPlatform? {
        if (arguments !is K2JVMCompilerArguments) return null

        val jvmTargetDescription = arguments.jvmTarget ?: return JvmPlatforms.defaultJvmPlatform
        val jvmTarget = jvmTargetDescriptionMap[jvmTargetDescription] ?: return JvmPlatforms.defaultJvmPlatform

        return JvmPlatforms.jvmPlatformByTargetVersion(jvmTarget)
    }

    @Deprecated(
        message = ""IdePlatform is deprecated and will be removed soon, please, migrate to org.jetbrains.kotlin.platform.TargetPlatform"",
        level = DeprecationLevel.ERROR
    )
    override fun getDefaultPlatform(): Platform = Platform(JvmTarget.DEFAULT)

    override fun createArguments(): CommonCompilerArguments {
        return K2JVMCompilerArguments()
    }

    val platforms: List<TargetPlatform> = JvmTarget.values()
        .map { ver -> JvmPlatforms.jvmPlatformByTargetVersion(ver) } + listOf(JvmPlatforms.unspecifiedJvmPlatform)

    override val defaultPlatform get() = JvmPlatforms.defaultJvmPlatform

    override val argumentsClass get() = K2JVMCompilerArguments::class.java

    override val name get() = ""JVM""

    @Deprecated(
        message = ""IdePlatform is deprecated and will be removed soon, please, migrate to org.jetbrains.kotlin.platform.TargetPlatform"",
        level = DeprecationLevel.ERROR
    )
    data class Platform(override val version: JvmTarget) : IdePlatform<JvmIdePlatformKind, K2JVMCompilerArguments>() {
        override val kind get() = JvmIdePlatformKind

        override fun createArguments(init: K2JVMCompilerArguments.() -> Unit) = K2JVMCompilerArguments()
            .apply(init)
            .apply { jvmTarget = this@Platform.version.description }
    }
}",val IdePlatformKind?.isJvm
"<!DIRECTIVES(""HELPERS: REFLECT"")!>

val Boolean.<!ELEMENT(1)!>: Boolean
    get() {
        return true
    }

val Boolean?.<!ELEMENT(2)!>: Boolean
    get() {",return false
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_PARAMETER
open class Base<T>(p: Any?) {
    fun foo1(t: T) {}
}

fun Base<Int>.foo() {
    class B : Base<String> {
        constructor() : super(<!INSTANCE_ACCESS_BEFORE_SUPER_CALL!>foo1<!>(""""))",constructor(x: Int) : super(foo1(1))
"// !LANGUAGE: +ProperIeee754Comparisons

// JVM_ABI_K1_K2_DIFF: KT-63855

fun <A: Double, B: Double?> eq_double_doubleN(a: A, b: B) = a == b

fun <A: Double, B: Any> eq_double_any(a: A, b: B) = a == b

fun <A: Double, B: Any?> eq_double_anyN(a: A, b: B) = a == b

fun <A: Double?, B: Double> eq_doubleN_double(a: A, b: B) = a == b

fun <A: Double?, B: Double?> eq_doubleN_doubleN(a: A, b: B) = a == b

fun <A: Double?, B: Any> eq_doubleN_any(a: A, b: B) = a == b

fun <A: Double?, B: Any?> eq_doubleN_anyN(a: A, b: B) = a == b

fun box(): String {
    if (!eq_double_doubleN(0.0, -0.0)) throw AssertionError(""!eq_double_doubleN(0.0, -0.0)"")
    if (eq_double_doubleN(0.0, null)) throw AssertionError(""eq_double_doubleN(0.0, null)"")
    if (!eq_double_any(0.0, 0.0)) throw AssertionError(""!eq_double_any(0.0, 0.0)"")
    if (eq_double_any(0.0, -0.0)) throw AssertionError(""eq_double_any(0.0, -0.0)"")
    if (!eq_double_anyN(0.0, 0.0)) throw AssertionError(""!eq_double_anyN(0.0, 0.0)"")
    if (eq_double_anyN(0.0, -0.0)) throw AssertionError(""eq_double_anyN(0.0, -0.0)"")
    if (eq_double_anyN(0.0, null)) throw AssertionError(""eq_double_anyN(0.0, null)"")","if (eq_doubleN_double(null, 0.0)) throw AssertionError(""eq_doubleN_double(null, 0.0)"")"
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package org.jetbrains.kotlin.fir.backend.jvm
"* @sample samples.collections.Collections.Aggregates.maxBy
 */
@SinceKotlin(""1.7"")
@kotlin.jvm.JvmName(""maxByOrThrow"")
@Suppress(""CONFLICTING_OVERLOADS"")
public inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int {
    if (isEmpty()) throw NoSuchElementException()
    var maxElem = this[0]
    val lastIndex = this.lastIndex
    if (lastIndex == 0) return maxElem
    var maxValue = selector(maxElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = selector(e)
        if (maxValue < v) {
            maxElem = e
            maxValue = v
        }
    }
    return maxElem
}

/**
 * Returns the first element yielding the largest value of the given function.
 * 
 * @throws NoSuchElementException if the array is empty.
 * 
 * @sample samples.collections.Collections.Aggregates.maxBy
 */
@SinceKotlin(""1.7"")
@kotlin.jvm.JvmName(""maxByOrThrow"")
@Suppress(""CONFLICTING_OVERLOADS"")
public inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long {
    if (isEmpty()) throw NoSuchElementException()
    var maxElem = this[0]
    val lastIndex = this.lastIndex
    if (lastIndex == 0) return maxElem
    var maxValue = selector(maxElem)
    for (i in 1..lastIndex) {
        val e = this[i]
        val v = selector(e)
        if (maxValue < v) {
            maxElem = e
            maxValue = v
        }
    }
    return maxElem
}

/**
 * Returns the first element yielding the largest value of the given function.
 * 
 * @throws NoSuchElementException if the array is empty.
 * 
 * @sample samples.collections.Collections.Aggregates.maxBy
 */
@SinceKotlin(""1.7"")
@kotlin.jvm.JvmName(""maxByOrThrow"")
@Suppress(""CONFLICTING_OVERLOADS"")
public inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float {
    if (isEmpty()) throw NoSuchElementException()
    var maxElem = this[0]
    val lastIndex = this.lastIndex
    if (lastIndex == 0) return maxElem
    var maxValue = selector(maxElem)",for (i in 1..lastIndex) {
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.backend.jvm.codegen

import org.jetbrains.kotlin.backend.common.IrWhenUtils
import org.jetbrains.kotlin.codegen.`when`.SwitchCodegen.Companion.preferLookupOverSwitch
import org.jetbrains.kotlin.ir.expressions.*
import org.jetbrains.kotlin.ir.types.*
import org.jetbrains.kotlin.ir.util.hasAnnotation
import org.jetbrains.kotlin.load.java.JvmAnnotationNames
import org.jetbrains.org.objectweb.asm.Label
import org.jetbrains.org.objectweb.asm.Type

// TODO: eliminate the temporary variable
class SwitchGenerator(private val expression: IrWhen, private val data: BlockInfo, private val codegen: ExpressionCodegen) {
    data class ExpressionToLabel(val expression: IrExpression, val label: Label)
    data class CallToLabel(val call: IrCall, val label: Label)
    data class ValueToLabel(val value: Any?, val label: Label)

    private val context = codegen.context

    // @return null if the IrWhen cannot be emitted as lookupswitch or tableswitch.
    fun generate(): PromisedValue? {
        val expressionToLabels = ArrayList<ExpressionToLabel>()
        var elseExpression: IrExpression? = null
        val callToLabels = ArrayList<CallToLabel>()

        // Parse the when structure. Note that the condition can be nested. See matchConditions() for details.
        for (branch in expression.branches) {
            if (branch is IrElseBranch) {
                elseExpression = branch.result
            } else {
                val conditions = IrWhenUtils.matchConditions(context.irBuiltIns.ororSymbol, branch.condition) ?: return null",val thenLabel = Label()
"}
}

fun test22() {
    var x: Any? = materialize()
    for (i in 1..10) {
        require(x is String)
        exactlyOnce {
            x.length
            x = materialize()
        }
    }
}

fun test23() {
    var x: Any? = materialize()
    for (i in 1..10) {
        require(x is String)
        atLeastOnce {
            x.<!UNRESOLVED_REFERENCE!>length<!>
            x = materialize()
        }
    }
}

fun test24() {
    var x: Any? = materialize()
    for (i in 1..10) {
        require(x is String)
        runWithoutContract {
            x.<!UNRESOLVED_REFERENCE!>length<!>
            x = materialize()
        }
    }
}

fun test25() {
    var x: Any? = materialize()
    for (i in 1..10) {
        require(x is String)
        exactlyOnce {
            x.length
        }
        x = """"
    }
}

fun test26() {
    var x: Any? = materialize()
    for (i in 1..10) {
        require(x is String)
        atLeastOnce {
            x.length
        }
        x = """"
    }
}

fun test27() {
    var x: Any? = materialize()
    for (i in 1..10) {
        require(x is String)
        runWithoutContract {
            <!SMARTCAST_IMPOSSIBLE!>x<!>.length
        }","x = """""
"""<artifactId>sample-lib-multiplatform</artifactId>"",
                    ""<version>1.0</version>""
                )
                assertFileContains(
                    ""repo/com/exampleapp/sample-app-jvm8/1.0/sample-app-jvm8-1.0.pom"",
                    ""<groupId>com.example</groupId>"",
                    ""<artifactId>sample-lib-multiplatform</artifactId>"",
                    ""<version>1.0</version>""
                )
                assertFileContains(
                    ""repo/com/exampleapp/sample-app-jvm8/1.0/sample-app-jvm8-1.0.pom"",
                    ""<groupId>com.external.dependency</groupId>"",
                    ""<artifactId>external</artifactId>"",
                    ""<version>1.2.3</version>""
                )
            }
        }
    }

    @Test
    fun testMppBuildWithCompilerPlugins() = with(transformNativeTestProject(""sample-lib"", gradleVersion, ""new-mpp-lib-and-app"")) {
        val printOptionsTaskName = ""printCompilerPluginOptions""
        val argsMarker = ""=args=>""
        val classpathMarker = ""=cp=>""
        val compilerPluginArgsRegex = ""(\\w+)${Regex.escape(argsMarker)}(.*)"".toRegex()
        val compilerPluginClasspathRegex = ""(\\w+)${Regex.escape(classpathMarker)}(.*)"".toRegex()

        gradleBuildScript().appendText(
            ""\n"" + """"""
            buildscript {
                dependencies {
                    classpath ""org.jetbrains.kotlin:kotlin-allopen:${'$'}kotlin_version""
                    classpath ""org.jetbrains.kotlin:kotlin-noarg:${'$'}kotlin_version""
                }
            }
            apply plugin: 'kotlin-allopen'
            apply plugin: 'kotlin-noarg'

            allOpen { annotation 'com.example.Annotation' }
            noArg { annotation 'com.example.Annotation' }

            task $printOptionsTaskName {
                // if the tasks are not configured during evaluation phase, configuring them during execution
                // leads to new dependencies unsuccessfully added to the resolved compilerPluginsClasspath configuration
                kotlin.targets.all { compilations.all { /*force to configure the*/ compileKotlinTask } }
                doFirst {
                    kotlin.sourceSets.each { sourceSet ->
                        def args = sourceSet.languageSettings.compilerPluginArguments
                        def cp = sourceSet.languageSettings.compilerPluginClasspath.files
                        println sourceSet.name + '$argsMarker' + args
                        println sourceSet.name + '$classpathMarker' + cp
                    }
                }
            }
            """""".trimIndent()
        )

        projectDir.resolve(""src/commonMain/kotlin/Annotation.kt"").writeText(
            """"""
            package com.example
            annotation class Annotation
            """""".trimIndent()
        )
        projectDir.resolve(""src/commonMain/kotlin/Annotated.kt"").writeText(
            """"""",package com.example
"// WITH_STDLIB

@file:JvmName(""TestKt"")
package test

import kotlinx.parcelize.*",import android.os.Parcel
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.impl.base.test.cases.components.readWriteAccess

import org.jetbrains.kotlin.analysis.test.framework.base.AbstractAnalysisApiBasedTest
import org.jetbrains.kotlin.analysis.test.framework.project.structure.KtTestModule
import org.jetbrains.kotlin.analysis.test.framework.services.expressionMarkerProvider
import org.jetbrains.kotlin.idea.references.readWriteAccess",import org.jetbrains.kotlin.psi.KtExpression
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_PARAMETER, -ERROR_SUPPRESSION
@DslMarker
annotation class Ann

@Ann
class A {
    @Suppress(""INVISIBLE_MEMBER"", ""INVISIBLE_REFERENCE"")
    @kotlin.internal.LowPriorityInOverloadResolution
    fun a() = 1
}

@Ann
class B {
    fun b() = 2
}

fun foo(x: A.() -> Unit) {}
fun bar(x: B.() -> Unit) {}

fun test() {
    foo {
        a()
        bar {",<!DSL_SCOPE_VIOLATION!>a<!>()
"// CORRECT_ERROR_TYPES
// NO_VALIDATION

@file:Suppress(""UNRESOLVED_REFERENCE"")
import java.util.Date as MyDate
import java.util.concurrent.TimeUnit as MyTimeUnit
import java.util.concurrent.TimeUnit.*
import java.util.concurrent.TimeUnit.MICROSECONDS as MyMicroseconds
import kotlin.arrayOf
import a.b.ABC as MyABC
import bcd as MyBCD

class Test {",lateinit var date: MyDate
"if (!property.visibility.isPublicAPI) {
                if (useTypeTable()) {
                    builder.inlineClassUnderlyingTypeId = typeId(inlineClassRepresentation.underlyingType)
                } else {
                    builder.setInlineClassUnderlyingType(type(inlineClassRepresentation.underlyingType))
                }
            }
        }

        classDescriptor.multiFieldValueClassRepresentation?.let { multiFieldValueClassRepresentation ->
            val namesToTypes = multiFieldValueClassRepresentation.underlyingPropertyNamesToTypes
            builder.addAllMultiFieldValueClassUnderlyingName(namesToTypes.map { (name, _) -> getSimpleNameIndex(name) })
            if (useTypeTable()) {
                builder.addAllMultiFieldValueClassUnderlyingTypeId(namesToTypes.map { (_, kotlinType) -> typeId(kotlinType) })
            } else {
                builder.addAllMultiFieldValueClassUnderlyingType(namesToTypes.map { (_, kotlinType) -> type(kotlinType).build() })
            }
        }

        if (versionRequirementTable == null) error(""Version requirements must be serialized for classes: $classDescriptor"")

        builder.addAllVersionRequirement(versionRequirementTable.serializeVersionRequirements(classDescriptor))

        extension.serializeClass(classDescriptor, builder, versionRequirementTable, this)

        plugins.forEach { it.afterClass(classDescriptor, builder, versionRequirementTable, this, extension) }

        if (metDefinitelyNotNullType) {
            builder.addVersionRequirement(
                writeLanguageVersionRequirement(LanguageFeature.DefinitelyNonNullableTypes, versionRequirementTable)
            )
        }

        typeTable.serialize()?.let { builder.typeTable = it }
        versionRequirementTable.serialize()?.let { builder.versionRequirementTable = it }

        return builder
    }

    fun propertyProto(descriptor: PropertyDescriptor): ProtoBuf.Property.Builder? {
        val builder = ProtoBuf.Property.newBuilder()

        val local = createChildSerializer(descriptor)

        var hasGetter = false
        var hasSetter = false

        val compileTimeConstant = descriptor.compileTimeInitializer
        val hasConstant = compileTimeConstant != null && compileTimeConstant !is NullValue

        val hasAnnotations =
            hasAnnotations(descriptor) || hasAnnotations(descriptor.backingField) || hasAnnotations(descriptor.delegateField)

        val defaultAccessorFlags = Flags.getAccessorFlags(
            hasAnnotations,
            ProtoEnumFlags.descriptorVisibility(normalizeVisibility(descriptor)),
            ProtoEnumFlags.modality(descriptor.modality),
            false, false, false
        )

        val getter = descriptor.getter
        if (getter != null) {
            hasGetter = true
            val accessorFlags = getAccessorFlags(getter)
            if (accessorFlags != defaultAccessorFlags) {",builder.getterFlags = accessorFlags
"@Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    fun linuxMips32(
        name: String = ""linuxMips32"",
        configure: KotlinNativeTarget.() -> Unit = { }
    ): KotlinNativeTarget =
        configureOrCreate(
            name,
            @Suppress(""DEPRECATION"")
            presets.getByName(""linuxMips32"") as KotlinNativeTargetPreset,
            configure
        )


    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMips32() = linuxMips32(""linuxMips32"") { }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMips32(name: String) = linuxMips32(name) { }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMips32(name: String, configure: Action<KotlinNativeTarget>) = linuxMips32(name) { configure.execute(this) }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMips32(configure: Action<KotlinNativeTarget>) = linuxMips32 { configure.execute(this) }


    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    fun linuxMipsel32(
        name: String = ""linuxMipsel32"",
        configure: KotlinNativeTarget.() -> Unit = { }
    ): KotlinNativeTarget =
        configureOrCreate(
            name,
            @Suppress(""DEPRECATION"")
            presets.getByName(""linuxMipsel32"") as KotlinNativeTargetPreset,
            configure
        )


    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMipsel32() = linuxMipsel32(""linuxMipsel32"") { }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMipsel32(name: String) = linuxMipsel32(name) { }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMipsel32(name: String, configure: Action<KotlinNativeTarget>) = linuxMipsel32(name) { configure.execute(this) }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMipsel32(configure: Action<KotlinNativeTarget>) = linuxMipsel32 { configure.execute(this) }


    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    fun wasm32(
        name: String = ""wasm32"",",configure: KotlinNativeTarget.() -> Unit = { }
"throw IndexOutOfBoundsException(
                ""The destination array does not have enough capacity, "" +
                        ""destination offset: $destinationOffset, destination size: $destinationSize, capacity needed: $capacityNeeded""
            )
        }
    }

    // companion object

    /**
     * The ""base64"" encoding specified by [`RFC 4648 section 4`](https://www.rfc-editor.org/rfc/rfc4648#section-4),
     * Base 64 Encoding.
     *
     * Uses ""The Base 64 Alphabet"" as specified in Table 1 of RFC 4648 for encoding and decoding.
     * Encode operation does not add any line separator character.
     * Decode operation throws if it encounters a character outside the base64 alphabet.
     *
     * The character `'='` is used for padding.
     */
    public companion object Default : Base64(isUrlSafe = false, isMimeScheme = false) {

        private const val bitsPerByte: Int = 8
        private const val bitsPerSymbol: Int = 6

        internal const val bytesPerGroup: Int = 3
        internal const val symbolsPerGroup: Int = 4

        internal const val padSymbol: Byte = 61 // '='

        internal const val mimeLineLength: Int = 76
        private const val mimeGroupsPerLine: Int = mimeLineLength / symbolsPerGroup
        internal val mimeLineSeparatorSymbols: ByteArray = byteArrayOf('\r'.code.toByte(), '\n'.code.toByte())

        /**
         * The ""base64url"" encoding specified by [`RFC 4648 section 5`](https://www.rfc-editor.org/rfc/rfc4648#section-5),
         * Base 64 Encoding with URL and Filename Safe Alphabet.
         *
         * Uses ""The URL and Filename safe Base 64 Alphabet"" as specified in Table 2 of RFC 4648 for encoding and decoding.
         * Encode operation does not add any line separator character.
         * Decode operation throws if it encounters a character outside the base64url alphabet.
         *
         * The character `'='` is used for padding.
         */
        public val UrlSafe: Base64 = Base64(isUrlSafe = true, isMimeScheme = false)

        /**
         * The encoding specified by [`RFC 2045 section 6.8`](https://www.rfc-editor.org/rfc/rfc2045#section-6.8),
         * Base64 Content-Transfer-Encoding.
         *
         * Uses ""The Base64 Alphabet"" as specified in Table 1 of RFC 2045 for encoding and decoding.
         * Encode operation adds CRLF every 76 symbols. No line separator is added to the end of the encoded output.
         * Decode operation ignores all line separators and other characters outside the base64 alphabet.
         *
         * The character `'='` is used for padding.
         */
        public val Mime: Base64 = Base64(isUrlSafe = false, isMimeScheme = true)
    }
}


// ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/""
private val base64EncodeMap = byteArrayOf(
    65,  66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,  79,  80,  /* 0 - 15 */
    81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  97,  98,  99,  100, 101, 102, /* 16 - 31 */
    103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, /* 32 - 47 */","119, 120, 121, 122, 48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  43,  47,  /* 48 - 63 */"
"inline fun <T> with(receiver : T, body :  T.() -> Unit) = receiver.body()

fun example() {",with(java.lang.System.out) {
"// WITH_STDLIB
// WORKS_WHEN_VALUE_CLASS
// LANGUAGE: +ValueClasses

import kotlin.test.*

OPTIONAL_JVM_INLINE_ANNOTATION",value class S(val string: String)
"import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SINGLETON_IN_SUPERTYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SINGLE_ANONYMOUS_FUNCTION_WITH_NAME
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SMARTCAST_IMPOSSIBLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SMARTCAST_IMPOSSIBLE_ON_IMPLICIT_INVOKE_RECEIVER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SPREAD_OF_NULLABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUBCLASS_OPT_ARGUMENT_IS_NOT_MARKER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUBCLASS_OPT_IN_INAPPLICABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUBTYPING_BETWEEN_CONTEXT_RECEIVERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERCLASS_NOT_ACCESSIBLE_FROM_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPES_FOR_ANNOTATION_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_APPEARS_TWICE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_INITIALIZED_IN_EXPECTED_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_INITIALIZED_IN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_INITIALIZED_WITHOUT_PRIMARY_CONSTRUCTOR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_IS_EXTENSION_FUNCTION_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_NOT_A_CLASS_OR_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_NOT_INITIALIZED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPER_CALL_FROM_PUBLIC_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPER_CALL_WITH_DEFAULT_PARAMETERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPER_IS_NOT_AN_EXPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPER_NOT_AVAILABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TAILREC_ON_VIRTUAL_MEMBER_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TAIL_RECURSION_IN_TRY_IS_NOT_SUPPORTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.THROWABLE_TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TOO_MANY_ARGUMENTS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TOO_MANY_CHARACTERS_IN_CHARACTER_LITERAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TOPLEVEL_TYPEALIASES_ONLY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPEALIAS_AS_CALLABLE_QUALIFIER_IN_IMPORT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPEALIAS_EXPANDS_TO_ARRAY_OF_NOTHINGS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPEALIAS_EXPANSION_DEPRECATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPEALIAS_EXPANSION_DEPRECATION_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPEALIAS_SHOULD_EXPAND_TO_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_ARGUMENTS_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_ARGUMENTS_REDUNDANT_IN_SUPER_QUALIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_ARGUMENT_ON_TYPED_VALUE_CLASS_EQUALS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_CANT_BE_USED_FOR_CONST_VAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_INFERENCE_ONLY_INPUT_TYPES_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETERS_IN_ANONYMOUS_OBJECT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETERS_IN_ENUM
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETERS_IN_OBJECT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETERS_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETER_AS_REIFIED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETER_AS_REIFIED_ARRAY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETER_IN_CATCH_CLAUSE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETER_IS_NOT_AN_EXPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETER_OF_PROPERTY_NOT_USED_IN_RECEIVER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETER_ON_LHS_OF_DOT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_VARIANCE_CONFLICT_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_VARIANCE_CONFLICT_IN_EXPANDED_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNCHECKED_CAST
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNDERSCORE_IS_RESERVED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNDERSCORE_USAGE_WITHOUT_BACKTICKS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNEXPECTED_SAFE_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNINITIALIZED_ENUM_COMPANION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNINITIALIZED_ENUM_ENTRY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNINITIALIZED_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNINITIALIZED_VARIABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNNECESSARY_LATEINIT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNNECESSARY_NOT_NULL_ASSERTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNNECESSARY_SAFE_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNREACHABLE_CODE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNRESOLVED_IMPORT",import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNRESOLVED_LABEL
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.serialization.deserialization

import org.jetbrains.kotlin.builtins.*",import org.jetbrains.kotlin.builtins.StandardNames.CONTINUATION_INTERFACE_FQ_NAME
"@Ann<A?>
expect fun nonNullvsNull()

@Ann<Ann<in A>>
expect fun differentVariance()

@Ann<Ann<in A>>
expect fun varianceVsNoVariance()

@Ann<Ann<in A>>
expect fun sameVariance()

@Ann<Ann<*>>
expect fun startProjection()

annotation class ComplexNested<T>(
    vararg val anns: ComplexNested<*>,
)

@ComplexNested<A>(
    ComplexNested<A>(),
    ComplexNested<A>(),
)
expect fun complexSame()

@ComplexNested<A>(
    ComplexNested<A>(),
    ComplexNested<B>(),
)
expect fun complexDiffer()

annotation class NestedWithSameTypeArgument<T>(
    vararg val anns: NestedWithSameTypeArgument<T>
)

@NestedWithSameTypeArgument<A>(
    NestedWithSameTypeArgument()
)
expect fun explicitVsInfered()

// MODULE: m1-jvm()()(m1-common)
// FILE: jvm.kt
@Ann<A>
actual fun sameTypeParam() {}

<!ACTUAL_ANNOTATIONS_NOT_MATCH_EXPECT!>@Ann<A>
actual fun differentTypeParam() {}<!>

<!ACTUAL_ANNOTATIONS_NOT_MATCH_EXPECT!>@Ann<A>
actual fun differentWithSameName() {}<!>

<!ACTUAL_ANNOTATIONS_NOT_MATCH_EXPECT!>@Ann<A>
actual fun nonNullvsNull() {}<!>

<!ACTUAL_ANNOTATIONS_NOT_MATCH_EXPECT!>@Ann<Ann<out A>>
actual fun differentVariance() {}<!>

<!ACTUAL_ANNOTATIONS_NOT_MATCH_EXPECT!>@Ann<Ann<A>>
actual fun varianceVsNoVariance() {}<!>

@Ann<Ann<in A>>
actual fun sameVariance() {}

<!ACTUAL_ANNOTATIONS_NOT_MATCH_EXPECT!>@Ann<Ann<Any>>",actual fun startProjection() {}<!>
"assertFalse(eqLongQBooleanQ(1.toLong(), undefined))
    assertFalse(eqLongQBooleanQ(null, false))
    assertFalse(eqLongQBooleanQ(null, true))
    assertTrue(eqLongQBooleanQ(null, null))
    assertTrue(eqLongQBooleanQ(null, undefined))
    assertFalse(eqLongQBooleanQ(undefined, false))
    assertFalse(eqLongQBooleanQ(undefined, true))
    assertTrue(eqLongQBooleanQ(undefined, null))
    assertTrue(eqLongQBooleanQ(undefined, undefined))
    assertTrue(eqLongShort(0.toLong(), 0.toShort()))
    assertFalse(eqLongShort(0.toLong(), 1.toShort()))
    assertFalse(eqLongShort(1.toLong(), 0.toShort()))
    assertTrue(eqLongShort(1.toLong(), 1.toShort()))
    assertTrue(eqLongShortQ(0.toLong(), 0.toShort()))
    assertFalse(eqLongShortQ(0.toLong(), 1.toShort()))
    assertFalse(eqLongShortQ(0.toLong(), null))
    assertFalse(eqLongShortQ(0.toLong(), undefined))
    assertFalse(eqLongShortQ(1.toLong(), 0.toShort()))
    assertTrue(eqLongShortQ(1.toLong(), 1.toShort()))
    assertFalse(eqLongShortQ(1.toLong(), null))
    assertFalse(eqLongShortQ(1.toLong(), undefined))
    assertTrue(eqLongQShort(0.toLong(), 0.toShort()))
    assertFalse(eqLongQShort(0.toLong(), 1.toShort()))
    assertFalse(eqLongQShort(1.toLong(), 0.toShort()))
    assertTrue(eqLongQShort(1.toLong(), 1.toShort()))
    assertFalse(eqLongQShort(null, 0.toShort()))
    assertFalse(eqLongQShort(null, 1.toShort()))
    assertFalse(eqLongQShort(undefined, 0.toShort()))
    assertFalse(eqLongQShort(undefined, 1.toShort()))
    assertTrue(eqLongQShortQ(0.toLong(), 0.toShort()))
    assertFalse(eqLongQShortQ(0.toLong(), 1.toShort()))
    assertFalse(eqLongQShortQ(0.toLong(), null))
    assertFalse(eqLongQShortQ(0.toLong(), undefined))
    assertFalse(eqLongQShortQ(1.toLong(), 0.toShort()))
    assertTrue(eqLongQShortQ(1.toLong(), 1.toShort()))
    assertFalse(eqLongQShortQ(1.toLong(), null))
    assertFalse(eqLongQShortQ(1.toLong(), undefined))
    assertFalse(eqLongQShortQ(null, 0.toShort()))
    assertFalse(eqLongQShortQ(null, 1.toShort()))
    assertTrue(eqLongQShortQ(null, null))
    assertTrue(eqLongQShortQ(null, undefined))
    assertFalse(eqLongQShortQ(undefined, 0.toShort()))
    assertFalse(eqLongQShortQ(undefined, 1.toShort()))
    assertTrue(eqLongQShortQ(undefined, null))
    assertTrue(eqLongQShortQ(undefined, undefined))
    assertFalse(eqLongChar(0.toLong(), 0.toChar()))
    assertFalse(eqLongChar(0.toLong(), 1.toChar()))
    assertFalse(eqLongChar(1.toLong(), 0.toChar()))
    assertFalse(eqLongChar(1.toLong(), 1.toChar()))
    assertFalse(eqLongCharQ(0.toLong(), 0.toChar()))
    assertFalse(eqLongCharQ(0.toLong(), 1.toChar()))
    assertFalse(eqLongCharQ(0.toLong(), null))
    assertFalse(eqLongCharQ(0.toLong(), undefined))
    assertFalse(eqLongCharQ(1.toLong(), 0.toChar()))
    assertFalse(eqLongCharQ(1.toLong(), 1.toChar()))
    assertFalse(eqLongCharQ(1.toLong(), null))
    assertFalse(eqLongCharQ(1.toLong(), undefined))
    assertFalse(eqLongQChar(0.toLong(), 0.toChar()))
    assertFalse(eqLongQChar(0.toLong(), 1.toChar()))
    assertFalse(eqLongQChar(1.toLong(), 0.toChar()))
    assertFalse(eqLongQChar(1.toLong(), 1.toChar()))
    assertFalse(eqLongQChar(null, 0.toChar()))
    assertFalse(eqLongQChar(null, 1.toChar()))
    assertFalse(eqLongQChar(undefined, 0.toChar()))
    assertFalse(eqLongQChar(undefined, 1.toChar()))","assertFalse(eqLongQCharQ(0.toLong(), 0.toChar()))"
"// TARGET_BACKEND: JVM_IR
// FILE: Nls.java

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Documented
@Retention(RetentionPolicy.CLASS)
@Target({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE, ElementType.TYPE_USE, ElementType.TYPE, ElementType.PACKAGE})
public @interface Nls {

    enum Capitalization {","NotSpecified,"
"override fun remove(key: Boolean): Boolean {
        return true
    }
}

abstract class E : SortedMap<Boolean, Boolean>, MutableMap<Boolean, Boolean>, KotlinInterface   //Kotlin ← Java, Kotlin1, Kotlin2

abstract class F : SortedMap<Boolean, Boolean>, MutableMap<Boolean, Boolean>, KotlinInterface {
    override fun remove(key: Any): Boolean {
        return true
    }
}

abstract class I : Java1, Java2()   // Kotlin ← Java1, Java2 ← Java3

abstract class J : Java1, Java2() {
    override fun remove(key: Boolean?): Boolean? {
        return true
    }
}

abstract class K : Java1, Java3()   //Kotlin ← Java1, Java2 ← Kotlin2

abstract class L : Java1, Java3() {
    override fun remove(key: Boolean): Boolean {
        return true
    }
}

abstract class M : Java1, KotlinInterface3  //Kotlin ← Java, Kotlin2 ← Kotlin3

abstract class N : Java1, KotlinInterface3 {
    override fun remove(key: Boolean): Boolean? {
        return null
    }
}


interface KotlinInterface {
    fun remove(key: Any): Boolean
}

interface KotlinInterface2 : SortedMap<Boolean, Boolean>

interface KotlinInterface3 : MutableMap<Boolean, Boolean>

fun test(a: A, b: B, c: C, d: D, e: E, f: F, i: I, j: J, k: K, l: L, m: M, n: N) {
    a.size
    a.remove(null)
    a.remove(true)

    b.size
    b.remove(null)
    b.remove(true)

    c.size
    c.remove(null)
    c.remove(true)
    c.remove("""")

    d.size
    d.remove(true)
    d.remove("""")

    e.size",e.remove(true)
"}
        }
    }

    private data class ErrorInfo(
        val expectedErrorKind: String?,
        val expectedErrorMessage: String?
    ) {
        val isAllowedInCli
            get() = when (expectedErrorKind) {
                ""NO_ACTUAL_FOR_EXPECT"", null -> true
                else -> false
            }
    }

    internal enum class CliCompiler(
        val targets: List<String>
    ) {
        K2METADATA(listOf(""jvm"", ""js"")),
        NATIVE(listOf(""linuxX64"", ""linuxArm64""));
    }

    class GradleAndMppHighlightingProvider : GradleArgumentsProvider() {
        private val testDataRoot = File(""../../../idea/testData/multiModuleHighlighting/multiplatform"")

        private val bannedDependencies = setOf(""fulljdk"", ""stdlib"", ""coroutines"")

        private fun isTestSuiteValidForCommonCode(
            testDataDir: File,
            sourceRoots: List<TestCaseSourceRoot>
        ): Boolean = when {
            sourceRoots.any { bannedDependencies.intersect(it.dependencies.toSet()).isNotEmpty() } -> false
            // Java sources can't be used in intermediate source sets
            testDataDir.walkTopDown().any { it.extension == ""java"" } -> false
            // Cannot test !CHECK_HIGHLIGHTING in CLI
            testDataDir.walkTopDown().filter { it.isFile }.any { ""!CHECK_HIGHLIGHTING"" in it.readText() } -> false
            else -> true
        }

        private val testData = testDataRoot
            .walkTopDown()
            .maxDepth(1)
            .filter { it.isDirectory && Files.newDirectoryStream(it.toPath()).use { stream -> stream.toList().isNotEmpty() } }
            .map { testDataDir ->
                Pair(
                    testDataDir,
                    Files.newDirectoryStream(testDataDir.toPath()).use { stream ->
                        stream.map { TestCaseSourceRoot.parse(it.fileName.toString()) }
                    }
                )
            }
            .filter {
                isTestSuiteValidForCommonCode(it.first, it.second)
            }
            .toList()

        override fun provideArguments(
            context: ExtensionContext
        ): Stream<out Arguments> {
            val gradleVersions = super.provideArguments(context).map { it.get().first() as GradleVersion }.toList()

            return gradleVersions
                .flatMap { gradleVersion ->
                    CliCompiler.entries.flatMap { cliCompiler ->
                        testData.map {","Arguments.of(gradleVersion, cliCompiler, it.first, it.second)"
"// IGNORE_BACKEND_MULTI_MODULE: JVM_IR, JVM_MULTI_MODULE_IR_AGAINST_OLD, JVM_IR_SERIALIZE
// NO_CHECK_LAMBDA_INLINING
// IGNORE_BACKEND: JVM_IR
// IGNORE_BACKEND_K2_MULTI_MODULE: JVM_IR JVM_IR_SERIALIZE
// FILE: 1.kt
package builders
inline fun call(crossinline init: () -> Unit) {
    return init()
}

// FILE: 2.kt

import builders.*


inline fun test(): String {
    var res = ""Fail""

    call {
        {
            res = ""OK""
        }()
    }",return res
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.descriptors.utils

import org.jetbrains.kotlin.analysis.api.annotations.*
import org.jetbrains.kotlin.analysis.api.descriptors.Fe10AnalysisContext
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.classId
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.getKtNamedAnnotationArguments
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.maybeLocalClassId
import org.jetbrains.kotlin.analysis.utils.printer.PrettyPrinter
import org.jetbrains.kotlin.analysis.utils.printer.prettyPrint
import org.jetbrains.kotlin.descriptors.ClassifierDescriptorWithTypeParameters
import org.jetbrains.kotlin.descriptors.PossiblyInnerType
import org.jetbrains.kotlin.descriptors.TypeParameterDescriptor
import org.jetbrains.kotlin.descriptors.annotations.AnnotationDescriptor
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.SpecialNames
import org.jetbrains.kotlin.name.StandardClassIds
import org.jetbrains.kotlin.renderer.DescriptorRenderer
import org.jetbrains.kotlin.renderer.render
import org.jetbrains.kotlin.resolve.calls.inference.CapturedType
import org.jetbrains.kotlin.resolve.descriptorUtil.annotationClass
import org.jetbrains.kotlin.types.*
import org.jetbrains.kotlin.types.checker.NewCapturedType
import org.jetbrains.kotlin.types.checker.NewTypeVariableConstructor
import org.jetbrains.kotlin.types.error.ErrorType
import org.jetbrains.kotlin.types.typeUtil.builtIns

internal class KtFe10DebugTypeRenderer {
    private companion object {
        const val ERROR_TYPE_TEXT = ""ERROR_TYPE""
    }

    fun render(analysisContext: Fe10AnalysisContext, type: KotlinType, printer: PrettyPrinter) {
        with(analysisContext) {
            renderType(type, printer)
        }
    }

    private fun Fe10AnalysisContext.renderType(type: KotlinType, printer: PrettyPrinter) {
        renderTypeAnnotationsDebug(type, printer)
        when (val unwrappedType = type.unwrap()) {
            is DynamicType -> printer.append(""dynamic"")
            is FlexibleType -> renderFlexibleType(unwrappedType, printer)
            is DefinitelyNotNullType -> renderDefinitelyNotNullType(unwrappedType, printer)
            is ErrorType -> renderErrorType(printer)
            is CapturedType -> renderCapturedType(unwrappedType, printer)
            is NewCapturedType -> renderCapturedType(unwrappedType, printer)
            is AbbreviatedType -> renderType(unwrappedType.abbreviation, printer)",is SimpleType -> {
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"", ""unused"")

package org.jetbrains.kotlin.fir.declarations.builder

import kotlin.contracts.*
import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.FirImplementationDetail
import org.jetbrains.kotlin.fir.FirModuleData
import org.jetbrains.kotlin.fir.builder.FirAnnotationContainerBuilder
import org.jetbrains.kotlin.fir.builder.FirBuilderDsl
import org.jetbrains.kotlin.fir.builder.toMutableOrEmpty
import org.jetbrains.kotlin.fir.contracts.FirContractDescription
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.declarations.impl.FirPrimaryConstructor
import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.expressions.FirBlock
import org.jetbrains.kotlin.fir.expressions.FirDelegatedConstructorCall
import org.jetbrains.kotlin.fir.references.FirControlFlowGraphReference
import org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol
import org.jetbrains.kotlin.fir.types.ConeSimpleKotlinType
import org.jetbrains.kotlin.fir.types.FirTypeRef
import org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedContainerSource

@FirBuilderDsl
class FirPrimaryConstructorBuilder : FirAbstractConstructorBuilder, FirAnnotationContainerBuilder {
    override var source: KtSourceElement? = null
    override var resolvePhase: FirResolvePhase = FirResolvePhase.RAW_FIR
    override lateinit var moduleData: FirModuleData
    override lateinit var origin: FirDeclarationOrigin",override var attributes: FirDeclarationAttributes = FirDeclarationAttributes()
"// TODO(KT-65977): reenable these tests with caches
//IGNORE_NATIVE: cacheMode=STATIC_EVERYWHERE
//IGNORE_NATIVE: cacheMode=STATIC_PER_FILE_EVERYWHERE
import kotlinx.atomicfu.*
import kotlin.test.*

class LoopTest {
    private val a = atomic(0)
    private val a1 = atomic(1)
    private val b = atomic(true)
    private val l = atomic(5000000000L)
    private val r = atomic<A>(A(""aaaa""))
    private val rs = atomic<String>(""bbbb"")

    class A(val s: String)

    fun atomicfuIntLoopTest() {
        a.loop { value ->
            if (a.compareAndSet(value, 777)) {
                assertEquals(777, a.value)
                return
            }
        }
    }

    fun atomicfuBooleanLoopTest() {
        b.loop { value ->
            assertTrue(value)
            if (!b.value) return
            if (b.compareAndSet(value, false)) {
                return
            }
        }
    }

    fun atomicfuLongLoopTest() {
        l.loop { cur ->
            if (l.compareAndSet(5000000003, 9000000000)) {",return
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.backend

import org.jetbrains.kotlin.backend.common.IrSpecialAnnotationsProvider
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.backend.generators.*
import org.jetbrains.kotlin.fir.declarations.FirFile
import org.jetbrains.kotlin.fir.resolve.ScopeSession
import org.jetbrains.kotlin.fir.signaturer.FirBasedSignatureComposer
import org.jetbrains.kotlin.ir.IrLock
import org.jetbrains.kotlin.ir.declarations.IrFactory
import org.jetbrains.kotlin.ir.linkage.IrProvider
import org.jetbrains.kotlin.ir.overrides.IrFakeOverrideBuilder
import org.jetbrains.kotlin.ir.util.KotlinMangler
import org.jetbrains.kotlin.ir.util.SymbolTable

interface Fir2IrComponents {
    val session: FirSession
    val scopeSession: ScopeSession

    /**
     * It's important to use this fir provider in fir2ir instead of provider from session,
     *   because this provider will also contain synthetic fir files for declarations generated
     *   by frontend plugins
     */
    val firProvider: FirProviderWithGeneratedFiles

    val converter: Fir2IrConverter

    val symbolTable: SymbolTable
    val irBuiltIns: IrBuiltInsOverFir
    val specialAnnotationsProvider: IrSpecialAnnotationsProvider?
    val manglers: Manglers

    val irFactory: IrFactory
    val irProviders: List<IrProvider>
    val lock: IrLock

    val classifierStorage: Fir2IrClassifierStorage
    val declarationStorage: Fir2IrDeclarationStorage

    val typeConverter: Fir2IrTypeConverter
    val signatureComposer: FirBasedSignatureComposer
    val visibilityConverter: Fir2IrVisibilityConverter

    val callablesGenerator: Fir2IrCallableDeclarationsGenerator
    val classifiersGenerator: Fir2IrClassifiersGenerator
    val lazyDeclarationsGenerator: Fir2IrLazyDeclarationsGenerator
    val dataClassMembersGenerator: Fir2IrDataClassMembersGenerator",val annotationGenerator: AnnotationGenerator
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.codegen

import org.jetbrains.kotlin.descriptors.ValueParameterDescriptor
import org.jetbrains.kotlin.psi.KtExpression
import org.jetbrains.kotlin.resolve.calls.model.ResolvedCall
import org.jetbrains.kotlin.resolve.jvm.AsmTypes.OBJECT_TYPE
import org.jetbrains.org.objectweb.asm.Type

enum class ValueKind {
    GENERAL,
    GENERAL_VARARG,
    DEFAULT_PARAMETER,
    DEFAULT_INLINE_PARAMETER,
    DEFAULT_MASK,
    METHOD_HANDLE_IN_DEFAULT,
    READ_OF_INLINE_LAMBDA_FOR_INLINE_SUSPEND_PARAMETER,
    READ_OF_OBJECT_FOR_INLINE_SUSPEND_PARAMETER
}

interface CallGenerator {

    class DefaultCallGenerator(private val codegen: ExpressionCodegen) : CallGenerator {

        override fun genCallInner(
            callableMethod: Callable,
            resolvedCall: ResolvedCall<*>?,
            callDefault: Boolean,
            codegen: ExpressionCodegen
        ) {
            if (!callDefault) {
                callableMethod.genInvokeInstruction(codegen.v)
            } else {
                (callableMethod as CallableMethod).genInvokeDefaultInstruction(codegen.v)
            }
        }

        override fun processHiddenParameters() {}

        override fun putHiddenParamsIntoLocals() {}

        override fun genValueAndPut(
            valueParameterDescriptor: ValueParameterDescriptor?,
            argumentExpression: KtExpression,
            parameterType: JvmKotlinType,
            parameterIndex: Int
        ) {
            val container = valueParameterDescriptor?.containingDeclaration
            val isVarargInvoke = container != null && JvmCodegenUtil.isDeclarationOfBigArityFunctionInvoke(container)

            val v = codegen.v
            if (isVarargInvoke) {
                if (parameterIndex == 0) {
                    v.iconst(container!!.valueParameters.size)
                    v.newarray(OBJECT_TYPE)
                }
                v.dup()
                v.iconst(parameterIndex)
            }",val value = codegen.gen(argumentExpression)
"return list
}

/**
 * Returns a list of values built from the elements of `this` array and the [other] collection with the same index
 * using the provided [transform] function applied to each pair of elements.
 * The returned list has length of the shortest collection.
 * 
 * @sample samples.collections.Iterables.Operations.zipIterableWithTransform
 */
public inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {
    val arraySize = size
    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))
    var i = 0
    for (element in other) {
        if (i >= arraySize) break
        list.add(transform(this[i++], element))
    }
    return list
}

/**
 * Returns a list of values built from the elements of `this` array and the [other] collection with the same index
 * using the provided [transform] function applied to each pair of elements.
 * The returned list has length of the shortest collection.
 * 
 * @sample samples.collections.Iterables.Operations.zipIterableWithTransform
 */
public inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {
    val arraySize = size
    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))
    var i = 0
    for (element in other) {
        if (i >= arraySize) break
        list.add(transform(this[i++], element))
    }
    return list
}

/**
 * Returns a list of values built from the elements of `this` array and the [other] collection with the same index
 * using the provided [transform] function applied to each pair of elements.
 * The returned list has length of the shortest collection.
 * 
 * @sample samples.collections.Iterables.Operations.zipIterableWithTransform
 */
public inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {
    val arraySize = size
    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))
    var i = 0
    for (element in other) {
        if (i >= arraySize) break
        list.add(transform(this[i++], element))
    }
    return list
}

/**
 * Returns a list of values built from the elements of `this` array and the [other] collection with the same index
 * using the provided [transform] function applied to each pair of elements.
 * The returned list has length of the shortest collection.
 * 
 * @sample samples.collections.Iterables.Operations.zipIterableWithTransform
 */
public inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {",val arraySize = size
"assertTrue((0.toByte() until Byte.MIN_VALUE).isEmpty())
        assertTrue((0.toByte() until Int.MIN_VALUE).isEmpty())
    }

    @Test fun shortRange() {
        val range = (-5).toShort()..9.toShort()
        assertFalse((-1000).toShort() in range)
        assertFalse((-6).toShort() in range)

        assertTrue((-5).toShort() in range)
        assertTrue((-4).toShort() in range)
        assertTrue(0.toShort() in range)
        assertTrue(3.toShort() in range)
        assertTrue(8.toShort() in range)
        assertTrue(9.toShort() in range)

        assertFalse(10.toShort() in range)
        assertFalse(239.toShort() in range)

        assertFalse(range.isEmpty())

        assertTrue(1.toByte() in range)
        assertTrue(1.toInt() in range)
        assertTrue(1.toLong() in range)

        assertFalse(Long.MAX_VALUE in range)

        // assertTrue(1.toShort() as Short? in range) // expected not to compile

        val openRange = 1.toShort() until 10.toShort()
        assertTrue(9.toShort() in openRange)
        assertFalse(10.toShort() in openRange)

        assertTrue((0.toShort() until Short.MIN_VALUE).isEmpty())
        assertTrue((0.toShort() until Int.MIN_VALUE).isEmpty())
    }

    @Test fun longRange() {
        val range = -5L..9L
        assertFalse(-10000000L in range)
        assertFalse(-6L in range)

        assertTrue(-5L in range)
        assertTrue(-4L in range)
        assertTrue(0L in range)
        assertTrue(3L in range)
        assertTrue(8L in range)
        assertTrue(9L in range)

        assertFalse(10L in range)
        assertFalse(10000000L in range)

        assertFalse(range.isEmpty())

        assertTrue(9 in (range as ClosedRange<Long>))
        assertFalse((range as ClosedRange<Long>).isEmpty())

        assertTrue(1.toByte() in range)
        assertTrue(1.toShort() in range)
        assertTrue(1.toInt() in range)

        assertFalse(null in range)
        assertTrue(1L as Long? in range)
        assertFalse(10L as Long? in range)",val closedRange = 1L..9L
"/*
 * Copyright 2000-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.calls.smartcasts

import org.jetbrains.kotlin.KtNodeTypes
import org.jetbrains.kotlin.builtins.KotlinBuiltIns
import org.jetbrains.kotlin.config.LanguageVersionSettings
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.descriptors.ModuleDescriptor
import org.jetbrains.kotlin.descriptors.VariableDescriptor
import org.jetbrains.kotlin.lexer.KtTokens
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.calls.context.ResolutionContext",import org.jetbrains.kotlin.resolve.descriptorUtil.builtIns
"source = objectLiteral.toFirSourceElement()
                anonymousObject = buildAnonymousObject {
                    val objectDeclaration = objectLiteral.getChildNodesByType(OBJECT_DECLARATION).first()
                    source = objectDeclaration.toFirSourceElement()
                    origin = FirDeclarationOrigin.Source
                    moduleData = baseModuleData
                    classKind = ClassKind.CLASS
                    scopeProvider = baseScopeProvider
                    symbol = FirAnonymousObjectSymbol(context.packageFqName)
                    status = FirDeclarationStatusImpl(Visibilities.Local, Modality.FINAL)
                    context.appendOuterTypeParameters(ignoreLastLevel = false, typeParameters)
                    val delegatedSelfType = objectDeclaration.toDelegatedSelfType(this)
                    registerSelfType(delegatedSelfType)

                    var modifiers: Modifier? = null
                    val objectAnnotations = mutableListOf<FirAnnotationCall>()
                    var primaryConstructor: LighterASTNode? = null
                    val superTypeRefs = mutableListOf<FirTypeRef>()
                    var delegatedSuperTypeRef: FirTypeRef? = null
                    var classBody: LighterASTNode? = null
                    var delegatedConstructorSource: KtLightSourceElement? = null
                    var delegatedSuperCalls: List<DelegatedConstructorWrapper>? = null
                    var delegateFields: List<FirField>? = null

                    objectDeclaration.forEachChildren {
                        when (it.tokenType) {
                            MODIFIER_LIST -> {
                                modifiers = convertModifierList(it)
                                objectAnnotations += convertAnnotationList(it)
                            }
                            PRIMARY_CONSTRUCTOR -> primaryConstructor = it
                            SUPER_TYPE_LIST -> convertDelegationSpecifiers(it).let { specifiers ->
                                delegatedSuperTypeRef = specifiers.superTypeCalls.lastOrNull()?.delegatedSuperTypeRef
                                superTypeRefs += specifiers.superTypesRef
                                delegatedConstructorSource = specifiers.superTypeCalls.lastOrNull()?.source
                                delegateFields = specifiers.delegateFieldsMap.values.map { it.fir }
                                delegatedFieldsMap = specifiers.delegateFieldsMap.takeIf { it.isNotEmpty() }
                                delegatedSuperCalls = specifiers.superTypeCalls
                            }
                            CLASS_BODY -> classBody = it
                        }
                    }

                    superTypeRefs.ifEmpty {
                        superTypeRefs += implicitAnyType
                        delegatedSuperTypeRef = implicitAnyType
                    }
                    val delegatedSuperType = delegatedSuperTypeRef ?: FirImplicitTypeRefImplWithoutSource

                    annotations += objectAnnotations
                    this.superTypeRefs += superTypeRefs

                    val classWrapper = ClassWrapper(
                        modifiers ?: Modifier(),
                        ClassKind.OBJECT,
                        this,
                        hasSecondaryConstructor = classBody.getChildNodesByType(SECONDARY_CONSTRUCTOR).isNotEmpty(),
                        hasDefaultConstructor = false,
                        delegatedSelfTypeRef = delegatedSelfType,
                        delegatedSuperTypeRef = delegatedSuperType,
                        delegatedSuperCalls = delegatedSuperCalls ?: emptyList(),
                    )
                    //parse primary constructor
                    convertPrimaryConstructor(
                        objectDeclaration,","primaryConstructor,"
"import org.jetbrains.kotlin.serialization.js.ModuleKind
import org.jetbrains.kotlin.utils.KotlinPaths
import org.jetbrains.kotlin.utils.PathUtil
import org.jetbrains.kotlin.utils.join
import org.jetbrains.kotlin.wasm.config.WasmConfigurationKeys
import java.io.File
import java.io.IOException

private val K2JSCompilerArguments.granularity: JsGenerationGranularity
    get() = when {
        this.irPerFile -> JsGenerationGranularity.PER_FILE
        this.irPerModule -> JsGenerationGranularity.PER_MODULE
        else -> JsGenerationGranularity.WHOLE_PROGRAM
    }

private val K2JSCompilerArguments.dtsStrategy: TsCompilationStrategy
    get() = when {
        !this.generateDts -> TsCompilationStrategy.NONE
        this.irPerFile -> TsCompilationStrategy.EACH_FILE
        else -> TsCompilationStrategy.MERGED
    }

private class DisposableZipFileSystemAccessor private constructor(
    private val zipAccessor: ZipFileSystemCacheableAccessor
) : Disposable, ZipFileSystemAccessor by zipAccessor {
    constructor(cacheLimit: Int) : this(ZipFileSystemCacheableAccessor(cacheLimit))

    override fun dispose() {
        zipAccessor.reset()
    }
}

class K2JsIrCompiler : CLICompiler<K2JSCompilerArguments>() {
    class K2JsIrCompilerPerformanceManager : CommonCompilerPerformanceManager(""Kotlin to JS (IR) Compiler"")

    override val defaultPerformanceManager: CommonCompilerPerformanceManager = K2JsIrCompilerPerformanceManager()

    override fun createArguments(): K2JSCompilerArguments {
        return K2JSCompilerArguments()
    }

    private class Ir2JsTransformer(
        val arguments: K2JSCompilerArguments,
        val module: ModulesStructure,
        val phaseConfig: PhaseConfig,
        val messageCollector: MessageCollector,
        val mainCallArguments: List<String>?
    ) {
        private val performanceManager = module.compilerConfiguration[CLIConfigurationKeys.PERF_MANAGER]

        private fun lowerIr(): LoweredIr {
            return compile(
                mainCallArguments,
                module,
                phaseConfig,
                IrFactoryImplForJsIC(WholeWorldStageController()),
                keep = arguments.irKeep?.split("","")
                    ?.filterNot { it.isEmpty() }
                    ?.toSet()
                    ?: emptySet(),
                dceRuntimeDiagnostic = RuntimeDiagnostic.resolve(
                    arguments.irDceRuntimeDiagnostic,
                    messageCollector
                ),
                safeExternalBoolean = arguments.irSafeExternalBoolean,",safeExternalBooleanDiagnostic = RuntimeDiagnostic.resolve(
"package common

import kotlin.test.FrameworkAdapter
import kotlin.collections.*

private var sortingContext = SortingContext()

private var bodyContext: TestBodyContext? = null

fun call(name: String) = bodyContext!!.call(name)

fun raise(name: String): Nothing {
    bodyContext!!.raised(name)
    throw Exception(name)
}

// Adapter should be initialized eagerly
@Suppress(""INVISIBLE_MEMBER"")
@OptIn(kotlin.ExperimentalStdlibApi::class)
@EagerInitialization
private val underscore = kotlin.test.setAdapter(object : FrameworkAdapter {
    override fun suite(name: String, ignored: Boolean, suiteFn: () -> Unit) {
        sortingContext.suite(name, ignored) { suiteFn() }
    }","override fun test(name: String, ignored: Boolean, testFn: () -> Any?) {"
"*
     * If the [other] value is less than or equal to `this` value, then the returned range is empty.
     */
    @SinceKotlin(""1.9"")
    @WasExperimental(ExperimentalStdlibApi::class)
    public operator fun rangeUntil(other: Short): LongRange =
        this until other

    /**
     * Creates a range from this value up to but excluding the specified [other] value.
     *
     * If the [other] value is less than or equal to `this` value, then the returned range is empty.
     */
    @SinceKotlin(""1.9"")
    @WasExperimental(ExperimentalStdlibApi::class)
    public operator fun rangeUntil(other: Int): LongRange =
        this until other

    /**
     * Creates a range from this value up to but excluding the specified [other] value.
     *
     * If the [other] value is less than or equal to `this` value, then the returned range is empty.
     */
    @SinceKotlin(""1.9"")
    @WasExperimental(ExperimentalStdlibApi::class)
    public operator fun rangeUntil(other: Long): LongRange =
        this until other

    /**
     * Shifts this value left by the [bitCount] number of bits.
     *
     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.
     * The shift distance actually used is therefore always in the range `0..63`.
     */
    @kotlin.internal.IntrinsicConstEvaluation
    public inline infix fun shl(bitCount: Int): Long =
        wasm_i64_shl(this, bitCount.toLong())

    /**
     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with copies of the sign bit.
     *
     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.
     * The shift distance actually used is therefore always in the range `0..63`.
     */
    @kotlin.internal.IntrinsicConstEvaluation
    public inline infix fun shr(bitCount: Int): Long =
        wasm_i64_shr_s(this, bitCount.toLong())

    /**
     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.
     *
     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.
     * The shift distance actually used is therefore always in the range `0..63`.
     */
    @kotlin.internal.IntrinsicConstEvaluation
    public inline infix fun ushr(bitCount: Int): Long =
        wasm_i64_shr_u(this, bitCount.toLong())

    /** Performs a bitwise AND operation between the two values. */
    @kotlin.internal.IntrinsicConstEvaluation
    @WasmOp(WasmOp.I64_AND)
    public infix fun and(other: Long): Long =
        implementedAsIntrinsic

    /** Performs a bitwise OR operation between the two values. */",@kotlin.internal.IntrinsicConstEvaluation
"fun foo() {
    var v: Any = 42",v.<!UNRESOLVED_REFERENCE!>length<!>()
"import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.declarations.IrExternalPackageFragment
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
import org.jetbrains.kotlin.ir.declarations.lazy.AbstractIrLazyFunction
import org.jetbrains.kotlin.ir.expressions.IrMemberAccessExpression
import org.jetbrains.kotlin.ir.util.DeserializableClass
import org.jetbrains.kotlin.ir.util.IdSignature
import org.jetbrains.kotlin.ir.util.resolveFakeOverrideOrFail
import org.jetbrains.kotlin.ir.visitors.IrElementVisitorVoid
import org.jetbrains.kotlin.ir.visitors.acceptChildrenVoid
import org.jetbrains.kotlin.test.backend.ir.IrBackendInput
import org.jetbrains.kotlin.test.model.FrontendKinds
import org.jetbrains.kotlin.test.model.TestModule
import org.jetbrains.kotlin.test.services.TestServices

class IrInlineBodiesHandler(testServices: TestServices) : AbstractIrHandler(testServices) {
    val declaredInlineFunctions = hashSetOf<IrSimpleFunction>()

    @OptIn(ObsoleteDescriptorBasedAPI::class)
    override fun processModule(module: TestModule, info: IrBackendInput) {
        info.irModuleFragment.acceptChildrenVoid(InlineFunctionsCollector())
        info.irModuleFragment.acceptChildrenVoid(InlineCallBodiesCheck(firEnabled = module.frontendKind == FrontendKinds.FIR))

        assertions.assertTrue((info as IrBackendInput.JvmIrBackendInput).backendInput.symbolTable.descriptorExtension.allUnboundSymbols.isEmpty())
    }

    override fun processAfterAllModules(someAssertionWasFailed: Boolean) {
        assertions.assertTrue(declaredInlineFunctions.isNotEmpty())
    }

    inner class InlineFunctionsCollector : IrElementVisitorVoid {
        override fun visitElement(element: IrElement) {
            element.acceptChildrenVoid(this)
        }

        override fun visitSimpleFunction(declaration: IrSimpleFunction) {
            if (declaration.isInline) declaredInlineFunctions.add(declaration)
            super.visitSimpleFunction(declaration)
        }
    }

    inner class InlineCallBodiesCheck(val firEnabled: Boolean) : IrElementVisitorVoid {
        override fun visitElement(element: IrElement) {
            element.acceptChildrenVoid(this)
        }

        override fun visitMemberAccess(expression: IrMemberAccessExpression<*>) {
            val symbol = expression.symbol
            assertions.assertTrue(symbol.isBound)
            val callee = symbol.owner
            if (callee is IrSimpleFunction && callee in declaredInlineFunctions) {
                val trueCallee = callee.resolveFakeOverrideOrFail()
                assertions.assertTrue(trueCallee.hasBody()) {
                    ""IrInlineBodiesHandler: function with body expected""
                }
            }
            super.visitMemberAccess(expression)
        }

        private fun IrSimpleFunction.hasBody(): Boolean {
            if (this !is AbstractIrLazyFunction) return body != null
            if (!isDeserializationEnabled) return false
            if (!isInline || isFakeOverride) return false",val topLevelDeclaration = getTopLevelDeclaration()
"/**
 * Returns a new array which is a copy of the specified range of the original array.
 * 
 * @param fromIndex the start of the range (inclusive) to copy.
 * @param toIndex the end of the range (exclusive) to copy.
 * 
 * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.
 * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].
 */
public actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {
    checkCopyOfRangeArguments(fromIndex, toIndex, size)
    return copyOfUninitializedElements(fromIndex, toIndex)
}

/**
 * Returns a new array which is a copy of the specified range of the original array.
 * 
 * @param fromIndex the start of the range (inclusive) to copy.
 * @param toIndex the end of the range (exclusive) to copy.
 * 
 * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.
 * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].
 */
public actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {
    checkCopyOfRangeArguments(fromIndex, toIndex, size)
    return copyOfUninitializedElements(fromIndex, toIndex)
}

/**
 * Returns a new array which is a copy of the specified range of the original array.
 * 
 * @param fromIndex the start of the range (inclusive) to copy.
 * @param toIndex the end of the range (exclusive) to copy.
 * 
 * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.
 * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].
 */
public actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {
    checkCopyOfRangeArguments(fromIndex, toIndex, size)
    return copyOfUninitializedElements(fromIndex, toIndex)
}

/**
 * Returns a new array which is a copy of the specified range of the original array.
 * 
 * @param fromIndex the start of the range (inclusive) to copy.
 * @param toIndex the end of the range (exclusive) to copy.
 * 
 * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.
 * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].
 */
public actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {
    checkCopyOfRangeArguments(fromIndex, toIndex, size)
    return copyOfUninitializedElements(fromIndex, toIndex)
}

/**
 * Returns new array which is a copy of the original array's range between [fromIndex] (inclusive)
 * and [toIndex] (exclusive) with new elements filled with **lateinit** _uninitialized_ values.
 * Attempts to read _uninitialized_ values from this array work in implementation-dependent manner,
 * either throwing exception or returning some kind of implementation-specific default value.
 */
internal fun <T> Array<T>.copyOfUninitializedElements(fromIndex: Int, toIndex: Int): Array<T> {
    val newSize = toIndex - fromIndex",if (newSize < 0) {
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.internal

import org.gradle.api.NamedDomainObjectSet",import org.gradle.api.Project
"modality,
    oldPropertyBackingField,
) else createLeafMfvcNode(
    parent,
    context,
    type,
    methodFullNameMode,
    nameParts,
    fieldAnnotations,
    static,
    overriddenNode as LeafMfvcNode?,
    defaultMethodsImplementationSourceNode,
    oldGetter,
    modality,
    oldPropertyBackingField
)

fun createIntermediateMfvcNode(
    parent: IrClass,
    context: JvmBackendContext,
    type: IrSimpleType,
    typeArguments: TypeArguments,
    methodFullNameMode: MethodFullNameMode,
    nameParts: List<Name>,
    fieldAnnotations: List<IrConstructorCall>,
    static: Boolean,
    overriddenNode: IntermediateMfvcNode?,
    defaultMethodsImplementationSourceNode: UnboxFunctionImplementation?,
    oldGetter: IrSimpleFunction?,
    modality: Modality,
    oldPropertyBackingField: IrField?,
): IntermediateMfvcNode {
    require(type.needsMfvcFlattening()) { ""${type.render()} does not require flattening"" }
    val valueClass = type.erasedUpperBound
    val representation = valueClass.multiFieldValueClassRepresentation!!

    val replacements = context.multiFieldValueClassReplacements
    val rootNode = replacements.getRootMfvcNode(valueClass)

    val oldField = oldGetter?.correspondingPropertySymbol?.owner?.backingFieldIfNotDelegate

    val shadowBackingFieldProperty = if (oldField == null) oldGetter?.getGetterField()?.correspondingPropertySymbol?.owner else null
    val useOldGetter = oldGetter != null && (oldField == null || !oldGetter.isDefaultGetter(oldField))

    val subnodes = representation.underlyingPropertyNamesToTypes.map { (name, type) ->
        val newType = type.substitute(typeArguments) as IrSimpleType
        val newTypeArguments = typeArguments.toMutableMap().apply { putAll(makeTypeArgumentsFromType(newType)) }
        val newDefaultMethodsImplementationSourceNode = when {
            defaultMethodsImplementationSourceNode != null -> defaultMethodsImplementationSourceNode[name]
            shadowBackingFieldProperty != null -> DelegatingUnboxFunctionImplementation(
                replacements.getMfvcPropertyNode(shadowBackingFieldProperty)!!
            )
            useOldGetter -> CustomUnboxFunctionImplementation(oldGetter!!, rootNode[name]!!)
            else -> DefaultUnboxFunctionImplementation
        }
        createNameableMfvcNodes(
            parent,
            context,
            newType,
            newTypeArguments,
            methodFullNameMode,
            nameParts + name,
            fieldAnnotations,
            static,
            overriddenNode?.let { it[name]!! },","newDefaultMethodsImplementationSourceNode,"
"@Serializer(forClass = Foo2Kept::class)
object Foo2KeptSerializer

@Serializer(forClass = Foo25Kept::class)
object Foo25KeptSerializer

@Serializer(forClass = Foo5Kept::class)
object Foo5KeptSerializer

@Serializer(forClass = Foo6Kept::class)
object Foo6KeptSerializer

@Serializer(forClass = Foo7Kept::class)
object Foo7KeptSerializer

@Serializer(forClass = Foo8Kept::class)
class Foo8KeptSerializer(val serializer: KSerializer<*>)

@Serializer(forClass = Foo9Kept::class)
class Foo9KeptSerializer(val serializer: KSerializer<*>)

@Serializer(forClass = Baz::class)
object NullableBazSerializer: KSerializer<Baz?>

<!SERIALIZER_TYPE_INCOMPATIBLE!>@Serializable(with = BazSerializer::class)<!>
class Biz(val i: Int)

@Serializable
class Foo(@Serializable(with = BazSerializer::class) val i: <!SERIALIZER_TYPE_INCOMPATIBLE!>Bar<!>)

@Serializable(FooKeptSerializer::class)
@KeepGeneratedSerializer
class FooKept(@Serializable(with = BazSerializer::class) val i: <!SERIALIZER_TYPE_INCOMPATIBLE!>Bar<!>)

@Serializable
class Foo2(val li: List<@Serializable(with = BazSerializer::class) <!SERIALIZER_TYPE_INCOMPATIBLE!>Bar<!>>)

@Serializable(Foo2KeptSerializer::class)
@KeepGeneratedSerializer
class Foo2Kept(val li: List<@Serializable(with = BazSerializer::class) <!SERIALIZER_TYPE_INCOMPATIBLE!>Bar<!>>)

@Serializable
class Foo25(val i: @Serializable(with = BazSerializer::class) <!SERIALIZER_TYPE_INCOMPATIBLE!>Bar<!>)

@Serializable(Foo25KeptSerializer::class)
@KeepGeneratedSerializer
class Foo25Kept(val i: @Serializable(with = BazSerializer::class) <!SERIALIZER_TYPE_INCOMPATIBLE!>Bar<!>)

@Serializable
class Foo3(@Serializable(with = BazSerializer::class) val i: Baz)

@Serializable
class Foo4(val li: List<@Serializable(with = BazSerializer::class) Baz>)

@Serializable
class Foo5(@Serializable(with = BazSerializer::class) val i: <!SERIALIZER_TYPE_INCOMPATIBLE!>Bar?<!>)

@Serializable(Foo5KeptSerializer::class)
@KeepGeneratedSerializer
class Foo5Kept(@Serializable(with = BazSerializer::class) val i: <!SERIALIZER_TYPE_INCOMPATIBLE!>Bar?<!>)

@Serializable
class Foo6(@Serializable(with = NullableBazSerializer::class) val i: <!SERIALIZER_NULLABILITY_INCOMPATIBLE, SERIALIZER_TYPE_INCOMPATIBLE!>Bar<!>)",@Serializable(Foo6KeptSerializer::class)
"val functionDescriptor = SimpleFunctionDescriptorImpl.create(
            classDescriptor,
            Annotations.EMPTY,
            createComponentName(parameterIndex),
            CallableMemberDescriptor.Kind.SYNTHESIZED,
            parameter.source
        )

        functionDescriptor.initialize(
            null,
            classDescriptor.thisAsReceiverParameter,
            emptyList<ReceiverParameterDescriptor>(),
            emptyList<TypeParameterDescriptor>(),
            emptyList<ValueParameterDescriptor>(),
            property.type,
            Modality.FINAL,
            property.visibility
        )
        functionDescriptor.isOperator = true

        trace.record(BindingContext.DATA_CLASS_COMPONENT_FUNCTION, parameter, functionDescriptor)
        return functionDescriptor
    }

    fun createCopyFunctionDescriptor(
        constructorParameters: Collection<ValueParameterDescriptor>,
        classDescriptor: ClassDescriptor,
        trace: BindingTrace
    ): SimpleFunctionDescriptor {
        val functionDescriptor = SimpleFunctionDescriptorImpl.create(
            classDescriptor,
            Annotations.EMPTY,
            COPY_METHOD_NAME,
            CallableMemberDescriptor.Kind.SYNTHESIZED,
            classDescriptor.source
        )

        val parameterDescriptors = arrayListOf<ValueParameterDescriptor>()

        for (parameter in constructorParameters) {
            val propertyDescriptor = trace.bindingContext.get(BindingContext.VALUE_PARAMETER_AS_PROPERTY, parameter)
            // If a parameter doesn't have the corresponding property, it must not have a default value in the 'copy' function
            val declaresDefaultValue = propertyDescriptor != null
            val parameterDescriptor = ValueParameterDescriptorImpl(
                functionDescriptor, null, parameter.index, parameter.annotations, parameter.name, parameter.type, declaresDefaultValue,
                parameter.isCrossinline, parameter.isNoinline, parameter.varargElementType, parameter.source
            )
            parameterDescriptors.add(parameterDescriptor)
            if (declaresDefaultValue) {
                trace.record(BindingContext.VALUE_PARAMETER_AS_PROPERTY, parameterDescriptor, propertyDescriptor)
            }
        }

        functionDescriptor.initialize(
            null,
            classDescriptor.thisAsReceiverParameter,
            emptyList<ReceiverParameterDescriptor>(),
            emptyList<TypeParameterDescriptor>(),
            parameterDescriptors,
            classDescriptor.defaultType,
            Modality.FINAL,
            DescriptorVisibilities.PUBLIC
        )

        trace.record(BindingContext.DATA_CLASS_COPY_FUNCTION, classDescriptor, functionDescriptor)",return functionDescriptor
"Collections.unmodifiableMap(Object2ObjectOpenHashMap<String, PsiClass>().apply {
            for (psiClass in classes) {
                val name = psiClass.name
                if (name == null) {
                    Logger.getInstance(KotlinClassInnerStuffCache::class.java).error(psiClass)
                } else if (psiClass !is ExternallyDefinedPsiElement || !containsKey(name)) {
                    put(name, psiClass)
                }
            }
        })
    }

    fun findInnerClassByName(name: String, checkBases: Boolean): PsiClass? {
        return if (checkBases) {
            PsiClassImplUtil.findInnerByName(myClass, name, true)
        } else {
            innerClassByNameCache.value[name]
        }
    }

    private val valuesMethodCache = cache { KotlinEnumSyntheticMethod(myClass, KotlinEnumSyntheticMethod.Kind.VALUES) }

    private fun getValuesMethod(): PsiMethod? {
        if (myClass.isEnum && !myClass.isAnonymous && !isClassNameSealed()) {
            return valuesMethodCache.value
        }

        return null
    }

    private val valueOfMethodCache = cache { KotlinEnumSyntheticMethod(myClass, KotlinEnumSyntheticMethod.Kind.VALUE_OF) }

    fun getValueOfMethod(): PsiMethod? {
        if (myClass.isEnum && !myClass.isAnonymous) {
            return valueOfMethodCache.value
        }

        return null
    }

    private fun isClassNameSealed(): Boolean {
        return myClass.name == PsiKeyword.SEALED && PsiUtil.getLanguageLevel(myClass).toJavaVersion().feature >= 16
    }
}

private class KotlinEnumSyntheticMethod(
    private val enumClass: KtExtensibleLightClass,
    private val kind: Kind
) : LightElement(enumClass.manager, enumClass.language), KtLightMethod, SyntheticElement {
    enum class Kind(val methodName: String) {
        VALUE_OF(""valueOf""), VALUES(""values""), ENTRIES(""getEntries""),
    }

    private val returnType = run {
        val elementFactory = JavaPsiFacade.getElementFactory(project)
        val enumTypeWithoutAnnotation = elementFactory.createType(enumClass)
        val enumType = enumTypeWithoutAnnotation
            .annotate { arrayOf(makeNotNullAnnotation(enumClass)) }

        when (kind) {
            Kind.VALUE_OF -> enumType
            Kind.VALUES -> enumType.createArrayType().annotate { arrayOf(makeNotNullAnnotation(enumClass)) }
            Kind.ENTRIES -> {
                val enumEntriesClass = JavaPsiFacade.getInstance(project).findClass(
                    /* qualifiedName = */ StandardClassIds.EnumEntries.asFqNameString(),",/* scope = */ resolveScope
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.cli.common.arguments

import kotlin.reflect.KClass
import kotlin.reflect.KVisibility

/**
 * @param value should be one of [DefaultValue] enum values
 * @param gradleInputType should be one of [GradleInputTypes] enum values
 */
@Retention(AnnotationRetention.RUNTIME)
annotation class GradleOption(
    val value: DefaultValue,
    val gradleInputType: GradleInputTypes,
    val shouldGenerateDeprecatedKotlinOptions: Boolean = false
)

enum class DefaultValue {
    BOOLEAN_FALSE_DEFAULT,
    BOOLEAN_TRUE_DEFAULT,
    BOOLEAN_NULL_DEFAULT,
    STRING_NULL_DEFAULT,
    EMPTY_STRING_LIST_DEFAULT,
    EMPTY_STRING_ARRAY_DEFAULT,","LANGUAGE_VERSIONS,"
"// !DIAGNOSTICS: -UNUSED_PARAMETER
// FILE: a/a.java
package a;

public class a {}

// FILE: a/b.java
package a;

public class b {
    public void a_b() {}
}

// FILE: test/a.java
package test;

public class a {}

// FILE: test/d.java
package test;

public class d {
    public a.b getB() { return null; }
}

// FILE: b.kt
package test

val x = d().<!MISSING_DEPENDENCY_CLASS!>getB<!>()

// FILE: test/c.java
package test;",import a.a;
"/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.typesBenchmarks

import kotlin.random.Random
import kotlinx.cinterop.*

const val benchmarkSize = 1000

actual class StringBenchmark actual constructor() {
    val charPool: List<Char> = ('a'..'z') + ('A'..'Z') + ('0'..'9')
    val randomString = generateRandomString()
    val randomChar = charPool[Random.nextInt(0, charPool.size)]
    val strings = mutableListOf<String>()

    init {
        // Generate random strings.
        for (i in 1..benchmarkSize) {
            strings.add(generateRandomString())
        }
    }

    fun generateRandomString(): String {
        return (1..benchmarkSize)
                .map { i -> Random.nextInt(0, charPool.size) }
                .map(charPool::get)
                .joinToString("""")
    }

    actual fun stringToCBenchmark() {
        // Generate random strings.
        for (i in 1..benchmarkSize) {
            charFrequency(randomString, randomChar.toByte())
        }
    }

    actual fun stringToKotlinBenchmark() {
        memScoped {
            val result = StringBuilder()
            for (i in 1..benchmarkSize) {
                val pointer = findSuitableString(strings.toCStringArray(this), benchmarkSize, ""a"")",val str = pointer?.toKString()
"overloadsList.first {
            val receiverType = it.owner.extensionReceiverParameter?.type
            receiverType != null && arrayType.isNullable() == receiverType.isNullable() && arrayType.classOrNull == receiverType.classOrNull
        }

    fun findContentToStringOverload(arrayType: IrType): IrSimpleFunctionSymbol = findOverloadForReceiver(arrayType, contentToString)

    fun findContentHashCodeOverload(arrayType: IrType): IrSimpleFunctionSymbol = findOverloadForReceiver(arrayType, contentHashCode)

    private val getProgressionLastElementSymbols =
        irBuiltIns.findFunctions(Name.identifier(""getProgressionLastElement""), ""kotlin"", ""internal"")

    override val getProgressionLastElementByReturnType: Map<IrClassifierSymbol, IrSimpleFunctionSymbol> by lazy {
        getProgressionLastElementSymbols.associateBy { it.owner.returnType.classifierOrFail }
    }

    private val toUIntSymbols = irBuiltIns.findFunctions(Name.identifier(""toUInt""), ""kotlin"")

    override val toUIntByExtensionReceiver: Map<IrClassifierSymbol, IrSimpleFunctionSymbol> by lazy {
        toUIntSymbols.associateBy {
            it.owner.extensionReceiverParameter?.type?.classifierOrFail
                ?: error(""Expected extension receiver for ${it.owner.render()}"")
        }
    }

    private val toULongSymbols = irBuiltIns.findFunctions(Name.identifier(""toULong""), ""kotlin"")

    override val toULongByExtensionReceiver: Map<IrClassifierSymbol, IrSimpleFunctionSymbol> by lazy {
        toULongSymbols.associateBy {
            it.owner.extensionReceiverParameter?.type?.classifierOrFail
                ?: error(""Expected extension receiver for ${it.owner.render()}"")
        }
    }

    private val wasmStructRefClass = getIrClass(FqName(""kotlin.wasm.internal.reftypes.structref""))
    val wasmStructRefType by lazy { wasmStructRefClass.defaultType }

    val wasmAnyRefClass = getIrClass(FqName(""kotlin.wasm.internal.reftypes.anyref""))

    inner class JsInteropAdapters {
        val kotlinToJsStringAdapter = getInternalFunction(""kotlinToJsStringAdapter"")
        val kotlinToJsAnyAdapter = getInternalFunction(""kotlinToJsAnyAdapter"")
        val numberToDoubleAdapter = getInternalFunction(""numberToDoubleAdapter"")

        val jsCheckIsNullOrUndefinedAdapter = getInternalFunction(""jsCheckIsNullOrUndefinedAdapter"")

        val jsToKotlinStringAdapter = getInternalFunction(""jsToKotlinStringAdapter"")
        val jsToKotlinAnyAdapter = getInternalFunction(""jsToKotlinAnyAdapter"")

        val jsToKotlinByteAdapter = getInternalFunction(""jsToKotlinByteAdapter"")
        val jsToKotlinShortAdapter = getInternalFunction(""jsToKotlinShortAdapter"")
        val jsToKotlinCharAdapter = getInternalFunction(""jsToKotlinCharAdapter"")

        val externRefToKotlinIntAdapter = getInternalFunction(""externRefToKotlinIntAdapter"")
        val externRefToKotlinBooleanAdapter = getInternalFunction(""externRefToKotlinBooleanAdapter"")
        val externRefToKotlinLongAdapter = getInternalFunction(""externRefToKotlinLongAdapter"")
        val externRefToKotlinFloatAdapter = getInternalFunction(""externRefToKotlinFloatAdapter"")
        val externRefToKotlinDoubleAdapter = getInternalFunction(""externRefToKotlinDoubleAdapter"")

        val externRefToKotlinUByteAdapter = getInternalFunction(""externRefToKotlinUByteAdapter"")
        val externRefToKotlinUShortAdapter = getInternalFunction(""externRefToKotlinUShortAdapter"")
        val externRefToKotlinUIntAdapter = getInternalFunction(""externRefToKotlinUIntAdapter"")
        val externRefToKotlinULongAdapter = getInternalFunction(""externRefToKotlinULongAdapter"")

        val kotlinIntToExternRefAdapter = getInternalFunction(""kotlinIntToExternRefAdapter"")","val kotlinBooleanToExternRefAdapter = getInternalFunction(""kotlinBooleanToExternRefAdapter"")"
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.descriptors.symbols.psiBased.base

import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.base.KtFe10Symbol
import org.jetbrains.kotlin.analysis.api.descriptors.types.KtFe10ClassErrorType
import org.jetbrains.kotlin.analysis.api.symbols.KtSymbolOrigin
import org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolKind
import org.jetbrains.kotlin.analysis.api.types.KtType
import org.jetbrains.kotlin.cfg.getElementParentDeclaration
import org.jetbrains.kotlin.descriptors.ClassDescriptorWithResolutionScopes
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.descriptors.Visibilities
import org.jetbrains.kotlin.descriptors.Visibility
import org.jetbrains.kotlin.lexer.KtTokens
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.psi.psiUtil.getParentOfType
import org.jetbrains.kotlin.psi.psiUtil.hasBody
import org.jetbrains.kotlin.psi.psiUtil.parentsWithSelf
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.scopes.LexicalScope
import org.jetbrains.kotlin.types.error.ErrorTypeKind
import org.jetbrains.kotlin.types.error.ErrorUtils

internal val KtDeclaration.ktVisibility: Visibility?
    get() = when {
        hasModifier(KtTokens.PUBLIC_KEYWORD) -> Visibilities.Public
        hasModifier(KtTokens.PROTECTED_KEYWORD) -> Visibilities.Protected
        hasModifier(KtTokens.PRIVATE_KEYWORD) -> Visibilities.Private
        hasModifier(KtTokens.INTERNAL_KEYWORD) -> Visibilities.Internal
        else -> null
    }

internal val KtDeclaration.ktModality: Modality?
    get() = when {",hasModifier(KtTokens.ABSTRACT_KEYWORD) -> Modality.ABSTRACT
"@Suppress(""DEPRECATION_ERROR"")
    fun linuxMips32(name: String, configure: Action<KotlinNativeTarget>) = linuxMips32(name) { configure.execute(this) }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMips32(configure: Action<KotlinNativeTarget>) = linuxMips32 { configure.execute(this) }


    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    fun linuxMipsel32(
        name: String = ""linuxMipsel32"",
        configure: KotlinNativeTarget.() -> Unit = { }
    ): KotlinNativeTarget =
        configureOrCreate(
            name,
            @Suppress(""DEPRECATION"")
            presets.getByName(""linuxMipsel32"") as KotlinNativeTargetPreset,
            configure
        )


    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMipsel32() = linuxMipsel32(""linuxMipsel32"") { }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMipsel32(name: String) = linuxMipsel32(name) { }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMipsel32(name: String, configure: Action<KotlinNativeTarget>) = linuxMipsel32(name) { configure.execute(this) }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun linuxMipsel32(configure: Action<KotlinNativeTarget>) = linuxMipsel32 { configure.execute(this) }


    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    fun wasm32(
        name: String = ""wasm32"",
        configure: KotlinNativeTarget.() -> Unit = { }
    ): KotlinNativeTarget =
        configureOrCreate(
            name,
            @Suppress(""DEPRECATION"")
            presets.getByName(""wasm32"") as KotlinNativeTargetPreset,
            configure
        )


    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun wasm32() = wasm32(""wasm32"") { }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun wasm32(name: String) = wasm32(name) { }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun wasm32(name: String, configure: Action<KotlinNativeTarget>) = wasm32(name) { configure.execute(this) }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")",fun wasm32(configure: Action<KotlinNativeTarget>) = wasm32 { configure.execute(this) }
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.psi.psiUtil

import com.intellij.extapi.psi.StubBasedPsiElementBase",import com.intellij.openapi.util.Key
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.unitTests

import org.jetbrains.kotlin.gradle.internal.properties.PropertiesBuildService
import org.jetbrains.kotlin.gradle.plugin.extraProperties
import org.jetbrains.kotlin.gradle.util.buildProject
import org.jetbrains.kotlin.gradle.util.registerMinimalVariantImplementationFactoriesForTests
import org.junit.Assert.assertEquals
import org.junit.Test

class PropertiesBuildServiceTest {

    @Test
    fun testPrecedenceOrder() {
        val project = buildProject()
        project.extraProperties.apply {
            set(""a"", ""extra"")
            set(""b"", ""extra"")
            set(""x"", 1) // Test the case where extra property is not a String
        }
        // TODO: Find a way to test Gradle properties (it seems that more setup is needed for Gradle to pick up the contents of
        //  `gradle.properties` in this test).
        project.projectDir.resolve(""local.properties"").writeText(
            """"""
            a = local
            c = local
            x = ""local""
            """""".trimIndent()
        )

        project.gradle.registerMinimalVariantImplementationFactoriesForTests()
        val properties = PropertiesBuildService.registerIfAbsent(project).get()

        assertEquals(""extra"", properties.get(""a"", project))
        assertEquals(""extra"", properties.get(""b"", project))
        assertEquals(""local"", properties.get(""c"", project))
        assertEquals(null, properties.get(""d"", project))
        assertEquals(""1"", properties.get(""x"", project))
    }

    @Test
    fun testDifferentSubProjectsExtraProperties() {
        val rootProject = buildProject()
        val subProject1 = buildProject(projectBuilder = {
            withParent(rootProject)
            withName(""sub-project-1"")
        })
        val subProject2 = buildProject(projectBuilder = {
            withParent(rootProject)
            withName(""sub-project-2"")
        })
        rootProject.gradle.registerMinimalVariantImplementationFactoriesForTests()
        subProject1.gradle.registerMinimalVariantImplementationFactoriesForTests()
        subProject2.gradle.registerMinimalVariantImplementationFactoriesForTests()

        rootProject.extraProperties.set(""a"", ""root"")","subProject1.extraProperties.set(""a"", ""subProject1"")"
"CXToken_Literal(3),
    CXToken_Comment(4),
    ;
    
    companion object {
        
        @Deprecated(""Will be removed."", ReplaceWith(""""), DeprecationLevel.WARNING)
        fun byValue(value: Int): CXTokenKind = values().find { it.value == value }!!
    }
    
    override open val value: Int = value
    class Var(rawPtr: NativePtr) : CEnumVar(rawPtr) {
        @Deprecated(""Use sizeOf<T>() or alignOf<T>() instead."")
        companion object : Type(sizeOf<IntVar>().toInt())
        var value: CXTokenKind
            get() = byValue(this.reinterpret<IntVar>().value)
            set(value) { this.reinterpret<IntVar>().value = value.value }
    }
}

enum class CXCompletionChunkKind(value: Int) : CEnum {
    CXCompletionChunk_Optional(0),
    CXCompletionChunk_TypedText(1),
    CXCompletionChunk_Text(2),
    CXCompletionChunk_Placeholder(3),
    CXCompletionChunk_Informative(4),
    CXCompletionChunk_CurrentParameter(5),
    CXCompletionChunk_LeftParen(6),
    CXCompletionChunk_RightParen(7),
    CXCompletionChunk_LeftBracket(8),
    CXCompletionChunk_RightBracket(9),
    CXCompletionChunk_LeftBrace(10),
    CXCompletionChunk_RightBrace(11),
    CXCompletionChunk_LeftAngle(12),
    CXCompletionChunk_RightAngle(13),
    CXCompletionChunk_Comma(14),
    CXCompletionChunk_ResultType(15),
    CXCompletionChunk_Colon(16),
    CXCompletionChunk_SemiColon(17),
    CXCompletionChunk_Equal(18),
    CXCompletionChunk_HorizontalSpace(19),
    CXCompletionChunk_VerticalSpace(20),
    ;
    
    companion object {
        
        @Deprecated(""Will be removed."", ReplaceWith(""""), DeprecationLevel.WARNING)
        fun byValue(value: Int): CXCompletionChunkKind = values().find { it.value == value }!!
    }
    
    override open val value: Int = value
    class Var(rawPtr: NativePtr) : CEnumVar(rawPtr) {
        @Deprecated(""Use sizeOf<T>() or alignOf<T>() instead."")
        companion object : Type(sizeOf<IntVar>().toInt())
        var value: CXCompletionChunkKind
            get() = byValue(this.reinterpret<IntVar>().value)
            set(value) { this.reinterpret<IntVar>().value = value.value }
    }
}

enum class CXEvalResultKind(value: Int) : CEnum {
    CXEval_UnExposed(0),
    CXEval_Int(1),
    CXEval_Float(2),
    CXEval_ObjCStrLiteral(3),","CXEval_StrLiteral(4),"
"val variable: KtProperty,
            val descriptor: VariableDescriptor,
            typeInfo: KotlinTypeInfo,
            scopeWithSubject: LexicalScope
        ) : Subject(variable, typeInfo, scopeWithSubject) {
            override fun createDataFlowValue(contextAfterSubject: ExpressionTypingContext, builtIns: KotlinBuiltIns) =
                DataFlowValue(
                    IdentifierInfo.Variable(
                        descriptor,
                        DataFlowValue.Kind.STABLE_VALUE,
                        contextAfterSubject.trace.bindingContext[BindingContext.BOUND_INITIALIZER_VALUE, descriptor]
                    ),
                    descriptor.type
                )

            override fun makeValueArgument(): ValueArgument? =
                variable.initializer?.let {
                    CallMaker.makeExternalValueArgument(
                        KtPsiFactory(variable.project, true).createExpression(variable.name!!),
                        it
                    )
                }

            override fun getCalleeExpressionForSpecialCall(): KtExpression =
                variable

            override val valueExpression: KtExpression?
                get() = variable.initializer
        }


        class None : Subject(null, null, null) {
            override fun createDataFlowValue(contextAfterSubject: ExpressionTypingContext, builtIns: KotlinBuiltIns) =
                DataFlowValue.nullValue(builtIns)

            override fun makeValueArgument(): ValueArgument? = null

            override val valueExpression: KtExpression? get() = null
        }

    }

    fun visitWhenExpression(
        expression: KtWhenExpression,
        contextWithExpectedType: ExpressionTypingContext,
        @Suppress(""UNUSED_PARAMETER"") isStatement: Boolean
    ): KotlinTypeInfo {
        val trace = contextWithExpectedType.trace
        WhenChecker.checkDeprecatedWhenSyntax(trace, expression)
        WhenChecker.checkSealedWhenIsReserved(trace, expression.whenKeyword)
        checkWhenGuardsAreEnabled(trace, expression)

        components.dataFlowAnalyzer.recordExpectedType(trace, expression, contextWithExpectedType.expectedType)

        val contextBeforeSubject = contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE).replaceContextDependency(INDEPENDENT)

        // TODO change scope according to the bound value in the when header

        val subjectExpression = expression.subjectExpression
        val subjectVariable = expression.subjectVariable

        val subject = when {
            subjectVariable != null ->
                processVariableSubject(subjectVariable, contextBeforeSubject)",subjectExpression != null ->
"// Auto-generated by GenerateSteppedRangesCodegenTestData. Do not edit!
// WITH_STDLIB
import kotlin.test.*

fun box(): String {
    val uintList = mutableListOf<UInt>()
    for (i in 1u until 8u step 3 step 2) {
        uintList += i
    }
    assertEquals(listOf(1u, 3u, 5u, 7u), uintList)

    val ulongList = mutableListOf<ULong>()
    for (i in 1uL until 8uL step 3L step 2L) {",ulongList += i
"}

sealed class StubContainer : StubIrElement {
    abstract val meta: StubContainerMeta
    abstract val classes: List<ClassStub>
    abstract val functions: List<FunctionalStub>
    abstract val properties: List<PropertyStub>
    abstract val typealiases: List<TypealiasStub>
    abstract val simpleContainers: List<SimpleStubContainer>
}

/**
 * Meta information about [StubContainer].
 * For example, can be used for comments in textual representation.
 */
class StubContainerMeta(
        val textAtStart: String = """",
        val textAtEnd: String = """"
)

class SimpleStubContainer(
        override val meta: StubContainerMeta = StubContainerMeta(),
        override val classes: List<ClassStub> = emptyList(),
        override val functions: List<FunctionalStub> = emptyList(),
        override val properties: List<PropertyStub> = emptyList(),
        override val typealiases: List<TypealiasStub> = emptyList(),
        override val simpleContainers: List<SimpleStubContainer> = emptyList()
) : StubContainer() {

    override fun <T, R> accept(visitor: StubIrVisitor<T, R>, data: T): R {
        return visitor.visitSimpleStubContainer(this, data)
    }
}

val StubContainer.children: List<StubIrElement>
    get() = (classes as List<StubIrElement>) + properties + functions + typealiases

/**
 * Marks that abstract value of such type can be passed as value.
 */
sealed class ValueStub

class TypeParameterStub(
        val name: String,
        val upperBound: StubType? = null
) {
    fun getStubType(nullable: Boolean) =
            TypeParameterType(name, nullable = nullable, typeParameterDeclaration = this)

}

interface TypeArgument {
    object StarProjection : TypeArgument {
        override fun toString(): String =
                ""*""
    }

    enum class Variance {
        INVARIANT,
        IN,
        OUT
    }
}

class TypeArgumentStub(","val type: StubType,"
typealias SuspendFn = suspend () -> Unit,val test1f: suspend () -> Unit = <!INITIALIZER_TYPE_MISMATCH!>fun () {}<!>
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin.mpp

import org.gradle.api.Project
import org.gradle.api.file.FileCollection
import org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension
import org.jetbrains.kotlin.gradle.dsl.metadataTarget
import org.jetbrains.kotlin.gradle.dsl.multiplatformExtensionOrNull
import org.jetbrains.kotlin.gradle.plugin.KotlinPluginLifecycle.Stage.AfterEvaluateBuildscript
import org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet
import org.jetbrains.kotlin.gradle.plugin.await
import org.jetbrains.kotlin.gradle.plugin.mpp.MetadataDependencyResolution.ChooseVisibleSourceSets.MetadataProvider.ProjectMetadataProvider
import org.jetbrains.kotlin.gradle.targets.metadata.awaitMetadataCompilationsCreated

private typealias SourceSetName = String

internal fun ProjectMetadataProvider(
    sourceSetMetadataOutputs: Map<SourceSetName, SourceSetMetadataOutputs>,
): ProjectMetadataProvider {
    return ProjectMetadataProviderImpl(sourceSetMetadataOutputs)
}

internal class SourceSetMetadataOutputs(
    val metadata: FileCollection?,
)

private class ProjectMetadataProviderImpl(
    private val sourceSetMetadataOutputs: Map<SourceSetName, SourceSetMetadataOutputs>,
) : ProjectMetadataProvider() {

    override fun getSourceSetCompiledMetadata(sourceSetName: String): FileCollection? {
        val metadataOutputs = sourceSetMetadataOutputs[sourceSetName] ?: return null",return metadataOutputs.metadata
"// WITH_SIGNATURES

abstract class DoubleCollection : Collection<Double>",abstract class StringCollection : Collection<String>
"// WITH_STDLIB
// WITH_COROUTINES
import helpers.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*

var log = """"
var postponed: () -> Unit = { }
var complete = false

suspend fun suspendHere(x: String): Unit {
    log += ""suspendHere($x);""
    return suspendCoroutineUninterceptedOrReturn { c ->
        postponed = { c.resume(Unit) }
        log += ""suspended;""
        COROUTINE_SUSPENDED
    }
}

class A(val x: String) {
    suspend fun foo() = suspendHere(""A.foo($x)"")
}

fun builder(c: suspend () -> Unit) {
    c.startCoroutine(handleResultContinuation {
        log += ""complete;""
        complete = true
    })
}

fun box(): String {
    val a1: A? = A(""*"")
    val a2: A? = null
    builder {
        val r1 = a1?.foo().simpleName + "";""
        log += r1
        val r2 = a2?.foo().simpleName + "";""
        log += r2
        A(""@"").foo()
    }

    while (!complete) {
        log += ""resuming;""
        postponed()
    }

    if (log != ""suspendHere(A.foo(*));suspended;resuming;Unit;null;suspendHere(A.foo(@));suspended;resuming;complete;"") return ""fail: $log""","return ""OK"""
"// TARGET_BACKEND: JVM_IR
// COMMENTED[LANGUAGE: +ProperFieldAccessGenerationForFieldAccessShadowedByKotlinProperty] uncomment when KT-56386 is fixed
// IGNORE_BACKEND_K1: JVM_IR
// IGNORE_BACKEND_K2: JVM_IR
// Reason: KT-56386 is not fixed yet

// FILE: BaseJava.java
public class BaseJava {
    public String a = ""OK"";

    public String foo() {
        return a;
    }
}

// FILE: Derived.kt
class Derived : BaseJava() {
    private val a = ""FAIL""
}

fun box(): String {
    val first = Derived().a","if (first != ""OK"") return first"
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kotlin.reflect.jvm.internal

import org.jetbrains.kotlin.descriptors.CallableMemberDescriptor
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.TypeParameterDescriptor
import org.jetbrains.kotlin.descriptors.runtime.components.ReflectKotlinClass
import org.jetbrains.kotlin.load.kotlin.JvmPackagePartSource
import org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedMemberDescriptor
import org.jetbrains.kotlin.types.Variance
import kotlin.jvm.internal.TypeParameterReference
import kotlin.reflect.KType
import kotlin.reflect.KTypeParameter
import kotlin.reflect.KVariance",internal class KTypeParameterImpl(
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.low.level.api.fir.lazy.resolve

import com.intellij.psi.PsiElement
import kotlinx.collections.immutable.PersistentList
import kotlinx.collections.immutable.persistentListOf
import kotlinx.collections.immutable.toPersistentList
import org.jetbrains.annotations.TestOnly
import org.jetbrains.kotlin.KtFakeSourceElementKind
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.FirDesignation
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.withFirDesignationEntry
import org.jetbrains.kotlin.analysis.low.level.api.fir.util.forEachDeclaration
import org.jetbrains.kotlin.fir.*
import org.jetbrains.kotlin.fir.builder.PsiRawFirBuilder
import org.jetbrains.kotlin.fir.contracts.FirRawContractDescription
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.declarations.utils.getExplicitBackingField
import org.jetbrains.kotlin.fir.expressions.*
import org.jetbrains.kotlin.fir.expressions.impl.FirLazyDelegatedConstructorCall
import org.jetbrains.kotlin.fir.expressions.impl.FirSingleExpressionBlock
import org.jetbrains.kotlin.fir.references.FirDelegateFieldReference
import org.jetbrains.kotlin.fir.references.FirResolvedNamedReference
import org.jetbrains.kotlin.fir.references.builder.buildDelegateFieldReference
import org.jetbrains.kotlin.fir.references.builder.buildImplicitThisReference
import org.jetbrains.kotlin.fir.references.builder.buildResolvedNamedReference
import org.jetbrains.kotlin.fir.scopes.kotlinScopeProvider
import org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol
import org.jetbrains.kotlin.fir.types.builder.buildResolvedTypeRef
import org.jetbrains.kotlin.fir.types.builder.buildTypeProjectionWithVariance
import org.jetbrains.kotlin.fir.types.impl.ConeTypeParameterTypeImpl
import org.jetbrains.kotlin.fir.utils.exceptions.withFirEntry
import org.jetbrains.kotlin.fir.utils.exceptions.withFirSymbolEntry
import org.jetbrains.kotlin.fir.visitors.FirTransformer
import org.jetbrains.kotlin.fir.visitors.transformSingle
import org.jetbrains.kotlin.psi.KtAnnotated
import org.jetbrains.kotlin.psi.KtAnnotationEntry
import org.jetbrains.kotlin.psi.KtClassOrObject
import org.jetbrains.kotlin.psi.psiUtil.getStrictParentOfType
import org.jetbrains.kotlin.types.Variance
import org.jetbrains.kotlin.utils.exceptions.errorWithAttachment
import org.jetbrains.kotlin.utils.exceptions.requireWithAttachment

internal object FirLazyBodiesCalculator {
    fun calculateBodies(designation: FirDesignation) {
        designation.target.transformSingle(","FirTargetLazyBodiesCalculatorTransformer,"
"override fun setUp() {
        super.setUp()

        environment.projectEnvironment.environment.registerFileType(
            KlibMetaFileType, KlibMetaFileType.defaultExtension
        )
    }

    override fun createEnvironment(): KotlinCoreEnvironment {
        return KotlinCoreEnvironment.createForTests(
            ApplicationEnvironmentDisposer.ROOT_DISPOSABLE,
            KotlinTestUtils.newConfiguration(
                ConfigurationKind.JDK_NO_RUNTIME,
                TestJdkKind.MOCK_JDK,
            ),
            EnvironmentConfigFiles.METADATA_CONFIG_FILES,
        )
    }

    fun runTest(testDirectory: String) {
        val testDirectoryPath = Paths.get(testDirectory)
        withKnmIgnoreDirective(testDirectoryPath) { doTest(testDirectoryPath) }
    }

    protected fun compileToKnmFiles(testDirectoryPath: Path): List<VirtualFile> {
        val (compilationOutputFile, outputType) = compileCommonMetadata(testDirectoryPath)
        return getKnmFiles(compilationOutputFile, outputType)
    }

    private fun compileCommonMetadata(testDirectory: Path): Pair<File, OutputType> {
        val ktFiles = Files.list(testDirectory).filter { it.extension == ""kt"" }.collect(Collectors.toList())
        val testKlib = KtTestUtil.tmpDir(""testLibrary"").resolve(""library.klib"")
        val additionalArgumentsFromLanguageDirectives = ktFiles.flatMap { path ->
            path.readText().let { fileText ->
                InTextDirectivesUtils.findListWithPrefixes(fileText, ""// !LANGUAGE: "").map { ""-XXLanguage:$it"" }
            }
        }

        val outputType = knmTestSupport.compileCommonMetadata(ktFiles, testKlib.toPath(), additionalArgumentsFromLanguageDirectives)
        return testKlib to outputType
    }

    private fun getKnmFiles(compilationOutput: File, outputType: OutputType): List<VirtualFile> {
        val root = extractVirtualFileRootFromCompiledMetadata(compilationOutput, outputType)
        val files = mutableListOf<VirtualFile>()
        VfsUtilCore.iterateChildrenRecursively(
            root,
            { virtualFile -> virtualFile.isDirectory || virtualFile.name.endsWith(KLIB_METADATA_FILE_EXTENSION_WITH_DOT) },
            { virtualFile ->
                if (!virtualFile.isDirectory) {
                    files.addIfNotNull(virtualFile)
                }
                true
            })

        return files
    }

    private fun extractVirtualFileRootFromCompiledMetadata(rootFile: File, outputType: OutputType): VirtualFile {
        return when (outputType) {
            OutputType.KLIB -> {
                val path = rootFile.toPath()
                val jarFileSystem = environment.projectEnvironment.environment.jarFileSystem as CoreJarFileSystem
                jarFileSystem.refreshAndFindFileByPath(path.absolutePathString() + ""!/"")!!
            }",OutputType.UNPACKED -> {
"// WITH_STDLIB
// FILE: First.java

public class First implements Comparable<First> {
    public static First compose(int something) {
        return null;
    }
}

// FILE: Second.java

public class Second implements Comparable<Second> {
    public static Second compose(String something) {
        return null;
    }
}

// FILE: complexMapping.kt

private fun <R : Comparable<R>> range(vararg ranges: Pair<R?, R?>): Ranges<R> = null!!

private abstract class Ranges<C : Comparable<C>> {
    abstract fun <M : Comparable<M>> map(transform: (C) -> M): Ranges<M>
}

private val INF: Nothing? = null

private val foo = listOf(
    range(0 to 1) to range(INF to """"),
    range(2 to 3) to range(INF to """", """" to INF),
    range(4 to 5) to range("""" to INF),
    range(6 to INF) to range("""" to INF)",).map {
"""""""
        }
        typeParam(""R"")
        returns(""R"")
        body {
            """"""
            var accumulator = initial
            for (element in this) accumulator = operation(accumulator, element)
            return accumulator
            """"""
        }
    }

    val f_foldRight = fn(""foldRight(initial: R, operation: (T, acc: R) -> R)"") {
        include(CharSequences, Lists, ArraysOfObjects, ArraysOfPrimitives, ArraysOfUnsigned)
    } builder {
        inline()
        specialFor(ArraysOfUnsigned) { inlineOnly() }

        doc {
            """"""
            Accumulates value starting with [initial] value and applying [operation] from right to left 
            to each ${f.element} and current accumulator value.

            Returns the specified [initial] value if the ${f.collection} is empty.

            @param [operation] function that takes ${f.element.prefixWithArticle()} and current accumulator value, and calculates the next accumulator value.
            """"""
        }
        typeParam(""R"")
        returns(""R"")
        body {
            """"""
            var index = lastIndex
            var accumulator = initial
            while (index >= 0) {
                accumulator = operation(get(index--), accumulator)
            }
            return accumulator
            """"""
        }
        body(Lists) {
            """"""
            var accumulator = initial
            if (!isEmpty()) {
                val iterator = listIterator(size)
                while (iterator.hasPrevious()) {
                    accumulator = operation(iterator.previous(), accumulator)
                }
            }
            return accumulator
            """"""
        }
    }

    private fun MemberBuilder.reduceDoc(fName: String): String {
        fun summaryDoc(isLeftToRight: Boolean, isIndexed: Boolean): String {
            val acc = ""current accumulator value""
            val element = if (isIndexed) ""each ${f.element} with its index in the original ${f.collection}"" else ""each ${f.element}""
            val start = if (isLeftToRight) ""first"" else ""last""
            val iteration = if (isLeftToRight) ""left to right\nto $acc and $element"" else ""right to left\nto $element and $acc""
            return """"""
                Accumulates value starting with the $start ${f.element} and applying [operation] from $iteration.""""""
        }","fun paramDoc(isLeftToRight: Boolean, isIndexed: Boolean): String {"
"// EXPECTED_REACHABLE_NODES: 1284
// This test was adapted from compiler/testData/codegen/box/callableReference/function/.",package foo
"name,
            @Suppress(""DEPRECATION"")
            presets.getByName(""tvosX64"") as KotlinNativeTargetWithSimulatorTestsPreset,
            configure
        )

    fun tvosX64() = tvosX64(""tvosX64"") { }
    fun tvosX64(name: String) = tvosX64(name) { }
    fun tvosX64(name: String, configure: Action<KotlinNativeTargetWithSimulatorTests>) = tvosX64(name) { configure.execute(this) }
    fun tvosX64(configure: Action<KotlinNativeTargetWithSimulatorTests>) = tvosX64 { configure.execute(this) }

    fun tvosSimulatorArm64(
        name: String = ""tvosSimulatorArm64"",
        configure: KotlinNativeTargetWithSimulatorTests.() -> Unit = { }
    ): KotlinNativeTargetWithSimulatorTests =
        configureOrCreate(
            name,
            @Suppress(""DEPRECATION"")
            presets.getByName(""tvosSimulatorArm64"") as KotlinNativeTargetWithSimulatorTestsPreset,
            configure
        )

    fun tvosSimulatorArm64() = tvosSimulatorArm64(""tvosSimulatorArm64"") { }
    fun tvosSimulatorArm64(name: String) = tvosSimulatorArm64(name) { }
    fun tvosSimulatorArm64(name: String, configure: Action<KotlinNativeTargetWithSimulatorTests>) = tvosSimulatorArm64(name) { configure.execute(this) }
    fun tvosSimulatorArm64(configure: Action<KotlinNativeTargetWithSimulatorTests>) = tvosSimulatorArm64 { configure.execute(this) }

    fun linuxX64(
        name: String = ""linuxX64"",
        configure: KotlinNativeTargetWithHostTests.() -> Unit = { }
    ): KotlinNativeTargetWithHostTests =
        configureOrCreate(
            name,
            @Suppress(""DEPRECATION"")
            presets.getByName(""linuxX64"") as KotlinNativeTargetWithHostTestsPreset,
            configure
        )

    fun linuxX64() = linuxX64(""linuxX64"") { }
    fun linuxX64(name: String) = linuxX64(name) { }
    fun linuxX64(name: String, configure: Action<KotlinNativeTargetWithHostTests>) = linuxX64(name) { configure.execute(this) }
    fun linuxX64(configure: Action<KotlinNativeTargetWithHostTests>) = linuxX64 { configure.execute(this) }


    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    fun mingwX86(
        name: String = ""mingwX86"",
        configure: KotlinNativeTarget.() -> Unit = { }
    ): KotlinNativeTarget =
        configureOrCreate(
            name,
            @Suppress(""DEPRECATION"")
            presets.getByName(""mingwX86"") as KotlinNativeTargetPreset,
            configure
        )


    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun mingwX86() = mingwX86(""mingwX86"") { }

    @Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)
    @Suppress(""DEPRECATION_ERROR"")
    fun mingwX86(name: String) = mingwX86(name) { }","@Deprecated(DEPRECATED_TARGET_MESSAGE, level = DeprecationLevel.ERROR)"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.generator.print

import org.jetbrains.kotlin.generators.tree.AbstractFieldPrinter
import org.jetbrains.kotlin.generators.tree.AbstractImplementationPrinter
import org.jetbrains.kotlin.generators.tree.ClassRef
import org.jetbrains.kotlin.generators.tree.elementAncestorsAndSelfDepthFirst
import org.jetbrains.kotlin.generators.tree.printer.FunctionParameter
import org.jetbrains.kotlin.generators.tree.printer.ImportCollectingPrinter
import org.jetbrains.kotlin.generators.tree.printer.printBlock",import org.jetbrains.kotlin.ir.generator.IrTree
"// FIR_IDENTICAL

val String.test1 get() = 42

var String.test2
    get() = 42
    set(value) {}

class Host {
    val String.test3 get() = 42

    var String.test4
        get() = 42",set(value) {}
"/**
 * Returns a list containing only distinct elements from the given collection.
 * 
 * Among equal elements of the given collection, only the first one will be present in the resulting list.
 * The elements in the resulting list are in the same order as they were in the source collection.
 * 
 * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy
 */
public fun <T> Iterable<T>.distinct(): List<T> {
    return this.toMutableSet().toList()
}

/**
 * Returns a list containing only elements from the given collection
 * having distinct keys returned by the given [selector] function.
 * 
 * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.
 * The elements in the resulting list are in the same order as they were in the source collection.
 * 
 * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy
 */
public inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {
    val set = HashSet<K>()
    val list = ArrayList<T>()
    for (e in this) {
        val key = selector(e)
        if (set.add(key))
            list.add(e)
    }
    return list
}

/**
 * Returns a set containing all elements that are contained by both this collection and the specified collection.
 * 
 * The returned set preserves the element iteration order of the original collection.
 * 
 * To get a set containing all elements that are contained at least in one of these collections use [union].
 */
public infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {
    val set = this.toMutableSet()
    set.retainAll(other)
    return set
}

/**
 * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.
 * 
 * The returned set preserves the element iteration order of the original collection.
 */
public infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {
    val set = this.toMutableSet()
    set.removeAll(other)
    return set
}

/**
 * Returns a new [MutableSet] containing all distinct elements from the given collection.
 * 
 * The returned set preserves the element iteration order of the original collection.
 */
public fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {
    return when (this) {
        is Collection<T> -> LinkedHashSet(this)",else -> toCollection(LinkedHashSet<T>())
"var path: Path2D? /* = null */
        get() = definedExternally
        set(value) = definedExternally
    var fillRule: CanvasFillRule? /* = CanvasFillRule.NONZERO */
        get() = definedExternally
        set(value) = definedExternally
    var id: String? /* = """" */
        get() = definedExternally
        set(value) = definedExternally
    var parentID: String? /* = null */
        get() = definedExternally
        set(value) = definedExternally
    var cursor: String? /* = ""inherit"" */
        get() = definedExternally
        set(value) = definedExternally
    var control: Element? /* = null */
        get() = definedExternally
        set(value) = definedExternally
    var label: String? /* = null */
        get() = definedExternally
        set(value) = definedExternally
    var role: String? /* = null */
        get() = definedExternally
        set(value) = definedExternally
}

@Suppress(""UNUSED_PARAMETER"")
public fun HitRegionOptions(path: Path2D? = null, fillRule: CanvasFillRule? = CanvasFillRule.NONZERO, id: String? = """", parentID: String? = null, cursor: String? = ""inherit"", control: Element? = null, label: String? = null, role: String? = null): HitRegionOptions { js(""return { path, fillRule, id, parentID, cursor, control, label, role };"") }

/**
 * Exposes the JavaScript [ImageData](https://developer.mozilla.org/en/docs/Web/API/ImageData) to Kotlin
 */
public external open class ImageData : ImageBitmapSource, TexImageSource, JsAny {
    constructor(sw: Int, sh: Int)
    constructor(data: Uint8ClampedArray, sw: Int, sh: Int = definedExternally)
    open val width: Int
    open val height: Int
    open val data: Uint8ClampedArray
}

/**
 * Exposes the JavaScript [Path2D](https://developer.mozilla.org/en/docs/Web/API/Path2D) to Kotlin
 */
public external open class Path2D() : CanvasPath, JsAny {
    constructor(path: Path2D)
    constructor(paths: JsArray<Path2D>, fillRule: CanvasFillRule = definedExternally)
    constructor(d: String)
    fun addPath(path: Path2D, transform: JsAny? = definedExternally)
    override fun closePath()
    override fun moveTo(x: Double, y: Double)
    override fun lineTo(x: Double, y: Double)
    override fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double)
    override fun bezierCurveTo(cp1x: Double, cp1y: Double, cp2x: Double, cp2y: Double, x: Double, y: Double)
    override fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radius: Double)
    override fun arcTo(x1: Double, y1: Double, x2: Double, y2: Double, radiusX: Double, radiusY: Double, rotation: Double)
    override fun rect(x: Double, y: Double, w: Double, h: Double)
    override fun arc(x: Double, y: Double, radius: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean /* = definedExternally */)
    override fun ellipse(x: Double, y: Double, radiusX: Double, radiusY: Double, rotation: Double, startAngle: Double, endAngle: Double, anticlockwise: Boolean /* = definedExternally */)
}

/**
 * Exposes the JavaScript [ImageBitmapRenderingContext](https://developer.mozilla.org/en/docs/Web/API/ImageBitmapRenderingContext) to Kotlin
 */
public external abstract class ImageBitmapRenderingContext : JsAny {
    open val canvas: HTMLCanvasElement",fun transferFromImageBitmap(bitmap: ImageBitmap?)
"/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.javac.wrappers.symbols

import com.sun.tools.javac.code.Symbol",import org.jetbrains.kotlin.javac.JavacWrapper
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.backend

import com.intellij.psi.tree.IElementType
import org.jetbrains.kotlin.*
import org.jetbrains.kotlin.contracts.description.LogicOperationKind",import org.jetbrains.kotlin.descriptors.Visibilities
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:kotlin.jvm.JvmMultifileClass
@file:kotlin.jvm.JvmName(""UArraysKt"")
@file:kotlin.jvm.JvmPackageName(""kotlin.collections.unsigned"")

package kotlin.collections

//
// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt
// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib
//",import kotlin.ranges.contains
"fun testDiamondFakeOverrideAbstractOverridesConcrete() {
        val a = v(""+D1"")
        val b = v(""+D2"")
        val c = v(""-D3"")
        val d = v(""+F4"")
        graph(b to a, c to a, d to b, d to c)
        doTest(b, setOf(bridge(a, b)))
        doTest(c, setOf())
        doTest(d, setOf(bridge(c, b)))
    }

    // More complex tests where a fake override inherits several declarations

    fun testFakeOverrideInheritingDeclarationsAndAbstract() {
        val a = v(""-D1"")
        val b = v(""-D2"")
        val c = v(""+D3"")
        val e = v(""+F4"")
        graph(e to a, e to b, e to c, c to b)
        doTest(a, setOf())
        doTest(b, setOf())
        doTest(c, setOf(bridge(b, c)))
        doTest(e, setOf(bridge(a, c)))
    }

    fun testFakeOverrideManyDeclarations() {
        val a = v(""-D1"")
        val b = v(""+D2"")
        val c = v(""-D3"")
        val d = v(""-D4"")
        val e = v(""+F5"")
        graph(e to a, e to b, e to c, e to d)
        doTest(e, setOf(bridge(a, b), bridge(c, b), bridge(d, b)))
    }

    fun testFakeOverrideTwoDeclarationsThroughFakeOverrides() {
        val a = v(""+D1"")
        val b = v(""+F2"")
        val c = v(""-D3"")
        val d = v(""-F4"")
        val e = v(""+F5"")
        graph(b to a, d to c, e to b, e to d)
        doTest(e, setOf(bridge(c, a)))
    }

    fun testFakeOverrideMisleadingImplementation() {
        val a = v(""+D1"")
        val b = v(""-D2"")
        val c = v(""-D3"")
        val d = v(""+D4"")
        val e = v(""+F5"")
        val f = v(""+F6"")
        graph(c to a, e to d, f to b, f to c, f to e)
        doTest(e, setOf())
        // Although ""a"" is a concrete declaration, it's overridden with abstract in ""c"" and all bridges should delegate to ""d"" instead
        doTest(f, setOf(bridge(b, d), bridge(a, d), bridge(c, d)))
    }

    // Fake override overrides another fake override (or declaration) with some bridges already present there

    fun testFakeOverrideInheritsBridgeFromFakeOverride() {
        val a = v(""-D1"")
        val b = v(""+D2"")
        val c = v(""+F3"")","val d = v(""+F4"")"
"@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UShortArray?.contentToString(): kotlin.String

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.internal.InlineOnly
public inline fun <T> kotlin.Array<out T>.copyInto(destination: kotlin.Array<T>, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.Array<T>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.internal.InlineOnly
public inline fun kotlin.BooleanArray.copyInto(destination: kotlin.BooleanArray, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.BooleanArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.internal.InlineOnly
public inline fun kotlin.ByteArray.copyInto(destination: kotlin.ByteArray, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.ByteArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.internal.InlineOnly
public inline fun kotlin.CharArray.copyInto(destination: kotlin.CharArray, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.CharArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.internal.InlineOnly
public inline fun kotlin.DoubleArray.copyInto(destination: kotlin.DoubleArray, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.DoubleArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.internal.InlineOnly
public inline fun kotlin.FloatArray.copyInto(destination: kotlin.FloatArray, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.FloatArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.internal.InlineOnly
public inline fun kotlin.IntArray.copyInto(destination: kotlin.IntArray, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.IntArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.internal.InlineOnly
public inline fun kotlin.LongArray.copyInto(destination: kotlin.LongArray, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.LongArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.internal.InlineOnly
public inline fun kotlin.ShortArray.copyInto(destination: kotlin.ShortArray, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.ShortArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun kotlin.UByteArray.copyInto(destination: kotlin.UByteArray, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.UByteArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun kotlin.UIntArray.copyInto(destination: kotlin.UIntArray, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.UIntArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun kotlin.ULongArray.copyInto(destination: kotlin.ULongArray, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.ULongArray

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun kotlin.UShortArray.copyInto(destination: kotlin.UShortArray, destinationOffset: kotlin.Int = ..., startIndex: kotlin.Int = ..., endIndex: kotlin.Int = ...): kotlin.UShortArray

public inline fun <T> kotlin.Array<out T>.copyOf(): kotlin.Array<T>

public fun <T> kotlin.Array<out T>.copyOf(newSize: kotlin.Int): kotlin.Array<T?>",public fun kotlin.BooleanArray.copyOf(): kotlin.BooleanArray
"import org.jetbrains.org.objectweb.asm.tree.*

class RedundantNullCheckMethodTransformer(private val generationState: GenerationState) : MethodTransformer() {
    override fun transform(internalClassName: String, methodNode: MethodNode) {
        do {
            val changes = TransformerPass(internalClassName, methodNode, generationState).run()
        } while (changes)
    }

    private class TransformerPass(val internalClassName: String, val methodNode: MethodNode, val generationState: GenerationState) {
        private var changes = false

        fun run(): Boolean {
            if (methodNode.instructions.none { it.isOptimizable() }) return false

            val nullabilityAssumptions = NullabilityAssumptionsBuilder().injectNullabilityAssumptions()

            val nullabilityMap = analyzeNullabilities()

            nullabilityAssumptions.revert()

            transformTrivialChecks(nullabilityMap)

            return changes
        }

        private fun analyzeNullabilities(): Map<AbstractInsnNode, StrictBasicValue> {
            val frames = analyze(internalClassName, methodNode, NullabilityInterpreter(generationState))
            val insns = methodNode.instructions.toArray()
            val nullabilityMap = LinkedHashMap<AbstractInsnNode, StrictBasicValue>()
            for (i in insns.indices) {
                val frame = frames[i] ?: continue
                val insn = insns[i]

                val value = when {
                    insn.isInstanceOfOrNullCheck() -> frame.top()
                    insn.isCheckNotNull() -> frame.top()
                    insn.isCheckNotNullWithMessage() -> frame.peek(1)
                    insn.isCheckExpressionValueIsNotNull() -> frame.peek(1)
                    else -> null
                } as? StrictBasicValue ?: continue

                val nullability = value.getNullability()
                if (nullability == Nullability.NULLABLE) continue
                nullabilityMap[insn] = value
            }
            return nullabilityMap
        }

        private fun AbstractInsnNode.isOptimizable() =
            opcode == Opcodes.IFNULL ||
                    opcode == Opcodes.IFNONNULL ||
                    opcode == Opcodes.INSTANCEOF ||
                    isCheckNotNull() ||
                    isCheckNotNullWithMessage() ||
                    isCheckExpressionValueIsNotNull()

        private fun transformTrivialChecks(nullabilityMap: Map<AbstractInsnNode, StrictBasicValue>) {
            for ((insn, value) in nullabilityMap) {
                val nullability = value.getNullability()
                when (insn.opcode) {
                    Opcodes.IFNULL -> transformTrivialNullJump(insn as JumpInsnNode, nullability == Nullability.NULL)
                    Opcodes.IFNONNULL -> transformTrivialNullJump(insn as JumpInsnNode, nullability == Nullability.NOT_NULL)
                    Opcodes.INSTANCEOF -> transformInstanceOf(insn as TypeInsnNode, nullability, value)",Opcodes.INVOKESTATIC -> {
"// FIR_IDENTICAL
// SKIP_TXT
// WITH_STDLIB
// LANGUAGE: +NoBuilderInferenceWithoutAnnotationRestriction

class A
class B

var B.foo: Boolean
    get() = true
    set(value) {}",private fun A.bar(b: B) {
")
                        isAnyFunctionExpressionWithReceiver =
                            isAnyFunctionExpressionWithReceiver or anotherArgument.isFunctionExpressionWithReceiver()

                        val parameterTypesFromDeclarationOfRelatedLambda = anotherArgument.parameterTypesFromDeclaration

                        if (areTypeVariablesRelated && parameterTypesFromDeclarationOfRelatedLambda != null) {
                            Pair(parameterTypesFromDeclarationOfRelatedLambda, anotherArgument.isLambda())
                        } else null
                    }
                }
            }

        val declaredParameterTypes = mutableSetOf<List<KotlinTypeMarker?>>()

        val maxParameterCount = maxOf(
            parameterTypesFromConstraints?.map { it.size }?.maxOrNull() ?: 0,
            parameterTypesFromDeclarationOfRelatedLambdas.map { it.first.size }.maxOrNull() ?: 0,
            parameterTypesFromDeclaration?.size ?: 0
        )

        val isFeatureEnabled =
            considerExtensionReceiverFromConstrainsInLambda()

        parameterTypesFromDeclarationOfRelatedLambdas.mapTo(declaredParameterTypes) { (types, isLambda) ->
            if (
                isFeatureEnabled && isLambda &&
                (extensionFunctionTypePresentInConstraints || isAnyFunctionExpressionWithReceiver) &&
                types.size + 1 == maxParameterCount
            )
                listOf(null) + types
            else
                types
        }

        return Triple(declaredParameterTypes, isAnyFunctionExpressionWithReceiver, maxParameterCount)
    }

    private fun considerExtensionReceiverFromConstrainsInLambda() =
        resolutionTypeSystemContext.isForcedConsiderExtensionReceiverFromConstrainsInLambda ||
                languageVersionSettings.supportsFeature(LanguageFeature.ConsiderExtensionReceiverFromConstrainsInLambda)

    private fun Context.createTypeVariableForReturnType(argument: PostponedAtomWithRevisableExpectedType): TypeVariableMarker =
        with(resolutionTypeSystemContext) {
            return when (argument) {
                is LambdaWithTypeVariableAsExpectedTypeMarker -> createTypeVariableForLambdaReturnType()
                is PostponedCallableReferenceMarker -> createTypeVariableForCallableReferenceReturnType()
                else -> throw IllegalStateException(""Unsupported postponed argument type of $argument"")
            }.also { getBuilder().registerVariable(it) }
        }

    private fun Context.createTypeVariableForParameterType(
        argument: PostponedAtomWithRevisableExpectedType,
        index: Int
    ): TypeVariableMarker = with(resolutionTypeSystemContext) {
        return when (argument) {
            is LambdaWithTypeVariableAsExpectedTypeMarker -> createTypeVariableForLambdaParameterType(argument, index)
            is PostponedCallableReferenceMarker -> createTypeVariableForCallableReferenceParameterType(argument, index)
            else -> throw IllegalStateException(""Unsupported postponed argument type of $argument"")
        }.also { getBuilder().registerVariable(it) }
    }

    private fun Context.createTypeVariablesForParameters(
        argument: PostponedAtomWithRevisableExpectedType,
        parameterTypes: List<List<TypeWithKind?>>",): List<TypeArgumentMarker> = with(resolutionTypeSystemContext) {
"// FIR_IDENTICAL
fun foo(numbers: Collection<Int>) {
    for (i in numbers) {
        val b: Boolean
        if (1 < 2) {
            b = false
        }
        else {",b = true
"exactlyOnce {
        require(x is String)
        x = 10
    }
    exactlyOnce {
        x.<!UNRESOLVED_REFERENCE!>length<!>
    }
}

fun test36() {
    var x: Any? = materialize()
    atLeastOnce {
        require(x is String)
        x = 10
    }
    atLeastOnce {
        x.<!UNRESOLVED_REFERENCE!>length<!>
    }
}

fun test37() {
    var x: Any? = materialize()
    require(x is String)
    fun local() {
        atLeastOnce {
            <!SMARTCAST_IMPOSSIBLE!>x<!>.length
        }
        x = """"
    }
}

fun test38() {
    var x: Any? = materialize()
    require(x is String)
    fun local() {
        exactlyOnce {
            <!SMARTCAST_IMPOSSIBLE!>x<!>.length
        }
        x = """"
    }
}

fun test39() {
    var x: Any? = materialize()
    require(x is String)
    fun local() {
        runWithoutContract {
            <!SMARTCAST_IMPOSSIBLE!>x<!>.length
        }
        x = """"
    }
}

fun test40() {
    var x: Any? = materialize()
    require(x is String)
    fun local() {
        atLeastOnce {
            x.length
        }
    }
}

fun test41() {
    var x: Any? = materialize()",require(x is String)
"// NO_CHECK_LAMBDA_INLINING
// FILE: 1.kt
package test

class Test {

    val prop: String = ""OK""

    fun test() =
            inlineFun {
                noInline {
                    object {
                        val inflater = prop
                    }.inflater
                }
            }
}

inline fun <T> inlineFun(init: () -> T): T {
    return init()
}

fun <T> noInline(init: () -> T): T {
    return init()
}

// FILE: 2.kt

import test.*",fun box(): String {
"*/

package org.jetbrains.kotlin.backend.konan.driver.phases

import org.jetbrains.kotlin.backend.common.phaser.createSimpleNamedCompilerPhase
import org.jetbrains.kotlin.backend.konan.KonanConfigKeys
import org.jetbrains.kotlin.backend.konan.OutputFiles
import org.jetbrains.kotlin.backend.konan.driver.PhaseContext
import org.jetbrains.kotlin.backend.konan.driver.PhaseEngine
import org.jetbrains.kotlin.config.KotlinCompilerVersion
import org.jetbrains.kotlin.konan.library.impl.buildLibrary
import org.jetbrains.kotlin.library.KLIB_PROPERTY_HEADER
import org.jetbrains.kotlin.library.KotlinAbiVersion
import org.jetbrains.kotlin.library.KotlinLibraryVersioning
import org.jetbrains.kotlin.library.metadata.KlibMetadataVersion
import org.jetbrains.kotlin.util.removeSuffixIfPresent
import java.util.*

internal data class KlibWriterInput(
        val serializerOutput: SerializerOutput,
        val customOutputPath: String?,
        val produceHeaderKlib: Boolean
)
internal val WriteKlibPhase = createSimpleNamedCompilerPhase<PhaseContext, KlibWriterInput>(
        ""WriteKlib"", ""Write klib output"",
) { context, input ->
    val config = context.config
    val configuration = config.configuration
    val outputFiles = OutputFiles(input.customOutputPath
            ?: config.outputPath, config.target, config.produce)
    val nopack = configuration.getBoolean(KonanConfigKeys.NOPACK)
    val output = outputFiles.klibOutputFileName(!nopack)
    val libraryName = config.moduleId
    val shortLibraryName = config.shortModuleName
    val abiVersion = KotlinAbiVersion.CURRENT
    val compilerVersion = KotlinCompilerVersion.getVersion().toString()
    val libraryVersion = configuration.get(KonanConfigKeys.LIBRARY_VERSION)
    val metadataVersion = KlibMetadataVersion.INSTANCE.toString()
    val versions = KotlinLibraryVersioning(
            abiVersion = abiVersion,
            libraryVersion = libraryVersion,
            compilerVersion = compilerVersion,
            metadataVersion = metadataVersion,
    )
    val target = config.target
    val manifestProperties = config.manifestProperties ?: Properties()

    if (input.produceHeaderKlib) {
        manifestProperties.setProperty(KLIB_PROPERTY_HEADER, ""true"")
    }
    val nativeTargetsForManifest = config.nativeTargetsForManifest?.map { it.visibleName } ?: listOf(target.visibleName)

    if (!nopack) {
        val suffix = outputFiles.produce.suffix(target)
        if (!output.endsWith(suffix)) {
            error(""please specify correct output: packed: ${!nopack}, $output$suffix"")
        }
    }

    /*
    metadata libraries do not have 'link' dependencies, as there are several reasons
    why a consumer might not be able to provide the same compile classpath as the producer
    (e.g. commonized cinterops, host vs client environment differences).
    */
    val linkDependencies = if (context.config.metadataKlib) emptyList()",else input.serializerOutput.neededLibraries
"@kotlin.SinceKotlin(version = ""1.4"")
public infix fun kotlin.LongArray?.contentEquals(other: kotlin.LongArray?): kotlin.Boolean

@kotlin.SinceKotlin(version = ""1.4"")
public infix fun kotlin.ShortArray?.contentEquals(other: kotlin.ShortArray?): kotlin.Boolean

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.ExperimentalUnsignedTypes
public infix fun kotlin.UByteArray?.contentEquals(other: kotlin.UByteArray?): kotlin.Boolean

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.ExperimentalUnsignedTypes
public infix fun kotlin.UIntArray?.contentEquals(other: kotlin.UIntArray?): kotlin.Boolean

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.ExperimentalUnsignedTypes
public infix fun kotlin.ULongArray?.contentEquals(other: kotlin.ULongArray?): kotlin.Boolean

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.ExperimentalUnsignedTypes
public infix fun kotlin.UShortArray?.contentEquals(other: kotlin.UShortArray?): kotlin.Boolean

@kotlin.SinceKotlin(version = ""1.4"")
public fun <T> kotlin.Array<out T>?.contentHashCode(): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
public fun kotlin.BooleanArray?.contentHashCode(): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
public fun kotlin.ByteArray?.contentHashCode(): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
public fun kotlin.CharArray?.contentHashCode(): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
public fun kotlin.DoubleArray?.contentHashCode(): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
public fun kotlin.FloatArray?.contentHashCode(): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
public fun kotlin.IntArray?.contentHashCode(): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
public fun kotlin.LongArray?.contentHashCode(): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
public fun kotlin.ShortArray?.contentHashCode(): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UByteArray?.contentHashCode(): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UIntArray?.contentHashCode(): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.ULongArray?.contentHashCode(): kotlin.Int

@kotlin.SinceKotlin(version = ""1.4"")
@kotlin.ExperimentalUnsignedTypes
public fun kotlin.UShortArray?.contentHashCode(): kotlin.Int","@kotlin.SinceKotlin(version = ""1.4"")"
"// EXPECTED_REACHABLE_NODES: 1284
package foo

fun box(): String {
    var l1: Long = 0x12344478935690
    var l2: Long = 0x12344478935698",var diff: Long = l2 - l1
"// WITH_STDLIB
// WORKS_WHEN_VALUE_CLASS
// IGNORE_BACKEND: JS_IR, JS_IR_ES6
// LANGUAGE: +ValueClasses, +GenericInlineClassParameter

OPTIONAL_JVM_INLINE_ANNOTATION
value class A<T>(val x: T)

fun <T> isNotNullVacuousLeft(s: A<T>) = s != null
fun <T> isNotNullVacuousRight(s: A<T>) = null != s
fun <T> isNotNullLeft(s: A<T>?) = s != null
fun <T> isNotNullRight(s: A<T>?) = null != s
fun <T> isNotEqualSame(s: A<T>, t: A<T>) = s != t
fun <T> isNotEqualAnyLeft(s: A<T>, t: Any?) = s != t
fun <T> isNotEqualAnyRight(s: Any?, t: A<T>) = s != t
fun <T> isNotEqualSameNullable(s: A<T>?, t: A<T>?) = s != t
fun <T> isNotEqualAnyNullableLeft(s: A<T>?, t: Any?) = s != t
fun <T> isNotEqualAnyNullableRight(s: Any?, t: A<T>?) = s != t
fun <T> isNotEqualNullableUnboxedLeft(s: A<T>, t: A<T>?) = s != t
fun <T> isNotEqualNullableUnboxedRight(s: A<T>?, t: A<T>) = s != t

fun box(): String {
    if (!isNotNullVacuousLeft(A(0))) return ""Fail 1""
    if (!isNotNullVacuousRight(A(0))) return ""Fail 2""
    if (!isNotNullLeft(A(0))) return ""Fail 3""
    if (!isNotNullRight(A(0))) return ""Fail 4""
    if (isNotNullLeft<Any?>(null)) return ""Fail 5""
    if (isNotNullRight<Any?>(null)) return ""Fail 6""
    if (isNotEqualSame(A(0), A(0))) return ""Fail 7""
    if (!isNotEqualSame(A(0), A(1))) return ""Fail 8""
    if (!isNotEqualAnyLeft(A(0), 0)) return ""Fail 9""
    if (!isNotEqualAnyLeft(A(0), null)) return ""Fail 10""
    if (isNotEqualAnyLeft(A(0), A(0))) return ""Fail 11""
    if (!isNotEqualAnyRight(0, A(0))) return ""Fail 12""
    if (!isNotEqualAnyRight(null, A(0))) return ""Fail 13""
    if (isNotEqualAnyRight(A(0), A(0))) return ""Fail 14""
    if (isNotEqualSameNullable<Any?>(null, null)) return ""Fail 15""
    if (isNotEqualSameNullable(A(0), A(0))) return ""Fail 16""
    if (!isNotEqualSameNullable(null, A(0))) return ""Fail 17""
    if (!isNotEqualSameNullable(A(0), null)) return ""Fail 18""
    if (!isNotEqualSameNullable(A(0), A(1))) return ""Fail 19""
    if (isNotEqualAnyNullableLeft<Any?>(null, null)) return ""Fail 20""
    if (isNotEqualAnyNullableLeft(A(0), A(0))) return ""Fail 21""
    if (!isNotEqualAnyNullableLeft(A(0), 0)) return ""Fail 22""
    if (!isNotEqualAnyNullableLeft<Any?>(null, 0)) return ""Fail 23""
    if (!isNotEqualAnyNullableLeft(A(0), null)) return ""Fail 24""
    if (!isNotEqualAnyNullableLeft(A(0), A(1))) return ""Fail 25""
    if (isNotEqualAnyNullableRight<Any?>(null, null)) return ""Fail 26""
    if (isNotEqualAnyNullableRight(A(0), A(0))) return ""Fail 27""
    if (!isNotEqualAnyNullableRight(0, A(0))) return ""Fail 28""
    if (!isNotEqualAnyNullableRight<Any?>(0, null)) return ""Fail 29""
    if (!isNotEqualAnyNullableRight(null, A(0))) return ""Fail 30""
    if (!isNotEqualAnyNullableRight(A(0), A(1))) return ""Fail 31""

    if (!isNotNullVacuousLeft(A(null))) return ""Fail 32""
    if (!isNotNullVacuousRight(A(null))) return ""Fail 33""
    if (!isNotNullLeft(A(null))) return ""Fail 34""
    if (!isNotNullRight(A(null))) return ""Fail 35""
    if (!isNotEqualAnyLeft(A(null), null)) return ""Fail 36""
    if (!isNotEqualAnyRight(null, A(null))) return ""Fail 37""
    if (!isNotEqualAnyNullableLeft(A(null), null)) return ""Fail 38""
    if (!isNotEqualAnyNullableRight(null, A(null))) return ""Fail 39""
    if (!isNotEqualSameNullable(A(null), null)) return ""Fail 42""","if (!isNotEqualSameNullable(null, A(null))) return ""Fail 43"""
"// FIR_IDENTICAL
// MODULE: m1-common
// FILE: common.kt
expect class E {
    fun f(x: Int): Int
}

expect class E2 {
    fun f(x: Int): Int
}

// MODULE: m2-jvm()()(m1-common)
// FILE: jvm.kt
interface I {
    fun f(x: Int = 5): Int = x
}

actual class <!NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS!>E<!>(i: I) : I by i",actual class E2(i: I) : I by i {
"@Test
    fun `test - readWriteProperty - notNull`() {
        val subject = Subject()
        assertEquals(3, subject.notNullReadWriteA)
        assertEquals(4, subject.notNullReadWriteB)

        subject.notNullReadWriteA = -1
        assertEquals(-1, subject.notNullReadWriteA)
        assertEquals(4, subject.notNullReadWriteB)

        subject.notNullReadWriteB = -2
        assertEquals(-1, subject.notNullReadWriteA)
        assertEquals(-2, subject.notNullReadWriteB)
    }

    @Test
    fun `test - factoryProperty`() {
        run {
            val subject = Subject()
            assertNotNull(subject.factoryList)
            assertSame(subject.factoryList, subject.factoryList)
            assertSame(subject.extras[keyList], subject.factoryList)
        }

        run {
            val subject = Subject()
            val list = mutableListOf(Dummy())
            subject.extras[keyList] = list
            assertSame(list, subject.factoryList)
        }
    }


    @Test
    fun `test - lazyProperty`() {
        run {
            val subject = Subject()
            assertNotNull(subject.lazyList)
            assertSame(subject.lazyList, subject.lazyList)
            assertSame(subject.extras[keySubjectList], subject.lazyList)
            assertSame(subject, subject.lazyList.firstOrNull())

            val subject2 = Subject()
            assertSame(subject2, subject2.lazyList.firstOrNull())
            assertNotSame(subject.lazyList.firstOrNull(), subject2.lazyList.firstOrNull())
        }

        run {
            val subject = Subject()
            val list = mutableListOf<Subject>()
            subject.extras[keySubjectList] = list
            assertSame(list, subject.lazyList)
        }
    }

    @Test
    fun `test - lazyNullableProperty`() {
        val subject1 = Subject()
        val subject2 = Subject()

        assertNull(subject1.lazyNullString)
        assertNull(subject1.lazyNullString)
        assertEquals(listOf(subject1), lazyNullStringInvocations)

        assertNull(subject2.lazyNullString)",assertNull(subject2.lazyNullString)
"open fun visitSplitPostponedLambdasNode(node: SplitPostponedLambdasNode, data: D): R {
        return visitNode(node, data)
    }

    open fun visitPostponedLambdaExitNode(node: PostponedLambdaExitNode, data: D): R {
        return visitNode(node, data)
    }

    open fun visitMergePostponedLambdaExitsNode(node: MergePostponedLambdaExitsNode, data: D): R {
        return visitNode(node, data)
    }

    open fun visitAnonymousFunctionExpressionNode(node: AnonymousFunctionExpressionNode, data: D): R {
        return visitNode(node, data)
    }

     // ----------------------------------- Files ------------------------------------------

    open fun visitFileEnterNode(node: FileEnterNode, data: D): R {
        return visitNode(node, data)
    }

    open fun visitFileExitNode(node: FileExitNode, data: D): R {
        return visitNode(node, data)
    }

    // ----------------------------------- Classes -----------------------------------

    open fun visitAnonymousObjectEnterNode(node: AnonymousObjectEnterNode, data: D): R {
        return visitNode(node, data)
    }

    open fun visitAnonymousObjectExpressionExitNode(node: AnonymousObjectExpressionExitNode, data: D): R {
        return visitNode(node, data)
    }

    open fun visitClassEnterNode(node: ClassEnterNode, data: D): R {
        return visitNode(node, data)
    }

    open fun visitClassExitNode(node: ClassExitNode, data: D): R {
        return visitNode(node, data)
    }

    open fun visitLocalClassExitNode(node: LocalClassExitNode, data: D): R {
        return visitNode(node, data)
    }

    // ----------------------------------- Scripts ------------------------------------------

    open fun visitScriptEnterNode(node: ScriptEnterNode, data: D): R {
        return visitNode(node, data)
    }

    open fun visitScriptExitNode(node: ScriptExitNode, data: D): R {
        return visitNode(node, data)
    }

    // ----------------------------------- Code Fragments ------------------------------------------

    open fun visitCodeFragmentEnterNode(node: CodeFragmentEnterNode, data: D): R {
        return visitNode(node, data)
    }

    open fun visitCodeFragmentExitNode(node: CodeFragmentExitNode, data: D): R {","return visitNode(node, data)"
"* to current accumulator value and each element with its index in the original array.
 * 
 * Returns `null` if the array is empty.
 * 
 * @param [operation] function that takes the index of an element, current accumulator value and the element itself,
 * and calculates the next accumulator value.
 * 
 * @sample samples.collections.Collections.Aggregates.reduceOrNull
 */
@SinceKotlin(""1.4"")
@ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun UByteArray.reduceIndexedOrNull(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte? {
    if (isEmpty())
        return null
    var accumulator = this[0]
    for (index in 1..lastIndex) {
        accumulator = operation(index, accumulator, this[index])
    }
    return accumulator
}

/**
 * Accumulates value starting with the first element and applying [operation] from left to right
 * to current accumulator value and each element with its index in the original array.
 * 
 * Returns `null` if the array is empty.
 * 
 * @param [operation] function that takes the index of an element, current accumulator value and the element itself,
 * and calculates the next accumulator value.
 * 
 * @sample samples.collections.Collections.Aggregates.reduceOrNull
 */
@SinceKotlin(""1.4"")
@ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun UShortArray.reduceIndexedOrNull(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort? {
    if (isEmpty())
        return null
    var accumulator = this[0]
    for (index in 1..lastIndex) {
        accumulator = operation(index, accumulator, this[index])
    }
    return accumulator
}

/**
 * Accumulates value starting with the first element and applying [operation] from left to right
 * to current accumulator value and each element.
 * 
 * Returns `null` if the array is empty.
 * 
 * @param [operation] function that takes current accumulator value and an element,
 * and calculates the next accumulator value.
 * 
 * @sample samples.collections.Collections.Aggregates.reduceOrNull
 */
@SinceKotlin(""1.4"")
@ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun UIntArray.reduceOrNull(operation: (acc: UInt, UInt) -> UInt): UInt? {
    if (isEmpty())
        return null
    var accumulator = this[0]
    for (index in 1..lastIndex) {","accumulator = operation(accumulator, this[index])"
").apply {
                    boundReceiver?.let {
                        putValueArgument(0, it)
                    }
                }
                IrCompositeImpl(startOffset, endOffset, type, origin, listOf(clazz, ctorCall))
            }
        }

        private fun buildFunctionReference(expression: IrFunctionReference): Pair<IrClass, IrConstructor> {
            val target = expression.symbol.owner
            val reflectionTarget = expression.reflectionTarget?.owner ?: target
            return CallableReferenceBuilder(target, expression, reflectionTarget).build()
        }

        private fun buildLambdaReference(function: IrSimpleFunction, expression: IrFunctionExpression): Pair<IrClass, IrConstructor> {
            return CallableReferenceBuilder(function, expression, null).build()
        }
    }

    private inner class CallableReferenceBuilder(
        private val function: IrFunction,
        private val reference: IrExpression,
        private val reflectionTarget: IrFunction?
    ) {

        private val isLambda: Boolean get() = reflectionTarget == null

        private val shouldBeCoroutineImpl = isLambda && function.isSuspend && !context.compileSuspendAsJsGenerator

        private val superClass = if (shouldBeCoroutineImpl) context.ir.symbols.coroutineImpl.owner.defaultType else context.irBuiltIns.anyType
        private var boundReceiverField: IrField? = null

        private val referenceType = reference.type as IrSimpleType

        private val superFunctionInterface: IrClass = referenceType.classOrNull?.owner
            ?: compilationException(
                ""Expected functional type"",
                reference
            )
        private val isKReference = superFunctionInterface.name.identifier[0] == 'K'

        // If we implement KFunctionN we also need FunctionN
        private val secondFunctionInterface: IrClass? = if (isKReference) {
            val arity = referenceType.arguments.size - 1
            if (function.isSuspend)
                context.ir.symbols.suspendFunctionN(arity).owner
            else
                context.ir.symbols.functionN(arity).owner
        } else null

        private fun StringBuilder.collectNamesForLambda(d: IrDeclarationWithName) {
            val parent = d.parent

            if (parent is IrPackageFragment) {
                append(d.name.asString())
                return
            }

            collectNamesForLambda(parent as IrDeclarationWithName)

            if (d is IrAnonymousInitializer) return

            fun IrDeclaration.isLambdaFun(): Boolean = origin == IrDeclarationOrigin.LOCAL_FUNCTION_FOR_LAMBDA",when {
"package org.jetbrains.kotlin.gradle.targets.native.internal

import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.attributes.Category
import org.gradle.api.attributes.Usage
import org.gradle.api.file.FileCollection
import org.jetbrains.kotlin.commonizer.CommonizerOutputFileLayout
import org.jetbrains.kotlin.commonizer.SharedCommonizerTarget
import org.jetbrains.kotlin.commonizer.identityString
import org.jetbrains.kotlin.gradle.dsl.metadataTarget
import org.jetbrains.kotlin.gradle.dsl.multiplatformExtension
import org.jetbrains.kotlin.gradle.dsl.multiplatformExtensionOrNull
import org.jetbrains.kotlin.gradle.plugin.KotlinProjectSetupCoroutine
import org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet
import org.jetbrains.kotlin.gradle.plugin.categoryByName
import org.jetbrains.kotlin.gradle.plugin.launch
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinUsages
import org.jetbrains.kotlin.gradle.plugin.mpp.internal
import org.jetbrains.kotlin.gradle.plugin.mpp.resolvableMetadataConfiguration
import org.jetbrains.kotlin.gradle.plugin.sources.internal
import org.jetbrains.kotlin.gradle.targets.metadata.awaitMetadataCompilationsCreated
import org.jetbrains.kotlin.gradle.targets.metadata.findMetadataCompilation
import org.jetbrains.kotlin.gradle.utils.*
import org.jetbrains.kotlin.gradle.utils.createConsumable
import org.jetbrains.kotlin.gradle.utils.createResolvable
import org.jetbrains.kotlin.gradle.utils.setAttribute
import org.jetbrains.kotlin.tooling.core.UnsafeApi

/* Elements configuration */

internal val CInteropCommonizedCInteropApiElementsConfigurationsSetupAction = KotlinProjectSetupCoroutine setup@{",val extension = multiplatformExtensionOrNull ?: return@setup
"override fun argFromBridged(expr: KotlinExpression, scope: KotlinScope, nativeBacked: NativeBacked) =
                ""interpretCPointer<${pointee.render(scope)}>($expr)""

        override val bridgedType: BridgedType
            get() = BridgedType.NATIVE_PTR

        override fun cFromBridged(expr: NativeExpression, scope: NativeScope, nativeBacked: NativeBacked) =
                ""(${getPointerTypeStringRepresentation(cPointee)})$expr""

        override fun constructPointedType(valueType: KotlinType) = KotlinTypes.cPointerVarOf.typeWith(valueType)
    }

    class ObjCPointerInfo(val kotlinType: KotlinType, val type: ObjCPointer) : TypeInfo() {
        override fun argToBridged(expr: String) = ""$expr.objcPtr()""

        override fun argFromBridged(expr: KotlinExpression, scope: KotlinScope, nativeBacked: NativeBacked) =
                ""interpretObjCPointerOrNull<${kotlinType.render(scope)}>($expr)"" +
                        if (type.isNullable) """" else ""!!""

        override val bridgedType: BridgedType
            get() = BridgedType.OBJC_POINTER

        override fun constructPointedType(valueType: KotlinType) = KotlinTypes.objCObjectVar.typeWith(valueType)
    }

    class ObjCBlockPointerInfo(val kotlinType: KotlinFunctionType, val type: ObjCBlockPointer) : TypeInfo() {

        override val bridgedType: BridgedType
            get() = BridgedType.OBJC_POINTER

        // When passing Kotlin function as block pointer from Kotlin to native,
        // it first gets wrapped by a holder in [argToBridged],
        // and then converted to block in [cFromBridged].

        override fun argToBridged(expr: KotlinExpression): KotlinExpression = ""createKotlinObjectHolder($expr)""

        override fun cFromBridged(
                expr: NativeExpression,
                scope: NativeScope,
                nativeBacked: NativeBacked
        ): NativeExpression {
            val mappingBridgeGenerator = scope.mappingBridgeGenerator

            val blockParameters = type.parameterTypes.mapIndexed { index, it ->
                ""p$index"" to it.getStringRepresentation()
            }.joinToString { ""${it.second} ${it.first}"" }

            val blockReturnType = type.returnType.getStringRepresentation()

            val kniFunction = ""kniFunction""

            val codeBuilder = NativeCodeBuilder(scope)

            return buildString {
                append(""({ "") // Statement expression begins.
                append(""id $kniFunction = $expr; "") // Note: it gets captured below.
                append(""($kniFunction == nil) ? nil : "")
                append(""(id)"") // Cast the block to `id`.
                append(""^$blockReturnType($blockParameters) {"") // Block begins.

                // As block body, generate the code which simply bridges to Kotlin and calls the Kotlin function:
                mappingBridgeGenerator.nativeToKotlin(
                        codeBuilder,
                        nativeBacked,","type.returnType,"
"}

private inline fun <F> createSessionsForLegacyMppProject(
    files: List<F>,
    rootModuleName: Name,
    libraryList: DependencyListForCliModule,
    targetPlatform: TargetPlatform,
    sessionProvider: FirProjectSessionProvider,
    noinline sessionConfigurator: FirSessionConfigurator.() -> Unit,
    isCommonSource: (F) -> Boolean,
    createFirSession: FirSessionProducer<F>,
): List<SessionWithSources<F>> {
    val commonModuleData = FirModuleDataImpl(
        Name.identifier(""${rootModuleName.asString()}-common""),
        libraryList.regularDependencies,
        listOf(),
        libraryList.friendsDependencies,
        targetPlatform,
        isCommon = true
    )

    val platformModuleData = FirModuleDataImpl(
        rootModuleName,
        libraryList.regularDependencies,
        listOf(commonModuleData),
        libraryList.friendsDependencies,
        targetPlatform,
        isCommon = false
    )

    val commonFiles = mutableListOf<F>()
    val platformFiles = mutableListOf<F>()
    for (file in files) {
        (if (isCommonSource(file)) commonFiles else platformFiles).add(file)
    }

    val commonSession = createFirSession(commonFiles, commonModuleData, sessionProvider, sessionConfigurator)
    val platformSession = createFirSession(platformFiles, platformModuleData, sessionProvider) {
        sessionConfigurator()
        // The CLI session might contain an opt-in for an annotation that's defined in the platform module.
        // Therefore, only run the opt-in LV checker on the platform module.
        useCheckers(OptInLanguageVersionSettingsCheckers)
    }

    return listOf(
        SessionWithSources(commonSession, commonFiles),
        SessionWithSources(platformSession, platformFiles)
    )
}

private inline fun <F> createSessionsForHmppProject(
    files: List<F>,
    rootModuleName: Name,
    hmppModuleStructure: HmppCliModuleStructure,
    libraryList: DependencyListForCliModule,
    targetPlatform: TargetPlatform,
    sessionProvider: FirProjectSessionProvider,
    noinline sessionConfigurator: FirSessionConfigurator.() -> Unit,
    fileBelongsToModule: (F, String) -> Boolean,
    createFirSession: FirSessionProducer<F>,
): List<SessionWithSources<F>> {
    val moduleDataForHmppModule = LinkedHashMap<HmppCliModule, FirModuleData>()

    for ((index, module) in hmppModuleStructure.modules.withIndex()) {
        val dependencies = hmppModuleStructure.dependenciesMap[module]",?.map { moduleDataForHmppModule.getValue(it) }
// EXPECTED_REACHABLE_NODES: 1286,package foo
"fun returned(msg: Any?)
}

private sealed class Entity(val name: String,
                    val ignored: Boolean)

private class Suite(name: String, ignored: Boolean, val body: SuiteContext.() -> Unit): Entity(name, ignored)

private class Test(name: String, ignored: Boolean, val body: TestBodyContext.() -> Unit): Entity(name, ignored)


private class SortingContext: SuiteContext {

    val structure = mutableListOf<Entity>()

    override fun suite(name: String, ignored: Boolean, body: SuiteContext.() -> Unit) {
        structure += Suite(name, ignored, body)
    }

    override fun test(name: String, ignored: Boolean, body: TestBodyContext.() -> Unit) {
        structure += Test(name, ignored, body)
    }

    fun <T: SuiteContext> replayInto(context: T): T {
        structure.sortedBy { it.name }.forEach {
            when (it) {
                is Suite -> context.suite(it.name, it.ignored) {
                    val oldSorter = sortingContext

                    sortingContext = SortingContext()
                    it.body(sortingContext)
                    sortingContext.replayInto(this)

                    sortingContext = oldSorter
                }
                is Test -> context.test(it.name, it.ignored) {
                    bodyContext = this
                    it.body(this)
                    bodyContext = null
                }
            }
        }

        return context
    }
}

private class LoggingContext : SuiteContext, TestBodyContext{
    val log: String
        get() = logHead + (lastRecord ?: """")

    private var indentation = """"

    override fun suite(name: String, ignored: Boolean, body: SuiteContext.() -> Unit) = indent {
        record(""suite(\""$name\""${optionalIgnore(ignored)}) {"")
        runSafely { this.body() }
        record(""}"")
    }

    override fun test(name: String, ignored: Boolean, body: TestBodyContext.() -> Unit) = indent {
        val num = record(""test(\""$name\""${optionalIgnore(ignored)}) {"")

        runSafely { this.body() }

        if (!writtenSince(num)) {","record(""test(\""$name\""${optionalIgnore(ignored)})"", replaceLast = true)"
"// KJS_WITH_FULL_RUNTIME
// EXPECTED_REACHABLE_NODES: 1661
/*
 * Copy of JVM-backend test
 * Found at: compiler/testData/codegen/boxInline/builders/builders.1.kt
 */


// FILE: foo.kt
package foo

fun testAllInline() : String {
    val args = arrayOf(""1"", ""2"", ""3"")
    val result =
            html {
                val htmlVal = 0
                head {
                    title { +""XML encoding with Kotlin"" }
                }
                body {
                    var bodyVar = 1
                    h1 { +""XML encoding with Kotlin"" }
                    p { +""this format can be used as an alternative markup to XML"" }

                    // an element with attributes and text content
                    a(href = ""https://jetbrains.com/kotlin"") { +""Kotlin"" }

                    // mixed content
                    p {
                        +""This is some""
                        b { +""mixed"" }
                        +""text. For more see the""","a(href = ""https://jetbrains.com/kotlin"") { +""Kotlin"" }"
"// FIR_IDENTICAL
// TARGET_BACKEND: JVM

// FILE: javaWildcardType.kt
interface K {
    fun kf1(): Collection<out CharSequence>",fun kf2(): Collection<CharSequence>
"protected fun tryGetContainingDescriptor(): CallableDescriptor? =
        containingDeclaration.resolve() as? CallableDescriptor

    protected abstract fun tryGetKotlinType(): KotlinType?

    private val _parameterType: PsiType by lazyPub {
        computeParameterType(tryGetKotlinType(), tryGetContainingDescriptor())
    }

    override fun getType(): PsiType = _parameterType

    override val qualifiedNameForNullabilityAnnotation: String? by lazyPub {
        computeQualifiedNameForNullabilityAnnotation(tryGetKotlinType())
    }
}

internal class KtUltraLightParameterForSource(
    name: String,
    override val kotlinOrigin: KtParameter,
    support: KtUltraLightSupport,
    method: KtUltraLightMethod,
    containingDeclaration: KtCallableDeclaration
) : KtAbstractUltraLightParameterForDeclaration(name, kotlinOrigin, support, method, containingDeclaration) {

    override fun tryGetKotlinType(): KotlinType? = kotlinOrigin.getKotlinType()

    override fun isVarArgs(): Boolean = kotlinOrigin.isVarArg && method.parameterList.parameters.last() == this

    override fun setName(@NonNls name: String): PsiElement {
        kotlinOrigin.setName(name)
        return this
    }

    override val givenAnnotations: List<KtLightAbstractAnnotation>?
        get() {
            return if (kotlinOrigin.hasValOrVar()) {
                val entriesWithoutJvmField = kotlinOrigin.annotationEntries.filter { it.shortName?.identifier != ""JvmField"" }
                entriesWithoutJvmField.toLightAnnotations(this, null) +
                        entriesWithoutJvmField.toLightAnnotations(this, AnnotationUseSiteTarget.CONSTRUCTOR_PARAMETER)
            } else {
                kotlinOrigin.annotationEntries.toLightAnnotations(this, null)
            }
        }

    override fun getStartOffsetInParent(): Int = kotlinOrigin.startOffsetInParent
    override fun isWritable(): Boolean = kotlinOrigin.isWritable
    override fun getNavigationElement(): PsiElement = kotlinOrigin.navigationElement
    override fun getContainingFile(): PsiFile = parent.containingFile
    override fun getPresentation(): ItemPresentation? = kotlinOrigin.let { ItemPresentationProviders.getItemPresentation(it) }
    override fun findElementAt(offset: Int): PsiElement? = kotlinOrigin.findElementAt(offset)
}

internal class KtUltraLightParameterForSetterParameter(
    name: String,
    // KtProperty or KtParameter from primary constructor
    private val property: KtDeclaration,
    support: KtUltraLightSupport,
    method: KtUltraLightMethod,
    containingDeclaration: KtCallableDeclaration
) : KtAbstractUltraLightParameterForDeclaration(name, null, support, method, containingDeclaration) {

    override fun tryGetKotlinType(): KotlinType? = property.getKotlinType()

    override val givenAnnotations: List<KtLightAbstractAnnotation>?","get() = property.annotationEntries.toLightAnnotations(this, AnnotationUseSiteTarget.SETTER_PARAMETER)"
"import org.jetbrains.kotlin.name.SpecialNames
import org.jetbrains.kotlin.resolve.calls.inference.model.*
import org.jetbrains.kotlin.resolve.calls.tower.ApplicabilityDetail
import org.jetbrains.kotlin.resolve.calls.tower.CandidateApplicability
import org.jetbrains.kotlin.resolve.calls.tower.isSuccess
import org.jetbrains.kotlin.types.EmptyIntersectionTypeKind
import org.jetbrains.kotlin.utils.addIfNotNull
import org.jetbrains.kotlin.utils.addToStdlib.firstIsInstanceOrNull
import org.jetbrains.kotlin.utils.addToStdlib.runIf
import org.jetbrains.kotlin.utils.addToStdlib.shouldNotBeCalled

private fun ConeDiagnostic.toKtDiagnostic(
    source: KtSourceElement?,
    callOrAssignmentSource: KtSourceElement?
): KtDiagnostic? = when (this) {
    is ConeUnresolvedReferenceError -> FirErrors.UNRESOLVED_REFERENCE.createOn(
        source,
        this.name.asString(),
        null,
    )

    is ConeUnresolvedSymbolError -> FirErrors.UNRESOLVED_REFERENCE.createOn(source, this.classId.asString(), null)
    is ConeUnresolvedNameError -> FirErrors.UNRESOLVED_REFERENCE.createOn(source, name.asString(), operatorToken)
    is ConeUnresolvedTypeQualifierError -> {
        when {
            // this.qualifiers will contain all resolved qualifiers from the left up to (including) the first unresolved qualifier.
            // We want to report UNRESOLVED_REFERENCE exactly on the first unresolved qualifier with its name as argument.
            // Examples: <!UNRESOLVED_REFERENCE!>Unresolved<!>, <!UNRESOLVED_REFERENCE!>Unresolved<!>.Foo,
            // Resolved.<!UNRESOLVED_REFERENCE!>Unresolved<!>, Resolved.<!UNRESOLVED_REFERENCE!>Unresolved<!>.Foo
            source?.kind == KtRealSourceElementKind -> {
                val lastQualifier = this.qualifiers.last()
                FirErrors.UNRESOLVED_REFERENCE.createOn(lastQualifier.source, lastQualifier.name.asString(), null)
            }
            else -> {
                FirErrors.UNRESOLVED_REFERENCE.createOn(source, this.qualifier, null)
            }
        }
    }
    is ConeFunctionCallExpectedError -> FirErrors.FUNCTION_CALL_EXPECTED.createOn(source, this.name.asString(), this.hasValueParameters)
    is ConeFunctionExpectedError -> FirErrors.FUNCTION_EXPECTED.createOn(source, this.expression, this.type)
    is ConeNoConstructorError -> FirErrors.NO_CONSTRUCTOR.createOn(callOrAssignmentSource ?: source)
    is ConeResolutionToClassifierError -> when (this.candidateSymbol.classKind) {
        ClassKind.INTERFACE -> FirErrors.INTERFACE_AS_FUNCTION.createOn(source, this.candidateSymbol)
        ClassKind.CLASS -> when {
            this.candidateSymbol.isInner -> FirErrors.INNER_CLASS_CONSTRUCTOR_NO_RECEIVER.createOn(source, this.candidateSymbol)
            this.candidateSymbol.isExpect -> FirErrors.EXPECT_CLASS_AS_FUNCTION.createOn(source, this.candidateSymbol)
            else -> FirErrors.RESOLUTION_TO_CLASSIFIER.createOn(source, this.candidateSymbol)
        }
        else -> FirErrors.RESOLUTION_TO_CLASSIFIER.createOn(source, this.candidateSymbol)
    }
    is ConeHiddenCandidateError -> {
        // Usages of callables with @Deprecated(DeprecationLevel.HIDDEN) should look like unresolved references.
        // See: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-deprecated/
        FirErrors.UNRESOLVED_REFERENCE.createOn(
            source,
            ((this.candidateSymbol as? FirCallableSymbol)?.name ?: SpecialNames.NO_NAME_PROVIDED).asString(),
            null,
        )
    }

    is ConeTypeVisibilityError -> symbol.toInvisibleReferenceDiagnostic(smallestUnresolvablePrefix.last().source)
    is ConeSetterVisibilityError -> FirErrors.INVISIBLE_SETTER.createOn(
        source,
        symbol,
        symbol.setterSymbol?.visibility ?: symbol.visibility,",symbol.callableId
"result += compatibilityForClassesRegister(PRIVATE_KEYWORD, OPEN_KEYWORD)
    result += compatibilityForClassesRegister(PRIVATE_KEYWORD, ABSTRACT_KEYWORD)

    result += incompatibilityRegister(CROSSINLINE_KEYWORD, NOINLINE_KEYWORD)

    // 1. subclasses contained inside a sealed class can not be instantiated, because their constructors needs
    // an instance of an outer sealed (effectively abstract) class
    // 2. subclasses of a non-top-level sealed class must be declared inside the class
    // (see the KEEP https://github.com/Kotlin/KEEP/blob/master/proposals/sealed-class-inheritance.md)
    result += incompatibilityRegister(SEALED_KEYWORD, INNER_KEYWORD)

    // header / expect / impl / actual are all incompatible
    result += incompatibilityRegister(HEADER_KEYWORD, EXPECT_KEYWORD, IMPL_KEYWORD, ACTUAL_KEYWORD)

    return result
}

private fun incompatibilityRegister(vararg list: KtKeywordToken): Map<Pair<KtKeywordToken, KtKeywordToken>, Compatibility> {
    return compatibilityRegister(Compatibility.INCOMPATIBLE, *list)
}

private fun redundantRegister(
    sufficient: KtKeywordToken,
    redundant: KtKeywordToken
): Map<Pair<KtKeywordToken, KtKeywordToken>, Compatibility> {
    return mapOf(
        Pair(sufficient, redundant) to Compatibility.REDUNDANT,
        Pair(redundant, sufficient) to Compatibility.REVERSE_REDUNDANT
    )
}

private fun compatibilityForClassesRegister(vararg list: KtKeywordToken) =
    compatibilityRegister(Compatibility.COMPATIBLE_FOR_CLASSES_ONLY, *list)

private fun compatibilityRegister(
    compatibility: Compatibility, vararg list: KtKeywordToken
): Map<Pair<KtKeywordToken, KtKeywordToken>, Compatibility> {
    val result = hashMapOf<Pair<KtKeywordToken, KtKeywordToken>, Compatibility>()
    for (first in list) {
        for (second in list) {
            if (first != second) {
                result[Pair(first, second)] = compatibility
            }
        }
    }
    return result
}

val featureDependencies = mapOf(
    SUSPEND_KEYWORD to listOf(LanguageFeature.Coroutines),
    INLINE_KEYWORD to listOf(LanguageFeature.InlineProperties, LanguageFeature.InlineClasses),
    HEADER_KEYWORD to listOf(LanguageFeature.MultiPlatformProjects),
    IMPL_KEYWORD to listOf(LanguageFeature.MultiPlatformProjects),
    EXPECT_KEYWORD to listOf(LanguageFeature.MultiPlatformProjects),
    ACTUAL_KEYWORD to listOf(LanguageFeature.MultiPlatformProjects),
    LATEINIT_KEYWORD to listOf(LanguageFeature.LateinitTopLevelProperties, LanguageFeature.LateinitLocalVariables),
    FUN_KEYWORD to listOf(LanguageFeature.FunctionalInterfaceConversion),
    DATA_KEYWORD to listOf(LanguageFeature.DataObjects)
)

val featureDependenciesTargets = mapOf(
    LanguageFeature.InlineProperties to setOf(KotlinTarget.PROPERTY, KotlinTarget.PROPERTY_GETTER, KotlinTarget.PROPERTY_SETTER),
    LanguageFeature.LateinitLocalVariables to setOf(KotlinTarget.LOCAL_VARIABLE),
    LanguageFeature.LateinitTopLevelProperties to setOf(KotlinTarget.TOP_LEVEL_PROPERTY),
    LanguageFeature.InlineClasses to setOf(KotlinTarget.CLASS_ONLY),","LanguageFeature.JvmInlineValueClasses to setOf(KotlinTarget.CLASS_ONLY),"
"interface Intf {
  fun v(): Int
}
interface IntfWithProp : Intf {
  val x: Int
}
abstract class Base(p: Int) {
    open protected fun v(): Int? { }
    fun nv() { }
    abstract fun abs(): Int

    internal open val x: Int get() { }
    open var y = 1
    open protected var z = 1
}
class Derived(p: Int) : Base(p), IntfWithProp {
    override fun v() = unknown()
    override val x = 3",override fun abs() = 0
"// ISSUE: KT-56949

// IGNORE_LIGHT_ANALYSIS
// IGNORE_BACKEND: ANY
// REASON: red code (see corresponding diagnostic test)

fun box(): String {
    build {
        setTypeVariable(TargetType())
        consumeDifferentTypeSubtype(getTypeVariable())
    }","return ""OK"""
"val callableName = function.nameAsSafeName
        val callableId = CallableId(c.packageFqName, c.relativeClassName, callableName)
        val symbol = existingSymbol ?: FirNamedFunctionSymbol(callableId)
        val local = c.childContext(function, containingDeclarationSymbol = symbol)

        val simpleFunction = buildSimpleFunction {
            moduleData = c.moduleData
            origin = initialOrigin
            source = KtRealPsiSourceElement(function)
            returnTypeRef = function.typeReference?.toTypeRef(local) ?: session.builtinTypes.unitType
            receiverParameter = function.receiverTypeReference?.toTypeRef(local)?.let { receiverType ->
                buildReceiverParameter {
                    typeRef = receiverType
                    annotations += receiverAnnotations
                }
            }

            name = callableName
            val visibility = function.visibility
            status = FirResolvedDeclarationStatusImpl(
                visibility,
                function.modality,
                visibility.toEffectiveVisibility(classSymbol)
            ).apply {
                isExpect = function.hasExpectModifier()
                isActual = false
                isOverride = false
                isOperator = function.hasModifier(KtTokens.OPERATOR_KEYWORD)
                isInfix = function.hasModifier(KtTokens.INFIX_KEYWORD)
                isInline = function.hasModifier(KtTokens.INLINE_KEYWORD)
                isTailRec = function.hasModifier(KtTokens.TAILREC_KEYWORD)
                isExternal = function.hasModifier(KtTokens.EXTERNAL_KEYWORD)
                isSuspend = function.hasModifier(KtTokens.SUSPEND_KEYWORD)
            }
            this.symbol = symbol
            dispatchReceiverType = c.dispatchReceiver
            resolvePhase = FirResolvePhase.ANALYZED_DEPENDENCIES
            typeParameters += local.typeDeserializer.ownTypeParameters.map { it.fir }
            valueParameters += local.memberDeserializer.valueParameters(
                function.valueParameters,
                symbol
            )
            annotations +=
                c.annotationDeserializer.loadAnnotations(function)
            deprecationsProvider = annotations.getDeprecationsProviderFromAnnotations(c.session, fromJava = false)
            this.containerSource = c.containerSource

            function.contextReceivers.mapNotNull { it.typeReference() }.mapTo(contextReceivers, ::loadContextReceiver)
        }.apply {
            setLazyPublishedVisibility(c.session)
        }
        if (function.mayHaveContract()) {
            val resolvedDescription = StubBasedFirContractDeserializer(simpleFunction, local.typeDeserializer).loadContract(function)
            if (resolvedDescription != null) {
                simpleFunction.replaceContractDescription(resolvedDescription)
            }
        }
        return simpleFunction
    }

    fun loadConstructor(
        constructor: KtConstructor<*>,
        classOrObject: KtClassOrObject,
        classBuilder: FirRegularClassBuilder",): FirConstructor {
"is NameNotFound -> FirErrors.NAMED_PARAMETER_NOT_FOUND.createOn(
                rootCause.argument.source ?: source,
                rootCause.argument.name.asString()
            )

            is NameForAmbiguousParameter -> FirErrors.NAME_FOR_AMBIGUOUS_PARAMETER.createOn(
                rootCause.argument.source ?: source
            )

            is UnsafeCall -> mapUnsafeCallError(diagnostic.candidate, rootCause, source, qualifiedAccessSource)
            is ManyLambdaExpressionArguments -> FirErrors.MANY_LAMBDA_EXPRESSION_ARGUMENTS.createOn(rootCause.argument.source ?: source)
            is InfixCallOfNonInfixFunction -> FirErrors.INFIX_MODIFIER_REQUIRED.createOn(source, rootCause.function)
            is OperatorCallOfNonOperatorFunction ->
                FirErrors.OPERATOR_MODIFIER_REQUIRED.createOn(source, rootCause.function, rootCause.function.name.asString())

            is OperatorCallOfConstructor -> FirErrors.OPERATOR_CALL_ON_CONSTRUCTOR.createOn(source, rootCause.constructor.name.asString())
            is UnstableSmartCast -> rootCause.mapUnstableSmartCast()

            is DslScopeViolation -> FirErrors.DSL_SCOPE_VIOLATION.createOn(source, rootCause.calleeSymbol)
            is InferenceError -> {
                rootCause.constraintError.toDiagnostic(
                    source,
                    qualifiedAccessSource,
                    session.typeContext,
                    diagnostic.candidate
                )
            }

            is InferredEmptyIntersectionDiagnostic -> reportInferredIntoEmptyIntersection(
                source,
                rootCause.typeVariable,
                rootCause.incompatibleTypes,
                rootCause.causingTypes,
                rootCause.kind,
                isError = rootCause.isError
            )

            is AdaptedCallableReferenceIsUsedWithReflection -> FirErrors.ADAPTED_CALLABLE_REFERENCE_AGAINST_REFLECTION_TYPE.createOn(
                qualifiedAccessSource
            )

            // Reported later
            is TypeParameterAsExpression -> null

            is AmbiguousInterceptedSymbol -> FirErrors.PLUGIN_AMBIGUOUS_INTERCEPTED_SYMBOL.createOn(source, rootCause.pluginNames)

            is MissingInnerClassConstructorReceiver -> FirErrors.INNER_CLASS_CONSTRUCTOR_NO_RECEIVER.createOn(
                qualifiedAccessSource ?: source,
                rootCause.candidateSymbol
            )

            else -> genericDiagnostic
        }
    }.distinct()
    return if (diagnostics.size > 1) {
        // If there are more specific diagnostics, filter out the generic diagnostic.
        diagnostics.filter { it != genericDiagnostic }
    } else {
        diagnostics
    }
}

private fun UnstableSmartCast.mapUnstableSmartCast(): KtDiagnosticWithParameters4<ConeKotlinType, FirExpression, String, Boolean> {
    val factory = when {
        isImplicitInvokeReceiver -> FirErrors.SMARTCAST_IMPOSSIBLE_ON_IMPLICIT_INVOKE_RECEIVER",else -> FirErrors.SMARTCAST_IMPOSSIBLE
"@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedIterableTo"")
@kotlin.internal.InlineOnly
public inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {
    var index = 0
    for (element in this) {
        val list = transform(index++, element)
        destination.addAll(list)
    }
    return destination
}

/**
 * Appends all elements yielded from results of [transform] function being invoked on each element
 * and its index in the original array, to the given [destination].
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedIterableTo"")
@kotlin.internal.InlineOnly
public inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, Byte) -> Iterable<R>): C {
    var index = 0
    for (element in this) {
        val list = transform(index++, element)
        destination.addAll(list)
    }
    return destination
}

/**
 * Appends all elements yielded from results of [transform] function being invoked on each element
 * and its index in the original array, to the given [destination].
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedIterableTo"")
@kotlin.internal.InlineOnly
public inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, Short) -> Iterable<R>): C {
    var index = 0
    for (element in this) {
        val list = transform(index++, element)
        destination.addAll(list)
    }
    return destination
}

/**
 * Appends all elements yielded from results of [transform] function being invoked on each element
 * and its index in the original array, to the given [destination].
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""flatMapIndexedIterableTo"")
@kotlin.internal.InlineOnly
public inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C, transform: (index: Int, Int) -> Iterable<R>): C {
    var index = 0
    for (element in this) {
        val list = transform(index++, element)
        destination.addAll(list)
    }",return destination
"// TARGET_BACKEND: JVM
// WITH_STDLIB

inline fun <reified T : Any> check(expected: String) {
    val clazz = T::class.java!!
    assert (clazz.canonicalName == ""java.lang.$expected"") {
        ""clazz name: ${clazz.canonicalName}""
    }
}

fun box(): String {
    check<Boolean>(""Boolean"")
    check<Char>(""Character"")
    check<Byte>(""Byte"")","check<Short>(""Short"")"
"abandonedNumber = significand.substring(MAX_SIGNIFICANT_LENGTH)
            significand = significand.substring(0, MAX_SIGNIFICANT_LENGTH)
        }

        mantissa = significand.toLong(HEX_RADIX)

        if (exponent >= 1) {
            processNormalNumber()
        } else {
            processSubNormalNumber()
        }

    }

    private fun setInfinite() {
        exponent = MAX_EXPONENT
        mantissa = 0
    }

    private fun setZero() {
        exponent = 0
        mantissa = 0
    }

    private fun signum(x: Long) = when {
        x == 0L -> 0
        x > 0L -> 1
        else -> -1
    }

    /*
     * Sets the exponent variable to Long.MAX_VALUE or -Long.MAX_VALUE if
     * overflow or underflow happens.
     */
    private fun checkedAddExponent(offset: Long) {
        val result = exponent + offset
        val expSign = signum(exponent)
        if (expSign * signum(offset) > 0 && expSign * signum(result) < 0) {
            exponent = expSign * Long.MAX_VALUE
        } else {
            exponent = result
        }
    }

    private fun processNormalNumber() {
        val desiredWidth = MANTISSA_WIDTH + 2
        fitMantissaInDesiredWidth(desiredWidth)
        round()
        mantissa = mantissa and MANTISSA_MASK
    }

    private fun processSubNormalNumber() {
        var desiredWidth = MANTISSA_WIDTH + 1
        desiredWidth += exponent.toInt()//lends bit from mantissa to exponent
        exponent = 0
        fitMantissaInDesiredWidth(desiredWidth)
        round()
        mantissa = mantissa and MANTISSA_MASK
    }

    /*
     * Adjusts the mantissa to desired width for further analysis.
     */
    private fun fitMantissaInDesiredWidth(desiredWidth: Int) {
        val bitLength = countBitsLength(mantissa)",if (bitLength > desiredWidth) {
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.backend.konan.objcexport

import org.jetbrains.kotlin.backend.konan.InternalKotlinNativeApi
import org.jetbrains.kotlin.tooling.core.Extras
import org.jetbrains.kotlin.tooling.core.HasExtras
import org.jetbrains.kotlin.tooling.core.emptyExtras",import org.jetbrains.kotlin.types.Variance
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.api.descriptors.symbols.psiBased.base

import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.base.KtFe10Symbol
import org.jetbrains.kotlin.analysis.api.descriptors.types.KtFe10ClassErrorType
import org.jetbrains.kotlin.analysis.api.symbols.KtSymbolOrigin
import org.jetbrains.kotlin.analysis.api.symbols.markers.KtSymbolKind
import org.jetbrains.kotlin.analysis.api.types.KtType
import org.jetbrains.kotlin.cfg.getElementParentDeclaration
import org.jetbrains.kotlin.descriptors.ClassDescriptorWithResolutionScopes
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.descriptors.Visibilities
import org.jetbrains.kotlin.descriptors.Visibility
import org.jetbrains.kotlin.lexer.KtTokens
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.psi.psiUtil.getParentOfType
import org.jetbrains.kotlin.psi.psiUtil.hasBody
import org.jetbrains.kotlin.psi.psiUtil.parentsWithSelf
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.scopes.LexicalScope
import org.jetbrains.kotlin.types.error.ErrorTypeKind
import org.jetbrains.kotlin.types.error.ErrorUtils

internal val KtDeclaration.ktVisibility: Visibility?
    get() = when {
        hasModifier(KtTokens.PUBLIC_KEYWORD) -> Visibilities.Public
        hasModifier(KtTokens.PROTECTED_KEYWORD) -> Visibilities.Protected
        hasModifier(KtTokens.PRIVATE_KEYWORD) -> Visibilities.Private
        hasModifier(KtTokens.INTERNAL_KEYWORD) -> Visibilities.Internal
        else -> null
    }

internal val KtDeclaration.ktModality: Modality?
    get() = when {
        hasModifier(KtTokens.ABSTRACT_KEYWORD) -> Modality.ABSTRACT
        hasModifier(KtTokens.FINAL_KEYWORD) -> Modality.FINAL
        hasModifier(KtTokens.SEALED_KEYWORD) -> Modality.SEALED
        hasModifier(KtTokens.OPEN_KEYWORD) -> {
            if (this is KtCallableDeclaration && !hasBody()) {
                val parentDeclaration = this.getElementParentDeclaration()
                if (parentDeclaration is KtClass && parentDeclaration.isInterface()) {
                    Modality.ABSTRACT
                } else {
                    Modality.OPEN
                }
            }
            Modality.OPEN
        }
        else -> null
    }

internal val KtElement.ktSymbolKind: KtSymbolKind
    get() {",if (this is KtPropertyAccessor) {
"}

    override fun getModality() = Modality.FINAL


    override fun setOverriddenDescriptors(overriddenDescriptors: MutableCollection<out CallableMemberDescriptor>) {
        TODO(""not implemented"")
    }

    override fun getKind() = CallableMemberDescriptor.Kind.SYNTHESIZED

    override fun getConstructedClass() = (owner.parent as IrClass).toIrBasedDescriptor()

    override fun getName() = owner.name

    override fun getOverriddenDescriptors(): MutableCollection<out FunctionDescriptor> = mutableListOf()

    override fun getInitialSignatureDescriptor(): FunctionDescriptor? = null

    override fun getVisibility() = owner.visibility

    override fun isHiddenToOvercomeSignatureClash(): Boolean {
        TODO(""not implemented"")
    }

    override fun isOperator() = false

    override fun isInline() = owner.isInline

    override fun isHiddenForResolutionEverywhereBesideSupercalls(): Boolean {
        TODO(""not implemented"")
    }

    override fun getReturnType() = owner.returnType.toIrBasedKotlinType()

    override fun isPrimary() = owner.isPrimary

    override fun isExpect() = owner.isExpect

    override fun isTailrec() = false

    override fun isActual() = false

    override fun isInfix() = false

    override fun isSuspend() = false

    override fun <V : Any?> getUserData(key: CallableDescriptor.UserDataKey<V>?): V? = null

    override fun isExternal() = owner.isExternal

    override fun newCopyBuilder(): FunctionDescriptor.CopyBuilder<out FunctionDescriptor> {
        TODO(""not implemented"")
    }

    override fun <R, D> accept(visitor: DeclarationDescriptorVisitor<R, D>?, data: D): R =
        visitor!!.visitConstructorDescriptor(this, data)

    override fun acceptVoid(visitor: DeclarationDescriptorVisitor<Void, Void>?) {
        visitor!!.visitConstructorDescriptor(this, null)
    }
}

fun IrConstructor.toIrBasedDescriptor() = IrBasedClassConstructorDescriptor(this)",fun IrFunction.toIrBasedDescriptor(): FunctionDescriptor =
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package kotlin.time

import kotlin.js.json
import kotlin.math.*",internal actual inline val durationAssertionsEnabled: Boolean get() = true
"// SKIP_KT_DUMP
// TARGET_BACKEND: JVM
// FULL_JDK
// WITH_STDLIB

// MODULE: separate
// FILE: Java2.java
import java.util.*

public class Java2<T> {
    public List<T> a = new ArrayList();
    public Queue<T> b = new ArrayDeque();
    public Set<T> c = new HashSet();

    public void foo(List<T> a) {};
    public List<T> bar() { return a; };

    public void foo2(Queue<T> b) {};
    public Queue<T> bar2() { return b; };

    public void foo3(Set<T> c) {};
    public Set<T> bar3() { return c; };
}

// MODULE: main
// FILE: J1.java
import java.util.*;

public class Java1<T> {
    public List<T> a = new ArrayList();",public Queue<T> b = new ArrayDeque();
"private fun Context.findTypeVariableForFixation(
        allTypeVariables: List<TypeConstructorMarker>,
        postponedArguments: List<PostponedResolvedAtomMarker>,
        completionMode: ConstraintSystemCompletionMode,
        topLevelType: KotlinTypeMarker,
    ): VariableForFixation? {
        if (allTypeVariables.isEmpty()) return null

        val dependencyProvider = TypeVariableDependencyInformationProvider(
            notFixedTypeVariables, postponedArguments, topLevelType.takeIf { completionMode == PARTIAL }, this,
        )

        val candidate =
            allTypeVariables.maxByOrNull { getTypeVariableReadiness(it, dependencyProvider) } ?: return null

        return when (getTypeVariableReadiness(candidate, dependencyProvider)) {
            TypeVariableFixationReadiness.FORBIDDEN -> null
            TypeVariableFixationReadiness.WITHOUT_PROPER_ARGUMENT_CONSTRAINT -> VariableForFixation(candidate, false)
            TypeVariableFixationReadiness.OUTER_TYPE_VARIABLE_DEPENDENCY ->
                VariableForFixation(candidate, hasProperConstraint = true, hasDependencyOnOuterTypeVariable = true)

            else -> VariableForFixation(candidate, true)
        }
    }

    private fun Context.hasDependencyToOtherTypeVariables(typeVariable: TypeConstructorMarker): Boolean {
        for (constraint in notFixedTypeVariables[typeVariable]?.constraints ?: return false) {
            val dependencyPresenceCondition = { type: KotlinTypeMarker ->
                type.typeConstructor() != typeVariable && notFixedTypeVariables.containsKey(type.typeConstructor())
            }
            if (constraint.type.lowerBoundIfFlexible().argumentsCount() != 0 && constraint.type.contains(dependencyPresenceCondition))
                return true
        }
        return false
    }

    private fun Context.variableHasProperArgumentConstraints(variable: TypeConstructorMarker): Boolean {
        val constraints = notFixedTypeVariables[variable]?.constraints ?: return false
        // temporary hack to fail calls which contain callable references resolved though OI with uninferred type parameters
        val areThereConstraintsWithUninferredTypeParameter = constraints.any { c -> c.type.contains { it.isUninferredParameter() } }
        return constraints.any { isProperArgumentConstraint(it) } && !areThereConstraintsWithUninferredTypeParameter
    }

    private fun Context.isProperArgumentConstraint(c: Constraint) =
        isProperType(c.type)
                && c.position.initialConstraint.position !is DeclaredUpperBoundConstraintPosition<*>
                && !c.isNullabilityConstraint

    private fun Context.isProperType(type: KotlinTypeMarker): Boolean =
        isProperTypeForFixation(type, notFixedTypeVariables.keys) { t -> !t.contains { isNotFixedRelevantVariable(it) } }

    private fun Context.isNotFixedRelevantVariable(it: KotlinTypeMarker): Boolean {
        val key = it.typeConstructor()
        if (!notFixedTypeVariables.containsKey(key)) return false
        if (typeVariablesThatAreCountedAsProperTypes?.contains(key) == true) return false
        return true
    }

    private fun Context.isReified(variable: TypeConstructorMarker): Boolean =
        notFixedTypeVariables[variable]?.typeVariable?.let { isReified(it) } ?: false

    private fun Context.variableHasLowerNonNothingProperConstraint(variable: TypeConstructorMarker): Boolean {
        val constraints = notFixedTypeVariables[variable]?.constraints ?: return false

        return constraints.any {",it.kind.isLower() && isProperArgumentConstraint(it) && !it.type.typeConstructor().isNothingConstructor()
")
)

private val enumUsageLoweringPhase = makeIrModulePhase(
    ::EnumUsageLowering,
    name = ""EnumUsageLowering"",
    description = ""Replace enum access with invocation of corresponding function"",
    prerequisite = setOf(enumEntryCreateGetInstancesFunsLoweringPhase)
)

private val enumEntryRemovalLoweringPhase = makeIrModulePhase(
    ::EnumClassRemoveEntriesLowering,
    name = ""EnumEntryRemovalLowering"",
    description = ""Replace enum entry with corresponding class"",
    prerequisite = setOf(enumUsageLoweringPhase)
)


private val propertyReferenceLowering = makeIrModulePhase(
    ::WasmPropertyReferenceLowering,
    name = ""WasmPropertyReferenceLowering"",
    description = ""Lower property references""
)

private val callableReferencePhase = makeIrModulePhase(
    ::CallableReferenceLowering,
    name = ""WasmCallableReferenceLowering"",
    description = ""Handle callable references""
)

private val singleAbstractMethodPhase = makeIrModulePhase(
    ::JsSingleAbstractMethodLowering,
    name = ""SingleAbstractMethod"",
    description = ""Replace SAM conversions with instances of interface-implementing classes""
)

private val localDelegatedPropertiesLoweringPhase = makeIrModulePhase<WasmBackendContext>(
    { LocalDelegatedPropertiesLowering() },
    name = ""LocalDelegatedPropertiesLowering"",
    description = ""Transform Local Delegated properties""
)

private val localDeclarationsLoweringPhase = makeIrModulePhase(
    ::LocalDeclarationsLowering,
    name = ""LocalDeclarationsLowering"",
    description = ""Move local declarations into nearest declaration container"",
    prerequisite = setOf(sharedVariablesLoweringPhase, localDelegatedPropertiesLoweringPhase)
)

private val localClassExtractionPhase = makeIrModulePhase(
    ::LocalClassPopupLowering,
    name = ""LocalClassExtractionPhase"",
    description = ""Move local declarations into nearest declaration container"",
    prerequisite = setOf(localDeclarationsLoweringPhase)
)

private val staticCallableReferenceLoweringPhase = makeIrModulePhase(
    ::WasmStaticCallableReferenceLowering,
    name = ""WasmStaticCallableReferenceLowering"",
    description = ""Turn static callable references into singletons"",
    prerequisite = setOf(callableReferencePhase, localClassExtractionPhase)
)

private val innerClassesLoweringPhase = makeIrModulePhase<WasmBackendContext>(
    ::InnerClassesLowering,","name = ""InnerClassesLowering"","
"""670,725,987,528,80,48,11,18,541,821,994,183,174,109,729,308,703,704,835,702,850,431,346,457,338,483,8,814,39,307,635,590,4,577,329,895,758,812,643,282,200,140,306,257,375,190,889,325,830,827,928,846,644,982,652,76,787,582,852,120,899,801,990,34,83,237,231,258,791,250,606,36,97,267,895,944,978,880,811,605,445,566,346,477,456,923,886,822,562,336,350,117,145,409,561,23,958,955,463,272,943,836,653,157,216,427,986,806,518,852,261,591,101,106,691,851,959,348,192,579,199,546,666,989,502,200,618,268,292,180,821,886,257,737,127,679,3,435,800,301,753,711,614,153,634,536,292,788,793,450,799,603,965,428,776,600,488,345,784,532,934,5,665,994,779,346,804,402,295,562,149,670,917,417,967,198,768,300,623,904,517,138,242,660,475,285,339,763,879,605,704,303,175,953,16,744,542,69,156,354,412,754,784,402,930,116,650,600,702,29,563,42,778,752,909,19,390,52,120,308,511,26,806,346,852,236,25,720,72,888,904,88,642,326,199,528,300,486,824,240,61,903,147,151,951,600,841,770,746,884,699,819,519,57,588,472,373,902,452,447,858,246,384,987,652,654,965,221,632,747,678,834,998,199,324,919,359,973,466,345,416,81,375,247,883,942,346,909,508,31,563,408,94,927,10,962,656,818,680,239,597,177,216,747,397,570,496,737,393,110,457,382,125,940,118,636,470,991,299,664,630,617,251,593,697,687,576,899,877,598,470,73,882,266,288,769,901,711,343,342,119,198,652,619,222,473,224,873,794,628,705,725,282,192,88,331,80,461,26,469,284,504,185,25,155,402,427,737,282,438,602,333,956,83,667,406,90,370,690,886,25,308,603,34,244,212,327,279,109,208,789,43,455,562,441,415,473,315,973,639,773,553,214,878,421,170,871,856,224,591,416,320,42,752,944,718,592,932,3,934,199,879,338,83,466,730,304,75,875,918,279,455,676,429,4,493,833,636,521,514,794,273,66,799,250,896,810,327,475,793,128,88,286,209,51,136,30,203,251,209,965,189,880,976,702,258,948,464,423,433,527,218,401,797,427,128,69,858,338,259,433,822,377,197,841,904,832,454,810,494,831,293,199,962,235,204,431,914,36,663,22,718,245,402,79,309,254,62,375,465,707,925,492,715,252,8,188,426,200,357,571,931,846,636,975,204,731,711,161,431,14,957,426,8,573,505,667,96,35,205,86,534,247,218,197,226,539,686,545,206,358,31,442,439,843,829,629,841,480,271,110,831,728,211,692,995,703,427,194,466,225,409,533,399,931,664,981,978,893,640,947,586,976,664,848,624,91,400,535,273,103,409,728,952,960,530,564,70,852,665,276,466,988,52,835,813,470,334,401,466,327,158,901,509,327,593,822,733,838,639,866,184,825,0,775,785,386,707,247,740,662,709,622,518,93,819,356,472,993,516,706,967,131,720,710,898,851,65,810,974,797,739,517,367,477,93,448,172,686,852,99,653,269,570,166,721,939,764,8,351,18,749,809,441,253,406,184,957,287,650,475,626,766,249,508,866,778,699,625,609,449,890,878,576,700,615,784,996,408,83,727,111,593,36,253,198,196,291,279,111,729,987,734,482,53,171,591,310,55,56,320,974,814,319,281,661,979,448,691,839,698,114,273,124,951,627,76,253,77,165,474,679,871,295,687,108,367,888,288,636,308,731,293,337,949,274,983,682,38,711,769,600,900,171,733,739,166,317,980,219,84,119,676,67,115,894,664,257,323,370,277,256,867,386,289,415,653,410,322,914,181,768,231,674,834,104,398,692,844,386,161,49,798,618,739,548,332,137,614,864,868,611,720,927,76,550,136,619,280,307,9,225,759,340,304,347,159,362,874,563,702,507,629,435,180,461,51,362,151,691,217,436,782,990,212,390,520,769,848,987,403,671,612,391,722,970,43,328,98,996,242,778,166,144,143,197,411,31,168,300,928,291,648,809,731,683,743,614,306,289,176,382,149,72,991,272,842,681,224,802,227,547,668,978,890,215,742,257,142,840,587,890,11,255,826,333,844,644,900,119,221,924,549,58,32,983,24,755,139,478,953,616,676,931,431,829,81,193,725,806,375,425,563,885,335,483,574,483,649,381,912,748,326,171,644,99,90,933,839,998,961,878,885,443,161,197,242,647,550,922,857,382,539,839,616,120,837,822,81,345,780,776,75,475,648,867,110,426,907,918,966,624,651,281,151,597,182,820,982,879,27,488,137,31,427,994,152,96,777,892"",
    ""313,758,173,531,791,903,85,750,793,211,211,481,381,919,590,67,350,344,885,357,457,503,848,678,270,416,21,551,283,936,35,822,898,934,571,104,395,65,486,893,797,422,600,846,156,16,775,353,30,866,18,306,171,633,822,658,741,881,305,658,799,571,824,673,461,822,601,14,27,190,137,376,278,145,401,590,702,881,894,825,157,959,685,397,670,690,173,721,720,157,967,63,318,572,608,46,277,218,808,140,103,238,670,900,572,191,67,881,499,460,146,503,219,769,51,590,567,656,73,496,548,932,364,347,538,21,409,304,90,325,142,67,966,282,776,951,896,367,949,98,589,323,277,685,597,755,613,902,968,569,31,555,499,626,70,240,634,920,741,613,251,457,758,902,630,692,948,626,885,35,950,492,912,783,47,204,355,739,970,335,371,771,843,923,309,294,592,631,84,198,913,290,158,364,290,511,10,426,975,894,294,906,639,284,771,691,98,242,502,403,82,219,299,631,930,349,660,479,722,124,421,282,725,899,747,296,170,506,949,94,596,870,173,212,634,268,481,979,746,378,671,788,75,959,896,238,601,824,372,711,977,806,642,444,560,450,607,787,212,642,984,737,262,202,932,875,581,743,511,398,211,626,584,726,512,932,379,96,110,792,953,609,324,538,9,546,303,993,574,902,881,380,828,682,589,621,740,728,165,159,456,156,313,109,565,306,310,352,159,541,675,940,259,357,371,348,906,699,688,273,706,777,194,842,114,661,657,576,651,747,905,342,985,60,65,197,429,641,264,805,331,884,805,598,753,800,235,536,172,795,905,327,784,837,767,921,525,48,958,934,319,864,342,300,336,912,51,895,167,66,51,240,845,161,54,97,124,955,103,750,888,674,8,372,686,195,330,617,297,971,833,662,741,303,35,364,739,992,278,607,28,168,520,627,267,482,867,23,333,314,618,281,111,913,409,881,652,15,735,515,560,737,132,92,623,398,406,777,86,411,248,300,131,636,81,179,740,798,530,33,936,157,436,206,631,745,937,198,694,341,484,731,237,6,992,141,235,444,601,558,972,405,396,602,528,291,619,238,789,30,856,893,727,803,561,688,637,612,206,762,33,458,556,144,776,355,269,428,256,504,537,772,360,908,46,170,415,745,419,629,974,278,398,466,230,267,263,215,616,475,858,892,377,972,82,618,94,852,953,450,921,927,588,840,715,231,963,603,969,737,348,750,817,382,9,420,801,822,542,875,469,172,205,594,767,940,361,591,652,181,3,742,596,277,506,567,992,808,217,221,87,732,741,536,968,281,825,61,459,538,508,479,456,147,375,994,612,194,715,919,170,552,839,663,512,865,536,615,412,432,472,691,993,961,602,674,912,791,130,761,545,376,708,343,986,135,415,136,423,89,720,813,442,741,855,145,552,778,779,416,407,539,856,775,0,288,160,61,486,996,929,475,663,351,944,819,351,285,848,704,708,959,743,736,845,490,48,908,65,369,121,720,317,242,262,302,498,623,554,837,880,915,679,36,631,971,403,856,603,42,81,579,969,833,322,879,626,291,654,422,278,623,630,420,999,300,729,932,763,599,972,790,247,752,662,617,296,395,989,157,868,138,681,816,595,645,254,67,102,82,122,952,858,504,706,264,671,952,228,360,331,945,579,151,906,667,177,525,241,912,829,544,646,238,616,523,221,771,467,84,46,411,954,460,206,366,706,887,206,299,416,143,346,265,251,636,418,382,24,678,373,576,491,469,75,287,701,312,126,243,117,892,939,668,638,118,565,864,37,447,461,265,438,975,790,688,610,772,457,635,143,339,624,799,838,595,258,248,514,63,105,379,421,11,967,658,925,646,191,219,646,354,150,628,698,854,156,733,276,197,304,334,493,327,427,320,848,835,30,879,197,106,722,120,746,758,199,549,558,788,752,5,342,951,234,261,282,717,176,897,137,137,752,446,477,948,340,807,288,637,405,500,935,436,352,499,78,794,941,63,92,520,418,59,679,146,761,762,918,994,519,772,311,286,709,322,414,635,735,810,189,699,355,371,883,202,985,573,999,390,691,437,64,516,858,289,7,496,864,375,752,505,738,932,123,156,709,872,849,55,975,319,261,408,392,694,905,196,244,136,915,530,901,860,258,824,357,19,249,91,66,450,664,742,231,187,807,11,754,545,76,796,806,758,131,219,30,208,638,844,244,626,850,835,181,663,959,891,805,405,996,131,454,573,782,963,182,518,372,935,364,656,432,124,159,165,711,148,900,532,127,142,761,730,325,881,592,513,667,761"",
    ""555,453,553,733,526,74,168,538,542,649,800,579,730,467,757,913,254,935,158,689,879,518,301,445,997,198,981,699,439,49,148,394,109,703,169,814,360,849,612,427,824,626,419,776,986,581,781,153,755,986,765,47,322,266,265,711,489,460,397,333,735,258,564,277,66,678,479,711,618,66,776,517,676,975,985,500,180,999,777,486,939,617,754,360,70,751,33,527,935,754,490,199,541,797,93,155,157,866,439,145,863,255,734,475,801,378,13,968,475,244,411,912,291,470,744,209,492,655,312,508,645,497,862,987,578,339,159,560,180,388,792,962,693,36,336,697,94,957,21,686,26,401,341,949,651,462,453,774,894,874,902,903,284,26,744,911,892,794,957,86,469,413,985,649,889,445,216,231,767,473,991,987,612,733,69,645,933,754,75,577,401,37,540,354,762,372,957,80,473,705,874,944,225,194,108,857,107,230,941,776,798,99,818,368,626,475,155,937,617,900,268,532,902,364,462,964,804,382,192,415,298,461,376,190,602,531,348,918,538,195,869,668,917,323,58,129,192,387,169,909,100,538,936,600,819,869,705,3,525,240,352,647,651,909,159,914,96,553,474,89,151,597,644,573,908,569,168,965,613,469,79,802,186,97,470,194,129,374,355,372,319,155,34,998,928,313,500,258,652,589,891,344,986,293,385,60,921,359,65,30,232,753,478,125,621,280,471,876,292,854,926,635,400,79,262,889,326,660,770,35,148,655,940,351,736,826,904,690,441,94,603,729,287,255,112,101,786,180,728,392,525,705,705,363,968,317,902,77,974,89,279,206,668,518,318,240,281,275,785,440,737,129,940,485,59,351,710,8,284,32,786,516,473,528,126,776,82,6,566,883,271,92,326,903,240,853,540,224,483,705,708,341,748,335,486,54,176,873,946,904,248,688,848,784,782,861,225,749,642,879,560,360,910,740,751,868,903,985,567,256,396,454,865,430,983,423,206,729,684,422,162,924,669,661,914,31,941,6,381,667,602,615,593,154,466,641,189,198,172,988,540,219,935,889,367,320,728,548,251,954,432,587,496,875,407,123,372,745,366,795,244,402,115,844,86,27,311,504,676,858,952,197,818,873,158,830,413,47,348,104,343,133,724,484,500,55,771,124,536,635,307,151,537,887,969,318,148,129,778,810,285,312,751,193,443,973,237,583,5,828,826,321,360,393,591,454,347,724,275,625,364,989,599,807,652,56,78,38,527,809,292,878,468,449,69,273,392,271,712,469,937,797,694,360,263,204,448,397,872,752,584,746,375,423,855,3,122,106,715,53,191,522,936,54,842,859,603,708,322,817,824,896,427,241,252,464,260,441,129,316,857,425,187,797,142,796,259,906,386,342,193,103,591,906,569,494,41,990,621,910,905,69,903,916,765,605,957,793,128,761,951,399,142,785,288,0,245,635,906,580,678,689,467,261,548,946,914,243,966,474,36,54,464,659,23,924,393,434,336,163,107,40,135,737,974,733,935,143,192,102,925,147,192,665,906,52,851,785,613,182,853,996,334,172,386,243,137,846,769,793,851,999,889,754,375,737,210,267,620,118,958,641,456,894,271,269,438,963,458,68,457,88,252,270,779,494,531,822,183,427,21,39,142,49,421,782,658,976,208,831,410,714,811,754,544,812,441,422,306,134,139,120,102,941,329,911,943,4,724,543,925,247,159,174,782,343,295,254,276,680,231,770,801,396,977,874,496,384,551,180,475,72,383,301,477,373,972,31,188,734,995,200,273,481,781,446,539,273,811,478,858,240,434,952,464,261,30,990,578,906,80,32,241,599,717,363,949,953,503,530,106,712,432,792,129,215,106,195,394,452,478,603,808,671,477,897,388,317,405,568,145,542,906,247,164,766,968,635,782,650,286,706,221,508,844,376,295,984,848,927,650,177,965,821,58,956,36,585,500,835,564,502,12,921,656,17,526,179,24,382,503,443,58,217,945,998,375,868,641,222,630,428,344,642,458,455,52,630,850,323,545,34,781,562,248,720,659,963,452,17,125,372,115,654,829,486,711,579,398,109,843,198,165,26,729,802,88,108,238,814,953,148,965,650,543,664,810,813,770,641,911,550,801,772,804,279,919,392,826,503,944,260,814,945,862,474,84,271,831,23,568,206,365,872,353,79,386,349,627,572,768,564,259,997,587,137,202,540,765,826,761,399,856,957,955,478,319,107,785,557,471,61,312,468,890,760,352,374,916,782,493,472,737,600,884,752,314,379,982,740,858,904,574,615,938,955,949,73,837,428"",
    ""762,652,181,988,923,969,3,756,433,562,573,966,542,435,63,96,832,736,895,959,614,651,624,206,186,971,280,979,380,33,672,644,943,220,894,50,437,196,617,297,631,937,919,535,463,804,90,19,875,452,130,406,808,881,840,348,27,208,407,517,506,853,339,386,655,523,872,870,378,484,621,10,645,128,263,323,90,300,563,313,399,788,694,787,179,477,538,548,668,968,224,113,224,791,559,525,20,509,372,433,186,576,303,711,288,668,665,571,195,137,452,384,431,700,643,444,713,251,454,19,887,682,914,451,380,87,990,202,969,33,284,105,46,360,250,247,36,262,508,927,704,914,266,679,778,676,561,887,528,366,575,180,86,613,316,408,351,716,313,229,598,692,838,123,937,590,141,491,453,26,546,879,67,443,917,668,88,233,805,446,853,440,127,355,988,237,607,445,97,795,951,171,528,561,883,209,552,411,511,640,495,311,258,670,514,559,654,735,601,505,455,52,487,47,635,837,463,262,287,251,510,541,293,372,898,772,476,832,332,320,29,347,527,368,58,681,755,955,754,721,755,403,428,809,251,370,276,125,485,970,593,596,229,365,484,151,927,538,859,754,73,812,494,967,963,323,205,609,632,820,82,721,776,672,74,9,192,289,881,583,809,792,420,153,137,757,757,904,524,613,425,938,806,589,615,64,116,878,910,363,512,422,416,812,321,476,688,893,276,964,906,907,620,107,203,231,966,424,135,103,405,878,917,903,163,550,106,955,738,751,811,864,816,644,361,514,860,392,828,5,914,762,751,615,899,618,639,562,566,137,490,836,354,491,441,151,984,521,229,580,950,963,90,200,692,285,207,38,776,984,217,226,498,109,241,919,747,950,895,426,90,768,890,299,47,338,750,365,11,150,481,368,549,56,554,282,811,761,78,740,149,690,756,363,288,749,703,711,814,585,426,160,842,209,371,768,538,973,57,898,391,172,317,76,218,452,274,374,929,789,152,973,826,753,346,767,494,790,901,711,322,159,869,549,70,665,183,983,629,712,267,803,889,708,433,725,413,49,231,347,879,923,526,280,20,592,317,988,491,784,51,918,968,378,410,723,826,529,801,250,865,603,429,306,143,978,918,721,713,213,86,581,209,182,837,409,529,78,185,66,242,709,70,238,774,571,668,815,353,390,647,668,65,77,587,278,914,633,509,673,986,65,136,63,921,682,315,209,185,299,394,435,125,233,570,763,46,720,989,80,164,565,713,190,621,593,414,154,311,574,321,255,933,945,231,601,727,867,290,180,171,253,484,728,602,77,581,160,410,773,246,275,511,919,581,976,898,849,961,820,776,855,851,154,933,830,566,386,639,239,750,396,629,816,518,304,206,130,492,41,707,856,136,600,943,174,940,854,312,425,559,544,442,792,519,238,476,593,330,795,589,502,334,386,160,245,0,124,434,644,493,55,721,44,922,35,948,115,933,107,429,983,600,462,161,644,875,428,678,518,744,74,783,649,356,135,721,356,574,688,557,711,367,567,358,955,973,266,991,737,628,441,143,685,342,436,159,173,41,300,123,401,60,997,429,789,165,329,30,70,301,597,600,329,496,722,17,220,96,261,60,560,625,116,661,202,108,68,940,119,117,72,513,197,382,666,785,891,602,356,533,777,270,920,581,792,321,945,549,546,748,727,902,762,329,329,408,176,680,856,344,421,231,689,232,794,729,927,130,93,20,824,846,651,657,522,675,154,542,103,960,274,155,715,590,336,404,199,111,295,696,367,509,980,872,710,33,545,369,158,545,835,531,886,480,708,891,691,232,11,548,47,825,675,848,38,134,950,885,254,959,397,299,428,803,950,52,381,706,773,677,296,649,753,757,836,791,697,645,642,299,429,615,405,816,524,705,314,512,297,384,985,386,158,93,177,238,895,831,569,7,703,884,863,847,252,801,877,17,120,481,61,569,644,780,156,276,621,934,637,614,444,9,586,17,344,959,207,868,638,94,222,904,985,220,556,530,237,348,685,561,977,423,943,411,217,110,811,453,760,116,430,225,114,175,317,454,345,468,896,680,245,926,300,752,580,901,81,892,530,735,543,802,260,272,923,807,674,932,546,743,568,52,210,670,543,106,120,321,839,251,336,86,797,560,964,278,804,205,656,648,488,547,7,257,750,552,392,291,819,244,430,537,35,956,264,238,659,824,441,861,537,587,276,506,22,198,808,735,37,25,686,272,144,218,920,598,253,71,567,355,701,207,983,633,267,672,796,182,318,559,829,105,407,934,587,144,680,867,478"",
    ""962,41,402,941,824,145,38,455,208,588,260,600,115,826,180,326,994,895,453,138,570,699,388,503,719,719,888,252,511,20,95,154,940,63,386,435,39,233,496,309,406,465,445,602,642,747,283,45,828,818,224,589,147,288,681,941,637,405,928,336,482,772,12,415,509,444,478,954,715,191,182,89,246,793,720,867,522,611,264,68,106,695,619,391,805,233,316,766,107,601,378,914,261,995,897,717,761,604,736,164,788,306,354,934,148,955,433,876,473,469,573,12,107,147,943,600,284,242,613,327,655,381,529,955,401,95,37,532,677,915,510,634,484,273,992,553,243,863,748,265,980,390,632,580,148,966,983,854,63,735,43,70,45,674,367,668,443,559,294,140,472,244,617,530,999,832,194,437,949,354,476,373,527,661,120,985,558,202,205,727,152,341,333,779,688,77,92,659,811,648,685,663,419,962,55,308,932,12,758,201,428,990,180,288,871,130,764,117,815,222,291,387,869,942,741,821,156,450,486,855,596,295,344,811,451,377,177,123,675,784,77,417,612,188,503,947,423,823,128,511,321,603,173,737,937,113,690,22,679,995,763,968,48,629,594,717,210,641,133,322,714,982,129,165,811,788,26,283,92,134,41,318,451,883,976,211,262,998,90,571,876,736,865,360,939,656,246,217,822,643,25,319,639,461,773,674,398,630,183,591,612,492,634,495,355,767,303,854,131,998,393,231,570,147,371,733,46,284,230,585,530,274,914,112,645,939,364,974,648,228,376,757,331,67,290,186,713,428,206,422,534,786,506,912,857,262,107,434,478,139,330,619,66,881,590,429,862,218,62,328,882,461,802,649,916,611,687,898,88,107,313,768,26,540,809,477,953,374,185,460,220,636,996,495,895,861,819,198,880,47,561,683,850,760,346,196,97,238,15,230,261,515,924,215,226,889,926,206,234,467,415,905,440,190,650,221,929,481,266,770,696,191,547,867,426,937,397,633,5,492,862,783,266,52,207,371,538,74,588,460,782,695,948,776,340,285,127,407,625,449,971,897,796,271,392,732,936,192,533,232,983,519,247,553,86,688,675,365,435,583,439,657,272,32,326,458,79,12,346,884,241,298,469,889,275,913,874,85,304,760,424,810,875,479,648,631,975,908,892,384,668,660,710,850,478,919,11,940,464,643,613,863,865,970,821,529,963,526,772,7,967,269,877,234,455,781,781,326,172,320,448,312,3,988,352,966,86,652,910,111,431,322,684,985,851,111,355,720,268,587,146,387,389,238,695,558,344,825,582,908,97,135,453,158,323,26,792,180,496,961,608,205,618,240,310,606,630,428,897,513,115,220,707,644,294,104,116,642,703,519,237,520,99,200,218,731,318,981,795,496,37,116,814,758,358,53,875,751,267,685,263,783,122,860,601,173,381,926,387,317,720,87,333,707,61,635,124,0,479,597,404,716,867,870,183,77,932,345,187,818,318,133,842,156,209,509,804,650,2,543,948,528,404,388,70,401,97,91,296,376,191,934,616,873,143,200,831,343,207,625,610,862,250,269,36,980,872,921,360,768,929,459,792,169,315,720,764,562,643,52,818,800,66,797,917,991,821,854,814,495,713,159,421,328,813,291,625,838,218,179,408,239,826,743,272,318,953,131,746,709,592,769,462,735,429,109,576,171,270,836,30,922,190,69,655,455,774,732,175,140,263,595,954,56,632,471,705,117,501,48,196,258,27,544,505,162,780,802,804,128,534,711,297,490,568,165,908,571,946,526,403,180,521,17,161,185,81,743,488,725,761,32,429,711,625,699,917,382,546,743,155,317,90,622,707,437,741,883,459,722,890,595,9,395,495,314,439,945,25,449,127,514,320,164,688,656,378,71,135,419,512,401,130,677,872,530,712,849,891,292,552,267,864,38,96,147,483,97,51,337,214,431,205,514,674,46,427,781,289,390,307,96,619,151,69,911,518,967,699,347,243,427,578,793,747,762,542,127,354,69,475,896,820,111,899,805,199,445,359,31,662,353,253,789,393,14,847,940,57,909,773,604,208,971,64,545,258,364,297,913,965,782,698,821,159,463,927,401,976,868,616,621,131,421,181,568,473,931,828,231,240,16,588,578,461,705,335,82,842,236,267,230,759,102,508,229,626,669,505,136,903,694,351,738,118,816,947,986,769,589,488,120,595,13,656,751,431,107,716,729,734,181,673,378,125,119,141,46,616,21,590,39,119,225,995,244,406,660,287,450,423,755,508,896,388,138,821,597,824,982,901,565,856,509,751,773,24,839,773,445"",
    ""212,207,156,654,658,406,823,860,479,773,853,165,406,730,546,854,708,59,707,231,631,779,87,360,170,311,266,737,756,842,851,348,707,955,921,781,426,107,50,292,182,273,905,567,143,615,322,669,697,646,371,67,708,560,287,951,94,103,608,906,103,164,232,310,129,653,316,309,889,980,240,425,710,817,190,176,795,654,770,416,439,253,729,178,134,396,116,326,535,636,85,863,225,329,406,12,60,24,966,407,94,430,993,957,201,100,629,720,140,782,470,27,661,518,144,517,294,916,908,687,508,689,32,749,244,444,780,151,371,359,447,690,429,705,813,812,483,247,955,644,883,784,450,949,387,895,991,975,900,841,550,551,980,513,490,907,884,651,275,798,239,552,572,269,320,394,712,960,233,343,416,261,351,989,148,90,975,307,395,826,292,522,819,275,752,692,794,112,131,768,905,247,59,36,896,901,367,739,451,332,226,995,733,799,343,815,258,1000,802,815,608,950,487,869,821,354,43,52,391,174,489,43,126,884,341,238,516,791,494,94,989,267,314,619,910,79,147,79,213,706,72,106,764,54,904,875,717,447,580,880,350,892,636,390,801,338,768,465,860,137,804,388,322,291,243,564,607,969,879,102,403,700,9,62,63,814,630,737,345,967,697,89,523,762,719,742,583,864,7,9,759,149,972,78,80,800,956,480,519,373,133,556,301,180,163,536,177,154,521,115,131,829,316,859,844,436,14,359,810,675,395,559,146,160,444,646,143,567,588,655,319,749,648,930,25,931,637,126,318,836,795,459,189,637,150,984,297,625,61,210,417,851,557,802,420,439,114,262,290,862,306,594,532,740,32,913,664,46,942,989,932,484,167,508,128,914,872,649,366,973,598,50,941,514,859,727,731,291,705,229,38,101,387,331,129,613,648,133,119,273,711,349,774,362,364,316,937,155,56,360,973,360,185,877,766,244,7,166,893,296,148,195,787,951,951,711,781,517,975,218,188,743,975,577,485,647,853,839,296,855,752,84,41,212,450,138,749,335,40,629,943,752,643,894,210,628,535,797,377,708,591,990,61,600,650,189,384,701,205,524,402,329,138,438,502,333,697,921,587,275,85,311,416,465,243,41,966,117,306,423,655,307,413,355,89,726,196,453,339,530,26,240,244,772,345,916,536,954,45,394,219,283,797,629,799,841,554,887,237,5,566,738,373,491,590,163,561,985,155,69,291,679,725,374,411,199,809,583,444,862,433,988,946,970,428,747,293,914,246,171,715,59,385,435,277,552,286,110,599,63,121,704,685,563,548,729,425,168,14,544,99,129,983,454,439,432,799,600,681,333,689,569,3,480,120,775,568,896,98,835,446,801,768,408,60,506,253,688,73,111,732,974,53,512,497,236,596,257,946,220,796,753,10,380,776,242,927,295,560,894,73,218,459,247,486,906,434,479,0,944,317,820,87,579,373,487,550,478,461,260,633,11,954,152,76,794,938,923,598,421,898,310,163,55,88,523,32,987,385,733,423,647,696,489,20,303,918,852,574,120,931,812,635,552,754,441,727,850,431,78,468,839,628,513,102,140,684,872,517,233,823,170,754,726,845,313,830,750,341,664,326,295,922,692,208,62,9,483,969,167,782,168,464,546,120,274,961,166,128,161,764,39,981,337,142,529,782,951,851,687,876,337,946,578,421,822,42,393,575,290,829,798,585,597,46,522,760,768,893,85,75,973,703,785,475,875,114,103,100,991,851,714,758,241,254,568,166,489,262,295,910,780,463,672,667,686,341,29,18,440,221,692,339,851,651,707,593,751,256,233,281,564,531,332,791,124,900,49,919,189,90,338,404,422,110,227,577,736,935,857,553,104,212,276,915,951,759,575,648,20,778,905,401,158,291,220,334,531,208,847,457,4,945,19,183,916,968,748,302,553,423,257,901,660,383,884,361,97,39,691,183,401,50,333,650,316,778,63,218,349,199,953,939,432,364,494,825,791,808,561,617,807,626,635,225,408,61,200,787,941,610,931,552,565,972,371,673,529,23,893,359,912,452,267,820,382,676,281,443,273,323,778,692,51,173,198,342,980,721,736,868,957,406,692,938,241,603,429,313,322,537,672,158,582,878,506,860,311,984,970,759,323,924,998,460,367,515,915,69,727,580,911,880,99,652,267,829,847,907,704,297,761,872,203,803,559,631,423,820,696,504,958,174,491,165,724,737,798,124,93,411,824,304,380,111,214,158,210,737,828,462,601,909,247,357,972,123,622,405,354,676,273,134,592,951,195,557,16,870,759"",
    ""311,144,163,334,602,485,572,98,441,349,513,876,813,142,734,224,841,258,658,585,197,531,480,989,593,972,338,42,856,935,807,454,610,91,16,30,89,810,959,552,202,127,900,306,433,408,78,281,22,432,420,579,802,338,388,204,416,617,150,272,373,322,828,787,818,53,54,712,415,902,924,938,912,614,773,758,627,49,310,667,774,48,829,454,581,380,446,988,965,579,913,296,922,233,774,769,375,89,763,839,392,306,937,417,910,153,635,216,487,115,136,427,964,830,316,995,163,449,180,659,483,990,559,855,387,84,349,97,973,793,903,417,641,829,646,575,393,40,216,407,889,437,844,761,208,329,516,54,406,64,366,482,330,102,340,661,91,265,689,241,491,358,14,472,491,226,582,108,547,526,136,181,926,244,299,384,459,471,735,469,227,438,611,332,317,798,580,223,272,872,677,194,717,126,830,105,939,171,306,552,872,967,33,199,823,907,338,536,895,593,300,149,622,692,873,718,784,983,37,741,677,466,973,304,868,705,298,321,976,969,705,840,439,448,82,651,373,903,128,152,168,66,899,965,924,89,718,212,502,920,653,955,199,563,990,237,477,143,916,318,809,795,880,388,972,958,251,677,136,13,181,994,123,963,581,127,743,515,740,516,510,712,186,384,951,393,360,119,356,478,992,781,615,752,174,938,133,428,299,741,980,600,370,570,370,263,358,876,711,69,126,892,267,599,753,846,49,667,181,960,999,628,317,78,316,804,4,107,850,946,352,816,35,134,456,350,451,813,781,48,801,110,878,579,913,289,500,301,373,665,447,327,363,707,467,529,70,179,429,379,821,919,493,744,355,612,899,307,440,160,36,740,880,732,18,567,654,351,115,50,670,551,139,472,971,966,232,313,728,986,640,562,995,677,392,131,364,846,303,265,144,414,128,481,354,812,263,875,988,433,749,382,312,779,266,70,94,718,990,405,761,999,280,670,904,966,632,462,399,158,88,837,766,462,369,660,793,307,698,503,984,971,222,921,763,885,348,511,430,147,71,316,885,795,719,202,659,352,339,955,621,61,845,715,575,759,753,535,484,905,646,351,486,811,469,973,799,623,268,217,499,280,122,336,834,23,959,342,958,452,233,493,175,894,903,785,710,230,84,686,455,633,414,236,180,852,995,308,77,844,594,911,313,286,889,359,909,388,607,935,454,601,302,31,413,357,339,220,766,39,11,827,926,108,18,426,67,502,431,99,917,434,253,43,288,290,238,589,346,272,617,812,720,147,125,646,55,13,209,408,801,802,47,143,962,219,798,736,204,411,73,873,783,229,433,624,173,965,108,197,174,655,355,411,707,86,458,776,476,104,355,765,385,710,543,309,896,522,361,739,51,676,926,982,409,753,325,858,825,584,26,404,46,111,682,685,225,604,979,32,402,691,733,740,996,580,644,597,944,0,264,589,983,43,887,919,142,170,775,727,320,338,882,427,496,818,217,330,609,446,347,789,93,524,644,312,651,376,990,359,1000,93,395,638,76,371,606,329,530,946,604,870,195,942,502,374,648,541,528,679,228,893,4,328,265,388,975,692,286,937,879,303,97,125,895,365,724,516,966,271,113,634,189,617,738,225,541,598,388,146,819,82,73,770,658,43,237,522,276,640,583,541,670,242,567,162,203,531,998,933,42,263,888,468,723,384,292,599,123,315,639,826,917,124,888,544,615,484,59,114,865,744,727,80,375,233,520,12,967,452,174,150,230,676,944,442,10,569,730,993,161,702,94,690,546,129,400,719,129,527,921,49,800,121,521,762,596,372,610,226,499,124,481,931,532,752,918,331,513,438,296,67,43,499,280,396,906,980,946,501,49,600,415,864,236,753,951,615,258,698,173,154,914,523,289,122,66,740,856,791,745,323,215,409,144,637,246,477,863,684,240,206,897,797,880,370,824,118,571,841,94,172,702,238,43,387,423,967,296,464,954,144,800,868,757,29,710,365,876,570,844,243,602,380,99,521,920,207,401,404,468,920,26,444,917,411,706,453,87,434,653,385,90,700,376,790,459,513,906,553,699,271,944,754,910,992,776,373,616,912,418,364,230,290,584,829,145,144,436,397,757,457,463,617,520,444,625,581,91,257,776,292,441,462,508,975,71,311,709,987,77,123,571,602,693,674,444,222,935,393,444,709,599,454,239,354,599,336,520,307,764,485,774,797,166,186,813,729,578,277,838,150,580,866,979,892,433,628,924,454,721,522,374,466,56,414,287,544,592,98,408,11,342,508,257,958,868,543,415,561"",
    ""572,162,331,9,86,253,915,431,256,388,520,667,47,796,233,542,734,216,120,754,974,588,798,695,500,166,320,395,374,570,579,173,780,610,469,831,53,690,232,986,135,136,526,551,13,32,315,493,723,519,3,232,8,452,83,778,308,388,289,318,711,474,649,930,571,317,893,216,276,552,250,431,981,380,518,27,921,643,863,727,768,706,518,328,295,453,32,376,19,850,295,254,506,119,757,128,124,614,365,12,172,499,135,622,397,347,630,895,596,413,726,461,164,872,867,444,219,414,499,191,103,359,774,450,765,835,418,962,636,899,928,863,278,989,175,939,190,570,347,295,457,386,412,26,142,545,43,964,920,80,462,559,652,604,971,961,137,969,401,678,573,671,22,920,67,410,979,148,544,667,869,435,524,938,15,671,105,550,999,587,683,152,15,144,180,90,450,947,120,981,691,66,59,100,417,229,203,989,801,994,198,582,119,841,699,478,654,801,479,88,591,362,462,466,594,742,653,267,458,810,450,315,608,640,801,204,622,645,927,370,164,534,13,677,894,998,42,764,48,146,568,575,98,447,626,948,202,402,299,602,350,642,9,165,828,837,813,928,487,819,637,773,816,543,491,75,917,353,264,781,689,275,931,602,213,217,509,226,877,846,326,744,408,826,446,26,198,292,210,869,740,101,174,770,454,551,808,599,309,146,525,273,663,27,965,491,120,189,336,712,98,344,260,599,827,102,468,700,358,75,323,883,241,92,17,738,467,187,255,391,536,926,905,835,605,827,785,278,187,380,352,825,586,940,295,668,808,573,113,992,412,941,905,621,541,265,240,577,915,483,796,391,509,884,265,936,381,747,431,669,499,65,301,536,104,594,943,830,174,192,937,539,53,808,342,823,831,322,836,124,372,148,840,152,416,667,803,12,711,807,231,854,143,638,719,538,881,992,864,523,970,279,632,899,655,120,525,200,450,945,41,156,643,572,974,279,432,408,233,881,448,755,922,977,326,820,379,165,310,189,141,679,604,176,750,802,107,493,369,491,929,208,505,188,490,284,667,595,964,445,257,695,387,759,776,118,56,435,321,438,450,182,100,490,602,62,796,320,234,493,360,464,746,55,298,910,59,80,731,665,837,129,419,851,656,676,905,535,83,525,540,332,309,514,449,373,425,365,594,66,907,522,430,898,14,289,460,509,753,853,54,929,300,989,126,593,448,675,327,708,496,945,959,34,76,566,384,507,635,663,420,852,454,300,21,880,569,932,661,102,410,159,587,452,180,704,410,414,382,972,666,841,465,419,128,621,102,388,66,397,296,706,241,833,961,356,444,852,391,902,534,616,723,185,605,79,343,91,508,290,260,131,459,23,886,347,695,808,619,990,976,690,295,875,96,758,691,833,651,428,628,301,830,424,416,907,957,428,853,79,840,419,391,662,929,678,493,404,317,264,0,339,521,2,495,2,45,550,34,5,959,497,850,760,395,743,459,763,150,332,247,163,149,524,14,223,601,377,532,244,314,645,181,832,77,522,639,766,439,844,725,562,586,59,129,594,233,19,882,281,642,958,91,813,47,104,993,777,932,974,681,526,779,986,831,459,354,229,604,696,473,112,906,618,242,919,676,337,708,175,644,434,490,459,658,9,848,831,753,770,139,318,331,706,352,730,588,956,339,552,895,468,608,466,864,991,411,901,783,930,899,57,492,242,249,501,671,458,626,928,370,267,262,869,869,848,395,885,665,182,574,963,913,830,66,136,554,373,914,592,869,854,453,567,936,798,106,702,26,107,100,358,7,869,16,469,16,274,477,35,951,696,230,716,529,238,850,663,788,392,316,226,948,362,607,306,878,97,490,631,929,586,727,386,787,490,555,553,265,524,657,114,529,428,121,109,378,102,443,741,346,220,515,368,900,207,761,702,784,763,415,221,796,292,61,703,567,300,230,369,113,947,625,718,516,409,617,924,606,613,594,118,847,795,962,678,436,539,138,358,290,741,470,401,350,61,116,754,510,289,772,574,341,859,241,581,681,396,17,866,817,63,339,79,226,237,986,331,190,447,255,277,549,107,4,984,275,919,466,529,141,805,690,808,773,382,193,423,408,438,486,671,967,58,974,241,150,218,475,2,840,181,169,707,91,957,999,283,768,577,309,913,934,954,18,383,310,577,14,396,796,76,81,797,778,748,978,907,989,717,563,986,400,669,741,360,930,402,621,16,501,444,560,743,623,97,78,954,995,808,77,191,664,323,902,565,324,885,968,408,834,913,424,439,340,296,274,611,526,82"",
    ""852,46,587,294,332,210,41,416,947,245,746,42,270,991,552,859,387,48,427,622,618,550,487,127,701,428,585,798,616,14,833,635,89,751,187,824,368,35,485,373,478,816,100,406,883,570,228,761,403,411,54,266,638,947,166,906,343,303,947,904,71,314,86,592,439,630,984,677,841,988,536,228,160,88,862,687,333,393,641,166,322,277,642,682,131,701,90,853,682,971,282,616,876,531,580,842,980,515,410,389,265,565,853,181,38,476,398,187,985,529,91,621,970,234,924,974,493,833,356,221,590,67,712,367,771,626,173,539,421,204,790,135,496,968,769,22,534,626,382,703,950,797,23,233,796,106,766,937,994,300,945,500,366,811,854,380,937,981,692,189,393,751,133,666,833,948,154,253,663,691,513,849,370,847,645,73,77,93,207,701,184,682,328,390,377,229,277,792,247,568,422,724,757,737,9,497,11,893,997,850,144,462,522,423,686,269,370,521,539,405,699,918,467,719,58,274,555,412,985,49,876,234,540,492,610,247,400,4,508,393,371,972,592,222,65,441,583,351,753,373,572,558,759,91,809,852,725,330,976,761,489,144,663,291,179,27,350,140,859,809,596,986,664,117,766,809,426,449,635,714,525,779,735,347,840,329,140,121,257,497,69,546,753,61,26,900,368,506,151,642,217,738,107,130,324,172,759,404,667,634,135,669,223,563,929,976,882,653,334,976,766,214,511,941,873,75,55,282,995,471,929,45,799,96,438,101,862,401,981,789,134,197,594,695,249,266,890,935,317,658,433,9,18,138,169,713,80,25,986,443,500,931,726,826,86,846,232,321,497,948,234,815,156,97,855,1000,200,797,953,890,592,57,307,945,191,910,572,492,393,486,929,802,659,729,824,864,970,65,336,651,477,22,389,448,848,727,606,836,841,173,762,444,231,846,477,405,337,897,409,321,173,739,556,888,50,618,560,884,393,59,39,984,245,391,10,386,530,109,114,603,159,80,21,299,403,715,58,890,643,157,748,330,119,525,772,532,979,295,330,932,323,271,473,939,472,915,193,918,45,670,580,593,596,835,41,722,750,892,832,780,117,111,570,931,569,22,88,640,578,826,506,780,642,837,852,643,599,140,548,236,336,940,782,243,134,47,550,867,554,337,192,272,444,881,279,948,57,273,182,518,348,787,197,198,662,714,69,531,525,956,26,827,650,922,230,209,680,887,179,521,661,727,218,4,782,857,650,773,663,256,443,577,445,240,175,889,726,951,724,249,463,485,167,313,568,925,835,702,305,70,854,949,196,18,68,841,227,30,972,657,325,149,286,534,829,330,84,784,585,506,221,745,901,163,659,674,381,721,732,851,548,703,868,11,40,540,236,909,949,747,251,617,640,164,737,54,880,12,614,327,340,716,467,950,111,638,842,839,595,640,746,441,855,709,475,689,55,716,820,589,339,0,349,801,783,821,561,891,342,754,648,960,680,635,584,119,684,465,695,994,164,93,401,10,599,412,475,657,947,176,449,789,39,495,640,64,806,822,921,520,416,46,16,230,291,79,37,775,268,713,17,901,493,112,160,672,289,465,660,133,816,136,248,299,847,311,156,224,609,72,99,419,867,873,902,460,8,878,541,928,524,20,71,280,241,937,894,867,541,313,156,560,529,620,913,754,144,216,504,991,679,157,853,229,445,545,275,96,517,691,318,476,881,581,759,658,212,67,670,328,810,216,265,432,48,1,605,719,141,690,876,416,24,436,688,135,423,759,49,138,188,446,274,687,70,7,267,230,407,954,901,236,481,595,16,712,855,348,519,81,514,526,122,574,893,817,941,425,772,290,523,755,692,177,693,97,285,497,281,29,232,774,788,262,398,160,471,923,700,123,460,39,37,597,905,146,805,485,818,713,401,922,234,505,650,690,223,150,274,148,826,2,768,885,870,458,980,133,319,358,741,401,423,808,587,272,193,234,379,942,807,128,376,74,369,959,928,13,985,728,493,142,69,34,984,246,386,2,985,676,792,543,540,303,108,186,803,562,721,356,687,716,784,322,598,77,73,665,201,538,203,555,714,607,393,142,767,594,820,699,84,802,502,475,480,183,27,391,325,656,288,839,245,125,806,575,671,795,105,915,31,929,269,989,803,205,632,421,40,587,901,607,529,775,481,788,319,749,871,380,977,248,50,620,858,832,770,433,657,765,310,376,592,820,309,657,736,525,375,782,642,775,841,252,567,11,373,281,767,744,584,278,184,377,842,574,719,310,212,430,932,695,85,172,623,192,79,816,677,196"",
    ""657,689,771,441,104,338,817,524,998,748,711,450,677,32,886,351,456,619,102,141,656,560,49,403,155,115,635,587,368,420,648,992,110,355,321,930,419,855,414,450,378,717,606,216,475,261,539,579,73,747,858,393,152,111,969,884,68,238,786,127,503,80,9,450,598,756,219,653,1000,414,554,339,963,271,487,615,950,558,725,160,586,559,248,138,677,25,48,422,417,72,981,67,2,908,810,43,101,632,199,659,556,531,12,515,926,80,665,205,115,294,393,251,300,738,245,22,994,675,131,993,693,381,435,44,993,155,282,320,385,398,918,577,351,771,206,255,848,56,42,619,180,198,318,38,853,504,727,291,815,671,324,843,474,763,623,638,623,418,858,681,939,668,191,931,447,664,20,366,474,685,221,129,321,944,739,78,766,764,515,416,144,903,616,430,952,194,992,515,583,811,740,385,510,891,78,280,140,900,478,415,216,131,626,252,153,278,11,22,300,887,722,5,464,6,909,492,620,283,551,561,79,99,141,347,17,975,530,19,130,621,405,956,221,714,725,662,989,605,181,630,236,421,507,574,388,290,696,860,208,481,222,704,836,100,641,269,358,339,235,909,146,875,308,425,461,680,239,100,685,420,758,676,168,933,824,558,846,190,142,865,700,980,908,311,226,321,803,971,144,549,997,613,986,945,249,841,375,809,462,17,857,907,495,410,204,803,568,610,14,287,312,523,228,643,595,98,529,282,593,287,519,287,52,364,299,705,581,950,639,537,146,19,85,393,657,923,130,754,871,330,624,720,603,119,105,246,449,721,486,506,530,542,576,592,336,502,453,319,706,763,606,994,905,524,404,79,761,512,306,861,294,260,591,551,964,97,204,372,903,230,583,285,814,313,378,780,192,352,87,441,400,487,678,285,28,547,481,458,951,565,309,329,390,474,40,195,857,375,822,75,858,813,37,860,745,581,44,167,395,123,343,374,19,134,102,999,796,167,907,451,722,958,530,514,95,376,751,579,511,602,104,72,538,819,465,945,104,286,66,165,659,11,657,612,68,491,78,442,60,571,141,291,639,198,967,507,212,125,978,240,484,517,187,866,517,830,182,367,661,405,384,34,428,984,20,787,746,676,916,340,961,363,358,594,343,738,439,155,319,844,809,876,215,809,608,433,953,640,340,848,188,265,713,989,934,224,223,746,476,38,220,132,526,361,572,447,31,707,9,14,107,709,467,8,741,970,959,555,760,160,251,463,163,890,978,354,689,150,849,660,604,919,869,448,448,55,30,140,149,217,933,283,80,943,829,73,387,370,781,790,373,591,461,983,448,872,778,141,638,654,725,126,720,843,94,428,201,665,272,701,995,78,95,191,381,608,846,722,448,682,150,948,730,536,443,809,253,281,410,180,523,464,133,396,845,237,622,690,201,896,965,297,190,622,663,467,721,867,87,983,521,349,0,194,658,669,20,851,985,654,923,112,444,393,106,7,557,715,783,849,913,359,33,158,613,370,945,905,523,751,632,948,481,150,740,154,865,89,338,589,504,962,686,27,608,397,564,448,875,303,420,120,1,736,824,695,565,609,411,935,240,173,522,967,352,474,408,690,236,924,778,494,751,350,880,629,916,213,744,809,227,997,936,46,612,917,781,49,874,227,462,68,33,871,903,957,508,23,691,765,300,371,954,938,971,550,971,836,530,882,617,269,498,572,16,995,247,161,242,965,635,744,835,521,825,932,121,619,202,83,387,169,896,582,80,540,203,255,254,98,487,94,864,438,214,793,387,111,840,693,677,735,625,810,287,551,950,215,905,274,563,430,742,863,981,870,634,603,925,19,911,352,277,250,281,66,490,569,881,952,971,656,416,922,908,785,133,477,660,142,297,393,538,46,589,601,655,490,525,96,490,788,92,26,774,623,793,587,217,43,304,971,340,616,475,677,584,233,128,762,397,637,973,324,683,816,859,457,553,824,540,758,265,190,203,753,625,534,463,792,348,799,970,429,333,257,324,523,235,735,192,401,426,689,616,579,955,916,518,104,259,857,901,449,978,81,903,879,813,610,274,99,729,310,998,913,647,231,328,953,431,173,15,92,908,84,45,686,173,519,447,504,83,291,688,81,39,318,621,196,747,651,881,463,412,15,277,258,613,14,692,886,735,174,180,626,740,229,788,474,181,566,893,966,554,495,626,777,70,674,689,885,54,339,835,766,60,153,897,932,165,375,442,923,660,176,677,909,887,326,808,747,719,931,160,871,500,270,193,966,225,858,858,887,718,404,810,424,795,280"",
    ""622,775,204,194,689,36,812,629,357,385,548,643,964,413,200,914,467,588,476,126,536,114,225,11,846,931,990,554,496,572,14,876,14,109,922,716,914,921,371,81,770,648,970,198,67,523,503,390,729,603,233,322,458,259,452,395,788,442,918,651,744,750,317,652,269,955,143,53,220,275,925,821,280,223,328,594,528,778,824,665,137,119,586,490,262,182,601,526,280,239,320,266,355,836,611,61,576,946,988,942,98,545,23,288,555,93,402,166,371,62,25,283,456,102,274,568,212,659,398,683,66,665,584,934,681,671,581,866,188,222,761,442,108,179,952,618,763,877,662,132,950,433,58,428,363,575,659,286,155,556,232,520,978,833,120,567,898,756,802,571,490,550,663,832,656,737,655,365,973,101,150,870,106,647,9,13,940,914,314,88,704,707,756,285,100,513,108,439,702,796,409,809,317,589,152,89,949,176,732,750,713,550,554,336,942,92,147,634,435,903,539,814,493,31,845,846,147,763,388,427,931,858,933,395,108,978,806,404,867,5,471,985,782,73,930,687,787,603,138,334,446,416,437,370,234,369,277,671,930,46,885,12,490,282,979,587,989,633,725,206,812,575,71,120,830,697,204,647,671,754,293,523,250,305,31,886,402,25,527,221,664,354,848,827,241,431,882,199,452,159,285,676,834,786,949,665,891,720,552,577,38,180,408,248,173,166,432,867,856,630,174,588,674,50,335,630,664,101,19,943,355,514,780,3,775,973,881,718,564,712,564,499,385,659,557,290,360,835,700,865,995,857,205,552,899,69,149,792,192,928,579,970,981,3,277,722,397,612,333,950,37,55,829,153,573,379,663,683,719,583,118,73,372,398,837,730,496,703,726,645,646,600,537,208,865,951,445,675,832,542,627,323,767,424,988,509,672,860,701,339,70,602,752,153,371,620,247,552,666,280,433,553,756,478,397,783,137,968,849,439,506,959,409,280,59,933,16,842,825,246,61,214,123,553,145,377,55,360,662,7,393,4,735,767,464,336,666,527,459,793,345,133,815,857,284,633,285,610,913,63,285,724,209,630,534,220,9,76,754,847,987,864,947,766,851,31,522,433,782,510,56,708,245,355,442,776,43,354,22,819,74,473,641,398,965,536,878,66,627,614,801,229,207,586,170,946,352,55,806,792,219,352,445,393,230,399,449,494,9,572,891,326,341,544,122,229,963,977,103,14,954,572,583,904,643,890,156,134,859,155,587,306,391,546,152,471,58,602,512,427,926,181,129,215,348,830,325,136,914,648,963,944,110,115,767,661,157,303,412,736,996,184,878,811,496,471,242,836,447,702,834,845,376,185,921,756,482,147,970,906,400,369,204,807,130,332,41,16,422,670,745,527,634,151,993,879,24,980,987,224,764,547,81,606,15,990,70,694,598,461,787,527,54,518,351,261,44,870,579,43,2,801,194,0,965,459,597,57,970,470,405,327,341,479,790,561,633,885,843,277,29,484,837,388,745,605,811,916,269,538,669,401,232,362,948,821,243,217,237,57,442,332,847,25,859,260,95,827,316,42,11,758,42,379,869,792,781,279,965,759,315,270,164,27,738,483,604,709,818,525,614,938,789,107,881,983,466,627,174,187,682,191,842,487,157,662,549,585,821,375,34,811,357,908,667,576,178,245,876,323,230,339,671,745,923,509,3,405,126,175,930,995,113,806,802,762,711,401,801,158,512,700,296,426,135,965,723,344,859,851,390,630,15,871,997,411,722,93,377,878,92,888,304,731,373,256,185,266,968,688,905,381,64,947,244,279,645,779,68,37,362,504,726,137,194,491,211,235,193,722,290,834,619,890,891,982,488,813,884,185,893,929,370,334,802,768,791,781,886,595,536,104,224,513,646,733,334,326,70,296,528,154,24,767,161,829,83,901,180,297,490,127,29,837,298,161,714,489,653,968,121,558,891,858,376,705,864,469,583,429,536,527,411,409,674,823,642,959,127,306,253,936,402,834,597,864,588,989,502,219,450,99,310,166,506,494,509,185,130,437,406,175,402,893,931,330,823,144,172,827,437,50,917,830,151,298,187,280,957,105,224,241,334,649,927,463,274,396,455,317,866,149,635,89,995,687,675,793,467,713,871,634,713,112,631,587,257,992,737,454,114,782,53,101,117,106,902,435,757,798,650,119,536,363,790,649,601,394,397,134,533,375,210,208,624,166,854,859,679,676,25,717,678,801,969,816,879,873,823,59,144,812,351,512,675,596,986,871,213,501,190,981,154,623,11,28,101,450,204,773"",
    ""461,318,607,902,959,277,61,405,184,339,552,538,549,552,91,725,631,653,244,459,870,414,170,522,177,431,571,71,888,254,541,91,953,203,161,762,826,951,773,88,661,662,860,972,384,998,195,632,888,228,713,799,953,304,160,312,743,259,302,256,765,264,890,486,344,378,196,53,146,171,748,284,573,844,292,608,872,54,668,237,66,577,994,790,647,618,60,950,298,43,588,194,831,34,670,548,71,308,955,269,73,134,161,149,831,258,436,959,665,425,355,900,411,474,203,939,94,320,2,47,30,668,917,37,37,840,412,673,501,306,376,773,904,775,18,367,85,659,672,796,318,486,739,416,374,916,625,84,916,262,852,866,402,941,580,45,405,716,862,854,615,501,85,281,560,308,875,737,656,115,287,778,275,908,223,865,408,381,240,427,532,266,498,798,692,829,964,70,309,522,278,508,362,899,455,778,658,975,189,663,518,118,5,401,76,582,750,873,293,869,213,654,410,750,450,928,731,59,27,138,162,294,158,15,815,285,917,841,250,144,117,913,547,370,43,769,677,797,930,628,528,262,797,496,170,364,130,927,323,908,951,387,931,267,97,443,99,702,562,652,566,542,432,461,732,305,783,117,84,549,888,624,524,793,327,818,62,491,178,258,687,631,267,352,341,604,585,369,916,536,274,232,624,433,637,870,285,309,850,31,754,791,546,885,131,269,796,991,33,712,736,939,527,885,60,636,725,230,150,880,73,415,609,530,567,273,837,161,593,937,808,232,226,299,592,74,721,825,881,109,545,499,423,262,616,394,424,453,561,913,387,399,98,963,567,412,933,445,680,115,676,215,183,611,736,20,831,737,296,171,749,878,76,462,793,495,402,264,953,738,655,697,93,913,893,334,551,193,248,278,385,411,753,114,336,30,314,722,503,377,919,309,338,50,199,859,398,647,744,590,349,809,974,250,441,336,836,872,412,875,575,61,887,235,130,698,611,861,525,112,878,271,902,10,949,893,887,595,48,243,332,14,721,298,836,751,616,415,189,209,63,153,534,180,970,941,865,432,894,830,356,311,569,500,130,569,527,582,41,853,532,726,107,392,411,722,416,606,86,639,218,696,672,637,988,199,623,684,361,780,121,222,458,71,743,599,865,638,658,274,408,968,134,804,646,63,222,747,280,820,50,569,178,871,593,470,65,962,220,665,681,363,83,224,847,353,6,808,448,54,478,520,796,487,687,431,40,561,870,18,495,32,528,807,944,618,594,189,331,170,89,977,760,587,971,534,724,900,304,65,124,252,380,633,700,428,941,759,312,143,598,573,932,360,399,108,658,277,706,945,922,266,999,518,318,410,976,823,983,63,874,133,958,30,928,782,70,808,133,308,859,853,607,368,928,890,807,673,502,307,549,914,515,735,683,722,136,691,672,90,444,122,400,93,944,548,922,183,373,887,495,783,658,965,0,416,835,560,256,172,76,143,75,278,933,872,332,610,18,805,5,913,943,776,94,473,675,550,156,614,537,836,451,694,621,194,578,563,697,642,606,505,164,264,234,241,276,983,1000,707,882,117,20,250,790,664,337,678,661,791,412,314,645,629,161,713,290,902,239,695,254,634,36,281,652,829,46,414,800,737,211,92,600,793,780,254,270,582,399,517,859,311,808,609,480,523,992,660,98,968,964,47,898,437,791,128,946,460,930,547,514,419,406,786,770,692,510,290,614,831,567,902,783,849,344,114,856,511,174,841,740,724,46,138,740,410,404,589,363,620,117,668,350,93,941,662,124,461,848,445,576,928,849,603,748,626,647,467,146,950,487,190,385,286,504,621,575,667,732,881,977,580,890,94,181,855,639,846,605,632,550,892,795,9,612,745,518,238,971,698,118,80,852,75,611,643,407,448,511,755,405,541,983,607,265,586,776,707,561,459,345,987,624,894,190,445,378,508,466,864,139,734,721,896,686,607,172,521,377,6,370,997,346,6,562,93,576,32,231,732,375,535,692,176,265,240,160,586,500,656,720,611,805,989,726,425,957,491,155,989,78,332,481,787,798,128,726,149,821,371,137,604,260,454,912,501,169,420,444,976,65,243,142,966,362,233,510,116,532,232,611,584,966,764,177,34,985,417,798,202,800,679,449,864,956,148,122,17,39,890,36,741,480,703,55,752,805,368,599,799,563,991,968,91,207,453,890,410,575,236,844,101,291,963,738,393,525,62,502,696,206,39,19,811,484,22,313,226,439,915,115,596,395,109,293,452,917,543,381,986,368,750,197,500,791,397,841,941,142,149"",
    ""101,311,979,117,217,533,730,827,771,940,964,230,884,785,87,144,783,159,145,112,96,201,324,595,883,339,944,529,884,307,58,676,126,272,335,462,149,821,696,755,229,650,918,643,932,181,117,128,60,424,333,767,568,761,389,480,449,480,814,108,229,945,566,664,848,1,323,819,513,754,906,84,561,264,926,776,576,24,265,108,730,657,863,874,107,737,687,812,17,649,968,737,482,784,475,330,919,337,321,972,901,417,326,300,69,190,820,69,259,32,862,953,91,785,779,154,704,787,49,316,255,970,965,741,914,963,429,346,104,948,592,305,178,599,828,876,927,29,999,966,300,436,199,699,721,689,724,41,296,46,819,791,975,598,100,435,417,340,250,335,556,124,180,384,705,954,578,104,450,171,231,60,851,665,743,485,215,989,136,902,215,907,551,720,89,367,542,560,950,234,503,629,174,16,432,916,517,854,472,871,130,361,897,102,533,243,312,47,235,89,735,610,539,459,17,153,64,740,895,213,825,951,542,134,640,397,353,318,481,403,337,813,406,606,804,495,907,139,608,299,115,298,417,152,756,276,485,164,264,58,188,739,80,911,44,279,968,836,260,656,730,746,829,166,706,608,354,680,304,748,248,526,723,176,545,989,899,272,624,777,48,856,751,781,226,259,501,756,488,555,919,84,23,975,62,8,628,144,666,230,348,89,597,507,56,815,519,995,500,710,166,36,213,167,478,306,732,321,613,174,913,181,281,442,77,21,863,769,43,753,992,795,149,17,936,122,760,168,131,533,874,875,200,89,438,190,191,18,684,60,788,281,179,278,527,146,132,417,859,812,336,750,959,774,55,954,599,614,301,776,561,448,759,533,872,783,479,761,106,619,475,867,463,191,219,266,564,928,229,845,186,498,376,824,805,831,137,245,540,150,718,959,118,221,428,177,65,334,333,282,17,284,691,554,881,556,527,536,416,565,681,226,262,25,101,853,738,826,336,487,708,347,598,898,179,528,930,499,374,121,416,519,630,842,214,854,274,532,887,799,923,696,147,917,461,248,197,925,195,770,438,923,419,442,218,485,780,69,91,645,363,109,897,452,859,87,797,212,390,19,766,874,201,365,189,658,823,986,311,609,787,548,177,111,888,796,950,325,828,187,128,868,554,752,296,765,976,71,826,55,856,942,691,535,332,305,872,590,157,35,770,760,954,8,591,883,107,912,534,29,454,941,147,167,976,50,47,614,979,974,651,25,272,419,470,429,487,24,662,706,855,718,904,602,947,734,674,622,848,99,830,833,127,46,157,810,332,830,194,868,39,921,628,590,395,329,450,529,250,72,454,592,486,582,156,397,506,240,238,157,703,369,275,257,307,789,414,650,593,749,764,341,374,984,489,258,785,411,304,718,28,614,354,463,80,129,474,937,65,309,615,442,834,819,819,946,35,77,487,919,2,821,669,459,416,0,120,28,43,469,283,927,147,956,966,63,687,458,34,348,606,931,380,286,101,243,428,727,937,252,731,601,820,404,540,67,407,338,130,395,563,928,774,86,523,509,473,989,302,566,119,809,838,650,419,236,417,586,147,817,591,836,113,394,178,577,221,779,516,603,626,309,790,508,33,45,517,515,748,917,936,920,54,120,343,744,1000,943,629,66,592,373,706,839,35,754,709,757,666,826,4,265,542,478,492,9,530,736,922,920,331,614,650,19,435,33,998,285,832,669,244,234,883,853,46,678,615,159,309,72,87,687,761,233,809,430,387,871,731,724,663,589,952,938,564,404,303,459,988,807,695,40,220,387,451,625,262,386,789,49,326,931,934,147,471,959,394,63,369,962,308,544,557,428,447,940,997,578,323,165,920,94,566,917,462,664,736,207,241,648,6,155,607,429,495,872,261,80,360,567,185,890,190,158,473,65,762,189,442,383,586,935,636,104,573,47,843,530,259,394,117,64,723,642,341,588,42,563,455,951,265,203,944,447,100,329,863,520,291,167,571,689,74,579,385,821,532,203,179,847,264,96,880,468,45,243,284,167,284,771,11,552,482,477,444,426,583,627,608,876,576,83,920,788,927,511,379,241,411,696,264,836,794,161,338,223,401,45,430,527,538,570,716,286,460,146,208,184,330,14,770,223,230,70,101,924,274,577,656,695,374,909,554,331,265,906,185,674,702,697,288,531,603,377,714,859,897,285,72,933,494,646,505,668,888,321,62,525,719,565,357,108,347,717,255,881,140,291,358,69,202,323,894,904,922,957,439,602,780,658,593,231,283,287,423,224,398,558,268,672"",
    ""771,247,404,969,466,632,597,836,130,8,395,391,412,121,785,44,960,621,808,620,200,562,610,268,559,55,378,797,584,99,665,951,136,73,358,358,695,483,998,520,847,284,709,591,96,725,525,72,556,570,196,968,685,238,263,439,713,442,308,453,9,884,944,970,275,492,641,460,83,258,892,611,555,732,261,296,845,278,767,180,56,751,962,621,515,204,939,74,721,412,40,619,156,343,841,521,301,167,860,439,860,71,754,599,183,423,138,370,995,126,513,703,931,188,561,542,883,60,546,91,716,793,97,518,80,300,296,43,531,229,325,562,758,272,226,41,200,606,661,247,747,56,69,9,689,825,934,669,416,484,304,66,196,942,506,435,711,295,585,438,189,268,372,344,829,714,99,536,845,609,319,221,604,236,619,928,930,413,429,760,177,924,227,609,549,495,773,766,863,312,784,55,344,583,807,47,541,972,835,12,838,731,688,359,574,611,333,708,174,282,578,741,924,174,582,441,421,555,808,292,65,507,701,263,158,582,183,351,869,510,598,715,447,365,728,115,862,851,757,963,383,488,894,322,185,934,865,281,581,926,266,494,902,6,40,521,756,616,893,314,780,256,772,600,453,98,125,906,807,310,5,409,418,632,383,966,548,506,688,605,441,149,343,742,205,179,958,131,224,686,596,499,914,184,414,798,44,103,331,624,168,21,84,450,609,174,672,158,201,93,276,966,816,370,463,169,295,109,192,786,839,73,838,237,218,731,411,579,339,377,95,110,789,27,448,906,658,382,836,628,966,855,741,779,134,803,369,190,577,295,811,990,186,361,462,416,345,295,254,512,170,975,987,379,301,102,131,773,934,389,724,496,943,131,742,864,170,106,909,489,920,162,502,577,725,204,951,664,827,902,890,269,513,990,936,525,899,451,677,182,901,584,402,827,556,216,919,631,890,500,308,508,950,185,901,864,521,661,896,132,955,228,968,784,590,355,31,525,518,241,939,932,138,562,893,792,739,242,700,280,199,969,525,533,516,278,588,128,230,107,264,491,270,997,806,198,399,537,673,732,240,920,685,474,629,37,268,152,979,796,750,694,168,481,919,476,344,285,535,910,543,99,839,550,855,67,698,639,183,741,87,462,376,484,961,832,48,835,78,395,896,866,643,546,720,121,927,180,952,362,426,155,962,268,572,997,251,795,537,968,812,762,803,274,57,965,712,469,445,63,385,583,125,919,572,506,276,894,887,179,730,616,788,384,791,422,572,34,495,468,580,438,848,553,415,169,566,978,639,335,749,720,57,840,613,314,154,888,505,336,111,119,925,762,480,104,427,808,504,816,702,478,919,113,963,479,614,369,325,515,507,143,932,167,359,246,142,789,322,385,918,877,790,980,268,58,260,619,15,261,573,695,374,421,867,73,17,131,721,768,276,937,956,356,351,914,948,932,550,142,45,561,20,597,835,120,0,2,813,963,542,491,533,958,773,883,472,355,592,640,305,65,263,639,495,948,826,320,959,983,310,41,514,108,437,933,680,703,702,233,793,964,478,405,547,270,161,818,944,160,678,296,191,340,926,68,966,927,963,613,594,538,311,704,679,58,866,162,248,926,82,862,230,908,58,757,244,713,799,833,949,597,470,916,691,586,611,766,452,14,499,404,885,76,134,150,593,892,454,556,126,22,658,870,312,235,490,479,982,764,693,927,56,142,359,211,422,731,71,555,694,317,515,799,363,722,200,746,620,681,661,137,165,213,316,274,697,679,435,181,211,354,632,235,927,936,350,3,611,711,650,479,280,469,136,888,319,751,344,781,83,180,160,499,969,385,583,675,751,368,854,958,644,218,494,707,636,278,442,12,976,406,421,664,112,185,783,954,476,199,911,75,334,96,19,765,709,805,408,469,491,58,994,339,146,333,210,619,392,947,840,176,261,147,88,934,593,672,164,767,638,154,516,777,315,722,788,930,702,382,113,934,491,232,627,194,996,579,111,641,157,792,211,34,991,118,332,534,740,514,589,73,100,107,157,344,648,791,788,879,312,62,483,939,251,919,820,878,832,431,484,287,655,909,415,957,68,223,140,863,59,930,767,876,370,572,361,842,732,409,84,897,320,408,38,168,351,693,497,252,291,220,944,768,188,774,619,215,896,95,87,650,977,368,104,892,1000,779,161,824,687,785,291,123,298,801,859,122,488,952,792,541,885,703,840,674,723,566,766,991,7,614,528,911,638,600,598,557,308,454,202,484,909,484,707,449,3,688,126,253,395,254,739,787,850,368,173,909,447,298"",
    ""644,748,137,201,184,420,543,795,663,126,132,306,750,952,657,919,911,909,55,474,422,813,921,296,525,839,448,761,80,730,80,880,940,466,306,755,727,893,160,21,448,30,928,549,36,396,670,667,347,749,216,768,265,894,337,603,457,182,417,951,74,485,543,701,456,655,382,905,131,113,973,596,718,528,551,705,499,138,974,309,743,869,747,620,751,415,216,739,384,588,513,135,252,108,829,809,5,209,682,5,607,474,790,195,394,17,955,350,668,592,377,871,123,510,594,670,54,914,665,814,774,937,713,238,1000,849,373,488,979,81,967,72,279,336,225,906,347,926,561,853,235,438,278,160,796,179,934,151,91,420,101,330,365,464,760,446,590,534,902,415,467,654,203,613,224,215,583,124,150,641,90,641,886,534,818,71,239,624,385,908,420,866,448,646,261,424,247,661,704,219,354,94,88,731,555,337,954,44,531,170,4,780,145,833,636,173,268,602,18,719,707,844,369,775,27,602,127,23,958,384,649,207,231,577,478,106,546,361,371,588,29,69,339,76,524,378,967,401,611,197,989,667,796,328,433,980,385,795,986,322,828,873,290,382,374,708,378,757,223,489,261,68,934,230,612,467,66,156,787,242,197,204,886,9,889,227,686,321,112,195,222,760,117,292,911,464,805,394,470,289,932,418,588,761,568,464,667,725,192,143,904,658,661,285,116,882,329,897,748,535,994,745,366,467,221,887,150,465,173,708,160,620,465,512,911,188,131,86,803,100,656,996,440,72,212,134,976,641,507,445,803,171,747,296,688,466,955,500,219,116,343,217,316,247,609,509,331,563,955,748,662,331,913,757,791,531,786,297,106,128,477,485,83,431,255,960,391,448,373,177,431,462,157,736,253,307,861,804,490,600,623,291,85,323,210,652,709,948,108,549,581,806,511,591,524,34,772,817,780,108,809,833,428,144,975,216,431,735,182,153,632,887,207,222,972,339,288,16,598,468,865,273,432,101,616,247,634,61,750,847,600,871,985,167,811,506,554,402,187,616,514,129,906,841,554,8,526,685,448,724,62,834,261,288,286,309,656,91,75,775,171,384,229,591,387,180,526,282,7,534,483,460,988,779,860,530,899,325,14,704,397,323,22,320,525,776,293,915,960,828,290,618,450,933,288,543,328,788,815,11,822,840,669,58,92,159,597,178,694,123,877,886,599,67,516,651,635,795,880,605,660,460,484,397,838,189,143,815,412,927,914,251,1000,855,738,22,152,979,880,191,235,713,992,733,38,881,987,291,704,28,317,906,954,136,710,334,526,551,250,765,401,864,438,100,200,76,858,370,507,549,31,560,63,680,12,380,127,882,506,116,144,838,415,674,430,256,343,83,161,828,396,444,818,395,530,174,437,412,143,579,979,156,11,668,548,257,73,646,38,631,212,847,517,472,285,243,115,345,478,170,550,891,851,57,560,28,2,0,157,992,949,225,337,989,594,294,660,688,345,913,834,401,454,813,470,325,130,377,462,451,115,664,628,165,601,437,411,215,430,436,677,505,817,595,378,13,953,544,349,332,488,654,281,827,581,177,647,942,647,692,489,436,94,952,831,457,919,245,104,883,507,619,793,137,827,265,236,137,390,785,976,584,984,484,523,7,490,587,809,193,914,618,156,901,548,203,735,897,81,83,510,317,787,508,932,920,705,916,391,995,266,424,493,990,83,536,230,818,60,401,378,728,161,59,94,963,863,589,83,781,655,929,400,731,714,578,502,527,962,772,602,129,649,811,860,756,705,491,297,253,407,379,757,947,20,762,438,132,931,76,42,888,763,886,571,384,371,939,997,539,667,825,726,873,775,590,322,800,346,720,670,423,248,783,575,167,312,612,563,403,250,92,563,267,33,233,147,410,896,562,376,401,895,217,463,869,271,333,506,129,382,504,764,674,197,624,757,493,691,202,207,882,32,34,818,884,519,3,687,22,75,171,857,607,838,848,302,720,686,62,116,989,705,567,547,798,664,298,310,745,460,883,10,861,529,351,807,428,52,935,279,402,780,636,990,178,889,510,208,153,515,337,728,781,909,642,190,478,149,410,204,318,398,544,575,492,664,367,885,518,116,491,857,123,18,697,557,665,358,506,74,119,917,650,895,56,288,32,537,293,62,124,986,554,149,540,731,46,195,399,269,328,296,724,538,927,317,904,589,874,377,862,753,340,873,492,702,537,901,879,855,610,415,573,948,574,725,368,899,886,88,560,817,547,418,990,728,471,581,165,159,964,961,37,890,644,909,872,351,188"",
    ""925,318,688,451,313,213,601,122,498,996,444,929,109,932,786,60,835,474,477,9,355,602,469,976,60,933,768,684,610,561,636,617,3,395,209,29,206,768,512,208,95,410,105,242,884,920,203,344,316,837,675,472,189,528,479,580,180,874,379,745,154,428,84,317,332,22,992,222,991,929,624,944,445,119,956,614,290,439,833,27,689,582,108,834,949,451,635,804,826,365,699,192,696,928,951,346,547,116,599,685,745,23,554,251,17,445,129,241,869,974,465,915,975,854,269,270,579,891,829,980,677,884,674,9,548,943,873,115,111,753,856,643,700,781,194,247,771,25,814,693,227,280,40,461,263,981,582,717,937,929,653,743,768,737,648,883,500,109,870,31,824,173,765,624,922,391,532,718,897,194,788,3,957,370,432,414,670,987,341,821,673,94,123,456,370,320,79,896,803,915,816,72,726,293,753,744,679,602,536,103,558,725,941,93,643,716,170,910,796,926,412,480,21,834,87,255,745,207,913,789,671,710,882,718,684,748,325,707,889,708,893,321,673,178,378,51,673,501,598,266,582,244,325,659,121,100,303,117,600,265,37,843,550,435,998,770,10,850,442,889,364,695,133,266,486,74,574,544,564,903,445,375,79,809,852,982,619,436,892,828,903,978,55,182,124,859,495,835,938,474,83,609,377,500,509,78,30,704,105,65,62,14,430,242,933,8,522,453,198,307,430,275,645,100,140,826,234,950,72,249,628,507,136,351,614,742,176,802,877,706,947,796,300,730,533,515,466,797,552,182,247,429,247,73,679,128,794,398,486,746,875,517,282,794,620,969,441,760,301,871,156,858,905,413,796,724,702,881,999,59,272,954,626,4,761,712,33,417,99,993,701,91,822,953,845,151,347,239,527,531,563,940,129,489,480,648,942,945,160,223,279,116,103,611,565,950,396,489,542,708,294,374,745,174,907,873,774,835,595,544,519,29,411,149,685,110,431,108,846,814,280,221,915,882,146,617,203,687,867,102,855,568,804,436,608,227,11,857,489,649,556,324,119,201,104,113,858,122,969,89,868,827,68,276,156,518,105,83,883,131,933,836,959,229,206,426,402,993,445,928,581,369,228,466,541,871,407,515,620,937,484,620,461,683,800,575,128,561,400,224,779,21,11,982,665,545,841,329,122,390,860,814,399,594,982,917,506,744,802,823,348,322,904,444,310,504,730,970,725,732,593,106,77,476,187,276,942,866,742,796,925,479,655,572,257,837,779,324,921,872,163,216,562,18,657,17,123,192,323,247,150,555,763,653,658,253,978,833,106,288,441,382,564,976,678,212,23,5,340,653,164,580,429,946,16,395,604,887,366,95,847,810,220,412,303,63,735,356,265,368,394,231,434,714,521,17,530,571,157,543,470,369,210,765,105,281,619,881,771,59,436,623,653,993,848,966,933,187,461,775,34,342,985,970,256,43,813,157,0,764,721,377,80,949,853,851,99,570,634,152,112,484,929,785,432,596,146,218,732,910,648,67,671,770,405,697,915,19,38,157,185,177,68,392,961,343,876,33,968,505,448,459,788,160,415,87,74,827,61,992,92,868,990,234,302,950,336,912,957,95,251,989,295,621,59,240,964,507,910,292,277,751,452,809,280,265,495,456,941,919,144,856,825,50,206,194,556,49,81,280,562,880,773,676,433,879,973,545,190,114,640,526,128,155,711,341,870,209,298,979,841,39,90,14,665,702,475,458,934,929,492,959,583,753,401,205,96,155,473,321,178,606,930,768,94,441,326,959,690,162,899,721,767,902,718,631,852,48,752,128,383,383,49,487,337,187,957,533,520,228,552,365,946,809,1000,110,68,166,315,842,815,863,656,747,519,790,302,69,774,589,771,565,271,990,595,536,880,872,694,341,450,573,640,391,89,482,772,493,946,649,467,216,500,918,835,31,947,637,680,666,119,280,888,248,323,174,527,2,703,877,154,296,475,340,864,873,267,309,749,99,235,630,633,59,229,47,326,139,317,250,441,762,973,418,818,521,657,195,115,980,930,479,842,356,397,642,67,631,858,333,899,752,424,1,302,752,131,231,129,254,329,114,448,126,574,322,481,818,191,385,670,81,870,625,712,313,378,248,245,985,693,103,232,41,119,528,981,370,859,462,300,915,425,837,617,651,840,689,628,860,249,985,247,718,254,429,347,327,67,966,290,705,726,447,51,247,90,99,796,651,382,955,588,738,133,853,230,494,625,227,219,95,854,319,798,292,968,60,305,102,301,409,662,471,656,183,387,725,313,156"",
    ""761,828,572,589,774,53,31,296,536,242,154,350,136,600,151,467,213,376,829,770,759,978,550,145,706,191,616,66,221,220,613,399,181,572,499,420,681,187,846,914,818,689,526,978,308,18,576,525,173,607,778,703,568,869,331,440,824,996,878,980,304,29,517,230,402,30,134,766,101,997,846,37,720,772,312,986,610,22,451,175,606,232,777,330,395,922,423,262,479,818,788,429,442,864,400,754,372,477,825,81,23,264,465,501,817,374,941,28,647,519,637,113,419,812,341,346,554,989,896,542,190,780,938,355,730,59,757,177,319,61,778,599,416,313,475,839,130,266,721,63,732,717,443,665,52,850,542,199,325,836,237,909,825,482,311,432,204,688,106,287,763,429,649,173,408,563,515,793,366,187,447,914,229,871,642,36,679,437,80,291,819,352,677,597,309,175,993,172,255,371,344,785,930,44,793,424,703,528,788,658,4,370,959,91,969,817,189,955,23,515,94,21,974,893,826,90,873,264,956,131,543,248,127,929,604,627,342,124,386,187,910,817,611,907,719,576,504,696,418,159,564,158,251,362,93,861,141,159,838,119,1,966,82,520,794,796,647,700,699,108,940,178,648,669,591,832,9,667,158,779,536,392,333,895,346,296,166,923,350,274,62,177,243,761,387,124,42,678,625,168,900,207,349,569,559,955,722,91,379,21,748,778,338,97,669,858,173,480,252,952,607,694,157,6,39,759,822,933,413,670,485,93,738,65,287,674,704,809,167,972,72,516,764,601,441,485,395,905,761,15,443,114,822,453,460,593,499,840,542,99,886,470,733,950,304,309,508,79,984,793,336,786,119,719,13,373,217,339,52,196,226,301,782,511,712,575,319,329,832,972,136,376,346,634,256,921,238,711,539,1000,490,633,280,828,230,546,211,98,336,947,43,303,422,316,602,471,756,216,515,322,753,507,901,491,535,283,247,592,233,210,26,365,420,464,276,58,337,405,155,716,355,416,981,267,581,801,200,860,552,246,32,294,309,180,67,961,8,319,134,434,757,530,504,836,307,280,985,309,176,800,61,645,356,706,358,400,490,903,377,625,514,978,277,942,370,535,597,86,19,882,253,464,210,195,3,371,527,939,388,207,589,861,593,916,598,610,955,364,401,585,32,188,107,384,843,53,974,501,181,603,228,365,328,826,272,704,411,364,110,953,906,22,933,302,423,442,644,135,231,51,469,968,482,630,386,285,629,286,342,550,225,394,288,997,450,592,727,115,494,161,534,892,939,285,170,765,363,170,87,120,841,134,727,362,695,131,836,655,701,383,289,249,743,950,630,357,516,933,988,262,70,145,274,913,387,896,181,358,192,946,212,31,408,138,153,680,831,266,580,208,426,572,151,625,103,170,129,248,250,238,937,994,51,583,593,379,943,657,338,598,153,807,452,516,704,474,107,818,260,727,5,754,654,470,172,469,963,992,764,0,283,628,859,464,747,825,67,366,825,708,538,6,280,92,346,900,471,373,241,473,707,371,843,120,881,470,669,986,450,320,332,360,486,99,741,203,711,229,808,916,51,75,491,268,157,422,308,61,831,588,155,450,957,70,386,105,9,828,241,737,449,112,658,216,288,674,679,888,199,640,998,419,407,453,406,295,88,1000,402,826,267,410,685,292,445,319,234,215,490,233,258,55,524,371,113,984,694,502,194,239,373,459,741,355,599,868,169,660,597,687,406,770,906,510,713,108,910,114,277,360,124,756,897,453,228,965,481,762,147,384,420,624,922,427,282,316,529,306,780,48,684,66,700,601,233,372,739,71,410,430,943,642,573,400,827,215,668,235,577,658,11,797,75,440,402,312,764,775,738,257,849,325,658,884,736,670,394,371,653,497,193,342,924,243,864,243,434,888,7,636,696,162,735,744,559,461,666,524,27,788,374,446,564,815,981,11,837,928,844,403,50,581,643,352,640,59,495,139,534,526,913,539,82,669,239,82,504,264,786,281,236,444,88,745,125,87,878,904,110,654,126,567,740,947,839,485,12,439,656,192,57,109,866,692,538,458,808,739,427,525,178,735,500,123,425,690,219,391,703,878,71,582,159,846,203,924,138,428,517,659,62,391,900,599,377,966,612,627,17,26,436,694,246,840,907,985,668,995,373,446,236,350,671,790,532,702,659,2,396,213,945,253,902,706,873,961,808,451,529,298,938,883,333,638,992,437,467,979,818,220,593,538,672,679,865,939,759,679,840,531,440,348,444,341,676,161,895,764,814,86,559,879,648,344,872,915,448,654,706,974"",
    ""286,500,967,106,735,823,163,953,855,984,203,778,21,147,141,384,302,66,640,149,936,273,306,925,852,378,77,520,899,204,115,763,536,701,285,411,568,350,358,617,398,147,138,82,929,541,967,661,667,335,150,533,545,821,108,104,404,36,166,486,130,920,322,704,228,247,47,255,20,505,59,780,679,370,241,62,955,211,904,583,143,43,246,636,868,110,984,328,239,459,886,38,993,954,769,29,235,810,65,666,284,191,775,41,933,275,911,692,632,650,766,472,627,14,782,328,335,402,798,873,519,542,969,415,766,617,911,896,115,423,616,461,607,789,468,114,722,593,274,446,629,279,105,993,463,69,979,688,240,573,859,232,584,36,858,753,641,43,493,567,815,551,922,722,879,831,330,319,496,968,223,930,427,943,615,563,144,96,761,868,858,464,672,366,926,236,953,835,133,945,846,286,805,38,38,759,412,396,574,104,434,34,443,894,193,409,840,190,718,350,230,742,619,880,190,834,464,950,898,629,168,563,243,830,343,785,644,528,700,629,34,636,727,486,503,523,384,407,82,845,671,152,49,287,419,542,545,101,806,762,518,599,613,546,274,328,879,384,604,637,167,438,995,874,247,187,198,582,323,777,261,305,545,138,848,114,190,934,178,619,247,228,900,873,680,391,711,947,853,320,43,641,587,5,382,513,722,401,844,224,154,514,616,473,97,458,281,851,499,3,985,691,57,882,688,935,6,290,566,840,530,880,249,83,107,515,586,226,873,415,462,314,227,144,215,45,559,506,528,17,238,353,135,622,595,361,661,220,195,149,237,705,591,583,114,938,197,779,843,559,221,437,377,520,313,782,113,437,141,941,95,909,270,321,589,784,80,326,546,346,981,258,596,494,385,465,227,755,838,284,671,436,435,151,241,993,261,17,295,745,113,623,594,251,426,409,683,531,978,258,356,24,66,330,627,194,759,322,352,650,187,531,906,353,268,133,390,704,166,703,922,504,412,750,605,985,751,599,470,566,100,175,43,483,395,495,480,684,808,959,632,416,112,27,669,846,608,773,422,973,729,163,807,167,299,650,92,705,676,780,523,548,51,305,627,916,669,395,567,452,352,513,756,216,969,305,231,772,526,603,53,223,500,895,806,440,884,599,48,46,375,474,942,493,325,8,107,986,845,35,865,488,788,736,755,703,373,131,43,78,159,321,788,23,604,170,539,729,365,274,908,797,57,940,831,645,423,484,514,147,983,322,119,643,123,765,604,109,153,345,923,173,409,892,111,709,432,118,808,598,553,45,371,937,219,4,355,82,549,504,249,410,679,309,86,414,955,320,325,171,56,835,301,330,126,348,682,480,884,879,870,72,644,385,148,493,966,534,571,796,502,414,622,847,703,502,269,966,773,180,812,600,720,885,192,111,505,973,699,817,730,437,508,706,708,36,429,318,633,320,959,648,923,405,76,283,542,949,721,283,0,664,657,471,953,270,401,461,390,23,974,733,727,828,899,952,406,286,362,677,650,247,88,159,573,772,531,392,500,63,679,43,694,801,225,198,497,84,999,48,24,493,170,467,518,426,720,938,576,370,491,863,90,261,684,491,414,927,717,323,305,740,926,712,90,245,705,931,105,307,619,136,464,708,752,646,233,507,681,132,147,913,582,154,740,799,511,979,69,610,418,290,716,92,532,85,913,883,781,344,919,174,858,737,533,614,560,85,100,863,348,162,877,292,454,698,529,914,77,144,7,382,402,861,537,503,240,339,578,515,482,150,394,280,296,462,813,843,931,771,217,958,184,162,457,585,552,120,532,857,730,376,74,503,609,541,671,232,401,70,684,513,715,19,774,13,570,370,307,59,958,735,231,700,859,607,9,589,172,336,468,358,260,756,611,272,344,5,764,57,481,5,567,125,172,127,38,538,439,634,569,254,106,115,244,594,690,820,887,7,511,81,740,883,824,907,854,882,300,74,892,306,60,445,359,78,926,547,184,57,765,95,170,856,308,630,189,703,263,826,513,345,712,274,129,597,849,844,671,129,647,193,169,673,614,904,150,181,135,800,285,921,235,923,923,433,680,506,687,473,214,315,206,439,194,739,645,555,281,418,612,760,318,454,935,316,44,425,263,564,442,340,625,60,806,103,551,668,435,146,98,863,820,21,50,167,667,519,351,509,169,380,182,89,38,358,57,429,969,227,971,90,687,199,325,134,744,873,165,833,595,690,112,217,279,895,30,108,344,758,211,693,937,905,414,872,466,200,299,704,309,435,701,460,985,614,503,299,260,883"",
    ""275,276,206,322,829,430,389,103,230,718,567,677,896,945,107,475,382,369,747,237,358,877,511,364,120,693,337,996,604,814,517,653,654,829,55,884,163,985,450,550,889,714,361,516,402,661,886,164,145,929,613,567,121,853,240,463,50,963,625,246,563,889,73,397,853,649,940,531,808,138,190,629,666,114,896,62,144,422,467,84,861,430,773,259,479,387,688,131,770,911,359,801,933,802,271,21,98,958,136,936,573,345,832,728,654,636,813,303,460,686,402,918,830,500,387,718,593,295,848,127,419,445,972,557,940,863,778,598,379,401,172,157,867,205,631,821,905,193,85,895,574,96,452,751,925,136,713,989,465,632,287,34,147,270,372,181,983,487,324,922,621,958,885,373,427,365,998,680,132,157,190,308,766,222,221,932,359,611,667,187,938,643,881,939,721,231,626,872,154,687,304,219,754,707,678,927,254,33,664,420,775,221,825,484,46,782,542,788,349,442,564,89,237,114,953,751,989,205,960,189,722,700,106,130,541,25,220,230,758,360,695,246,296,743,537,679,549,103,477,98,61,625,743,488,372,9,520,256,611,383,334,300,527,136,811,640,954,569,909,930,318,764,228,704,426,100,693,234,956,630,277,327,433,558,626,52,324,566,628,319,335,522,451,379,510,50,565,692,387,653,307,778,789,599,619,834,411,239,935,574,134,239,630,649,482,146,656,491,446,54,805,171,182,247,223,579,642,245,44,314,176,559,722,588,431,4,489,823,424,217,757,273,527,74,550,902,217,51,783,757,86,741,552,742,256,900,348,996,664,231,759,220,241,53,882,400,487,723,996,5,660,492,321,827,163,527,455,674,82,820,109,968,479,944,230,668,946,12,691,790,68,734,424,285,953,156,487,183,203,751,509,248,64,42,448,378,64,751,4,295,306,517,308,418,608,579,846,492,573,667,449,458,451,925,66,694,799,672,104,205,291,467,53,705,780,284,586,593,750,928,955,546,836,929,718,331,52,882,238,535,458,952,694,143,360,2,59,688,175,555,649,353,569,771,537,360,778,320,20,958,350,79,725,865,786,500,613,28,720,227,73,233,570,931,484,675,209,699,632,282,184,444,757,356,159,796,698,772,626,400,630,940,191,234,936,222,392,79,314,884,830,857,665,821,454,147,284,130,119,351,362,380,605,876,940,974,323,759,375,370,58,479,372,941,470,184,105,853,566,173,695,148,558,906,527,347,2,526,366,246,414,595,389,938,87,282,265,609,357,245,631,86,297,198,166,410,730,195,86,794,449,977,796,561,546,830,600,744,83,926,837,107,506,392,434,771,480,28,7,315,513,177,420,739,637,556,981,930,585,55,898,896,24,719,856,745,602,157,965,983,342,457,122,717,182,624,273,140,906,67,533,538,440,458,936,403,192,60,586,643,95,746,417,967,959,54,983,133,11,338,497,960,112,327,143,927,491,225,377,628,664,0,251,288,442,642,221,706,972,11,761,773,23,296,928,829,859,185,237,452,398,417,410,819,830,431,755,996,247,959,885,555,329,612,34,151,345,141,418,249,29,873,166,165,239,963,871,47,983,238,981,960,704,220,953,938,287,191,370,37,597,487,473,671,534,674,103,601,614,520,862,12,723,599,620,589,891,857,296,862,471,196,349,100,902,584,537,559,690,112,978,64,766,719,229,632,348,259,738,96,892,305,836,310,766,929,741,841,243,950,304,130,616,373,199,43,576,875,797,187,906,218,322,572,88,875,315,823,566,302,89,6,685,82,773,227,920,257,141,398,446,966,454,582,802,639,342,859,519,888,52,221,495,791,571,15,184,147,712,657,490,351,315,969,15,284,550,684,877,983,609,633,611,303,65,906,840,794,897,93,119,376,630,173,841,882,475,182,147,915,573,244,773,823,618,559,327,489,420,63,720,990,383,741,488,350,731,270,651,175,944,322,777,639,637,912,917,114,28,128,665,732,76,641,369,663,179,998,104,320,781,128,464,930,298,535,71,738,497,448,874,744,923,162,696,922,137,284,724,319,875,700,123,42,507,943,735,799,367,359,674,49,765,348,30,416,910,956,724,700,141,771,718,53,200,886,560,260,118,667,410,376,654,484,995,415,492,10,430,718,187,276,525,103,894,937,845,39,871,361,711,527,793,440,896,939,791,146,543,381,232,162,598,549,638,425,653,243,528,176,389,367,702,667,496,200,245,619,520,93,740,355,777,417,408,297,301,239,294,440,618,353,652,833,378,162,558,959,354,350,247,347,700,832,225,787,725,647,986,593"",
    ""297,191,595,482,644,75,26,928,680,795,907,102,200,380,685,122,496,967,489,289,741,967,370,323,330,673,287,302,25,793,48,848,42,823,602,573,891,52,705,517,496,914,181,679,889,670,454,832,94,205,530,232,371,878,56,818,697,517,560,138,271,826,329,162,769,906,604,343,276,710,356,642,198,547,460,537,659,775,220,97,716,1,516,123,187,227,490,866,76,409,529,462,652,138,366,57,283,43,671,864,13,439,692,918,239,297,908,166,3,648,731,380,188,283,811,467,513,956,815,443,180,222,894,264,362,594,705,196,833,748,421,960,649,135,603,803,217,627,156,716,180,723,124,473,162,788,569,221,180,287,667,116,31,98,938,810,333,512,205,442,54,551,78,398,242,523,745,533,429,427,574,679,638,941,901,662,851,371,530,206,607,773,160,944,908,65,865,935,540,286,860,475,443,692,640,776,711,152,325,686,800,840,658,11,609,65,866,364,240,971,825,641,17,4,499,848,784,693,774,235,106,420,574,666,622,703,753,319,216,304,521,414,47,250,903,554,279,670,5,553,721,194,365,193,470,38,122,407,521,69,825,435,159,675,442,361,105,551,664,107,436,45,992,188,313,883,951,308,150,764,663,994,835,629,120,537,850,631,839,846,884,720,809,832,353,299,127,191,618,808,360,394,329,511,695,687,136,748,850,933,299,397,677,23,706,188,870,590,250,171,228,612,385,637,249,122,554,410,767,311,524,435,339,393,266,38,117,932,391,282,809,408,143,838,591,983,278,613,876,35,298,404,862,599,979,45,440,218,814,996,703,976,834,406,363,821,522,466,559,385,318,953,74,335,696,242,22,819,454,812,447,853,533,672,909,757,714,818,667,315,822,674,696,119,590,390,510,247,20,381,504,743,172,532,199,266,786,333,289,862,731,859,869,917,212,319,529,176,670,586,514,145,222,656,777,492,805,623,549,920,354,263,129,243,24,977,521,866,924,602,225,430,454,562,831,525,970,388,83,566,450,905,884,923,71,884,812,815,905,634,23,382,132,335,60,624,727,148,138,919,396,900,260,216,207,400,907,507,666,788,316,484,961,921,72,208,858,756,610,289,568,860,657,664,978,61,91,588,676,24,667,551,872,923,254,143,219,631,404,296,710,863,978,673,741,240,510,471,218,45,810,759,764,311,696,544,418,306,376,675,775,472,791,522,279,590,732,825,621,240,469,499,563,810,840,519,53,479,969,96,210,723,462,989,471,549,663,489,533,259,430,539,570,37,273,924,854,703,690,868,388,2,885,243,226,285,151,87,437,820,466,758,555,357,949,777,530,966,240,320,730,603,831,389,569,239,731,233,837,439,733,941,773,67,903,126,477,406,882,859,143,308,182,58,364,169,644,371,67,907,857,806,607,472,49,964,645,419,413,215,770,184,853,131,743,464,600,842,954,882,850,680,444,341,75,147,533,337,80,859,657,251,0,446,559,783,318,430,505,753,114,970,341,959,915,433,413,759,228,282,395,915,717,654,591,437,436,855,896,102,653,316,698,118,119,186,823,173,665,870,831,648,599,75,393,914,766,957,944,392,931,402,995,597,97,675,349,820,655,506,689,957,824,901,797,413,382,263,768,229,122,613,276,803,256,356,819,617,138,667,761,504,518,672,187,240,255,592,132,369,118,226,222,137,822,941,44,317,550,166,916,27,888,404,289,778,167,12,947,889,760,498,127,453,483,566,441,873,535,426,160,306,628,807,705,139,251,199,75,808,330,586,719,209,741,558,269,936,608,539,988,681,409,874,637,535,393,679,878,457,535,881,981,260,387,635,557,986,962,152,916,149,259,869,623,865,41,877,224,340,276,858,585,193,892,204,762,896,741,472,992,243,670,932,189,276,838,507,237,150,181,303,135,604,63,25,309,485,953,809,51,667,614,240,588,606,83,277,625,967,38,556,844,166,314,300,314,147,53,640,579,926,885,931,973,984,256,953,617,261,847,227,465,581,567,603,220,665,834,179,155,200,886,152,336,883,573,426,187,452,975,289,571,853,712,59,588,145,367,352,149,955,973,974,64,979,895,811,499,569,334,640,535,75,987,173,834,838,428,818,788,230,743,555,509,20,707,318,168,628,586,423,222,99,121,100,38,605,163,869,842,877,506,765,228,564,50,896,467,704,781,505,946,819,65,54,173,757,295,37,811,24,134,639,436,27,2,137,306,830,216,941,211,672,498,339,835,537,832,202,186,697,298,828,755,389,139,163,226,986,843,933,774,56,940,627,749,644,51,271"",
    ""246,218,5,542,115,619,543,855,931,346,724,220,46,128,297,722,983,253,720,836,460,903,798,753,999,67,838,87,416,234,146,460,784,127,298,921,798,657,691,907,67,775,843,543,211,407,51,790,650,12,755,778,109,851,921,125,511,601,17,770,938,322,50,496,354,257,800,350,270,145,727,686,45,276,73,42,756,909,274,438,713,349,138,798,122,825,622,751,120,267,39,553,670,636,895,809,721,684,519,596,36,212,899,866,768,972,164,885,902,61,874,41,201,531,26,457,597,740,553,748,3,175,829,829,9,369,173,902,754,43,900,19,474,692,611,917,463,950,966,556,747,132,21,352,558,484,33,662,315,749,140,227,355,680,116,512,56,691,591,162,373,721,701,974,424,445,408,631,747,510,972,234,825,340,398,521,727,601,836,591,410,65,220,58,271,712,502,44,587,531,502,915,631,905,813,709,317,38,379,825,533,457,345,90,937,138,413,738,759,455,338,53,706,978,933,649,808,219,170,585,108,128,811,139,754,408,338,854,307,348,260,160,763,433,432,552,294,442,382,916,154,580,656,274,888,301,633,608,57,770,17,287,226,530,339,15,568,946,108,382,241,440,603,751,908,175,259,796,653,360,398,813,943,769,123,49,174,29,59,2,434,2,872,829,692,687,26,757,154,983,872,873,587,44,156,601,226,964,791,901,505,12,586,385,797,994,236,990,231,17,51,410,246,623,196,326,880,676,716,505,743,605,192,739,908,482,965,83,440,950,331,97,80,159,276,16,40,662,119,701,72,924,210,725,622,680,484,163,502,564,606,200,165,20,970,343,157,800,903,560,705,689,542,674,130,384,837,974,855,103,855,219,858,7,283,273,507,331,938,434,708,432,459,422,46,8,989,659,603,111,595,315,492,164,750,560,701,593,713,184,145,175,738,813,460,516,360,551,354,524,207,980,953,165,330,111,51,768,367,246,280,124,441,668,295,793,799,807,699,521,501,754,728,999,503,713,500,248,100,410,359,907,994,103,716,691,919,480,467,699,310,275,787,417,468,904,919,432,67,910,583,909,746,336,168,716,569,444,816,894,643,139,177,4,441,216,951,770,673,169,236,552,512,347,572,411,269,624,997,31,994,696,629,580,558,652,527,739,823,596,430,750,594,636,114,672,314,251,983,125,169,240,10,37,812,734,492,373,807,325,836,136,892,800,585,397,731,68,739,570,508,684,878,489,257,992,757,54,822,628,168,160,889,449,934,858,249,232,585,807,739,761,278,635,134,231,281,338,16,731,321,574,223,827,930,93,893,588,361,152,457,834,100,553,350,679,765,793,670,867,67,125,714,504,542,273,949,441,259,733,135,283,328,420,475,291,881,325,490,340,796,287,933,245,343,116,770,258,615,358,290,657,918,10,995,897,184,883,770,18,644,440,948,720,736,659,462,156,152,427,760,635,393,479,278,956,958,989,949,464,471,288,446,0,664,858,119,754,875,334,368,403,750,767,292,11,204,744,186,579,390,367,482,160,594,276,852,846,164,869,494,155,920,205,530,872,764,473,7,804,793,662,792,919,228,821,264,312,172,246,955,689,888,255,870,132,887,444,740,927,505,866,198,608,580,984,607,281,338,791,877,696,253,109,541,890,384,224,193,700,671,520,632,400,578,49,719,803,433,286,289,201,596,62,307,972,787,95,655,416,903,860,259,293,820,481,520,857,271,87,14,793,424,199,769,29,512,797,281,143,49,426,498,448,770,165,561,282,194,728,697,317,175,588,206,918,551,523,383,868,714,973,194,74,924,39,373,860,179,179,584,461,923,643,627,294,419,432,23,832,93,542,910,220,251,647,994,25,868,602,46,340,771,75,422,534,329,729,562,870,351,277,769,279,110,910,514,790,584,510,64,660,69,690,51,190,595,349,562,244,497,239,690,251,358,342,599,417,692,264,759,731,21,40,267,604,290,428,459,190,303,15,832,969,661,535,891,667,713,472,343,696,493,876,726,727,129,109,874,259,12,16,915,130,536,433,294,97,243,437,49,570,78,473,454,947,272,252,260,372,657,957,556,369,70,230,350,738,439,985,426,416,981,348,180,843,378,233,638,815,18,525,42,916,546,137,574,499,766,680,373,655,537,489,379,921,872,550,698,317,143,63,723,597,924,192,135,517,70,183,10,651,262,230,278,322,528,393,80,258,966,271,249,349,143,204,391,9,282,994,181,48,325,567,753,313,862,757,896,84,160,37,329,641,810,362,559,136,904,369,594,216,338,313,13,462,520,484,207,672"",
    ""904,503,895,746,935,463,593,883,594,773,602,511,535,334,353,690,238,717,504,116,348,770,518,805,576,25,695,762,476,293,524,527,753,524,499,914,167,507,55,830,520,347,11,849,474,124,35,549,491,628,484,387,603,582,210,126,459,574,846,701,449,512,504,579,73,516,488,223,335,854,35,742,832,753,212,25,358,407,153,24,525,688,222,787,950,838,657,325,412,910,585,216,896,436,225,554,74,846,165,775,551,762,733,159,748,806,716,875,938,424,95,578,374,41,371,297,36,807,937,363,740,547,77,193,20,319,228,719,910,194,48,318,444,213,382,202,365,296,290,872,125,644,37,598,921,56,797,280,606,629,498,132,196,800,461,436,565,552,643,419,937,243,65,466,968,995,84,831,265,23,380,827,655,994,364,256,113,479,764,870,359,43,916,387,842,120,71,942,133,920,28,512,962,772,928,996,583,580,606,952,936,714,287,149,516,195,722,261,211,207,271,767,436,646,525,671,194,355,626,217,780,135,538,882,267,159,474,442,234,147,315,175,199,254,120,953,178,934,295,403,505,595,422,53,65,637,903,651,533,342,712,9,68,378,77,625,215,638,909,732,988,83,485,834,108,751,194,299,897,877,103,869,631,727,627,975,657,329,155,986,396,487,270,854,595,646,86,419,799,440,721,82,581,798,506,132,884,778,534,940,809,634,50,808,233,300,854,302,689,381,702,839,384,282,546,562,455,477,385,58,158,30,481,81,574,371,517,618,710,756,372,412,491,743,658,942,937,83,279,261,184,753,857,848,159,304,404,856,357,529,205,854,421,754,532,790,956,778,225,622,534,118,233,301,180,911,495,661,553,607,553,699,360,403,361,18,339,243,625,923,816,348,854,455,629,912,313,696,739,596,54,242,589,506,867,156,924,717,839,549,733,380,355,727,960,55,956,52,386,590,561,466,242,395,638,584,195,747,963,2,574,456,630,16,972,70,236,779,299,664,867,517,429,717,571,413,26,172,492,42,917,730,106,449,408,997,36,445,265,354,420,937,642,867,123,251,352,798,259,27,763,520,446,260,686,519,286,44,770,490,984,80,778,670,139,804,907,862,520,992,513,265,847,111,658,73,355,918,961,646,32,278,841,97,129,609,864,379,720,945,859,848,841,186,853,442,633,168,456,465,252,431,666,248,105,955,831,832,656,650,353,336,819,432,785,820,296,125,29,3,71,478,615,219,317,559,241,66,117,396,796,55,561,25,136,839,250,887,970,758,685,83,397,822,369,957,623,251,662,577,586,330,62,793,71,169,744,225,644,811,386,953,747,545,582,96,429,263,145,917,559,424,122,484,477,531,93,39,70,997,922,92,311,668,742,709,865,755,829,533,408,394,812,980,158,230,940,289,760,446,874,55,787,587,457,270,353,738,162,98,442,458,563,710,845,23,161,209,76,496,395,584,106,790,933,966,773,594,853,747,953,442,559,664,0,97,986,905,337,344,463,499,723,698,486,582,845,713,448,318,615,773,920,397,785,805,655,836,234,146,338,827,711,135,791,741,60,970,225,223,220,862,529,268,185,370,664,327,583,990,521,983,451,376,996,502,118,793,120,356,362,754,509,820,265,245,14,39,459,914,377,778,577,842,201,625,934,800,660,524,977,535,779,985,11,609,469,476,2,739,823,488,469,810,656,17,403,596,364,795,574,9,515,165,902,816,356,781,480,190,752,32,35,553,209,673,635,679,459,657,70,147,617,625,682,962,478,216,20,534,965,963,625,364,96,455,851,490,141,730,208,955,336,110,742,396,787,496,114,269,514,448,645,974,345,750,773,382,745,345,549,381,314,501,737,727,666,911,537,42,787,433,396,545,540,465,599,596,298,188,703,704,728,934,694,597,225,154,179,235,588,205,730,72,140,597,171,34,453,588,298,66,616,463,182,443,881,722,204,348,869,489,430,76,65,894,357,913,833,30,372,627,865,444,714,881,141,304,992,538,997,583,974,896,452,936,296,400,860,369,617,132,140,595,681,725,480,828,965,781,271,886,556,221,506,100,939,354,152,907,662,668,96,909,335,548,123,103,410,762,160,15,761,963,860,395,415,539,361,948,384,923,366,673,385,975,314,988,308,540,104,157,199,169,424,623,730,282,289,785,84,576,731,302,190,823,431,663,696,105,483,64,61,338,107,324,106,130,637,302,722,11,582,877,861,448,628,761,784,841,293,493,930,77,158,858,896,320,109,545,581,403,942,737,669,937,678,33,839,64,751,148,49,305,367,732,426,24,14,385"",
    ""24,751,787,391,807,196,847,117,105,259,150,303,366,866,357,676,182,587,350,171,520,491,659,614,938,618,521,501,775,377,794,641,583,892,188,813,723,274,899,79,163,855,927,121,579,243,348,340,307,580,624,742,475,732,211,268,899,325,259,614,669,735,942,460,381,128,498,708,800,953,271,622,325,301,802,885,473,927,892,375,733,814,166,491,179,817,918,33,138,690,202,693,314,823,659,956,815,736,485,710,252,47,80,732,559,459,240,497,645,243,655,655,895,212,199,968,423,414,181,838,342,509,724,78,362,506,156,261,500,389,691,926,644,105,743,441,843,296,384,331,230,750,348,663,946,735,816,85,869,782,455,832,369,604,154,43,263,778,841,293,894,920,465,75,129,624,162,570,258,444,574,760,298,109,976,658,763,70,820,188,245,608,462,870,571,710,607,831,167,916,300,778,799,22,981,375,530,714,759,772,750,80,189,998,249,905,887,386,248,629,396,61,149,300,724,928,359,650,801,247,13,284,20,126,338,83,136,629,230,750,887,865,590,862,659,931,16,78,271,944,189,681,110,904,65,119,842,324,737,562,827,613,643,535,171,186,16,830,55,2,269,732,130,885,609,728,579,957,839,532,861,355,24,24,497,871,42,488,76,586,508,24,732,202,756,38,565,389,929,340,224,185,564,703,998,743,523,292,33,952,712,851,590,274,781,531,70,443,952,319,98,958,664,1,229,15,407,3,333,985,117,899,870,567,714,167,188,806,908,177,114,33,274,434,252,488,169,483,544,919,738,203,191,448,373,618,232,297,296,37,50,886,16,786,831,843,181,388,177,402,618,57,240,534,159,835,651,121,296,656,669,75,617,544,672,123,997,596,287,719,668,550,741,317,25,937,258,919,864,576,15,942,25,544,411,558,579,728,327,421,294,972,462,932,740,377,33,879,887,477,558,481,856,273,595,745,252,135,937,717,897,842,175,339,83,985,905,746,242,803,609,354,831,688,639,730,100,671,745,811,464,695,631,419,999,337,870,33,965,881,467,640,526,523,210,480,204,155,985,846,160,936,359,584,965,597,280,20,828,661,611,742,284,859,243,729,68,197,760,571,708,118,579,598,895,464,224,869,299,971,822,459,544,673,406,845,469,62,736,30,905,441,588,444,15,251,899,585,376,174,328,517,61,915,27,224,283,911,310,421,520,303,153,957,652,763,808,146,553,52,297,136,836,245,821,867,83,693,557,74,146,133,924,217,655,308,829,537,641,94,682,153,903,459,911,839,885,422,432,116,154,534,628,798,967,108,621,74,300,804,430,800,296,682,723,283,576,926,940,592,367,521,112,870,511,853,463,633,317,581,438,503,198,244,494,360,761,72,731,900,738,943,538,270,291,793,584,708,937,416,777,112,61,256,679,449,602,35,638,509,322,318,49,898,490,924,644,509,794,818,743,119,7,561,872,63,883,294,851,825,270,642,783,858,97,0,991,480,901,265,246,391,648,119,187,710,45,35,507,359,646,846,997,582,510,89,501,266,217,121,143,28,475,599,955,304,666,70,196,92,436,670,658,654,483,281,984,665,303,139,283,419,906,112,873,483,349,687,143,16,896,973,472,500,499,905,691,743,640,761,263,633,440,414,178,848,697,14,462,75,37,724,816,805,853,631,315,213,158,870,931,609,160,507,221,921,576,261,277,663,777,876,713,431,115,565,452,576,443,432,957,801,10,839,55,684,109,610,907,629,205,881,464,754,130,835,44,865,590,674,234,871,818,822,511,749,744,25,763,301,601,991,876,349,234,319,586,862,903,380,427,242,404,499,602,131,449,645,363,620,674,494,790,402,989,665,731,334,4,114,707,174,738,510,891,124,468,582,736,384,501,583,186,481,246,793,874,716,17,359,429,485,115,667,523,907,149,316,451,923,425,10,980,58,641,275,528,799,579,722,204,309,921,754,822,929,379,420,711,112,894,242,504,453,224,233,557,591,504,300,853,152,218,590,109,258,654,429,451,6,5,290,28,637,363,243,239,899,743,410,442,104,130,8,560,210,790,696,676,279,471,10,239,555,52,989,504,518,790,355,665,644,229,246,659,460,70,779,507,779,259,314,767,996,336,816,345,314,901,869,817,565,327,544,137,714,196,412,791,315,556,458,878,954,851,16,435,435,205,427,728,475,313,58,691,194,257,11,883,925,262,179,12,322,942,276,324,993,700,487,873,168,582,385,443,149,563,15,549,754,87,108,83,142,648,435,630,406,772,660,485,961,107,818,113,800,952,20,412,396"",
    ""327,994,47,529,283,760,648,45,617,546,442,585,258,16,159,805,303,582,154,757,947,579,195,138,56,81,479,892,613,643,185,529,438,536,831,408,205,686,999,529,352,130,22,300,910,513,832,690,674,921,49,111,4,431,410,894,58,210,342,14,431,90,594,133,915,723,98,499,720,314,639,587,834,52,263,831,535,30,138,579,38,566,490,895,771,221,394,878,306,657,978,388,131,834,57,95,478,796,621,819,707,753,459,411,701,51,98,406,157,554,465,998,637,381,175,428,43,160,117,409,79,130,517,984,166,294,931,642,621,530,903,902,608,372,770,443,780,855,925,832,963,396,936,292,959,853,466,249,442,86,255,549,119,492,110,614,557,263,371,886,14,442,986,578,210,884,638,594,22,693,664,886,35,903,859,223,467,884,381,519,43,189,204,124,780,746,121,570,23,116,696,174,166,796,360,222,704,243,680,544,516,769,93,275,630,187,406,834,421,336,752,288,110,129,80,74,909,937,894,145,557,948,385,945,191,761,798,766,827,153,873,513,256,517,802,276,462,298,571,353,357,259,756,815,390,486,639,12,237,739,599,794,905,679,782,180,961,9,566,308,442,61,230,645,787,899,676,380,881,420,805,634,818,117,316,332,63,961,260,211,208,69,311,67,996,378,84,132,318,139,223,338,64,362,967,43,943,217,364,194,762,814,555,926,594,244,108,501,903,613,630,410,562,920,606,41,75,530,120,233,93,936,211,896,408,280,776,919,253,349,325,278,695,536,908,292,183,219,543,636,218,112,583,308,617,945,226,554,850,382,959,700,234,763,247,719,698,870,353,838,675,965,638,329,913,271,669,928,531,994,410,764,573,887,193,301,377,268,304,76,693,154,823,622,852,551,414,663,863,49,541,550,966,648,369,368,948,586,830,893,351,735,67,532,176,182,771,863,523,339,17,95,917,901,575,582,249,952,72,721,179,113,673,661,438,707,694,220,58,280,177,502,240,2,261,299,149,79,881,545,643,95,100,238,846,229,143,954,742,847,532,666,560,203,670,222,253,931,430,757,967,604,96,833,639,390,233,904,332,368,78,52,978,737,277,795,404,908,450,349,92,274,923,88,568,808,315,709,121,81,433,198,567,807,164,246,812,379,336,216,59,1000,841,388,185,323,701,72,379,163,267,30,668,990,518,712,158,977,925,444,122,193,974,192,876,91,997,196,607,206,236,264,897,267,144,362,871,490,453,708,349,302,933,230,503,730,493,986,684,414,925,507,741,188,19,342,24,957,255,74,46,479,336,682,370,924,628,482,729,104,569,293,86,815,395,339,628,241,849,913,658,583,769,748,570,375,704,838,717,380,19,53,768,527,762,124,595,155,966,718,275,943,793,159,525,402,269,490,156,68,144,652,395,243,733,737,327,795,13,546,172,856,782,851,48,393,875,804,938,217,459,684,557,633,332,687,472,660,99,67,401,221,318,119,986,991,0,581,985,669,360,135,140,232,42,748,995,874,468,866,312,97,496,92,353,400,598,559,357,126,906,908,361,902,266,570,438,713,224,968,954,308,400,178,747,247,366,300,335,379,363,954,109,440,664,165,285,255,150,470,834,78,505,328,9,731,700,387,160,252,710,989,323,19,626,680,331,421,233,348,467,939,300,707,689,201,411,726,651,350,440,781,673,939,794,940,118,169,97,783,60,921,402,822,324,53,747,810,665,814,937,801,203,35,257,80,519,457,59,876,204,715,244,83,298,159,577,43,431,580,547,680,236,199,20,193,357,935,894,854,604,874,605,900,360,474,643,188,981,177,862,728,400,968,724,513,502,515,6,740,495,854,392,978,900,217,534,50,899,29,512,143,128,239,761,694,484,235,406,701,385,401,484,218,820,1000,988,407,388,949,652,132,305,230,734,95,183,83,124,220,429,441,889,611,726,658,303,954,493,353,100,56,570,327,197,705,259,265,761,107,608,677,756,838,987,188,751,985,976,10,765,73,474,709,68,163,972,729,486,48,473,4,930,538,381,852,528,404,473,956,11,452,604,117,675,784,503,379,74,979,7,172,209,570,72,111,526,565,861,695,128,57,660,140,192,870,33,358,327,643,792,330,421,897,184,210,611,669,767,45,25,663,657,891,595,337,569,628,682,853,455,100,833,441,55,458,857,836,455,278,848,234,635,563,975,421,123,281,845,734,90,713,297,243,270,920,424,433,261,689,57,429,606,594,814,735,457,802,4,329,2,745,219,232,666,65,26,746,309,410,347,651,716,431,419,131,667,628,153,362"",
    ""474,171,844,74,48,490,138,955,359,564,336,5,858,356,158,149,380,774,681,111,474,350,752,576,459,673,623,149,505,148,695,585,48,484,457,647,130,955,97,386,230,141,26,520,285,419,965,805,941,177,30,6,750,922,127,203,868,671,551,686,569,834,227,348,774,574,431,692,715,271,951,408,768,330,944,168,960,107,425,942,20,120,600,154,452,404,432,736,99,793,163,627,11,333,507,484,205,619,847,418,881,530,70,759,622,438,522,885,963,595,801,423,647,404,982,449,43,925,96,112,695,693,436,360,652,383,269,580,228,702,219,574,281,626,240,973,752,739,412,130,50,312,212,352,646,879,112,203,818,682,646,698,122,989,121,950,791,670,848,680,440,622,243,858,323,600,324,3,899,388,170,203,749,60,164,89,705,129,155,583,801,487,395,50,853,185,452,550,854,532,457,668,956,175,43,872,501,920,897,406,630,5,105,539,52,52,55,184,47,101,850,367,583,470,559,233,470,663,429,894,32,140,102,550,835,24,860,364,970,257,245,114,949,804,734,176,208,118,161,844,212,337,12,672,814,965,796,26,228,85,830,19,171,591,716,206,142,760,867,33,562,292,335,617,654,450,734,863,152,596,573,627,270,932,657,738,562,635,606,112,305,529,383,959,39,763,103,410,643,345,99,228,76,925,385,614,609,742,574,241,115,274,267,436,642,979,859,284,773,340,312,821,151,93,739,897,868,828,849,531,301,306,193,977,215,243,620,829,630,110,604,298,4,596,788,455,208,160,256,183,283,918,249,175,866,568,855,816,805,140,761,881,868,536,198,53,792,473,56,260,604,945,141,849,244,546,114,857,866,425,206,655,373,344,970,917,383,366,189,12,220,994,479,935,810,45,9,949,135,197,329,194,332,501,647,587,632,14,735,340,924,22,132,155,564,356,286,206,77,305,971,63,618,749,414,799,927,695,694,573,432,598,590,511,896,872,901,402,256,510,238,693,640,708,226,735,421,232,628,960,670,222,848,748,999,518,186,430,242,288,419,776,984,412,261,483,927,138,635,734,119,586,812,304,861,469,886,174,504,429,219,433,942,382,223,420,363,790,555,141,984,375,892,279,911,978,795,266,71,887,268,801,948,887,148,397,713,166,441,567,902,283,829,245,790,816,629,124,310,452,40,865,221,558,482,735,660,690,921,393,17,750,157,371,583,141,603,94,484,575,572,478,449,271,84,598,877,305,360,230,358,416,217,168,657,495,264,824,958,644,494,544,811,528,937,772,754,169,173,944,743,696,943,838,981,789,460,341,241,640,360,592,140,478,68,702,268,836,316,53,826,290,439,436,604,491,383,938,529,281,356,414,144,234,969,29,769,609,439,235,288,70,203,140,207,24,906,454,380,437,335,848,657,441,132,901,922,910,191,504,892,100,529,65,908,434,428,650,923,330,763,465,715,885,610,458,355,688,570,366,461,706,430,754,905,480,581,0,992,825,975,951,899,970,424,444,595,107,646,905,929,305,436,862,862,829,930,436,270,31,197,897,307,275,938,174,704,826,599,547,735,517,745,554,885,510,14,942,628,794,426,5,625,445,908,835,688,911,899,583,65,887,806,368,361,35,3,608,186,920,987,231,916,489,349,211,834,181,920,176,177,489,74,624,372,565,771,349,307,604,852,157,13,788,63,37,102,771,167,115,963,2,23,627,179,718,789,367,679,150,629,195,702,446,616,519,511,642,297,328,414,318,759,312,720,249,767,396,368,682,914,121,450,302,578,716,768,621,68,277,561,277,294,579,420,466,389,583,233,224,121,134,420,213,117,284,489,397,464,590,683,236,342,45,615,79,6,748,104,301,887,595,114,906,29,600,392,406,958,141,947,599,641,601,85,67,526,93,668,753,888,162,362,34,524,598,363,715,520,828,709,181,462,597,832,952,427,46,210,534,376,28,929,958,499,552,977,457,204,526,40,821,144,451,485,546,180,545,331,209,727,466,389,1000,480,603,347,424,386,839,209,451,910,732,366,805,739,716,755,86,731,176,52,679,413,27,883,193,304,669,433,366,198,6,983,897,919,870,236,492,529,977,190,375,816,461,405,951,433,518,33,94,129,344,33,531,140,792,381,362,45,639,420,581,227,558,565,80,558,862,127,165,761,80,98,749,450,576,820,885,975,612,830,331,261,634,279,732,138,117,301,153,994,187,247,655,542,217,173,424,196,649,525,479,323,695,223,855,224,817,812,268,2,641,671,520,252,979,128,284,46,205,33,55,445,428,853,462,612,94"",
    ""455,530,458,858,38,338,134,882,169,265,278,109,980,25,702,491,734,382,564,272,371,880,670,778,822,297,694,11,133,207,220,963,512,235,598,646,769,823,395,768,157,684,972,33,499,336,291,572,760,998,204,453,840,434,808,106,43,18,137,593,957,5,14,826,133,480,787,851,291,548,329,235,335,975,130,4,566,495,879,513,597,184,484,135,685,22,85,314,262,980,504,84,758,812,938,374,235,475,639,332,947,619,438,236,4,721,947,729,714,30,314,700,772,736,790,93,845,186,491,591,315,394,337,442,706,401,359,52,615,28,498,196,874,478,869,476,851,788,395,736,438,607,260,856,728,137,361,639,725,777,173,676,142,649,970,723,746,173,146,150,653,940,74,497,264,135,689,351,786,348,212,348,268,903,82,271,53,427,282,899,911,632,470,367,785,875,282,906,711,828,631,774,25,766,585,591,635,345,939,631,124,811,718,979,51,985,840,89,959,903,546,366,389,285,468,483,117,897,744,215,769,873,143,797,257,170,509,573,485,292,157,289,583,280,185,85,3,289,960,39,334,255,355,302,514,766,468,113,623,544,87,295,342,987,157,480,243,376,718,463,884,881,184,93,575,439,743,492,433,944,515,655,607,569,583,833,305,657,223,998,923,70,432,758,960,190,938,930,858,712,267,98,83,433,503,343,472,757,415,730,497,270,63,108,858,976,449,125,590,473,905,969,16,879,149,191,870,664,877,497,595,629,979,230,118,214,223,578,952,707,670,328,730,897,795,801,595,130,295,889,823,711,944,859,486,42,912,493,9,785,408,105,995,312,191,57,280,263,604,609,316,209,770,350,59,946,847,22,32,148,629,396,925,975,101,579,217,867,431,673,561,432,4,930,30,362,181,908,551,807,567,166,959,906,474,966,884,715,314,529,530,958,581,206,479,798,147,369,917,316,822,807,182,402,726,771,279,817,429,248,734,845,466,421,186,283,765,633,505,906,512,856,596,87,752,202,747,187,948,762,231,25,391,514,544,896,335,554,874,309,240,410,89,90,216,175,211,654,777,624,530,190,455,648,522,414,862,426,910,98,803,628,419,642,986,394,449,829,34,47,86,616,393,52,309,631,274,520,524,573,67,266,979,134,975,257,451,280,493,292,903,30,446,386,88,921,276,405,821,153,606,67,788,689,868,373,671,456,280,867,707,921,12,108,360,353,236,745,438,194,127,471,634,775,307,94,952,877,818,948,653,165,402,930,183,414,854,682,367,875,436,337,235,817,563,880,399,609,888,952,162,595,879,181,511,921,670,302,976,757,792,969,127,716,973,724,837,159,883,622,717,932,656,696,624,925,965,286,654,490,467,805,610,280,404,416,868,13,725,132,397,811,735,432,385,580,615,259,971,330,980,953,631,908,77,903,735,422,417,98,623,321,594,810,65,336,678,2,598,609,150,695,783,843,18,34,592,345,634,825,390,972,505,875,337,901,985,992,0,598,645,259,344,174,360,120,725,837,451,782,41,306,690,220,924,618,687,732,118,188,470,324,803,72,271,18,914,868,438,36,823,716,447,663,422,195,976,59,338,187,532,784,792,200,356,719,229,573,258,320,941,538,719,366,835,46,323,775,892,269,525,51,297,703,490,691,365,18,723,658,107,464,962,922,367,768,592,886,285,318,179,468,803,339,241,70,228,609,383,11,663,887,244,816,386,548,750,945,762,167,68,670,160,708,421,345,272,464,320,456,282,675,458,187,955,198,638,442,883,174,943,836,889,750,488,349,941,839,395,572,924,85,827,245,609,926,365,998,867,610,122,875,483,970,576,261,308,650,164,207,493,349,716,72,747,881,783,982,596,911,106,519,365,206,379,872,550,908,217,757,645,728,498,67,950,957,293,924,322,532,644,281,731,879,748,780,671,646,904,200,831,625,922,200,848,727,363,560,873,969,273,171,956,333,951,233,99,933,186,732,947,379,336,136,813,457,259,548,536,844,297,752,795,864,256,75,581,641,766,626,252,730,825,976,377,620,363,661,940,475,384,893,741,386,481,252,97,553,774,238,334,67,736,499,589,553,503,412,913,731,294,264,203,384,422,605,271,373,997,689,933,923,721,400,899,377,657,915,490,104,498,811,7,486,122,357,268,145,887,80,457,695,272,978,459,980,935,795,257,957,637,685,902,450,719,176,937,270,937,664,271,753,692,750,565,448,807,30,939,102,482,29,973,757,700,744,711,129,328,731,723,69,244,563,421,204,991,796,294,120,878,398,42,873,221,681,18,226,130,186"",
    ""395,884,451,355,796,757,430,877,649,928,813,189,761,366,42,613,349,154,143,479,60,406,763,897,817,243,716,2,40,415,391,347,186,460,440,687,321,903,197,739,492,149,326,19,419,935,942,490,510,359,523,733,31,46,380,729,696,541,452,503,53,206,658,980,360,546,335,415,523,799,618,19,30,467,836,972,986,127,49,227,296,351,111,568,110,642,545,942,244,349,61,760,91,568,362,980,632,408,302,396,7,94,962,347,583,68,751,681,239,956,838,995,720,631,9,767,891,78,57,56,203,845,541,903,72,277,303,168,175,90,334,193,926,535,588,115,303,895,273,199,20,726,787,203,750,515,534,429,889,399,545,368,419,642,530,320,243,732,815,320,613,27,657,693,298,179,507,14,242,71,204,676,381,639,580,526,817,402,118,650,646,24,189,495,263,953,844,586,186,769,922,887,862,193,182,67,822,846,397,221,742,319,190,174,261,129,149,675,250,912,90,946,402,223,601,807,613,36,166,64,612,212,536,894,445,232,251,921,695,648,884,762,123,238,431,475,362,942,195,566,659,488,947,369,566,539,430,557,611,849,454,777,264,918,77,925,581,768,888,681,505,416,233,383,277,272,469,246,880,744,401,953,604,607,586,736,242,318,966,552,767,683,526,70,937,824,315,578,877,517,173,98,804,820,527,265,246,919,374,983,397,926,112,853,417,17,917,866,71,952,393,501,631,9,600,782,607,486,283,752,938,52,623,709,938,891,110,403,575,376,376,859,602,981,470,920,528,927,17,729,872,570,626,40,295,522,466,328,781,18,716,610,458,115,353,883,531,219,776,374,884,655,935,702,73,92,574,984,368,415,611,638,707,296,7,38,510,336,990,355,297,759,585,509,116,156,296,131,77,143,617,97,185,695,951,519,417,809,34,570,886,827,277,67,287,203,436,747,105,290,28,403,245,658,533,716,882,88,934,428,573,491,881,63,88,75,109,386,982,910,275,935,40,95,988,299,879,68,188,949,712,943,569,865,610,17,246,885,42,886,90,989,523,347,5,957,934,775,180,398,407,771,674,615,254,832,109,346,134,319,735,893,232,221,46,542,386,428,651,704,275,840,843,87,717,809,131,190,271,157,961,423,66,355,571,850,777,266,108,114,140,813,245,358,853,67,230,370,266,462,881,16,990,34,916,962,646,588,603,506,324,982,598,247,571,121,850,250,12,223,316,971,179,149,400,879,336,169,811,963,67,975,529,254,430,751,426,409,962,316,776,682,669,220,943,881,327,209,432,498,50,103,463,355,895,318,562,447,98,884,383,38,758,456,12,343,249,183,441,638,899,329,89,96,207,67,859,909,89,280,208,314,845,627,883,966,346,703,371,219,733,449,981,676,20,30,143,523,936,931,719,976,238,537,222,357,715,148,161,28,797,141,976,974,369,163,518,543,421,446,332,994,849,277,805,348,640,913,152,708,23,11,753,334,344,265,669,825,598,0,452,785,665,467,912,705,662,638,355,431,597,296,316,591,675,499,596,615,833,709,118,86,877,669,902,130,37,245,938,536,261,580,219,451,146,135,451,698,416,573,241,297,593,624,980,91,502,240,276,157,363,6,688,83,182,478,695,700,30,188,61,850,334,228,491,64,401,507,222,432,307,151,613,708,581,865,748,299,44,514,266,607,137,235,547,987,248,232,133,103,150,357,267,838,459,595,992,587,301,807,601,82,953,36,236,543,772,79,185,671,658,488,578,657,757,178,19,649,234,344,945,276,351,342,85,798,385,145,115,167,132,523,696,213,151,915,467,546,725,159,927,982,716,706,280,936,18,835,577,668,54,422,746,315,231,383,13,253,494,220,391,318,803,639,654,537,489,865,612,287,471,624,535,548,984,1,209,284,52,781,382,751,827,88,932,428,532,13,721,808,429,874,566,177,102,899,213,232,436,679,319,652,742,222,725,479,430,566,632,309,973,902,829,379,18,119,234,900,760,140,267,321,190,518,33,607,701,663,487,17,714,203,155,200,926,103,811,482,329,342,57,802,746,66,154,245,957,315,993,696,556,73,980,32,641,923,206,827,527,164,460,77,316,413,141,78,430,996,745,588,183,657,521,75,180,874,90,920,587,693,789,258,505,477,681,718,930,133,673,462,459,933,319,130,590,575,307,206,572,961,612,717,958,934,116,831,514,881,906,331,561,292,782,190,455,884,168,359,859,260,192,155,382,505,606,485,910,167,374,429,556,539,184,941,657,891,724,912,460,713,241,771,636,59,950,2,415,130,718,835"",
    ""148,538,269,46,924,161,266,718,80,365,709,859,407,431,715,56,254,261,881,695,291,991,144,621,165,678,14,200,758,471,157,474,455,708,62,834,437,883,779,999,302,56,268,343,445,965,969,184,255,22,176,559,840,805,670,109,895,384,295,410,541,723,284,112,783,406,339,810,833,323,93,575,975,242,671,989,108,838,201,155,515,768,72,15,313,142,700,562,529,577,226,473,704,616,351,545,724,257,432,255,591,767,26,199,753,819,689,538,488,178,528,778,696,920,5,100,221,754,756,248,866,411,356,593,362,265,94,762,204,330,213,75,323,156,34,484,633,607,585,196,518,629,6,447,822,725,764,137,157,25,389,194,884,244,345,106,909,821,535,951,989,415,725,656,920,279,987,851,190,935,938,896,455,386,62,585,475,605,714,388,822,530,775,296,55,939,40,952,341,227,842,852,23,896,79,986,148,819,735,113,676,223,498,640,792,586,58,617,879,671,794,621,438,476,131,587,967,964,619,545,585,6,403,902,714,535,931,696,808,531,686,654,703,592,233,237,143,612,216,284,131,987,795,371,779,312,176,438,547,902,676,166,220,75,61,190,429,680,68,776,942,342,647,782,829,641,790,497,584,92,931,400,364,498,911,840,118,715,956,504,121,498,113,780,137,589,578,725,991,938,855,586,341,981,509,820,969,911,405,978,26,227,786,357,18,657,499,624,467,703,78,93,6,949,760,24,431,59,815,202,140,17,427,568,177,788,426,181,921,877,741,747,533,387,534,946,474,717,782,856,889,535,23,761,2,575,490,809,661,777,292,997,37,877,302,396,976,692,593,36,964,545,465,847,590,484,758,437,407,958,410,345,913,72,740,240,35,261,204,941,352,523,428,267,125,722,364,715,608,9,942,163,785,912,647,732,736,885,783,997,339,260,115,338,794,191,390,428,712,495,607,427,890,363,35,751,447,223,458,86,988,558,151,868,419,310,68,334,433,174,232,7,736,844,600,729,756,169,772,970,730,200,649,360,352,261,517,121,428,507,138,33,477,375,117,753,577,994,81,256,783,444,539,421,292,328,121,235,737,698,352,57,24,423,710,656,882,779,716,390,191,752,312,499,885,390,986,990,133,329,431,476,730,349,675,948,484,670,579,451,449,557,838,789,194,934,311,208,783,944,583,268,158,396,202,510,711,313,340,956,481,11,930,586,562,417,52,267,342,21,205,493,710,672,746,764,215,83,548,846,642,806,793,984,440,345,256,221,672,961,561,459,62,193,329,522,815,523,17,427,407,31,234,360,898,17,248,460,699,732,829,24,698,318,603,754,52,298,241,623,109,745,476,481,230,868,9,64,976,389,280,723,392,498,671,746,438,27,327,753,579,654,368,677,570,57,30,850,314,536,929,597,961,15,761,562,879,261,520,137,296,520,311,797,121,107,744,948,898,347,247,164,913,29,5,606,305,834,112,538,974,761,114,368,463,246,360,975,645,452,0,323,434,5,671,212,159,489,630,581,373,397,372,591,681,178,671,654,931,75,19,100,602,990,922,446,621,349,850,985,918,820,789,602,556,824,407,571,702,458,474,31,792,349,217,276,427,315,689,265,573,574,185,40,388,6,217,971,548,606,58,548,776,483,165,448,952,498,910,777,327,84,157,608,971,709,561,261,162,346,488,422,840,897,946,874,168,20,979,991,883,112,805,92,477,843,608,154,465,148,523,519,714,8,795,730,967,161,875,465,803,657,266,631,621,779,490,412,722,275,225,867,338,666,924,60,478,291,419,375,796,445,449,957,857,631,279,452,754,249,347,258,663,116,751,764,709,789,412,49,761,460,879,332,204,170,36,232,254,266,194,634,532,131,899,611,244,212,693,960,227,978,264,392,114,574,310,627,229,44,521,628,756,946,772,581,586,964,75,731,573,225,51,144,983,645,4,366,523,540,70,408,862,432,164,797,849,451,603,93,934,856,407,354,926,290,870,296,501,169,948,777,935,851,429,339,870,120,870,182,736,249,273,681,369,976,602,277,287,84,383,434,927,404,795,687,968,866,190,841,404,769,23,350,553,417,515,38,893,988,387,310,711,504,843,969,83,564,554,908,530,284,750,471,347,629,440,139,730,763,473,207,594,632,102,498,427,628,563,413,267,158,935,786,18,350,644,688,621,121,210,242,976,229,862,650,35,645,139,95,953,286,821,642,28,221,55,661,412,293,893,229,647,182,720,393,383,174,173,691,353,300,731,775,243,510,791,819,382,379,801,191,180,920,864,649,894,937,570,660"",
    ""330,653,716,530,559,64,439,174,20,612,766,250,951,587,917,281,965,897,130,7,60,568,884,796,798,272,607,266,363,398,808,747,980,991,621,968,985,63,293,214,440,808,10,964,996,684,78,516,716,565,165,930,928,196,404,412,31,927,137,994,879,526,51,993,670,429,233,878,972,722,173,199,640,457,736,552,335,699,394,654,170,257,55,488,342,427,884,386,184,792,578,492,607,41,300,937,327,300,338,338,988,367,106,678,449,548,388,223,518,328,910,543,906,8,204,155,740,35,818,200,685,555,126,967,671,680,12,807,176,537,921,896,376,972,593,304,511,610,571,631,426,57,915,625,183,86,654,206,569,498,923,526,283,907,864,43,595,632,725,710,92,782,534,65,704,339,685,752,357,253,67,848,816,280,29,685,35,61,733,536,179,888,298,262,624,7,933,170,290,554,551,307,80,304,387,24,969,45,652,700,404,388,936,935,877,19,720,438,759,829,945,443,922,89,476,474,685,90,665,100,451,912,508,737,527,959,551,488,16,129,480,409,507,417,34,558,966,80,417,839,245,20,328,707,128,91,963,806,517,897,985,357,660,454,743,440,225,25,154,230,185,862,110,820,444,771,639,923,430,595,865,597,353,942,143,848,900,384,658,807,135,359,884,21,496,209,554,450,585,633,28,124,613,896,669,901,525,924,332,693,478,93,505,391,636,65,51,201,268,926,719,610,244,116,120,539,50,104,670,655,282,524,962,827,448,943,975,40,143,676,874,352,44,625,947,544,383,85,766,511,407,541,820,163,284,618,978,374,148,679,315,114,172,276,553,917,377,428,390,134,292,244,881,727,330,882,767,801,463,588,323,827,208,549,262,659,602,413,80,964,402,490,775,638,83,797,641,775,402,209,609,57,871,604,620,556,675,921,922,523,287,876,675,148,353,236,48,721,29,44,40,928,585,96,676,228,969,121,943,621,327,845,380,702,253,757,852,65,507,889,295,738,864,257,753,881,779,938,201,855,420,571,977,222,177,235,357,869,146,270,988,270,201,42,419,104,705,126,30,13,344,649,172,623,852,986,982,474,459,688,49,408,818,852,687,272,175,403,372,457,662,25,785,792,675,717,618,42,486,296,599,67,116,261,663,864,229,204,109,801,938,35,874,480,58,305,330,158,571,658,218,438,735,954,346,358,560,789,280,700,189,938,758,872,844,418,649,681,135,212,264,133,259,103,400,901,1,463,532,254,515,530,155,999,60,678,774,102,225,670,692,352,314,361,920,272,957,466,286,693,348,821,132,818,719,942,34,799,205,944,406,922,542,304,868,759,582,572,751,375,87,984,323,440,280,842,261,734,910,803,433,790,681,38,17,736,829,832,486,555,339,990,252,543,670,130,663,719,891,925,623,792,834,792,759,808,474,603,432,83,313,861,520,739,720,40,74,528,310,789,163,93,359,484,913,931,65,401,484,6,733,773,970,403,499,391,135,951,259,785,323,0,892,537,726,931,916,80,609,332,905,250,118,363,955,233,777,267,89,405,645,436,525,971,644,255,451,640,326,872,371,756,82,930,689,716,732,264,721,631,353,168,925,389,128,392,26,918,903,563,159,881,428,40,60,425,615,135,519,286,959,39,611,223,141,980,410,694,672,193,646,590,181,764,200,292,485,820,779,928,77,989,115,995,91,254,819,247,737,29,40,253,758,868,996,348,968,957,865,207,780,846,617,327,88,895,665,286,619,463,822,199,32,823,931,38,201,232,536,516,699,232,983,898,684,696,344,700,374,51,582,190,805,607,231,790,464,526,708,287,179,995,284,962,917,42,83,52,111,341,73,557,224,569,103,195,48,957,91,407,230,277,933,723,35,195,744,861,340,359,361,891,933,806,421,286,126,900,603,381,927,950,943,684,109,924,895,686,192,776,362,257,913,986,830,839,836,882,966,512,654,158,474,277,994,572,735,796,846,289,262,60,494,645,516,584,668,522,699,456,336,491,426,967,442,310,278,387,431,32,539,535,834,463,169,586,499,887,489,698,335,349,92,337,584,936,647,827,463,912,615,897,449,508,646,51,928,91,558,703,386,10,53,324,244,958,270,283,907,769,151,97,418,574,273,933,647,813,494,513,398,999,392,382,583,613,878,727,555,282,778,958,593,105,406,431,645,489,775,246,73,98,137,997,220,510,657,758,785,93,381,175,106,937,626,905,601,248,272,3,636,996,312,890,727,241,272,273,923,102,167,978,499,789,248,733,675,178,231,574,587,761,406,891,82,395,222,868,327,735"",
    ""919,69,260,200,160,626,858,536,285,390,238,387,425,677,832,49,224,383,67,550,809,158,764,791,116,330,185,868,632,400,322,577,972,69,857,110,527,234,213,905,256,930,34,876,286,691,222,196,754,718,580,560,536,72,130,258,869,49,315,304,446,592,738,69,101,529,898,753,267,405,863,285,520,288,534,566,146,35,528,174,70,811,566,579,431,959,877,585,78,257,945,552,60,329,700,61,444,255,909,561,98,82,291,824,685,359,893,737,457,504,809,385,374,26,294,417,587,392,323,847,348,565,166,230,792,911,853,362,914,285,628,702,964,286,655,51,530,847,823,827,290,168,171,594,334,725,864,66,974,715,213,830,357,995,395,56,658,886,225,117,210,783,59,861,846,189,467,297,458,247,184,82,841,417,967,113,580,656,282,527,699,142,179,495,334,277,360,842,980,371,739,172,851,418,272,888,172,325,139,588,413,428,951,446,589,636,150,10,792,502,884,647,626,553,642,945,773,829,900,159,610,980,161,165,348,602,178,38,665,433,5,856,804,895,581,813,185,15,566,18,201,822,277,855,927,656,815,961,613,883,814,304,802,587,398,871,207,252,504,507,783,624,736,404,715,866,217,994,635,368,499,611,881,911,768,489,454,133,405,645,190,824,385,202,716,560,612,440,601,363,96,791,910,560,368,189,698,166,45,759,885,358,73,81,120,457,622,829,937,820,344,252,138,603,873,907,791,919,244,547,272,294,417,445,733,72,638,508,775,610,236,447,411,674,473,869,14,171,187,791,908,41,493,235,524,832,601,139,888,648,952,744,404,771,598,573,827,169,437,756,443,171,86,514,322,493,502,450,111,216,259,135,871,575,76,241,819,657,780,437,739,206,212,931,792,430,950,514,538,226,475,867,988,519,913,83,579,469,984,865,189,628,988,344,994,494,692,616,949,918,651,220,718,621,439,614,383,598,43,539,624,864,50,426,344,331,569,82,964,782,848,956,801,661,573,652,251,543,105,593,662,186,207,306,994,44,455,530,636,273,613,115,933,126,378,985,691,353,507,693,678,975,720,952,525,900,402,90,400,906,93,372,992,362,233,480,777,950,763,409,830,717,189,521,918,167,253,754,439,101,285,25,795,751,860,830,890,178,217,89,647,329,388,258,8,472,685,865,122,563,406,116,102,266,444,286,516,638,909,105,243,31,442,766,672,250,140,225,729,929,483,498,617,262,937,45,364,147,222,501,351,270,582,102,371,633,920,728,796,428,393,239,100,993,871,215,161,874,945,948,500,66,267,974,833,138,965,756,925,318,308,939,312,33,80,598,880,613,792,453,580,923,68,433,673,965,105,446,319,207,927,43,635,908,573,26,172,474,803,50,457,779,870,5,384,951,595,375,702,332,775,98,808,975,161,316,426,846,525,323,195,62,924,517,317,135,783,404,163,93,149,401,33,837,943,380,263,454,929,280,727,23,341,750,723,648,140,899,344,665,434,892,0,930,345,614,26,239,200,519,874,713,564,423,237,786,418,148,128,795,282,64,301,908,420,334,989,964,31,606,119,614,345,458,582,82,499,227,638,866,44,251,980,125,666,983,507,192,247,467,651,206,462,349,66,636,734,3,107,17,996,64,466,410,801,878,987,986,733,18,728,897,350,890,949,224,561,950,690,891,48,77,316,595,995,256,952,205,983,657,389,882,170,276,740,210,843,865,420,12,534,88,508,984,65,29,452,612,213,382,686,535,170,915,287,34,966,584,714,987,965,51,725,116,902,825,971,953,213,44,224,632,84,178,385,600,518,889,743,694,958,397,593,310,66,6,895,985,749,876,562,791,194,100,325,714,534,215,957,601,987,938,611,229,533,916,304,225,26,216,686,144,462,680,662,535,452,938,350,368,805,58,485,516,519,361,711,521,467,990,453,489,273,522,85,976,642,481,347,940,184,99,513,513,752,626,22,267,282,524,788,529,279,899,103,901,126,842,77,224,19,930,604,239,381,984,29,300,505,772,511,638,565,628,846,931,653,268,30,176,388,423,823,886,919,888,874,838,291,724,494,789,114,517,865,999,227,695,204,452,803,170,137,133,820,310,58,349,671,964,452,926,715,281,743,663,752,825,54,817,735,782,790,801,650,621,399,267,781,786,693,832,937,665,212,606,775,367,15,89,819,729,439,614,775,838,500,480,700,76,337,36,364,184,625,846,23,939,40,563,109,991,86,662,710,805,904,557,372,930,324,255,682,997,796,750,514,117,335,31,698,789,397,210,98,942,577,982,245,961"",
    ""710,728,849,344,206,395,20,461,548,795,895,921,622,11,59,419,237,639,239,860,822,141,427,617,718,958,675,568,109,963,717,501,756,633,915,531,289,398,970,576,204,24,262,503,897,299,42,62,518,842,897,860,719,13,274,906,602,70,291,984,351,921,391,387,411,896,251,852,937,608,564,153,98,226,664,161,625,277,660,93,229,985,250,387,21,829,149,59,783,449,926,100,836,419,229,932,559,463,922,480,280,332,75,138,480,847,318,77,218,806,475,658,10,174,283,959,61,520,302,73,998,936,540,713,499,913,690,103,377,570,592,323,860,919,866,431,817,924,954,783,345,664,518,122,581,59,186,536,8,146,393,171,744,24,674,472,9,498,153,279,237,212,748,168,213,318,166,91,582,377,817,586,603,838,360,675,546,750,937,836,805,220,957,738,205,693,921,548,60,576,619,768,508,474,246,707,815,85,831,106,978,589,555,792,841,75,369,809,479,739,386,973,475,113,843,569,283,407,132,863,319,52,187,349,214,29,417,833,761,565,286,671,133,380,651,187,992,311,577,391,690,186,378,892,720,463,102,805,310,861,612,891,110,609,330,600,762,210,953,94,735,607,849,202,88,825,761,175,334,328,319,557,162,119,259,255,218,617,583,870,244,588,270,98,89,696,320,740,141,970,842,854,942,547,796,745,381,43,978,955,998,318,505,998,735,825,855,342,584,345,874,790,461,120,731,299,662,695,157,474,724,378,602,917,634,389,417,803,584,322,374,864,888,648,109,756,969,707,461,321,746,402,484,702,720,551,122,890,540,436,995,546,436,517,311,428,570,711,421,364,191,660,95,424,434,190,141,315,620,331,352,256,997,901,485,496,639,167,418,845,613,634,216,780,54,212,566,448,249,845,163,316,638,425,596,183,114,297,375,736,707,491,510,357,569,863,507,521,725,959,942,573,291,343,713,934,756,429,398,86,394,130,698,774,700,126,887,470,716,925,151,168,477,49,821,462,363,921,829,205,845,34,285,879,276,220,169,624,929,168,207,295,101,660,639,994,746,300,736,934,194,267,708,395,205,250,252,591,455,137,87,691,675,14,467,242,529,176,627,118,371,31,94,294,208,429,271,451,479,173,351,20,393,646,743,792,655,543,327,559,825,643,563,813,281,207,982,742,922,923,309,785,494,437,155,797,97,180,831,461,13,690,803,140,171,174,581,845,538,458,750,215,623,405,911,10,531,673,698,258,936,49,9,621,16,524,20,982,79,540,964,638,934,840,194,36,952,853,187,303,119,921,220,926,518,925,550,277,819,323,735,132,644,953,1,923,998,165,889,816,274,352,89,919,660,621,681,920,414,851,278,666,851,195,289,332,173,464,153,560,483,119,326,973,571,310,35,504,365,307,457,753,271,436,276,701,733,287,407,321,907,319,57,367,242,737,649,388,55,524,524,10,158,388,776,286,639,813,785,92,828,296,959,767,698,119,232,970,174,467,5,537,930,0,867,565,127,291,638,1000,120,31,169,49,355,894,361,256,572,618,304,209,117,677,589,485,986,984,340,902,676,664,841,482,810,203,281,658,847,627,69,929,259,577,314,465,132,922,691,564,367,973,422,521,599,985,610,495,52,592,47,947,510,641,432,387,758,4,198,387,326,467,392,40,762,41,680,739,77,179,672,165,315,307,141,701,924,660,203,442,994,591,899,221,371,453,589,334,438,482,283,975,163,636,660,146,609,278,291,462,187,809,370,571,804,439,551,649,624,465,386,388,921,392,386,871,721,488,391,846,674,393,480,24,378,275,442,416,329,523,71,224,370,635,36,658,980,876,905,334,387,617,988,172,532,637,280,595,868,66,254,72,582,949,729,67,284,392,32,856,583,293,349,94,58,178,458,389,570,326,995,601,413,348,995,436,344,599,214,932,477,276,995,329,763,701,914,232,761,768,228,415,336,971,88,486,738,297,352,871,600,877,569,886,233,625,444,988,979,490,454,578,796,564,630,566,879,76,10,485,495,327,628,288,64,53,139,172,500,341,450,433,789,298,180,144,30,463,852,57,993,780,763,169,872,865,528,888,304,468,565,174,519,62,767,446,223,590,201,567,615,405,496,310,424,5,433,105,593,11,677,16,619,192,5,606,172,661,963,592,383,411,354,136,233,282,301,266,183,449,505,540,850,110,233,569,443,371,472,337,231,26,655,733,721,22,605,960,127,823,980,715,757,283,678,699,254,105,474,844,901,886,73,822,700,474,338,550,489,864,935,289,576,888,724,635,291,452,784,803"",
    ""485,14,592,955,490,717,186,461,725,687,704,982,532,138,11,962,712,777,111,253,12,327,101,834,51,617,491,497,2,484,734,376,737,71,536,46,450,43,715,351,564,19,963,283,910,142,565,242,228,563,352,596,261,321,509,15,696,788,888,535,283,903,717,328,794,894,953,158,743,644,145,516,365,243,791,332,631,496,59,879,781,863,476,232,173,445,55,640,250,825,732,384,86,371,498,755,938,767,232,244,235,453,202,296,854,933,513,1,106,331,309,294,362,119,315,909,639,214,211,561,637,590,351,620,260,556,948,442,727,783,257,885,260,962,69,144,564,823,372,832,73,589,541,974,458,698,512,143,860,932,69,16,477,259,797,860,486,188,97,248,923,234,680,886,60,540,145,868,58,900,336,894,327,684,509,222,691,98,460,878,409,579,834,262,819,471,733,255,581,740,699,3,836,356,542,966,592,368,354,959,201,602,406,162,301,906,237,684,424,602,923,650,780,517,680,227,739,383,626,764,650,176,768,432,792,393,811,436,890,842,525,756,994,234,923,145,596,288,701,265,36,329,213,45,173,483,512,222,760,454,953,829,379,304,178,268,409,967,873,847,87,677,128,96,322,840,96,938,526,519,149,331,587,815,742,257,629,13,465,457,592,656,683,349,314,906,403,411,352,748,28,381,175,727,218,347,245,990,434,715,876,969,352,85,75,150,299,284,472,832,732,486,45,840,868,130,889,271,599,501,546,531,251,326,555,222,850,256,451,935,901,855,73,158,637,38,768,282,659,895,633,729,451,643,384,771,130,409,592,820,62,806,936,222,836,998,911,915,171,749,495,598,899,198,619,384,103,21,905,820,996,857,274,188,372,204,968,704,417,123,35,460,368,880,91,957,73,7,954,151,965,913,990,433,13,292,527,974,892,422,618,799,974,53,459,473,28,542,174,279,414,512,733,646,557,979,708,98,187,866,527,751,331,224,984,655,396,517,332,849,529,823,855,824,919,915,565,950,142,298,322,952,411,313,748,888,657,2,141,987,514,116,841,619,635,872,958,491,928,975,721,961,827,698,603,629,24,120,829,215,987,877,538,713,423,928,911,89,98,997,462,959,748,204,937,780,344,779,370,60,385,487,16,995,119,924,783,7,550,177,498,796,214,732,885,217,331,684,33,732,73,342,837,362,344,838,978,967,34,168,913,477,330,263,548,414,876,613,145,583,897,971,133,99,604,836,962,832,438,441,807,374,603,143,706,925,796,307,365,807,191,119,607,544,823,857,832,599,159,627,905,781,851,739,751,526,529,236,909,253,846,419,72,961,496,165,544,125,937,607,330,637,385,493,294,5,148,89,69,776,430,818,748,882,713,526,967,91,919,663,397,327,83,334,177,901,121,875,937,860,206,471,461,669,191,707,732,266,84,51,284,173,39,477,262,974,356,70,88,644,14,599,613,745,94,101,495,470,432,346,899,928,915,292,486,187,42,424,360,912,671,726,345,867,0,187,296,543,234,28,966,375,893,802,996,531,908,303,79,491,466,309,575,550,386,979,857,379,240,448,726,858,702,718,220,746,400,603,138,203,65,388,52,567,377,342,715,970,687,129,50,783,438,243,869,959,17,65,773,602,953,616,166,585,324,842,830,530,81,572,161,640,495,985,616,969,846,212,372,971,433,140,55,885,943,753,193,410,11,380,93,335,868,644,17,90,639,236,884,474,75,516,746,1,828,75,501,721,534,298,315,385,699,162,852,61,855,317,411,158,892,963,608,526,514,991,621,455,837,506,11,790,754,554,590,401,631,620,656,716,179,207,17,287,612,279,16,568,595,496,589,951,312,148,585,655,995,168,183,204,436,361,532,181,244,957,167,280,175,750,139,444,672,659,352,690,349,347,558,7,332,699,848,628,39,275,99,215,222,340,571,384,881,950,903,696,789,839,351,616,930,769,751,63,507,995,552,363,482,81,637,602,625,108,180,26,623,622,442,863,786,792,269,568,109,385,801,353,621,613,692,881,516,883,940,548,560,256,36,436,321,350,783,331,257,387,39,301,272,860,541,957,599,900,649,52,197,563,765,148,902,8,267,106,187,896,692,213,164,679,654,427,685,801,42,371,596,333,71,65,69,915,417,628,782,886,447,226,326,510,101,903,343,368,412,72,205,817,549,982,657,92,719,545,27,438,627,826,783,918,406,880,322,240,522,220,179,682,145,344,832,553,96,147,118,273,693,33,156,965,174,326,700,897,474,183,919,200,14,570,319,660,938,728,214,235,136,789,111,451"",
    ""709,905,462,789,866,79,967,776,454,931,728,251,50,258,977,152,333,451,149,96,450,226,113,475,735,289,480,407,292,288,701,70,513,983,989,668,496,281,669,863,794,745,173,494,804,711,503,784,416,748,972,385,365,693,564,869,355,193,680,648,531,531,893,28,951,221,321,628,767,31,170,516,195,771,822,629,651,832,879,571,453,580,749,598,490,492,246,151,836,154,140,830,482,439,890,164,286,219,919,932,757,339,315,529,608,299,791,597,556,742,660,648,396,935,478,712,432,220,152,263,704,857,578,38,406,168,870,547,628,119,739,621,960,309,756,947,382,892,228,863,471,107,800,107,791,94,687,438,21,560,475,613,542,412,495,886,495,578,339,436,216,513,51,571,130,521,790,948,63,660,75,386,737,527,408,571,128,35,670,287,54,38,49,621,419,47,125,464,163,660,728,743,434,752,245,705,754,241,675,213,227,813,677,734,712,334,208,892,796,486,903,653,717,601,968,710,679,866,962,900,304,296,188,990,141,723,53,503,36,146,453,955,684,758,957,868,685,714,697,959,498,525,777,850,859,971,738,346,487,424,222,221,99,876,359,818,505,691,450,380,68,127,413,350,974,813,415,922,9,629,643,223,872,755,386,585,901,729,304,76,434,324,879,265,645,566,316,759,656,794,964,376,845,307,16,199,312,184,287,788,891,220,118,998,94,652,476,988,641,482,90,871,740,747,50,919,93,669,776,806,428,163,422,773,945,59,97,521,206,81,986,209,458,481,870,418,459,716,438,107,675,465,662,189,244,286,339,455,374,615,563,848,480,214,343,704,429,672,739,553,297,120,727,24,994,950,658,416,824,822,637,186,793,938,700,27,164,260,474,34,604,790,492,982,957,420,967,578,249,241,486,654,629,74,721,599,410,848,584,376,297,487,626,261,88,790,915,11,563,222,76,448,895,252,312,539,139,406,235,626,933,239,206,309,167,947,786,330,696,288,619,585,113,457,508,606,84,314,531,136,74,166,697,873,78,458,636,55,370,874,467,663,524,230,15,376,153,726,88,431,447,5,914,294,996,203,799,23,945,242,823,192,783,483,26,438,495,940,885,361,475,642,726,484,584,254,668,925,76,243,136,44,920,914,139,321,723,107,186,868,927,745,532,919,947,54,434,230,907,825,945,33,898,936,773,542,317,574,363,765,103,679,305,158,811,707,506,582,456,10,222,673,529,219,374,932,618,902,617,427,504,459,190,643,159,297,244,916,924,536,565,974,108,704,570,888,551,429,169,929,277,669,45,302,687,651,69,59,997,958,539,793,780,349,693,156,343,518,302,711,289,764,792,462,40,491,384,228,390,646,328,925,928,800,938,84,472,604,991,129,253,195,100,759,298,781,292,214,477,381,232,171,14,890,638,685,981,826,806,310,113,653,512,93,302,733,135,401,523,312,223,412,370,605,473,243,948,325,596,900,952,829,433,11,582,710,748,444,120,705,212,931,614,565,187,0,610,232,780,345,912,364,925,300,393,335,587,786,689,689,182,600,133,162,617,362,66,147,296,152,288,4,807,354,55,312,295,326,683,69,252,827,146,892,511,152,809,528,858,465,128,865,407,180,923,118,593,50,963,897,794,836,610,597,318,688,719,316,832,931,374,674,451,300,958,512,531,673,204,542,512,26,997,602,365,362,939,431,791,969,955,50,561,929,35,681,613,937,381,348,156,941,390,21,745,207,366,25,121,612,730,835,990,599,402,637,221,586,135,532,204,629,520,941,4,866,170,19,603,629,613,902,867,576,793,684,981,712,76,888,399,891,386,486,746,815,708,71,721,198,588,480,818,656,298,32,25,149,229,361,263,770,556,512,292,757,793,520,323,308,323,785,611,91,879,428,2,803,313,163,902,948,680,31,749,426,314,598,543,600,757,279,754,112,637,31,854,504,420,752,820,400,99,133,123,493,491,937,449,879,306,275,895,845,271,542,426,190,275,801,291,932,805,459,91,826,920,296,263,391,648,122,584,592,67,471,882,745,267,551,213,953,392,129,337,674,80,590,513,866,224,109,288,525,986,296,638,643,302,131,81,298,169,626,95,613,76,185,57,226,702,208,691,905,1000,175,338,336,450,611,260,120,987,680,461,785,367,156,664,484,937,33,816,507,151,52,131,372,685,555,640,57,19,348,990,855,182,747,666,66,13,324,974,737,371,863,885,281,696,245,676,91,766,330,466,62,212,606,6,789,417,77,455,670,192,347,771,228,477,747,939,975,812,387,543,240,433,156,649,387"",
    ""341,147,850,221,432,839,710,643,985,179,335,547,64,135,227,866,39,497,537,744,485,517,507,710,168,912,809,387,431,4,893,787,8,657,868,810,556,819,928,234,755,409,312,768,90,209,400,939,781,353,259,430,336,876,687,413,322,723,761,84,752,809,870,972,149,151,78,284,629,70,62,63,556,966,130,372,655,851,42,110,140,912,177,145,267,735,761,981,734,943,572,675,18,47,470,994,990,889,677,464,886,148,379,691,47,914,973,453,357,809,964,95,147,764,820,308,299,263,986,180,462,981,810,856,589,348,361,47,952,546,781,642,182,825,553,476,288,779,395,658,514,358,52,405,912,506,290,761,670,629,949,983,686,224,172,770,859,60,372,85,975,390,343,110,952,4,233,265,634,811,964,327,974,210,144,201,887,442,838,945,301,128,993,109,365,549,360,665,494,126,559,341,334,781,801,330,699,705,768,23,557,566,483,139,495,954,445,688,71,834,653,986,251,769,16,921,442,411,995,213,556,207,337,836,636,689,701,504,265,970,556,251,157,543,154,721,451,604,155,830,724,474,514,225,351,72,301,902,43,284,903,465,439,358,133,44,74,231,553,733,86,298,621,514,121,516,301,789,171,250,921,934,406,809,438,105,290,988,132,380,954,24,436,219,589,148,744,635,297,572,714,171,771,610,405,470,501,814,704,312,685,789,775,260,401,500,790,123,618,399,208,336,955,615,59,996,739,406,788,190,553,491,574,189,718,344,487,56,571,945,970,486,328,41,714,780,647,194,67,680,245,560,282,930,195,629,286,154,706,562,29,658,659,130,933,989,232,708,628,426,555,674,272,913,359,785,85,982,216,27,518,289,992,883,502,111,16,221,822,657,35,674,838,448,702,136,28,876,235,490,895,184,520,413,675,932,239,123,718,602,854,900,548,848,60,111,395,831,253,275,814,810,318,671,975,383,513,102,564,176,237,973,978,680,512,163,506,347,680,476,393,589,952,15,111,62,639,648,18,457,820,488,502,444,89,257,480,950,515,190,84,407,922,956,630,625,557,481,490,338,695,657,56,169,481,787,501,406,434,154,462,903,585,951,449,894,905,646,81,738,61,313,913,43,470,872,98,514,988,913,513,502,265,490,615,859,999,817,172,72,785,898,386,45,819,381,584,434,843,193,705,56,649,124,34,504,181,575,624,800,104,70,808,362,65,692,964,890,996,395,671,821,642,936,119,987,139,498,183,857,25,958,928,704,672,600,885,555,64,646,919,106,225,46,193,276,841,2,123,602,967,51,981,102,468,860,724,504,347,761,836,789,7,549,334,248,272,361,68,187,834,294,744,658,647,476,204,802,803,653,515,4,15,303,910,5,296,860,502,125,75,362,741,398,907,490,601,996,538,583,468,946,392,567,952,755,303,581,209,724,70,498,957,448,498,935,721,97,32,651,601,475,945,811,675,428,826,130,146,471,406,859,413,204,845,45,995,595,725,662,159,916,26,127,296,610,0,952,664,183,460,876,619,429,700,445,510,28,175,317,269,251,981,502,933,699,985,589,254,343,974,836,939,637,612,822,722,745,278,819,49,216,379,809,422,436,722,989,357,758,506,701,610,256,361,148,601,121,443,709,296,834,63,408,979,869,378,612,352,194,321,872,672,580,58,86,136,573,309,846,228,134,574,905,381,750,953,791,864,170,250,863,787,505,434,721,689,158,283,963,409,238,528,471,840,887,436,531,937,116,622,572,612,614,323,995,469,706,424,753,64,266,530,128,82,411,468,530,176,433,583,277,902,720,73,652,674,592,205,507,580,670,965,391,5,33,969,394,764,614,400,975,897,685,497,629,157,34,538,835,310,339,715,229,735,578,154,709,601,345,335,915,344,29,636,823,648,533,526,678,540,12,346,918,223,688,268,399,853,902,881,530,109,800,662,382,140,819,223,445,454,784,965,139,137,130,597,207,735,140,613,216,251,852,852,464,283,895,955,346,186,425,469,456,850,168,646,297,282,184,27,981,99,774,501,525,226,10,13,432,807,796,173,537,223,900,583,769,244,443,537,359,82,699,450,224,582,718,230,914,840,592,883,982,241,344,509,548,314,901,507,463,688,757,61,402,25,533,977,682,446,305,220,759,457,171,413,705,166,454,7,5,299,595,862,330,479,773,307,641,327,442,381,264,25,821,67,634,887,480,330,873,672,899,71,400,464,344,621,5,962,767,847,405,776,443,114,523,998,259,542,8,891,284,894,174,810,536,722,583,19,547,486,279,787,237,42,231,616,162"",
    ""871,88,840,131,511,274,264,762,321,767,867,555,974,354,879,508,86,329,554,875,872,806,598,291,712,775,942,95,754,295,740,383,331,685,506,866,567,756,721,616,650,625,422,742,764,33,516,893,643,631,938,454,199,899,76,233,142,441,726,50,578,636,217,67,280,494,696,897,77,697,627,958,303,786,280,211,137,968,283,168,985,29,239,335,754,619,543,177,178,901,487,448,131,804,27,464,617,619,157,372,975,686,397,900,396,421,683,927,760,973,63,696,994,489,989,153,320,233,3,912,425,999,896,809,522,39,220,543,507,547,226,513,850,821,85,777,101,977,746,184,384,402,590,711,73,446,700,633,503,379,288,92,492,825,239,517,980,3,314,252,351,783,418,340,489,271,287,787,957,717,689,704,5,956,611,61,965,550,630,175,959,839,74,697,363,524,514,594,45,926,448,227,729,320,887,275,119,349,857,827,209,104,303,970,769,71,872,801,219,981,186,722,520,933,821,977,642,739,696,190,863,392,484,24,768,965,978,130,985,428,877,457,871,335,419,686,393,908,278,37,691,264,332,685,702,464,400,993,55,483,649,443,788,150,441,981,976,849,2,713,596,530,494,591,432,197,744,269,502,315,612,948,405,297,133,427,464,832,332,651,623,971,180,44,413,532,180,136,869,964,519,822,195,866,548,599,129,756,856,630,982,243,531,688,37,698,975,774,991,191,32,498,963,220,910,462,151,749,779,353,946,733,585,735,909,769,720,125,967,578,229,192,253,771,870,273,883,104,671,619,48,680,705,847,194,379,339,158,21,619,594,684,945,156,491,662,255,684,494,285,388,99,465,796,669,413,495,432,215,878,532,147,318,405,900,901,771,944,493,404,154,149,6,91,813,660,940,59,57,927,405,127,747,576,282,753,841,949,993,703,965,286,153,459,178,816,141,334,105,448,309,478,459,719,839,678,824,128,779,170,279,923,461,457,486,184,957,841,947,602,655,136,537,174,134,813,740,943,606,145,925,512,365,909,946,15,284,347,8,97,682,735,236,146,242,828,716,258,171,270,622,340,611,375,815,473,387,222,791,532,850,540,148,402,504,990,913,514,806,646,787,381,632,258,880,444,673,345,730,461,767,934,55,526,616,611,249,32,552,887,206,688,261,764,335,71,774,767,270,528,845,448,120,428,894,486,44,669,504,993,718,160,265,633,952,812,408,768,567,551,574,867,96,974,379,405,841,448,4,372,291,747,797,62,127,553,710,532,557,779,555,89,562,415,139,689,323,291,946,774,350,317,313,834,187,664,164,129,67,807,466,804,508,449,130,562,410,518,341,381,608,479,655,650,739,75,203,29,720,406,527,512,496,964,812,111,36,661,438,611,735,247,669,399,803,514,395,8,963,313,28,690,463,963,800,595,518,499,93,86,446,537,502,172,623,143,356,91,987,376,377,657,905,916,550,727,320,377,218,373,286,185,759,744,713,35,874,107,837,638,489,80,239,291,543,232,952,0,631,259,884,468,839,17,673,569,321,610,969,12,539,476,233,62,857,541,412,683,69,451,18,630,838,128,57,768,712,672,474,352,253,222,341,540,64,290,932,557,134,216,674,105,404,86,754,172,693,86,689,714,721,152,792,335,833,617,407,540,767,913,263,450,747,788,936,881,247,814,873,881,227,895,818,457,270,666,617,56,746,817,753,461,114,343,941,473,428,156,356,16,119,504,822,659,647,130,665,295,648,139,296,210,262,498,271,362,229,143,578,818,906,527,944,765,172,382,724,652,904,136,552,513,268,439,342,768,928,755,933,105,289,190,70,948,178,476,418,882,963,70,944,388,870,394,498,763,666,410,119,326,358,330,436,277,63,75,532,517,670,671,607,505,469,534,843,847,321,629,328,507,670,425,603,80,877,258,779,167,781,435,129,164,267,780,772,477,461,77,447,765,887,49,640,975,918,573,476,826,493,691,689,669,22,620,293,407,990,3,912,927,720,367,511,517,718,643,786,901,700,773,63,787,676,28,111,758,762,835,135,65,2,356,590,95,876,571,358,490,201,224,266,572,459,855,419,32,313,100,790,995,299,277,850,699,401,510,136,911,3,104,977,369,215,728,658,372,788,373,276,451,256,785,381,87,254,564,256,292,151,57,69,144,984,538,741,745,191,156,572,919,966,743,704,961,14,838,869,912,537,296,39,632,300,999,608,937,649,770,403,18,220,87,693,948,704,921,448,856,120,654,636,876,734,837,888,590,496,62,592,30,442,404,743,78,279,71,701,907,798,513"",
    ""669,291,359,555,231,903,802,383,248,518,393,617,735,388,797,937,205,780,191,816,100,584,421,364,903,550,228,954,994,477,834,675,137,973,323,234,973,992,563,952,548,326,521,876,962,826,517,687,844,772,311,143,72,678,288,219,539,434,723,703,332,441,616,469,113,998,617,88,737,672,452,885,20,116,792,892,231,620,628,738,108,32,623,495,694,684,19,469,939,18,679,488,555,336,631,464,599,981,976,67,825,544,703,20,115,452,121,303,667,767,337,539,287,8,135,954,891,72,987,320,56,377,214,837,658,282,400,472,3,758,508,520,376,114,198,476,427,841,411,87,439,28,8,977,202,986,726,697,94,163,375,410,529,853,580,832,710,919,538,847,141,923,143,925,141,243,591,645,831,567,296,846,901,534,772,852,9,325,296,628,188,405,68,563,135,599,29,467,817,981,926,454,389,935,248,829,239,682,707,369,607,155,328,529,744,501,81,572,21,31,967,703,462,201,452,709,172,427,231,404,258,883,362,394,570,434,289,730,308,110,868,832,568,398,803,555,770,266,376,305,917,49,459,793,191,583,156,837,971,327,221,490,749,174,463,134,324,104,969,99,486,916,919,301,342,411,684,378,784,776,123,524,411,632,874,545,59,195,262,129,204,336,707,742,261,50,221,905,750,251,222,848,495,527,636,275,202,353,27,976,874,194,491,496,808,94,506,813,931,883,175,492,4,4,320,460,340,32,903,266,298,139,962,157,349,490,939,379,117,335,168,307,560,421,788,877,318,233,339,914,132,686,855,187,872,797,190,896,946,625,236,1000,448,664,382,144,385,935,408,617,316,977,605,284,895,463,584,126,39,610,660,764,668,125,781,164,244,63,248,58,738,13,191,994,447,556,124,760,68,474,999,552,405,259,837,755,117,159,981,809,51,164,825,800,352,486,66,437,779,581,458,949,298,315,48,891,606,943,747,979,392,592,266,652,442,308,811,21,935,201,403,523,398,548,688,479,196,16,61,848,835,293,411,309,431,962,815,84,122,210,716,590,618,103,470,981,68,566,860,511,708,460,765,475,99,178,127,156,125,13,791,149,968,27,930,755,479,289,396,81,943,135,586,696,969,86,194,58,217,851,97,873,350,775,388,114,150,727,935,11,241,178,816,17,105,702,526,891,770,886,464,967,776,111,819,325,13,380,374,148,193,170,890,347,234,103,779,579,226,600,726,727,7,349,215,336,310,610,876,465,455,520,614,41,257,154,245,634,477,357,735,136,439,306,535,819,8,947,509,238,796,879,420,251,844,517,252,556,666,734,964,953,554,582,572,670,139,824,844,365,832,400,790,169,625,561,200,393,197,334,35,517,233,886,693,618,151,62,656,959,147,881,561,396,385,959,7,794,895,557,495,311,807,122,659,924,859,989,748,255,129,911,246,686,554,192,574,296,385,990,532,947,523,269,156,937,959,462,732,241,362,237,228,186,448,507,468,646,451,355,630,609,200,638,234,780,664,631,0,391,830,954,299,134,662,964,949,877,664,415,86,704,39,320,142,403,385,58,865,507,45,221,546,392,900,505,424,96,693,934,19,630,726,324,314,73,959,728,987,386,975,874,839,841,761,168,149,60,510,705,787,600,584,770,262,742,675,251,306,220,559,553,835,993,868,487,306,273,833,416,341,734,264,724,341,779,522,952,442,430,66,257,123,687,586,876,916,659,952,970,76,203,109,275,223,804,124,52,692,401,733,66,462,615,616,637,276,234,512,967,195,259,272,966,750,927,607,466,365,619,783,226,403,973,378,771,586,34,861,252,515,286,397,634,991,774,573,509,161,53,640,738,166,663,161,673,145,384,182,384,216,602,279,633,747,354,814,230,818,658,146,505,157,447,831,998,51,455,128,790,795,753,871,553,792,334,299,487,706,14,808,309,367,238,707,845,838,482,196,59,222,816,25,738,779,628,207,540,451,291,731,253,237,445,743,696,207,188,848,269,321,70,255,508,817,940,647,183,454,920,21,470,17,269,596,259,428,462,12,592,269,142,341,632,781,338,870,930,835,19,614,677,200,239,780,462,658,155,604,832,131,821,750,934,850,683,391,91,31,197,918,22,343,788,63,569,5,854,181,800,571,769,932,889,45,595,499,432,151,360,40,194,878,218,584,586,40,640,651,257,586,346,377,959,19,337,12,238,800,448,600,532,248,589,186,49,513,553,174,432,158,69,904,491,654,106,366,497,712,781,435,998,901,43,765,23,416,404,129,754,624,718,590,563,486,373,963,701,214,421"",
    ""27,192,296,217,445,630,265,575,40,997,99,146,311,167,9,226,616,515,952,12,147,825,486,632,668,526,322,625,885,330,906,874,866,116,875,190,540,353,6,925,580,335,477,21,724,788,283,968,447,273,305,577,308,754,371,865,460,262,960,528,527,726,583,970,555,482,770,224,380,332,82,541,911,926,519,71,743,893,430,888,500,219,627,805,57,435,307,81,582,745,398,956,557,88,278,908,522,3,450,819,137,969,375,934,569,616,281,135,290,164,896,762,531,730,701,218,729,655,885,651,441,365,567,643,407,647,62,423,404,844,460,624,283,7,156,814,548,536,47,821,599,406,186,653,788,787,348,16,147,779,285,607,188,971,674,307,384,189,132,328,486,279,456,145,652,17,892,742,59,884,853,897,855,339,435,866,476,341,645,649,657,256,327,48,487,351,32,341,571,63,367,464,383,68,471,738,47,649,43,19,699,262,967,522,459,48,684,2,692,111,498,310,708,544,750,778,899,926,84,765,929,91,425,595,472,645,71,181,392,562,876,123,537,220,432,767,3,470,824,27,139,44,353,926,47,733,291,61,796,854,288,968,998,234,971,440,130,967,959,945,287,151,349,419,365,532,675,85,210,241,308,888,24,278,442,557,720,385,649,573,488,781,781,927,764,201,63,225,361,833,355,633,505,773,318,118,16,672,822,124,104,935,912,312,892,849,894,458,273,487,55,714,755,762,944,24,542,855,477,398,929,275,968,310,436,330,75,370,291,50,443,277,912,652,916,603,906,900,158,655,103,237,540,44,569,116,307,838,146,162,878,755,869,594,504,148,407,364,368,974,264,807,311,901,255,83,791,341,284,147,575,279,383,710,976,181,709,84,800,431,229,392,482,737,208,36,935,751,610,483,78,543,628,192,463,227,155,209,457,422,285,438,395,224,178,988,302,12,309,545,721,137,705,920,740,275,975,153,689,741,822,568,435,74,289,25,207,846,996,61,384,408,992,447,986,867,332,382,726,592,38,85,55,489,509,109,455,239,85,407,438,566,218,879,532,660,683,9,678,986,786,887,540,25,966,796,122,481,14,663,39,437,12,56,913,328,982,28,466,232,165,51,221,693,227,136,899,772,704,484,171,191,859,819,121,640,150,153,683,263,22,245,20,4,676,390,430,293,184,65,805,922,220,615,204,555,164,28,772,57,886,718,56,224,388,259,271,885,817,710,967,942,726,272,424,539,270,2,956,349,11,854,381,919,474,931,809,344,988,538,990,101,809,846,142,34,596,854,871,232,248,440,445,393,19,629,244,392,903,759,361,381,534,483,489,772,402,204,792,455,141,368,172,495,328,480,801,494,393,189,108,571,298,267,291,412,443,153,75,258,960,866,788,513,145,529,726,925,568,731,622,876,130,756,157,842,372,270,825,334,679,709,608,852,837,102,688,376,733,359,244,176,751,538,614,252,983,451,910,473,677,452,282,579,318,359,866,905,782,431,581,332,519,1000,28,345,183,259,391,0,948,769,346,313,839,140,325,356,795,65,355,381,924,497,532,811,962,556,494,526,401,813,765,489,523,412,901,78,515,815,794,139,263,683,465,84,646,869,532,356,932,722,2,388,445,916,615,440,437,816,519,470,220,152,987,250,836,652,469,827,762,321,876,717,51,709,625,621,458,152,425,797,908,42,698,336,638,600,829,933,300,308,998,301,833,340,508,691,162,916,791,681,468,402,855,986,850,267,977,290,517,28,670,629,593,183,198,931,663,710,808,500,944,367,265,367,250,395,732,668,670,479,420,633,472,620,825,384,87,143,373,977,901,178,792,1,641,950,980,191,651,887,702,950,788,384,825,656,638,927,363,40,710,74,736,300,799,196,284,763,945,92,909,50,492,223,357,254,827,864,39,614,308,288,637,996,195,948,627,55,235,162,346,709,431,888,198,720,859,323,688,109,271,349,419,20,391,508,33,948,810,181,66,493,894,816,178,21,303,9,878,306,318,343,927,41,114,766,629,89,790,91,439,644,324,219,844,927,798,311,976,903,117,93,274,544,570,419,564,408,825,413,142,936,32,912,440,140,666,518,745,707,147,330,887,109,457,248,895,876,762,821,521,268,282,435,36,501,636,200,104,336,256,8,733,968,475,521,862,411,803,496,783,143,409,505,915,611,172,317,777,683,933,248,336,453,688,21,835,556,626,906,153,679,418,460,444,911,800,373,762,861,128,150,676,211,2,964,387,426,392,704,960,514,858,645,400,690,236,617,248,771,254,869,764,745,72,63,324,687"",
    ""5,669,830,275,841,282,317,503,661,477,942,817,448,186,567,226,689,313,248,249,414,624,917,56,910,187,67,620,65,160,48,131,979,802,484,602,545,263,107,91,532,779,888,284,31,798,564,782,709,376,73,374,312,149,584,385,273,842,632,639,513,640,759,242,507,655,393,400,767,293,870,790,648,211,788,137,405,886,850,811,23,148,857,862,460,33,427,308,618,367,233,690,226,929,223,497,400,601,266,17,273,647,806,269,933,694,321,238,71,680,826,970,914,917,943,555,702,480,65,327,461,814,362,660,475,496,658,492,461,547,849,860,517,71,575,194,579,159,784,476,808,393,510,254,851,466,959,705,527,707,945,316,457,189,60,541,720,347,623,752,227,894,9,654,284,231,985,795,523,844,503,266,135,428,235,358,403,445,826,215,655,810,429,12,799,326,886,878,566,324,691,15,775,725,420,29,33,560,937,559,311,24,680,356,452,172,692,105,851,366,630,216,549,61,821,390,509,42,463,2,381,833,512,191,361,468,695,379,54,417,944,788,947,414,215,808,108,328,991,497,734,370,609,834,495,364,100,633,131,589,187,669,509,686,89,449,735,675,419,945,48,448,320,359,86,332,812,177,349,514,64,697,848,98,486,664,442,587,293,621,874,673,905,605,47,665,509,716,119,293,323,593,638,61,328,259,475,132,952,163,524,675,751,495,227,238,903,787,312,15,324,172,863,818,925,541,641,491,93,817,916,91,487,786,120,768,232,914,417,560,440,526,590,323,585,666,960,737,685,775,513,567,417,66,955,891,680,70,597,854,306,730,148,7,177,730,43,83,149,357,775,828,858,409,621,426,316,863,281,104,618,532,507,983,667,869,843,610,629,712,443,52,633,153,283,552,745,864,31,13,411,469,590,381,748,481,581,528,778,87,718,128,637,570,703,849,404,849,11,698,817,313,920,285,148,785,309,952,376,198,239,83,834,128,572,423,938,672,469,968,686,624,363,907,109,375,41,140,484,226,470,471,795,50,419,93,523,219,777,464,306,202,894,752,44,861,568,73,324,756,310,830,815,29,650,609,526,488,570,710,123,759,680,552,920,30,528,370,249,975,768,775,570,659,22,979,341,191,957,320,717,886,441,326,674,478,46,826,929,146,231,46,888,764,513,263,179,606,927,228,738,308,998,110,567,489,475,663,213,455,958,70,131,5,672,908,128,176,320,738,515,803,4,701,244,90,777,554,347,678,616,720,323,916,223,237,564,387,695,630,695,906,325,560,987,87,877,390,206,849,533,89,316,285,806,615,288,798,13,59,297,961,177,894,805,631,693,700,127,751,541,813,196,351,488,706,322,409,302,122,913,72,807,112,524,4,653,674,929,230,808,452,326,587,389,831,731,283,283,782,86,299,1,984,57,315,622,628,571,534,801,860,164,99,880,925,557,191,423,1000,314,449,632,669,537,731,310,115,648,707,650,398,395,390,615,646,312,929,41,597,373,905,874,120,966,912,460,884,830,948,0,577,919,989,320,158,353,73,586,907,340,681,398,746,71,737,775,439,864,547,833,959,287,784,285,211,322,681,374,931,654,447,164,315,529,192,155,503,510,660,199,819,987,577,424,286,452,370,928,473,648,716,87,995,750,206,147,615,631,19,163,631,797,839,821,863,40,393,66,917,643,139,134,722,536,584,556,288,284,848,413,41,704,36,949,343,456,750,43,985,279,381,853,284,571,557,615,526,379,145,911,850,581,253,47,223,347,445,761,334,835,726,2,175,255,99,282,348,119,521,37,713,11,933,817,829,945,54,59,270,323,212,903,358,644,291,136,44,871,843,927,41,429,935,568,645,883,450,86,545,363,96,763,941,166,467,798,24,411,648,340,99,383,970,116,83,904,449,55,193,57,633,813,727,218,334,996,804,657,989,301,371,403,212,146,960,284,734,764,416,150,175,220,105,100,392,933,632,630,638,962,983,676,401,790,995,925,333,444,575,432,536,595,535,467,513,46,751,316,806,723,57,824,359,399,633,314,634,850,22,668,818,268,12,834,264,881,272,805,340,113,475,865,513,231,94,673,415,69,415,822,212,922,841,240,713,823,60,413,777,474,177,263,980,329,15,838,914,314,605,511,996,295,592,289,320,943,876,409,452,278,200,57,952,861,660,97,660,447,12,878,430,714,515,294,15,73,713,399,740,946,644,735,9,547,573,757,620,12,63,266,701,920,258,173,382,280,213,67,347,828,229,725,896,183,984,516,820,514,300,372,191,636,176,919,421,532,241,52,355"",
    ""643,742,724,964,657,966,325,143,717,624,926,541,227,929,514,943,686,218,383,545,315,504,535,846,621,915,65,340,794,403,619,402,449,539,175,633,244,36,535,356,128,522,787,882,131,818,813,109,942,806,610,241,286,420,20,991,526,685,860,155,593,507,581,29,515,86,8,148,762,234,241,61,965,901,360,48,400,271,653,981,574,351,479,285,121,73,62,660,223,57,346,117,47,101,236,748,312,552,81,945,311,499,124,903,336,665,202,598,809,690,631,313,782,228,561,316,761,645,403,194,873,202,200,391,9,318,732,298,55,604,933,272,93,809,506,893,805,304,649,228,837,788,82,164,647,637,227,279,565,31,622,962,665,126,334,860,965,524,396,908,271,451,632,432,985,222,743,686,564,175,516,900,213,934,143,274,162,408,90,620,114,729,82,319,200,939,692,897,403,409,357,730,275,594,486,332,514,17,712,310,548,948,243,573,919,354,338,164,245,657,668,531,509,456,300,953,189,372,808,498,121,377,161,390,652,444,992,891,683,106,163,36,935,997,999,4,683,411,820,421,75,380,512,681,190,408,48,756,288,488,591,696,376,388,860,644,379,730,165,889,440,707,237,301,156,463,998,340,254,492,437,913,141,960,424,624,656,730,28,341,803,917,51,230,986,869,60,703,339,751,456,348,809,865,514,231,514,686,309,579,601,782,336,945,732,743,585,434,471,788,820,654,979,53,205,658,413,94,815,87,36,94,340,782,673,403,853,769,24,666,926,883,939,931,885,747,425,913,312,670,525,319,533,952,659,243,935,397,608,937,432,467,392,738,749,561,349,300,445,988,995,92,860,254,541,252,419,177,996,705,657,34,339,647,384,774,867,529,774,400,404,409,439,995,851,346,939,894,847,777,467,839,938,628,392,812,780,783,58,26,223,266,376,470,266,106,716,678,707,276,471,71,374,657,146,897,77,604,339,886,7,992,235,89,474,596,490,777,318,701,123,571,161,564,250,978,433,170,708,493,61,74,94,51,53,247,945,197,489,266,928,194,769,553,983,98,871,420,999,845,362,623,133,890,544,267,988,360,128,553,489,429,386,868,40,332,19,956,608,847,383,858,834,358,835,129,831,722,122,454,826,941,358,930,89,596,462,604,6,799,621,137,761,982,6,737,612,182,976,110,964,841,488,150,259,833,986,864,469,195,508,798,219,855,951,412,859,344,295,7,913,832,694,372,63,390,449,593,917,97,736,529,695,891,129,192,100,571,774,755,330,142,242,295,88,301,233,241,95,808,30,863,573,144,106,913,345,11,42,788,977,661,929,91,140,657,893,691,872,358,558,23,945,919,58,128,250,397,375,335,15,420,240,96,11,120,239,229,4,571,31,576,492,366,111,850,651,476,919,789,274,737,271,761,523,934,144,243,767,338,480,686,360,653,915,147,711,934,647,93,645,789,948,401,836,601,41,664,67,371,247,417,915,367,773,846,97,305,306,296,397,250,713,31,375,364,876,468,954,769,577,0,867,514,921,472,436,685,967,163,333,215,886,704,257,95,918,200,691,176,530,537,470,920,968,295,6,419,899,964,579,901,817,802,211,217,226,678,811,489,399,668,356,807,95,454,425,93,996,427,183,103,20,444,914,763,851,433,356,375,499,712,504,890,551,433,602,228,160,493,130,835,399,37,485,928,964,206,783,372,183,481,139,512,501,75,389,792,168,38,810,715,552,935,280,187,526,236,45,394,988,458,713,686,56,524,39,114,317,834,599,444,776,843,143,55,828,462,88,930,878,221,788,685,102,148,939,711,750,565,264,649,278,848,187,589,136,234,916,12,48,99,450,967,394,204,520,277,54,857,636,564,653,610,571,890,975,184,700,649,780,157,961,343,382,175,567,370,810,460,260,478,194,575,949,329,311,760,998,726,882,370,385,167,990,27,164,123,272,362,834,253,812,880,159,842,645,936,422,576,965,50,88,609,682,906,276,868,601,838,338,164,586,665,993,281,53,423,784,235,670,898,769,394,679,399,67,916,41,14,865,655,862,157,851,184,643,306,102,471,638,461,739,42,779,410,285,626,413,720,790,92,77,434,798,156,277,122,764,318,743,67,376,445,854,747,962,944,665,242,635,162,172,888,97,34,118,909,623,675,624,31,151,782,740,995,201,512,727,614,333,596,276,445,277,211,496,585,623,369,497,980,718,77,2,698,847,788,151,961,173,55,406,816,686,716,327,733,425,979,98,749,242,769,582,628,532,798,119,868,963,800,627,966,504,694,201,387,859,746"",
    ""840,260,101,137,468,337,453,421,626,616,591,32,920,55,412,745,759,127,926,823,823,630,740,518,184,106,266,151,328,776,56,865,273,127,297,287,559,599,823,656,194,144,973,872,134,765,840,971,590,561,518,582,964,451,129,979,927,765,993,400,996,656,46,62,193,366,3,948,84,175,398,960,126,474,877,171,890,966,451,437,210,306,969,580,261,482,433,187,15,738,540,796,582,288,478,747,420,18,841,727,900,907,586,622,646,773,833,850,720,808,16,3,972,511,301,906,37,208,342,427,803,244,636,765,338,225,7,610,72,470,234,691,598,29,102,441,175,534,481,745,250,379,239,909,454,754,142,313,960,535,625,7,134,167,643,912,904,503,258,433,667,878,980,772,947,953,107,8,287,238,60,43,998,432,335,122,303,32,410,539,959,211,200,110,908,928,805,451,529,391,314,503,255,797,512,797,259,466,972,793,940,196,179,257,354,271,428,553,447,644,679,905,280,889,734,60,71,944,154,750,859,368,129,461,290,525,476,995,9,369,390,536,309,463,792,621,379,467,458,836,829,275,135,232,589,111,627,700,991,187,446,79,560,914,124,329,493,138,499,581,397,652,661,718,38,858,945,806,495,465,355,278,602,924,412,48,624,46,259,17,314,376,291,382,592,648,689,960,847,211,373,506,617,983,405,7,386,713,994,850,338,248,567,432,492,662,73,430,953,932,586,276,160,334,33,775,541,591,555,814,639,557,721,236,263,5,189,777,589,574,304,929,504,915,475,272,283,408,22,966,198,686,894,95,887,340,358,465,515,171,798,397,103,660,630,855,524,753,491,637,228,769,153,308,350,168,887,983,287,298,163,856,73,562,880,272,923,364,675,441,821,591,257,158,643,936,895,908,791,192,971,521,639,403,936,176,510,315,187,958,807,531,642,780,556,968,75,763,515,176,287,788,85,578,104,251,59,237,933,689,850,47,238,22,276,305,395,323,379,867,492,660,564,745,19,797,131,531,330,950,730,673,244,636,622,530,939,448,762,485,324,348,450,832,961,713,765,659,372,796,986,948,916,911,256,495,584,169,660,773,77,787,477,669,715,467,141,319,818,777,171,911,483,983,555,309,415,715,477,24,479,292,33,193,522,30,872,157,498,686,939,921,885,988,65,165,120,888,8,9,755,782,40,57,852,661,248,932,645,957,375,3,597,421,554,937,1000,171,976,81,407,371,525,211,433,717,50,179,795,629,119,716,150,736,981,966,597,394,654,81,151,284,277,153,949,297,41,411,430,662,55,390,188,265,999,695,866,310,50,436,614,926,228,827,483,853,186,116,383,777,12,154,696,442,583,972,2,930,350,498,254,830,449,540,659,949,702,962,253,692,94,360,958,657,993,684,906,977,563,520,233,728,541,99,149,802,838,929,875,52,524,319,872,269,679,192,367,616,696,395,181,39,481,232,451,820,514,628,671,843,88,410,717,482,920,997,496,436,690,316,372,118,564,169,893,925,619,839,299,346,919,867,0,453,91,72,252,777,985,429,108,762,132,849,959,597,915,926,994,337,236,191,944,913,69,571,609,606,935,715,644,192,610,602,733,161,641,376,779,641,596,435,946,383,607,289,910,555,290,585,725,279,857,566,108,875,624,484,725,326,570,103,447,38,998,169,749,24,924,603,25,545,691,147,314,138,441,335,101,215,612,731,238,265,26,763,936,825,671,555,366,537,384,437,551,134,390,272,351,740,473,550,808,387,195,401,758,714,445,561,260,499,275,695,670,554,915,97,693,225,952,752,999,26,817,135,543,431,245,389,105,420,829,849,754,915,134,710,321,928,146,795,627,172,777,22,239,44,184,26,593,912,754,743,30,495,794,557,710,478,418,41,6,47,706,733,988,779,590,793,217,799,209,546,584,170,738,438,40,332,405,620,672,774,875,203,74,457,459,322,602,650,645,774,471,78,526,997,945,976,669,861,209,559,214,920,11,384,180,197,745,499,391,361,865,638,707,13,782,94,182,209,209,869,303,42,519,338,654,876,505,889,409,546,52,727,938,293,302,798,890,816,949,161,484,7,508,341,201,852,824,94,487,548,865,411,631,555,831,526,155,634,82,756,959,738,640,714,362,384,753,266,460,948,686,561,760,550,329,884,943,725,95,122,129,514,945,180,187,409,297,658,449,336,483,178,882,47,383,748,921,99,149,208,122,405,426,740,943,566,753,579,162,670,426,80,820,217,146,864,27,417,428,553,688,811,517,42,193,936,226,515,787,472,258,489,836,353,578,599"",
    ""999,206,730,204,723,290,549,152,203,270,929,541,685,408,979,85,401,269,617,994,591,866,337,300,692,983,323,704,787,537,279,480,817,943,409,437,182,155,782,131,408,554,265,639,741,900,677,506,691,538,95,505,583,626,629,479,832,407,236,378,137,138,302,959,39,536,42,914,813,64,918,138,358,842,864,95,337,892,729,545,412,11,303,2,571,925,419,647,178,933,415,35,986,218,804,816,502,413,881,810,245,382,365,670,604,255,505,524,366,254,113,178,754,362,329,805,629,700,556,308,449,507,356,762,546,475,504,429,836,274,326,760,298,207,455,340,559,226,247,929,249,953,384,163,577,179,785,799,968,101,580,129,592,875,526,373,781,388,936,162,474,201,93,436,145,619,550,303,390,610,995,221,137,394,491,229,831,944,681,122,845,332,937,147,658,852,720,408,46,204,194,437,796,341,883,167,25,857,371,64,377,696,492,431,674,421,975,782,174,216,387,439,849,907,283,719,251,159,87,228,509,420,315,642,483,452,889,906,702,246,359,479,187,887,198,577,593,533,98,6,386,544,817,335,175,57,673,780,359,87,201,169,652,489,312,639,508,216,358,524,113,709,697,875,907,675,475,990,292,274,826,571,709,98,630,78,545,341,364,697,976,348,494,945,852,18,658,515,243,701,504,181,913,65,934,836,403,369,500,756,865,849,402,552,450,244,247,489,874,227,954,169,390,949,523,953,662,226,979,268,211,182,610,3,36,989,508,214,246,258,537,877,967,52,374,905,428,101,416,568,453,285,405,625,617,123,835,645,252,527,311,1000,461,778,617,562,829,577,926,826,61,576,687,821,586,819,146,930,328,58,450,784,204,257,392,447,117,635,91,531,163,85,519,507,262,527,34,40,615,253,207,110,984,279,501,927,299,920,538,50,711,333,910,719,291,391,443,54,82,859,283,226,992,478,94,11,268,758,760,474,867,330,59,478,683,362,977,453,355,406,463,285,977,804,429,348,795,889,486,209,303,423,156,836,50,634,961,186,122,510,80,651,859,244,937,677,401,934,800,446,461,476,617,202,207,515,250,663,341,436,247,407,275,490,214,962,458,841,650,598,677,479,985,530,634,254,378,512,210,448,785,657,931,556,432,780,918,452,384,175,784,846,882,102,582,575,891,145,769,6,137,338,910,974,826,465,340,315,854,378,418,30,107,235,618,475,628,921,724,656,500,960,41,610,647,485,110,720,831,153,109,378,296,408,148,208,811,862,116,291,432,708,560,732,765,282,861,712,780,129,133,296,54,945,594,283,655,278,961,448,432,191,166,396,948,985,728,14,152,217,222,9,343,92,793,399,648,824,214,626,254,135,162,835,72,531,557,281,718,291,464,778,547,34,517,882,690,905,338,992,549,332,192,614,730,455,267,778,611,512,709,895,734,570,36,665,567,873,489,638,832,495,150,362,694,404,108,165,770,120,159,819,654,160,397,582,92,862,220,591,591,363,423,49,802,300,429,17,134,313,989,514,453,0,55,828,191,824,511,674,340,963,255,270,743,799,232,950,514,636,565,266,90,812,628,894,202,271,734,195,170,730,363,72,507,982,368,178,280,114,727,548,450,671,359,553,944,354,69,449,888,262,862,372,605,96,379,686,938,752,374,614,784,914,968,838,323,775,405,636,762,473,742,988,675,667,89,104,642,658,310,689,403,63,334,184,280,145,206,742,455,49,290,801,751,330,299,17,165,975,725,406,775,597,426,22,904,407,156,395,130,47,714,399,303,387,94,805,605,322,36,85,777,40,186,792,975,667,766,33,616,50,413,131,359,970,28,698,357,359,634,976,352,34,14,937,407,267,119,431,916,583,977,125,343,368,937,141,432,266,980,700,990,854,730,48,263,569,360,539,136,889,176,908,627,13,109,746,791,772,924,861,663,864,400,59,994,236,107,273,167,160,930,217,41,47,922,390,101,131,853,368,494,909,969,679,806,755,792,103,203,991,464,789,414,641,927,674,123,490,476,436,521,926,765,494,151,561,504,366,27,967,913,515,816,242,119,842,381,734,736,749,969,154,414,687,543,945,725,424,467,250,199,240,88,824,309,169,724,997,979,595,40,100,613,427,798,953,630,890,855,544,262,833,842,535,287,389,637,468,522,872,755,882,583,908,681,831,428,978,301,963,979,898,401,897,713,549,338,181,889,175,491,918,637,87,544,859,494,934,387,805,949,276,114,601,465,906,558,177,36,625,499,895,236,208,170,998,957,751,81,618,749,889,154,757,165,860,710,705"",
    ""940,152,795,388,124,656,104,508,709,448,344,397,194,256,872,239,837,238,69,570,571,846,290,559,714,604,530,671,960,813,556,919,509,577,364,347,390,646,375,194,924,405,382,460,701,730,259,544,53,218,444,537,351,34,271,931,443,305,86,864,637,305,71,269,447,644,160,27,549,495,501,976,197,937,611,394,85,647,168,316,242,477,660,240,807,756,130,190,606,768,618,510,874,914,121,509,507,201,674,254,519,642,312,98,465,946,143,285,365,18,32,921,44,919,19,680,159,265,18,331,633,289,7,427,759,63,330,122,946,434,922,445,467,470,675,919,758,148,922,446,632,565,488,90,921,203,197,326,284,225,904,454,413,486,617,954,916,890,108,131,332,822,330,486,626,510,857,869,889,615,28,172,371,710,631,471,934,798,366,844,873,246,479,389,840,755,19,423,904,595,889,835,187,119,326,80,822,861,502,628,470,293,775,858,20,333,430,72,408,124,232,164,883,714,706,968,640,875,600,664,628,518,46,796,809,320,445,728,592,439,989,917,249,880,538,390,508,543,816,466,667,499,174,915,931,254,834,277,939,146,506,331,103,653,365,919,404,663,911,464,750,278,763,980,93,875,22,743,928,148,311,371,667,862,600,473,106,583,879,194,274,169,158,866,143,754,272,126,780,602,800,413,738,57,797,243,927,118,106,37,139,327,738,729,477,623,6,73,859,559,419,346,256,736,877,602,555,864,322,725,853,703,150,326,773,459,646,207,931,211,982,767,824,805,954,994,603,877,385,650,826,908,523,7,400,314,840,693,735,542,548,212,228,205,596,672,934,587,298,342,878,446,526,454,483,354,512,242,877,831,548,415,927,426,832,391,435,881,563,695,506,113,91,2,200,953,421,305,448,727,914,908,820,341,442,7,813,462,422,31,123,553,946,92,720,478,666,678,805,845,661,170,951,824,92,378,364,360,303,951,281,376,211,626,668,388,59,516,606,791,151,160,120,151,648,18,903,154,752,446,268,619,726,372,950,625,757,160,894,12,486,720,973,152,210,828,557,385,137,452,211,487,412,328,437,922,692,566,986,746,601,649,170,716,850,657,814,327,778,465,902,930,392,889,822,847,296,743,50,872,450,215,372,21,675,712,772,807,760,994,899,151,723,702,507,958,43,594,200,706,336,217,273,230,727,16,484,184,478,819,280,635,311,947,19,718,960,568,359,15,284,165,995,141,715,398,325,653,720,497,18,909,250,471,32,765,488,869,379,315,952,393,134,447,230,590,539,375,532,487,87,188,981,836,844,699,957,352,171,9,829,536,259,303,23,128,106,409,205,749,996,491,957,248,132,96,717,773,288,176,881,515,967,20,268,179,113,710,103,654,421,306,27,987,948,413,528,294,376,168,156,325,280,612,632,745,637,803,769,748,588,645,221,166,631,906,358,143,20,76,77,640,740,948,621,540,437,601,405,881,573,830,591,594,785,510,353,862,924,675,681,955,237,355,996,393,700,673,662,839,320,921,91,55,0,494,380,836,151,378,952,205,549,275,938,108,131,11,621,828,243,983,760,974,504,736,343,118,88,164,899,426,35,76,831,158,969,564,611,210,441,165,791,145,955,735,479,376,119,687,582,861,554,77,871,872,645,708,186,301,922,967,857,288,260,764,954,83,395,96,752,327,915,919,716,896,119,999,69,99,94,916,594,27,403,126,70,488,481,891,253,416,998,437,526,395,637,961,340,256,652,160,342,849,438,572,573,875,532,768,857,567,156,97,935,60,533,793,860,273,213,799,64,998,3,385,586,110,888,119,671,36,957,683,981,239,487,508,799,98,979,142,242,750,826,757,793,451,151,178,699,763,329,744,134,105,45,578,763,377,989,40,65,529,553,424,613,579,905,413,9,31,340,952,589,277,938,632,602,120,640,986,919,294,407,275,431,8,369,464,505,907,976,526,860,692,889,58,913,310,47,479,721,720,353,687,594,742,552,895,237,675,221,356,161,912,386,396,484,655,718,377,870,447,42,71,381,342,721,33,240,779,352,59,6,426,980,396,778,586,795,528,23,809,167,300,943,615,925,131,727,816,72,339,451,630,514,41,569,817,802,497,897,13,257,607,979,25,676,718,87,568,301,200,122,865,631,949,43,925,545,874,29,203,96,855,981,708,95,32,25,340,15,989,1000,684,70,88,722,455,384,950,835,515,656,359,390,245,672,214,836,633,495,463,325,728,550,238,787,986,523,369,526,476,971,226,682,389,714,25,435,415,103,865,764,441,652,520,864,137"",
    ""489,419,997,96,940,166,412,839,679,468,523,839,467,194,579,422,417,508,939,767,391,347,452,421,624,768,38,724,780,569,161,258,219,53,10,958,357,865,486,848,710,551,519,527,291,261,273,790,513,8,494,58,404,397,902,960,274,217,831,862,603,58,149,378,488,222,982,853,538,269,690,289,855,558,470,289,979,791,845,340,662,603,316,119,166,735,501,49,836,67,523,428,814,434,910,760,180,752,138,475,704,756,256,720,1,152,595,480,671,535,381,347,325,796,375,861,66,618,823,741,826,668,512,962,519,840,354,463,939,967,588,114,729,306,584,550,971,749,592,868,86,41,914,7,567,176,320,157,660,266,77,918,492,11,981,599,237,33,683,338,631,64,13,607,955,750,753,915,277,605,416,386,665,509,170,869,690,170,261,885,125,952,344,281,483,488,817,780,941,960,651,250,891,325,362,548,873,190,97,77,240,406,577,215,339,890,479,431,516,410,712,193,376,63,106,905,707,477,299,938,369,884,682,430,308,389,156,993,615,985,684,841,523,356,944,240,803,509,577,624,896,255,703,423,407,183,817,812,321,923,797,964,61,503,190,275,85,652,603,390,876,896,557,926,466,496,877,662,891,551,402,881,843,342,926,549,164,701,54,938,502,956,713,172,48,462,575,406,288,565,98,236,857,800,279,387,512,425,220,45,289,363,857,404,589,917,261,350,501,609,787,87,479,166,808,419,521,318,709,146,611,35,809,490,541,551,675,214,463,910,669,297,694,524,594,182,933,778,526,674,135,687,120,936,660,956,593,236,968,585,621,268,160,398,351,70,928,197,339,556,452,183,324,121,59,138,921,755,22,473,71,96,549,635,227,63,743,355,889,648,956,623,175,521,551,441,80,417,847,29,279,251,52,515,271,680,488,414,727,75,260,777,357,723,328,1,675,158,526,991,285,110,330,977,286,48,111,971,309,390,987,349,716,750,818,676,452,449,953,172,637,612,305,146,146,986,250,734,566,844,409,490,31,822,927,162,816,326,186,661,433,212,176,802,146,673,806,347,736,961,763,106,698,673,978,161,497,907,592,104,421,110,847,508,855,32,479,213,825,823,841,509,284,221,33,940,990,985,407,465,712,133,222,650,406,369,473,276,670,267,882,53,347,210,201,305,633,3,690,19,905,69,202,845,919,236,405,146,56,48,542,894,410,509,154,984,815,218,274,342,97,403,398,968,193,411,399,46,399,747,593,884,712,670,975,517,949,222,357,935,625,429,971,343,791,489,258,140,619,10,645,751,480,321,957,579,741,634,641,244,570,462,74,290,712,973,317,533,756,577,189,752,978,488,375,441,700,559,769,213,577,689,679,942,266,331,19,123,624,140,754,413,356,409,108,940,911,241,910,314,353,542,387,165,401,721,534,496,550,499,789,892,283,721,971,52,955,200,303,371,522,64,154,821,194,67,933,437,697,470,772,431,437,276,805,89,400,829,618,499,178,233,786,894,531,335,445,569,964,140,158,472,72,828,494,0,25,206,48,729,11,16,597,323,704,898,300,91,504,908,249,9,612,972,332,926,848,986,592,192,215,836,237,72,624,552,255,18,363,569,393,53,253,921,977,887,265,623,592,365,772,427,626,53,303,386,460,876,991,695,58,9,258,935,177,850,264,557,709,555,300,26,549,206,93,86,567,291,276,919,58,211,345,998,783,614,331,228,243,550,993,12,409,746,476,76,438,318,373,811,406,533,362,845,833,212,211,342,342,597,751,90,460,359,656,406,551,3,953,496,855,861,940,990,967,170,381,330,465,50,652,120,140,256,492,708,379,409,913,299,534,685,155,177,58,136,913,607,698,273,887,113,613,886,696,430,999,84,904,713,243,470,587,596,490,906,143,532,512,256,87,44,993,334,231,708,95,131,90,843,176,434,198,286,780,655,311,380,891,966,130,34,336,609,194,237,868,484,488,724,395,886,460,872,667,534,365,543,936,729,429,96,177,124,394,219,367,800,737,301,530,614,530,279,873,168,750,608,798,234,350,683,287,525,82,925,500,844,260,560,145,711,38,650,626,558,771,376,186,379,205,124,661,162,251,987,395,894,131,686,448,914,264,729,967,178,978,656,666,273,395,751,375,727,159,689,974,601,421,764,810,484,98,312,36,795,3,322,963,923,21,859,356,275,487,372,755,373,17,303,348,74,150,321,953,28,195,859,211,845,782,978,565,444,448,905,219,918,40,348,572,925,29,856,624,590,988,269,268,476,705,671,133,704,339,668,323,831,276,55"",
    ""803,84,795,121,212,637,156,769,367,496,601,568,603,869,630,607,468,661,235,916,846,824,132,736,66,750,889,237,892,762,426,951,174,21,764,183,130,452,582,243,830,454,820,219,864,6,930,865,109,756,918,262,453,563,245,442,494,442,676,836,308,152,271,606,787,904,142,627,815,199,86,390,526,361,169,237,528,979,662,769,448,117,659,142,648,687,367,936,506,383,254,978,660,274,125,391,413,645,231,640,443,16,853,9,659,571,407,602,195,228,500,486,909,759,690,292,609,426,673,658,757,372,421,32,60,764,176,360,732,744,666,740,382,676,560,837,919,708,933,881,433,357,841,4,945,63,376,961,678,780,422,602,675,537,627,249,67,991,907,215,552,8,118,851,583,933,798,887,145,838,629,134,571,51,401,546,92,780,418,292,371,969,270,392,540,325,749,755,453,967,271,306,166,452,909,139,861,44,138,802,554,379,673,319,311,770,770,841,734,800,541,236,712,526,107,42,97,995,481,929,214,464,664,721,254,145,255,398,936,234,333,838,669,628,671,120,834,613,823,149,198,577,610,847,200,117,111,653,91,7,3,18,828,657,255,790,852,642,653,976,297,57,438,760,503,117,281,475,379,896,685,373,675,758,817,337,347,459,545,725,802,631,631,367,924,221,111,303,948,259,208,650,639,310,614,686,761,964,746,440,64,995,750,227,589,457,688,645,125,51,54,594,395,528,412,976,142,142,809,806,420,588,33,848,30,352,370,150,457,737,508,969,683,901,50,671,924,799,30,500,866,958,53,232,207,859,891,311,199,698,921,926,884,204,668,68,29,255,943,927,57,462,443,685,548,26,58,722,681,250,851,408,698,117,434,162,659,930,750,149,611,198,212,904,963,654,228,884,874,949,767,106,477,460,647,723,118,26,124,423,616,561,788,594,708,480,598,76,243,664,850,232,897,531,81,620,464,151,577,742,472,945,98,897,142,209,937,669,31,545,966,73,884,976,882,429,656,534,574,895,142,443,87,805,675,764,391,168,588,548,160,717,864,234,398,163,167,347,486,650,417,850,136,533,629,329,294,50,630,195,446,881,927,69,684,266,536,395,823,713,765,788,857,702,158,172,444,716,704,389,838,196,957,158,128,534,114,464,627,518,902,116,390,152,267,560,747,266,167,742,808,57,673,183,888,877,652,677,507,716,996,733,496,873,875,73,733,961,410,962,579,973,104,301,729,949,838,21,794,746,924,500,468,274,511,402,4,190,379,280,531,980,437,550,709,210,323,694,24,887,322,876,89,754,886,372,85,865,632,284,377,522,910,578,220,457,409,640,276,647,211,37,100,285,625,73,991,170,622,919,853,478,968,322,352,427,595,512,810,7,300,22,366,650,310,488,859,459,743,727,209,17,609,348,78,19,631,3,598,608,108,349,491,939,403,851,973,831,918,606,639,806,865,243,578,407,680,411,915,669,531,755,436,852,655,501,598,930,687,596,671,777,418,361,908,587,510,321,949,325,353,436,252,191,380,25,0,287,95,373,497,341,933,514,779,911,761,693,485,832,104,875,617,819,127,956,513,282,222,110,81,929,72,512,103,656,133,390,84,69,433,436,39,731,526,458,760,324,199,41,860,284,37,226,554,318,769,990,253,235,496,124,240,843,184,87,10,734,759,985,256,560,389,167,220,174,603,439,527,185,784,138,458,210,930,614,372,525,200,94,561,74,676,594,264,635,84,785,733,247,224,22,508,907,571,895,838,354,590,702,818,966,52,130,329,585,621,871,419,451,272,776,189,154,838,961,593,379,487,885,15,403,861,387,787,407,300,229,214,326,496,889,153,207,839,228,386,715,680,305,939,724,804,318,172,911,150,278,6,632,863,718,681,548,830,296,420,79,428,771,948,819,917,826,70,116,344,614,815,657,925,499,290,36,372,201,885,874,571,306,58,785,721,602,106,391,848,926,659,497,256,780,370,811,588,634,984,699,90,564,976,397,811,56,193,425,829,818,383,801,556,662,432,924,932,937,527,357,255,479,380,762,225,446,618,667,430,140,605,669,396,533,692,602,871,147,776,785,296,445,133,473,94,793,80,653,102,50,143,188,194,450,539,951,854,344,354,795,329,983,280,535,96,978,233,642,829,89,873,332,862,631,330,517,939,72,686,734,106,249,52,818,170,321,529,175,906,572,614,953,268,211,905,146,316,319,763,970,446,350,249,175,432,916,178,823,771,133,225,57,341,528,814,48,178,862,506,62,887,600,717,142,665,380,630,677,391,779,723,292"",
    ""164,814,415,329,387,967,54,581,492,102,363,900,838,16,201,799,183,13,663,754,264,633,198,786,746,633,703,463,834,77,81,136,844,738,953,776,668,797,328,828,721,698,656,84,372,907,958,242,658,93,825,731,437,678,19,317,953,967,359,654,839,410,992,967,980,767,264,543,238,570,560,684,558,490,382,363,10,645,565,942,608,434,415,749,236,71,330,984,653,723,373,193,502,192,776,230,596,424,952,280,162,63,378,64,266,419,6,84,684,603,726,382,948,937,45,611,605,563,518,918,156,927,213,621,935,156,811,749,367,86,228,763,204,344,743,310,295,502,311,513,743,485,616,885,383,890,521,988,438,142,198,551,5,227,835,93,208,110,76,321,826,383,763,70,628,780,71,449,616,134,610,250,762,708,747,578,765,707,753,685,68,318,69,988,433,244,626,923,865,635,123,964,397,416,27,965,695,662,888,236,255,451,562,577,799,758,416,924,75,219,288,999,598,739,698,323,318,951,168,163,188,806,859,234,235,18,388,275,850,370,872,21,151,125,865,337,590,509,518,392,606,559,477,145,348,352,661,21,832,816,699,690,955,122,670,780,28,607,326,796,95,962,301,610,419,335,28,876,748,137,70,147,404,533,858,336,786,461,665,526,608,401,213,887,342,852,452,138,927,642,663,557,274,153,943,577,885,581,590,939,325,734,178,208,718,750,345,297,447,812,916,541,631,113,680,722,191,603,485,253,83,78,413,905,519,808,171,885,920,995,447,581,14,955,868,380,566,791,238,462,184,52,234,552,674,127,571,268,254,410,951,268,130,645,74,457,91,682,828,228,161,938,830,737,528,727,253,713,508,521,11,320,394,905,764,459,671,730,777,826,207,278,606,887,861,399,414,244,415,159,697,325,203,461,186,759,292,517,282,252,602,691,902,10,826,294,947,927,910,708,686,227,152,95,316,19,321,996,387,353,706,883,960,808,272,560,205,494,298,694,154,23,988,358,506,405,346,563,526,179,558,216,146,541,759,814,906,24,371,523,865,967,46,510,321,777,823,286,141,745,526,49,546,107,154,234,726,102,916,294,761,993,532,796,401,268,61,908,794,769,153,298,880,164,576,852,839,505,231,847,334,172,179,558,576,571,283,966,903,244,711,671,1000,370,195,884,59,166,335,453,466,321,656,155,196,7,91,425,230,902,222,427,790,749,987,548,583,237,646,452,19,456,31,534,870,743,893,514,789,434,184,778,233,177,344,569,107,724,812,250,718,156,72,630,279,56,755,787,606,289,73,469,877,358,113,250,945,282,977,977,22,662,734,769,45,122,983,704,721,865,395,232,437,746,656,50,171,494,160,816,29,882,237,803,579,915,452,352,7,733,590,23,41,243,791,963,885,797,461,115,219,931,146,536,751,758,992,646,940,164,996,554,420,764,856,785,266,343,852,329,766,822,89,217,563,338,703,215,19,986,392,996,855,846,836,266,559,436,732,615,654,267,148,256,303,786,28,610,877,356,73,685,777,824,836,206,287,0,502,659,210,857,973,888,997,193,214,760,935,734,815,74,26,506,91,395,42,340,911,977,894,967,382,25,842,217,514,980,744,563,811,588,691,299,204,585,452,821,760,174,538,203,406,565,172,435,567,441,626,548,968,141,634,546,943,773,450,615,517,582,445,968,646,268,740,613,352,449,594,162,63,536,403,151,880,60,653,906,256,358,722,483,666,604,312,916,155,340,687,438,287,545,528,342,215,738,349,444,318,382,553,812,791,263,446,928,847,691,363,419,930,953,306,936,446,354,938,215,271,522,729,224,2,296,457,970,598,554,159,205,78,331,10,20,688,944,159,699,953,828,497,910,784,768,461,432,134,103,527,74,586,506,804,756,191,271,73,47,418,349,908,975,965,410,98,965,545,114,962,220,645,365,818,711,835,628,666,600,725,773,174,980,527,690,552,180,210,819,903,538,181,845,368,426,296,460,714,657,106,144,404,202,43,661,943,554,584,6,903,862,564,828,236,332,899,339,475,932,505,940,420,388,211,677,727,9,788,601,347,542,747,877,450,240,850,127,10,490,751,439,564,37,610,224,833,280,979,669,748,427,660,344,83,563,23,101,75,111,511,634,902,758,715,700,965,159,141,364,273,378,894,785,681,967,933,261,217,153,89,979,62,441,727,296,595,89,618,909,532,336,185,107,368,247,318,470,447,704,624,14,541,433,653,236,95,348,790,58,777,244,965,522,931,329,867,155,828,540,524,655,829,666,333,963,286,548,854,487,954,378"",
    ""806,656,475,156,855,735,103,627,964,330,284,639,672,734,903,400,138,101,853,291,556,946,973,918,648,136,859,600,209,985,90,729,76,327,888,464,905,680,365,175,914,408,765,600,662,751,691,847,802,322,795,806,543,645,824,336,915,134,899,891,341,454,446,443,589,186,257,706,219,567,107,885,710,72,297,691,824,986,990,488,396,196,710,21,356,189,627,91,392,282,721,765,605,445,273,598,901,703,498,761,377,957,300,725,788,790,744,404,764,846,465,383,69,688,146,472,622,422,221,985,208,809,91,897,312,783,53,887,151,155,433,758,12,489,644,567,825,733,455,347,71,868,660,682,374,897,81,527,524,309,907,504,39,227,869,75,465,378,494,885,786,80,454,446,719,145,870,438,45,680,802,713,253,893,399,340,393,245,667,463,723,762,421,386,56,194,516,380,632,869,579,382,334,190,159,403,686,148,755,757,948,291,594,268,102,716,992,668,581,508,680,718,859,244,358,335,291,234,943,667,94,580,7,524,448,672,578,12,835,292,785,760,78,72,565,411,690,832,632,906,330,621,31,278,600,200,521,568,407,956,122,596,987,986,431,146,816,300,108,145,339,290,301,915,224,568,63,612,303,89,634,329,324,739,945,406,605,965,417,303,938,971,442,40,336,545,302,362,930,74,918,174,767,133,213,235,371,657,955,716,121,187,730,76,385,734,672,910,716,942,202,50,888,138,4,785,665,875,390,592,470,372,90,231,683,956,171,38,542,863,927,51,49,181,259,228,741,40,594,946,137,77,827,915,769,355,638,292,466,265,677,657,378,650,159,464,728,644,284,272,894,647,739,660,583,366,120,953,649,219,748,480,981,282,918,865,413,597,936,59,798,141,429,977,293,230,293,498,117,964,784,617,493,601,129,888,722,888,97,704,252,825,97,546,782,577,145,166,37,556,943,868,117,421,582,171,198,448,489,303,392,214,648,660,117,964,694,766,491,47,437,348,419,630,389,541,803,693,815,550,426,190,928,862,422,390,358,313,207,6,779,452,989,535,630,895,333,419,57,261,231,973,495,651,149,189,974,255,392,416,906,904,684,133,58,226,640,81,670,175,356,374,288,95,465,165,907,28,615,208,603,795,725,525,442,432,523,889,166,337,183,108,150,72,481,599,901,260,411,328,957,316,659,343,133,357,414,501,157,690,535,755,7,131,917,641,748,154,28,143,251,130,727,243,898,881,766,84,182,53,828,262,35,295,492,999,44,998,492,133,621,265,716,924,804,945,715,428,937,812,899,952,599,318,700,74,815,475,22,641,363,388,990,614,44,225,588,32,360,167,222,816,942,728,742,570,417,366,634,190,27,300,28,429,698,901,689,241,802,173,536,753,633,308,905,239,188,794,342,505,881,384,855,843,792,773,362,637,803,357,740,549,415,8,603,613,991,207,574,530,439,921,338,237,697,130,702,430,38,450,500,247,896,164,234,217,357,270,118,833,931,89,128,572,79,689,175,969,664,795,586,967,985,511,151,48,95,502,0,802,114,887,91,137,577,76,866,32,442,827,569,849,138,32,266,928,244,970,589,610,952,724,973,327,646,615,377,560,570,614,807,473,681,899,941,908,43,398,516,302,190,16,435,507,656,822,819,440,712,780,762,841,22,849,179,459,118,993,330,930,161,974,520,412,806,872,753,92,755,94,71,892,786,215,338,886,620,986,963,982,989,961,658,350,273,917,903,532,736,212,897,65,261,202,788,52,99,292,171,184,809,78,738,950,38,777,399,5,955,748,578,324,305,424,445,673,367,414,170,889,98,64,830,413,934,102,424,72,965,874,466,447,4,695,185,184,59,85,480,104,941,406,841,733,452,684,186,583,865,589,671,781,753,518,883,653,1,45,491,518,226,307,41,104,231,731,977,257,502,604,106,232,438,870,682,906,495,616,271,842,362,604,342,927,856,348,873,475,591,978,919,771,732,385,167,982,957,821,7,869,969,29,449,295,665,264,819,892,369,854,982,25,248,274,18,257,143,476,252,593,482,343,887,797,78,871,137,999,869,283,537,149,542,599,897,226,257,316,295,56,323,894,926,53,548,125,924,628,816,647,204,103,360,199,143,341,736,87,636,211,688,938,692,762,524,669,857,592,249,872,58,459,852,164,364,501,436,366,74,382,33,766,708,141,211,747,602,612,982,90,239,51,101,118,606,221,269,651,941,896,233,987,491,32,868,184,165,155,932,68,280,435,730,692,165,834,864,533,587,935,628,155,728,429,645,993,959,242,515,833"",
    ""187,236,851,488,65,177,668,340,544,547,636,80,776,12,576,724,844,146,543,31,952,837,952,589,409,389,178,503,677,586,909,557,974,352,32,914,546,561,117,772,897,79,353,640,585,630,129,235,847,964,862,323,566,727,220,305,310,651,406,997,850,423,726,329,643,436,263,492,118,13,41,288,973,604,208,819,535,79,24,259,144,643,175,585,4,971,902,208,519,66,907,640,497,761,108,578,143,173,498,672,157,371,982,223,866,563,536,127,510,568,496,371,225,83,423,550,180,69,277,571,588,571,704,973,48,167,821,910,456,783,905,413,817,259,585,613,33,784,374,851,744,901,837,943,497,980,745,540,720,717,780,99,76,493,89,895,298,533,903,852,403,709,293,57,875,237,651,440,443,589,369,234,967,62,792,394,670,234,928,531,516,647,361,490,22,647,951,327,312,802,669,489,578,755,922,898,863,468,117,217,350,400,979,299,299,820,227,855,776,677,666,124,878,76,203,871,917,416,141,232,647,504,438,77,623,641,290,484,22,675,119,952,591,185,481,507,548,402,954,21,375,977,31,989,693,451,615,462,499,771,402,828,443,780,223,482,655,236,299,944,453,179,947,880,816,852,411,434,763,173,603,874,808,708,987,549,836,710,2,512,692,839,152,484,973,921,934,635,702,192,989,564,223,840,581,957,251,57,858,742,337,444,21,237,84,289,845,296,244,756,73,560,984,834,721,800,226,514,465,626,928,357,388,535,376,284,922,681,930,554,297,187,411,964,373,718,629,618,216,348,354,706,100,838,38,140,543,322,197,695,202,381,401,899,801,179,320,129,971,583,316,476,950,512,519,702,658,234,781,925,426,834,13,255,229,456,957,908,472,161,450,571,382,201,475,988,112,998,321,577,942,304,925,968,199,489,495,852,991,435,698,780,852,701,638,960,504,388,353,790,511,693,645,323,173,914,521,686,674,90,124,882,332,164,972,517,780,391,177,52,341,932,596,609,525,677,318,842,386,671,423,284,116,197,258,941,615,275,120,434,752,759,657,476,242,14,588,242,395,538,854,4,817,784,478,575,806,852,860,760,605,694,756,547,118,236,231,283,551,246,386,577,361,536,257,167,686,448,574,628,963,102,242,1,284,70,582,68,706,671,523,892,704,986,139,267,610,73,194,190,654,721,793,431,583,956,574,793,5,993,423,899,44,54,302,698,958,197,974,998,875,33,408,183,497,203,288,648,117,160,268,250,557,742,799,246,473,647,342,422,942,331,131,455,389,574,542,939,813,714,879,863,558,999,308,802,334,476,611,748,73,348,56,140,662,634,239,120,939,769,631,742,681,840,41,913,10,566,648,42,666,594,211,104,424,443,167,647,343,934,788,758,766,272,12,328,736,932,17,54,485,303,493,841,626,514,322,944,74,382,793,916,206,351,42,182,737,625,120,946,844,520,589,57,642,395,233,436,157,320,63,959,102,869,146,121,126,31,188,709,75,405,795,618,491,689,317,12,415,65,907,163,429,674,378,729,373,659,802,0,322,311,992,377,575,244,441,7,725,481,383,837,98,455,406,880,682,357,646,928,178,486,536,849,494,861,601,114,653,570,4,863,375,5,172,884,698,571,622,174,130,98,915,478,1000,17,775,331,91,283,207,522,425,284,981,26,311,244,36,896,69,847,945,517,503,146,116,442,739,198,542,68,301,132,151,672,336,734,487,614,935,393,97,159,157,679,319,784,267,33,12,25,293,709,605,653,724,487,555,355,126,525,87,579,695,444,384,56,134,844,927,748,446,393,843,640,868,555,945,909,176,474,435,232,739,822,663,879,943,897,871,674,321,938,338,515,320,582,880,270,786,149,955,576,849,286,644,322,168,602,767,553,119,905,535,695,702,292,836,374,144,419,279,635,514,338,244,22,955,165,877,209,38,901,411,693,794,900,576,204,848,343,888,682,603,910,660,527,573,551,280,854,227,759,552,902,466,743,838,163,627,288,345,283,102,748,794,223,921,93,944,280,94,388,974,497,609,970,276,878,723,816,562,868,184,471,869,677,356,659,475,77,190,619,133,185,288,796,767,241,3,994,539,529,600,306,427,727,673,141,952,347,79,479,594,731,831,293,544,149,482,658,795,769,460,643,508,183,737,873,467,488,98,498,926,728,443,466,691,874,440,633,966,665,217,803,94,522,511,869,565,526,168,603,116,401,574,481,251,130,782,40,484,99,107,802,516,805,636,884,610,726,52,957,836,539,857,875,845,452,379,524,397,381,342,862,887,67,646,63"",
    ""989,262,274,645,382,766,113,686,852,550,445,617,937,131,577,628,56,208,491,805,693,725,16,389,108,887,491,627,431,341,816,550,566,703,502,928,792,649,289,786,884,654,214,592,625,334,964,954,409,304,910,964,786,914,834,36,297,829,477,112,797,4,327,607,703,80,908,299,965,837,990,66,68,30,179,542,77,849,897,999,462,774,33,284,233,110,714,155,388,71,91,441,214,108,854,550,339,740,230,134,336,685,599,830,114,233,901,843,356,678,132,715,39,693,734,217,510,275,662,213,781,301,890,382,721,89,447,33,375,635,357,280,712,819,214,108,322,594,787,788,789,437,502,505,593,888,573,274,862,180,85,702,173,831,620,739,582,46,993,625,811,595,395,494,455,306,764,289,131,504,424,522,401,882,293,432,143,721,759,906,23,923,111,219,698,342,873,968,275,404,395,866,490,119,67,496,174,225,304,278,632,598,816,866,634,901,414,588,647,328,349,551,332,246,548,494,278,705,953,119,753,712,990,817,121,820,497,934,213,813,442,938,723,720,695,148,18,271,261,922,306,788,204,117,544,281,276,740,614,940,599,146,268,448,481,155,128,266,674,208,21,398,932,331,617,694,649,719,206,626,294,771,448,431,475,516,905,436,247,617,77,468,792,55,643,215,760,467,613,443,661,217,430,403,896,838,796,535,297,150,761,581,490,318,509,528,278,552,519,740,127,594,812,61,92,88,979,659,693,262,714,727,402,9,670,886,498,318,716,90,478,688,677,516,127,819,811,392,571,560,335,412,920,284,52,565,680,697,243,259,628,177,464,519,789,244,853,609,116,56,618,619,278,481,311,671,662,162,697,883,968,126,441,852,797,211,181,36,163,364,873,271,539,671,262,333,113,404,521,583,350,943,20,91,289,705,873,667,488,799,196,220,513,308,861,655,527,275,797,199,193,347,521,924,745,191,249,163,420,947,532,551,733,192,313,876,239,971,923,238,715,180,996,113,132,5,517,374,355,726,121,96,866,287,766,241,792,36,3,570,212,503,405,104,271,844,681,166,63,432,532,218,713,501,785,311,809,848,428,453,854,378,869,964,860,446,610,299,778,352,586,509,635,529,508,361,127,190,167,257,465,728,242,429,566,363,332,60,772,805,867,227,89,343,319,44,167,531,174,17,618,48,506,936,858,804,249,200,111,682,7,454,426,523,314,134,297,275,118,986,926,483,800,526,542,655,284,992,86,756,54,653,899,15,920,737,547,973,714,989,445,573,397,296,587,789,122,977,314,591,423,125,717,971,762,418,603,558,59,562,814,187,5,468,191,97,216,745,831,6,81,728,426,896,421,973,948,479,852,855,444,649,938,573,516,320,848,516,289,252,764,3,556,470,363,709,839,608,770,592,170,933,367,891,892,756,484,329,317,552,896,944,836,18,81,853,628,610,931,604,725,416,504,442,606,563,793,677,185,332,679,885,653,494,338,143,906,197,470,118,19,645,282,304,466,182,269,539,86,355,340,333,108,340,952,11,497,210,114,322,0,246,430,989,897,512,380,976,550,851,513,582,583,329,822,29,988,726,163,15,166,426,645,612,93,790,8,195,41,626,989,896,158,541,958,83,65,139,156,160,631,393,956,976,457,886,171,896,974,372,393,939,872,323,520,963,936,827,423,448,853,293,529,943,968,947,267,396,62,509,313,708,937,146,708,409,409,863,821,614,825,536,682,101,260,839,537,315,282,127,128,344,122,704,377,452,120,337,748,268,495,753,407,424,441,281,364,803,40,344,139,221,651,46,744,812,621,651,392,195,384,366,912,560,306,963,833,101,116,307,951,923,794,394,870,518,132,819,824,12,621,122,213,801,863,813,733,169,969,288,868,858,353,216,868,34,663,641,273,683,88,228,956,462,357,689,399,24,639,687,411,793,946,84,662,609,901,786,443,543,233,223,948,619,522,508,828,888,306,166,751,89,540,645,264,858,855,556,93,805,545,421,894,312,198,148,783,428,833,495,124,881,366,978,803,278,738,252,877,393,381,267,675,159,860,591,987,221,742,401,565,51,477,482,963,765,286,643,524,489,848,119,11,183,572,107,750,461,765,116,844,200,143,104,628,565,340,324,745,72,705,173,47,790,863,203,379,314,405,269,33,898,680,413,469,159,167,662,527,759,154,497,391,209,475,779,475,174,159,464,887,742,391,960,116,478,136,459,108,357,972,664,541,800,913,585,221,46,879,858,8,324,461,351,406,866,567,646,483,761,463,320,464,226,138,455,667,789,842,71"",
    ""178,476,953,398,504,349,700,690,961,336,850,774,989,794,245,969,336,962,791,537,847,391,265,591,285,301,439,851,359,884,802,127,636,250,334,931,68,500,822,528,389,73,91,200,70,473,957,802,782,874,438,747,907,919,40,70,703,976,983,21,43,429,471,357,383,756,894,241,122,813,752,964,480,844,451,271,274,559,629,197,823,66,907,598,297,218,821,892,912,687,507,780,114,107,454,879,849,87,129,885,484,988,507,350,278,317,414,969,79,245,331,339,883,84,510,716,151,667,762,34,528,106,99,749,329,749,315,314,600,111,1,603,439,986,413,99,990,829,162,428,223,132,813,201,932,530,570,967,5,17,879,634,842,267,502,383,544,457,34,284,268,698,14,685,372,399,280,775,393,998,453,223,432,564,570,377,943,629,833,685,405,34,339,237,93,226,4,542,326,899,337,150,805,117,302,35,854,280,800,603,139,830,558,95,875,712,460,621,503,363,95,122,73,297,269,478,443,46,625,71,98,808,263,163,655,808,438,465,464,83,195,302,347,142,645,256,902,975,706,130,164,245,795,835,441,806,982,983,635,511,963,580,916,10,147,680,171,243,286,925,411,300,861,814,298,588,379,795,27,771,22,303,999,184,1,301,662,469,393,911,456,972,701,769,660,763,114,328,524,627,469,941,989,398,338,382,675,100,934,31,194,243,781,356,937,855,364,736,377,850,66,973,927,397,714,959,847,449,231,621,421,29,554,170,443,323,848,557,844,895,145,335,329,274,256,711,204,562,95,334,684,651,438,344,280,549,274,772,872,271,709,338,251,573,552,71,498,746,25,280,879,416,147,952,632,748,92,277,333,894,890,721,61,979,968,288,18,448,967,427,93,933,431,844,208,63,748,574,596,130,435,573,126,183,802,518,992,154,586,589,685,827,761,519,945,695,944,156,751,482,424,28,124,632,850,687,942,517,332,517,799,507,316,177,486,19,155,331,883,275,95,186,544,225,253,722,658,26,559,287,432,13,715,359,901,114,103,422,234,171,862,916,625,580,494,55,53,130,573,820,557,113,742,87,126,867,997,823,829,686,321,998,857,403,749,359,792,359,969,285,258,323,670,509,644,685,170,44,43,823,27,866,356,253,590,762,329,343,351,675,496,49,2,395,473,621,520,257,675,680,332,365,647,743,424,728,186,263,63,18,317,866,813,333,79,604,342,187,719,507,978,783,990,677,918,713,340,587,719,229,495,601,602,96,150,646,618,389,943,127,597,743,177,109,985,511,181,169,701,986,321,13,546,486,775,783,887,26,163,274,32,125,248,357,763,398,343,724,710,198,302,391,396,203,940,763,951,801,18,573,466,708,227,313,512,490,685,721,961,814,786,501,835,640,581,624,818,792,455,115,373,38,256,370,262,518,53,247,812,438,539,471,578,749,579,996,441,862,812,870,562,46,962,332,505,928,964,505,177,360,43,555,316,155,827,28,908,897,324,86,100,436,64,209,309,600,251,476,704,381,681,215,762,963,205,16,341,857,887,311,246,0,327,831,912,280,418,605,140,510,686,125,38,226,614,705,969,378,326,158,902,259,759,442,444,484,78,410,22,653,880,469,868,65,929,677,83,768,35,401,378,743,434,833,894,948,560,623,888,844,709,106,46,468,409,100,665,26,558,114,3,876,744,138,333,324,650,473,648,591,783,199,900,440,431,456,802,139,475,155,324,273,789,829,44,362,237,337,152,24,557,24,204,905,391,171,961,626,445,601,428,903,101,442,834,587,773,184,455,329,571,894,815,748,472,564,443,931,402,433,799,505,645,916,646,259,834,991,232,770,991,146,64,411,873,164,428,109,147,574,547,899,709,168,516,9,920,139,279,646,127,554,278,783,736,520,608,426,523,783,8,954,588,749,770,478,318,723,420,272,61,921,497,532,764,281,637,932,772,718,817,283,888,590,300,95,98,399,346,218,675,351,77,518,866,443,726,581,217,128,563,675,717,600,253,942,861,684,298,241,795,290,806,587,290,498,927,62,548,223,405,264,16,698,589,292,736,68,694,722,609,121,28,782,721,861,660,330,243,602,671,718,282,493,530,733,628,682,417,187,760,773,996,661,348,879,569,635,716,452,431,963,432,293,443,657,559,130,107,19,536,257,880,217,967,706,802,252,24,911,808,25,955,777,262,807,369,451,725,245,174,627,991,124,671,353,887,147,676,608,530,689,16,496,470,4,602,680,706,693,24,116,230,139,712,329,475,116,439,978,792,919,728,379,453,879,145,710,499,555"",
    ""257,806,899,23,586,119,736,248,608,70,798,145,62,153,53,509,354,513,738,766,663,38,351,714,472,689,347,258,374,371,29,415,22,261,990,772,105,318,861,82,573,317,983,345,224,346,349,595,262,790,505,653,560,88,60,543,145,651,89,541,803,86,417,947,106,129,299,794,866,566,104,40,67,634,52,418,365,174,343,737,634,929,723,3,545,744,682,103,400,342,861,52,472,856,376,261,298,115,782,718,831,202,205,531,552,776,666,722,246,200,459,805,209,937,406,728,632,521,886,984,683,742,475,290,896,925,841,927,701,847,927,478,28,831,19,359,693,451,279,987,831,69,598,319,576,923,813,900,754,271,857,899,791,428,862,929,603,294,74,565,824,484,6,792,987,810,935,796,622,762,583,671,532,668,274,334,477,822,724,595,438,11,5,6,925,757,43,8,451,977,357,834,176,692,699,934,869,426,603,180,709,137,167,226,733,499,670,610,691,371,89,730,387,828,823,575,284,746,52,642,985,70,321,118,30,849,175,683,392,545,63,951,498,130,144,398,829,674,421,839,857,278,566,2,161,455,809,124,583,949,180,551,228,520,836,699,896,78,949,207,924,746,772,412,191,113,723,98,338,297,63,516,140,304,518,299,360,279,123,371,496,613,585,48,96,896,667,971,349,231,272,707,558,492,716,300,73,892,81,657,94,948,494,89,939,238,794,771,433,633,924,27,494,371,802,621,169,417,173,507,126,197,371,31,490,185,881,868,581,404,602,242,316,31,491,161,499,321,768,236,739,803,994,915,237,229,715,827,793,230,803,51,659,309,200,262,561,638,59,844,112,304,386,845,238,432,405,231,468,341,398,283,765,644,750,214,708,226,833,801,829,709,254,484,741,528,2,401,782,153,635,441,434,842,159,673,93,772,157,612,566,3,623,668,986,581,887,253,167,151,354,724,386,953,402,445,778,407,808,334,499,190,759,68,859,89,102,948,405,588,951,405,78,786,58,915,617,900,852,723,931,709,903,771,479,12,960,429,473,88,179,755,460,546,46,565,24,538,173,774,15,212,946,987,39,255,813,653,333,701,13,94,805,539,935,930,345,463,319,679,352,884,909,413,286,381,845,232,36,634,384,677,898,331,195,201,969,343,593,589,159,182,842,346,754,707,867,29,40,878,121,308,336,739,783,177,450,751,364,129,337,342,666,305,412,682,270,344,88,636,508,186,762,387,552,145,54,730,583,215,511,562,485,246,685,689,192,371,600,311,288,150,459,459,309,998,421,126,344,2,693,740,585,960,788,592,839,240,52,484,728,873,141,533,221,512,130,440,315,986,93,732,464,207,497,206,595,599,745,120,136,349,473,368,821,911,327,456,285,815,842,609,252,548,735,677,350,356,802,834,554,113,217,347,288,936,299,157,961,770,397,123,952,809,969,334,143,250,635,195,586,16,686,847,164,774,478,817,68,486,694,329,698,920,711,475,361,307,803,877,602,525,301,117,575,133,981,233,39,924,398,886,132,255,549,597,933,973,91,992,430,327,0,256,439,969,344,339,851,315,372,219,575,898,360,512,824,103,829,936,946,599,795,980,691,216,974,403,738,666,448,570,562,631,271,768,291,601,746,323,424,93,517,930,946,851,121,640,965,661,830,535,132,752,593,353,696,295,435,612,137,766,875,220,795,529,416,28,836,889,200,417,101,111,347,173,388,296,342,151,828,653,766,883,734,915,628,572,799,169,722,926,190,136,184,563,56,26,255,694,873,122,878,332,147,586,362,648,766,913,379,400,376,104,291,232,413,230,184,212,850,901,56,543,317,728,341,686,136,858,23,575,729,272,809,514,461,382,470,554,216,877,98,883,280,993,571,932,744,841,461,496,870,931,794,102,390,259,807,64,13,931,636,181,338,157,622,926,229,395,368,154,179,281,218,701,489,216,692,438,720,551,174,557,230,881,319,991,59,504,795,37,9,902,818,96,400,611,217,475,787,302,683,598,992,312,405,837,580,813,778,566,937,247,127,155,539,3,507,445,787,128,999,440,453,6,718,64,312,20,830,940,633,633,520,938,83,736,398,473,918,765,126,779,559,964,745,967,286,723,432,962,615,798,400,538,297,781,582,653,290,255,94,18,666,560,994,574,933,976,311,658,241,51,364,145,639,561,114,316,401,942,283,754,347,191,283,689,541,853,38,11,675,395,530,765,951,260,100,783,847,192,413,839,585,879,140,69,679,822,870,260,454,912,572,716,991,116,997,712,24,338,155,134,818,891,522,976,350,667"",
    ""835,589,29,214,70,493,399,880,115,555,516,633,850,315,764,761,963,566,757,543,171,712,308,825,470,586,168,496,694,381,514,282,345,93,382,932,912,667,12,576,772,478,739,35,24,846,243,289,741,495,516,835,361,612,515,97,680,300,386,360,96,669,291,486,803,436,963,165,672,409,781,974,974,163,552,579,66,35,7,684,309,906,304,974,626,247,929,351,714,208,511,528,472,856,539,525,273,891,988,339,558,990,441,774,96,321,441,893,801,68,894,730,623,764,216,20,816,91,384,198,40,691,640,997,671,945,980,404,829,386,724,997,584,362,173,774,935,822,110,739,50,97,849,680,152,738,414,615,811,435,965,788,532,238,673,490,536,68,843,115,991,672,187,458,573,603,535,116,913,580,230,696,752,57,523,317,427,347,378,796,762,55,428,70,477,672,432,7,233,453,999,351,809,803,903,257,643,568,447,277,339,719,945,480,527,591,840,370,619,903,52,221,798,382,260,720,777,459,419,614,880,826,715,636,842,135,858,891,400,912,533,756,579,717,505,817,288,729,787,290,42,698,830,81,899,4,363,333,751,254,539,137,991,722,897,330,530,295,784,48,47,500,291,945,912,360,788,974,43,721,271,909,966,783,847,937,104,889,943,817,539,150,943,469,554,521,877,935,71,369,933,730,55,575,611,147,742,400,790,879,756,430,441,375,894,58,958,992,881,695,862,421,354,321,830,450,950,306,762,521,491,593,840,679,433,423,478,701,868,569,557,2,197,383,181,878,558,766,85,852,192,415,67,76,755,348,109,871,136,387,979,138,657,400,180,474,929,251,442,778,559,991,935,360,606,289,341,887,846,590,673,181,70,962,748,348,725,687,572,243,347,399,96,806,644,241,284,619,527,988,752,975,777,61,553,491,467,780,919,433,949,70,951,841,63,255,891,553,159,338,215,308,677,170,282,644,901,456,399,421,153,682,779,315,420,347,946,363,85,70,525,363,726,557,739,148,822,446,488,316,411,248,629,558,409,67,894,696,629,377,299,840,694,61,473,78,222,696,442,215,124,681,13,50,617,891,254,10,373,830,763,877,613,626,595,428,624,84,100,642,909,34,347,278,544,666,274,166,807,957,518,429,550,153,50,537,633,306,910,508,613,460,685,948,38,335,747,668,656,596,520,489,470,707,988,312,756,487,733,679,175,102,52,866,923,379,654,92,265,870,336,92,555,345,698,119,248,346,767,943,28,375,36,643,663,610,665,929,92,223,142,606,766,919,38,694,468,52,419,51,738,547,453,940,890,95,375,699,965,58,720,138,95,161,613,232,571,114,59,129,477,691,319,490,774,983,929,418,912,761,220,98,342,559,344,91,613,556,560,857,671,346,526,160,626,180,22,783,785,234,70,80,501,795,5,751,242,965,405,834,271,372,348,441,833,172,685,269,552,942,59,230,27,25,264,86,405,595,392,99,801,612,118,205,135,599,902,275,72,669,990,971,908,677,550,162,502,62,320,497,746,704,849,270,275,323,514,888,137,377,989,831,256,0,583,194,627,199,452,10,780,664,353,660,314,507,29,971,96,743,13,991,577,441,399,951,505,643,357,434,885,336,734,433,21,310,500,784,618,714,419,612,398,841,720,853,255,426,229,189,735,329,270,48,453,71,82,471,485,23,68,613,811,536,635,656,291,619,201,668,772,465,808,429,542,318,71,727,209,636,607,580,345,237,661,156,691,124,666,140,479,769,785,77,672,350,710,478,498,774,256,472,440,727,229,633,814,280,515,429,289,278,435,349,851,614,655,143,479,766,325,474,614,951,207,20,989,352,172,242,436,55,248,799,50,46,624,245,383,346,627,382,377,515,580,181,115,599,74,338,912,560,920,544,974,911,618,927,132,584,992,868,186,853,476,291,581,904,147,203,123,829,643,983,33,552,474,253,504,577,453,103,472,990,312,961,79,498,566,249,177,790,429,622,674,465,169,153,679,843,990,726,232,289,749,158,638,529,854,116,889,166,181,584,558,538,787,717,711,963,114,968,983,347,29,299,926,152,167,65,888,527,12,401,113,519,981,603,3,374,533,40,554,178,657,762,2,407,112,175,829,173,130,215,95,459,73,732,798,900,868,328,419,409,253,228,56,929,867,573,110,747,479,861,784,302,207,110,723,525,500,968,824,357,691,187,609,320,441,178,502,937,437,546,508,792,806,236,902,956,851,739,501,600,791,456,860,677,530,29,750,77,257,385,963,675,266,903,691,112,691,38,315,302,390,464,132,204,793,343"",
    ""516,155,442,709,704,957,458,878,242,305,465,261,262,454,828,278,915,770,903,61,576,21,22,471,730,705,876,856,352,300,883,501,828,538,293,339,88,269,589,959,335,519,990,174,693,184,783,654,797,918,450,2,33,299,930,413,476,924,929,701,635,151,432,201,969,536,778,216,34,182,695,252,272,507,419,857,64,385,32,360,310,973,644,206,815,483,731,387,694,251,796,282,207,498,781,121,182,640,900,439,429,961,851,122,251,122,342,679,569,496,80,984,440,269,335,308,465,4,430,392,699,785,999,833,324,75,329,873,63,12,960,856,743,562,823,33,462,198,834,73,83,312,832,964,676,718,906,613,991,453,762,549,451,299,556,637,625,467,577,21,17,383,942,772,827,823,712,787,942,796,781,109,92,571,662,371,868,282,715,183,132,4,404,80,354,699,994,307,737,709,183,613,46,731,235,312,995,813,232,34,179,676,297,67,388,859,49,55,506,576,830,265,40,190,43,834,264,18,744,246,669,988,617,265,790,586,343,737,949,737,342,253,665,761,715,664,258,159,944,991,2,867,491,998,450,37,640,852,524,499,59,954,198,927,272,153,886,22,691,201,788,926,25,709,264,198,82,503,287,187,61,307,781,868,282,126,204,983,333,565,323,909,665,935,550,90,285,359,591,200,458,796,769,99,561,9,114,915,548,840,785,88,204,334,645,459,531,712,729,505,517,519,540,297,975,344,230,961,456,327,933,470,565,481,944,933,201,898,266,407,825,871,97,354,643,168,349,146,713,210,132,560,529,614,50,735,835,183,296,632,438,107,961,175,840,251,319,127,767,36,829,66,99,574,856,13,307,552,613,550,493,863,944,377,98,806,753,459,656,569,860,124,213,942,543,989,709,195,586,925,978,651,431,810,540,558,540,893,71,511,422,509,256,615,113,674,927,960,149,543,165,144,583,836,614,539,807,613,272,456,952,351,643,669,307,345,657,165,339,427,836,673,959,733,844,617,509,371,490,450,955,68,97,366,765,564,626,229,443,773,413,924,438,584,515,51,881,644,606,872,232,329,986,996,688,993,326,152,570,157,147,215,737,273,334,681,999,724,549,368,516,960,585,957,404,27,885,617,811,511,403,722,256,389,794,962,475,524,164,796,896,15,404,278,921,143,169,733,843,865,910,856,831,479,672,440,453,249,368,701,707,466,654,361,92,908,778,492,494,48,161,289,148,953,388,498,440,987,870,581,143,345,346,191,972,588,844,532,997,487,161,216,472,926,678,472,164,692,325,395,395,878,415,463,652,934,489,150,104,368,338,982,657,731,520,408,183,693,175,174,133,81,418,298,523,770,62,536,18,752,643,141,971,762,170,586,870,156,79,999,543,984,452,743,210,777,399,162,365,212,53,456,257,7,863,754,180,193,401,299,661,894,868,253,322,386,342,36,754,502,129,291,608,859,234,523,547,378,961,741,225,34,119,530,791,955,266,938,271,902,922,644,420,589,386,617,933,857,142,532,71,257,959,743,938,704,779,997,577,575,897,912,439,583,0,928,993,327,530,432,605,823,25,749,716,782,640,85,710,94,447,67,719,734,634,10,715,394,913,746,714,391,259,607,253,449,929,350,95,9,926,329,150,616,336,65,175,823,990,231,962,1000,136,312,313,157,508,789,315,356,447,8,509,724,926,767,357,640,534,408,234,276,132,572,812,216,28,998,437,234,983,121,292,266,624,934,201,208,227,400,66,647,792,996,421,74,154,91,9,835,136,58,833,460,518,63,63,975,657,720,863,504,579,405,784,269,574,359,930,667,589,61,884,342,768,245,818,973,268,398,74,558,557,892,176,438,567,177,164,526,91,514,833,983,584,91,408,801,508,268,356,567,453,99,160,538,367,726,468,715,615,431,35,887,780,247,623,272,725,90,41,546,18,608,547,316,778,807,399,832,90,4,832,967,876,596,465,521,377,695,81,694,319,816,484,418,647,508,764,758,905,948,269,316,989,740,546,504,184,68,264,718,867,24,694,775,284,547,575,437,179,142,870,963,897,761,571,973,861,392,975,94,68,521,312,232,478,738,879,153,665,927,369,454,202,893,264,165,452,171,781,97,164,982,239,258,166,165,993,31,861,301,607,208,438,774,906,294,396,464,396,582,312,637,57,728,623,958,811,123,40,322,463,608,211,858,230,414,117,617,195,701,810,310,620,882,499,500,804,844,828,443,126,160,229,61,233,221,46,302,134,489,83,180,70,383,900,571,256,656,584,874,723,448,71,820,739,353,468,327"",
    ""172,935,830,875,459,388,984,492,783,595,159,825,788,770,902,940,880,64,58,622,825,443,706,477,368,317,362,143,559,351,476,526,577,48,144,822,854,513,750,588,15,829,520,912,83,432,862,576,826,831,214,908,48,54,206,445,196,772,295,239,111,181,102,653,401,405,244,445,564,8,739,420,237,683,739,37,71,521,909,495,177,759,512,267,720,881,479,494,649,548,539,563,256,243,804,710,90,933,212,142,38,815,270,988,49,131,289,337,815,866,538,691,826,326,624,442,550,970,333,806,153,629,201,448,111,16,163,4,901,186,281,479,741,756,995,19,861,204,803,592,17,196,487,885,378,831,986,945,655,969,590,450,840,661,486,242,338,655,734,155,897,334,640,107,233,766,182,558,355,194,209,559,375,653,433,606,337,853,874,786,818,978,910,951,180,229,91,604,520,966,948,209,214,568,75,109,974,771,43,281,268,314,102,457,669,704,914,448,236,206,504,342,563,658,395,304,499,372,473,656,179,791,821,723,690,630,442,691,722,472,924,537,359,716,343,855,487,951,308,529,834,630,336,889,696,407,1000,869,119,341,925,300,787,497,911,971,998,964,848,391,400,103,860,560,850,53,99,648,354,468,542,657,846,486,665,682,401,68,104,462,716,591,821,782,495,688,290,948,997,10,320,973,500,616,52,931,196,755,57,306,910,845,349,882,216,731,495,760,211,388,493,27,565,647,787,431,379,886,576,622,310,736,971,22,154,601,366,83,659,236,797,652,771,115,435,597,833,161,34,53,847,802,778,540,915,824,89,586,678,478,652,498,638,44,950,373,128,486,473,140,967,124,173,789,893,920,148,158,910,537,126,805,564,114,363,64,712,510,535,814,752,69,874,753,709,824,998,231,197,322,605,551,444,882,213,635,442,217,916,879,896,361,901,645,287,185,46,916,285,465,600,39,948,172,811,47,472,201,395,60,856,348,700,241,853,150,192,557,71,156,719,817,969,7,989,32,437,812,313,252,416,404,370,815,877,349,132,967,472,800,159,1,4,800,432,372,409,913,199,53,908,823,156,701,564,797,22,88,347,189,892,537,14,852,92,291,22,559,394,332,898,266,598,164,368,490,656,225,549,94,652,616,878,634,725,4,384,556,906,811,215,28,219,388,474,261,840,112,430,561,45,826,681,880,433,725,92,634,379,191,534,18,431,557,516,185,549,38,554,158,987,555,897,671,902,728,201,702,545,625,803,935,546,304,857,243,638,506,339,677,660,995,643,182,398,193,433,65,294,650,587,251,352,583,227,709,628,769,974,814,264,453,631,280,617,149,957,763,299,630,84,715,598,48,108,519,217,752,587,249,151,900,679,436,976,405,252,351,959,446,459,413,465,743,346,400,439,922,952,829,220,616,537,276,959,894,373,772,922,991,844,362,624,406,879,243,436,980,441,374,594,79,397,260,241,509,270,13,343,203,198,151,186,872,741,304,570,174,18,130,446,255,334,485,979,362,699,541,403,811,737,95,597,799,108,898,911,193,76,244,512,280,969,194,928,0,961,944,494,94,469,721,644,896,841,923,647,553,708,957,752,895,302,787,572,856,281,980,982,951,894,853,300,77,592,815,468,751,82,120,927,744,806,482,784,618,893,864,384,803,330,991,211,964,77,537,160,300,75,515,234,114,7,784,243,875,596,341,392,909,53,589,156,95,72,354,487,457,154,330,197,384,292,227,498,510,963,235,41,521,544,542,444,324,994,879,177,621,766,177,820,8,664,295,712,701,935,257,142,952,559,891,488,590,69,407,597,126,553,978,898,415,100,820,382,700,558,119,406,734,422,239,280,79,439,342,572,182,80,306,954,920,607,729,481,317,141,717,517,150,627,973,192,469,545,722,514,712,924,78,665,593,823,385,258,67,372,940,352,282,425,66,807,713,601,966,261,477,358,765,869,770,26,996,304,552,935,231,314,156,705,547,405,544,316,860,884,895,15,469,868,382,55,532,746,963,741,342,686,822,165,82,860,279,33,716,110,866,731,707,933,582,558,757,633,981,371,286,772,198,280,872,140,312,988,150,593,603,459,862,302,111,246,593,961,423,175,857,794,840,724,4,416,851,955,210,286,212,448,350,348,781,875,435,885,134,444,585,906,766,858,888,257,364,56,212,264,687,754,519,357,603,233,901,571,6,634,915,789,454,217,110,391,162,955,952,426,301,160,769,290,897,440,763,713,709,135,482,78,945,462,316,350,347,23,568,275,201,718,273,431,183,270,505,394,324,804,821,77,253"",
    ""594,197,374,129,831,574,689,914,664,628,259,625,364,441,88,591,802,314,86,366,111,872,327,304,195,729,751,625,9,510,391,907,731,304,243,865,256,742,524,325,790,887,55,517,555,276,360,788,525,615,125,791,907,223,878,421,672,120,713,749,549,746,726,305,982,94,565,674,275,877,697,264,172,377,549,914,198,597,717,707,58,448,264,518,519,477,213,823,343,401,117,62,673,444,669,766,279,702,429,629,572,798,263,395,72,705,709,629,490,665,77,699,541,366,917,647,378,452,124,329,483,370,492,823,557,653,986,905,856,646,280,827,708,784,484,224,338,527,185,530,900,110,499,414,376,830,538,665,323,338,381,732,329,616,82,124,634,120,723,60,576,324,106,34,559,522,927,886,348,388,222,506,226,566,686,830,406,625,612,145,57,638,36,181,295,117,28,347,586,450,971,303,901,871,100,340,829,34,72,209,525,184,463,994,105,364,963,558,804,95,403,512,622,164,2,630,630,254,403,543,542,626,889,220,847,637,700,526,866,963,285,155,288,8,924,29,894,586,345,624,998,81,10,489,496,215,216,101,779,455,197,24,607,869,856,895,129,709,975,708,431,538,613,332,305,730,61,868,632,386,988,273,751,682,586,977,440,811,532,685,547,759,552,12,722,84,952,890,115,150,222,99,431,22,361,975,616,503,790,920,386,136,681,326,936,732,354,583,61,606,158,817,197,880,76,477,815,229,732,367,261,272,714,278,62,135,309,844,939,270,92,667,952,615,931,806,675,669,696,284,313,613,641,154,297,665,362,156,658,424,951,20,441,986,648,114,709,564,416,610,168,805,573,979,738,531,740,552,369,287,301,978,891,108,202,719,453,193,556,445,190,137,708,354,138,288,677,750,146,471,755,491,63,235,698,349,952,476,675,321,988,196,989,71,839,319,121,940,838,955,296,9,745,272,670,518,756,271,599,45,478,907,124,101,695,527,106,601,137,121,720,721,215,815,571,333,880,686,68,961,49,894,624,602,851,620,582,788,532,38,374,467,719,13,532,849,412,340,387,419,285,179,116,479,449,776,328,487,847,684,182,138,456,307,532,894,926,853,96,786,677,785,453,313,876,363,229,372,203,689,901,886,821,102,93,342,46,227,812,810,114,235,432,944,948,927,712,976,631,529,727,742,221,889,650,713,464,930,319,792,958,96,569,975,145,800,899,603,858,453,994,293,854,542,375,663,532,688,441,983,202,985,627,595,286,15,6,302,724,514,367,342,562,554,478,128,361,617,414,572,4,477,476,750,155,712,580,259,69,406,176,334,364,542,406,87,485,491,721,430,4,885,848,172,862,263,311,142,60,484,827,971,19,29,730,352,924,253,543,112,139,635,606,532,971,911,775,805,156,186,539,166,112,984,684,906,337,964,790,795,697,357,168,184,626,137,159,872,727,648,233,37,564,95,276,473,161,953,876,711,497,345,823,764,60,666,438,704,914,37,621,451,989,986,857,66,985,412,385,962,775,918,915,232,131,300,761,214,866,441,380,418,344,627,993,961,0,636,315,563,979,592,620,68,79,309,469,22,70,723,656,517,182,312,116,391,291,249,144,549,973,391,595,405,230,71,935,193,856,910,731,490,955,426,67,620,187,764,881,974,944,697,805,723,394,640,733,263,853,662,172,931,16,583,92,377,343,119,607,987,693,302,86,392,127,31,397,551,25,913,696,80,546,685,885,198,437,850,604,82,266,27,588,655,223,305,498,640,314,347,822,285,520,387,875,69,702,278,345,169,749,383,49,530,582,431,423,209,3,889,668,157,34,794,792,773,801,419,195,913,215,603,405,113,218,600,57,689,500,631,124,435,411,160,176,844,674,73,294,366,572,103,188,783,169,847,193,920,360,577,193,434,678,623,961,454,568,297,299,846,275,856,954,152,75,693,207,647,852,841,912,664,567,388,692,3,832,449,709,178,233,202,310,908,596,642,367,480,827,575,895,993,465,924,436,450,426,360,420,795,420,529,696,820,278,364,662,620,924,521,704,980,209,279,819,238,155,815,722,500,902,898,521,913,460,63,225,983,647,868,614,935,77,967,309,655,206,85,65,742,225,24,230,816,6,252,171,515,881,62,637,657,486,523,100,767,135,224,287,9,13,79,570,645,959,578,832,136,112,180,739,820,997,324,315,997,902,435,130,748,746,200,843,41,459,142,186,520,66,521,499,105,444,784,570,946,696,714,817,292,890,277,831,268,248,225,302,358,489,605,391,541,182,445,816,830,359,960,272,705"",
    ""661,623,754,491,492,422,85,889,917,115,551,821,290,791,631,482,672,836,591,820,908,988,49,448,679,656,831,414,246,902,233,466,164,6,411,206,46,963,234,740,597,441,543,298,878,921,453,539,863,380,184,619,165,532,729,344,399,433,473,170,481,888,937,445,773,479,523,600,922,782,849,885,66,900,687,584,412,970,118,992,854,161,854,838,463,552,642,508,228,107,793,377,876,463,166,210,191,286,884,964,217,407,313,369,250,164,283,379,601,100,150,230,952,114,278,748,814,154,569,547,446,39,743,643,341,622,101,965,244,183,834,441,678,445,319,450,36,986,226,702,496,549,852,871,13,166,498,97,184,228,551,801,860,823,666,78,562,42,333,960,150,763,950,241,290,110,170,160,687,278,614,554,103,249,314,84,557,543,963,190,397,317,806,390,197,702,606,720,820,378,85,535,414,482,778,173,803,404,607,950,395,127,969,865,467,413,12,891,790,73,670,868,471,886,884,251,137,88,638,438,335,319,233,33,118,717,757,997,329,461,822,121,63,25,807,110,251,583,326,127,36,735,236,82,558,153,366,706,119,443,737,54,949,696,214,201,818,249,17,244,721,714,118,383,266,636,674,754,366,187,298,141,849,608,344,355,444,824,93,866,302,676,353,494,858,674,51,811,850,716,733,598,505,48,645,727,492,25,56,920,585,701,333,243,364,790,233,758,83,147,196,582,244,989,950,662,728,433,245,208,282,990,241,175,915,45,395,176,157,682,517,973,900,446,204,897,557,992,724,611,403,483,629,258,763,523,299,800,987,892,613,495,396,826,287,917,304,443,372,457,730,677,178,161,715,936,487,381,489,914,584,403,260,326,755,944,172,149,118,645,595,169,14,304,513,784,470,814,138,152,162,315,585,747,594,749,167,159,142,371,55,914,140,926,846,214,407,893,982,640,857,994,453,741,710,663,342,855,149,396,885,135,625,61,936,245,492,239,456,246,111,957,366,852,938,722,591,908,341,341,470,330,317,9,558,945,87,278,171,471,132,54,637,318,536,209,111,979,995,438,667,270,944,875,515,652,297,446,208,441,338,97,960,360,174,810,174,379,190,662,831,806,312,98,595,461,721,844,591,379,675,82,619,201,464,246,71,885,385,289,264,484,106,240,347,176,827,35,423,802,286,300,291,531,147,870,114,471,939,706,970,993,931,896,666,43,897,727,387,562,519,941,421,993,320,843,486,883,81,687,530,337,528,397,595,819,4,467,775,108,761,816,394,502,195,206,625,232,374,277,291,90,503,204,111,730,280,205,210,752,439,600,306,118,333,80,94,408,521,622,313,947,562,3,686,588,154,571,897,913,342,519,164,466,391,150,188,873,758,161,816,58,169,317,585,383,730,140,10,537,198,691,551,651,185,43,236,585,543,72,70,241,872,957,291,846,173,921,850,541,19,775,448,827,983,989,818,544,33,229,84,141,173,473,970,70,713,826,868,245,349,640,964,984,379,147,589,683,58,556,439,200,926,950,11,91,693,760,32,7,976,605,339,199,327,944,636,0,158,113,573,413,295,163,494,656,488,626,329,145,530,221,392,224,687,110,259,508,901,595,821,282,267,313,852,328,498,110,482,949,276,724,739,656,260,494,39,857,455,912,528,569,272,762,578,583,934,19,148,697,645,75,151,193,328,846,258,6,71,126,485,272,512,231,940,688,533,615,58,907,592,10,888,261,694,794,523,31,623,427,432,674,952,563,863,485,595,913,826,936,808,458,419,755,327,172,124,882,662,598,943,223,843,126,496,571,232,572,663,972,805,314,324,272,272,230,121,661,996,257,3,931,295,684,582,303,436,214,197,991,349,843,71,250,982,663,575,472,524,338,344,483,370,377,589,166,433,764,587,145,911,78,544,736,352,347,798,730,745,208,511,663,759,515,955,904,712,642,928,743,343,935,135,307,302,989,674,789,979,114,531,515,58,818,321,195,434,962,469,924,945,4,790,923,733,92,999,214,304,312,637,202,556,57,742,121,620,684,924,624,491,457,42,264,597,856,51,732,559,379,48,639,182,584,90,837,35,849,157,259,771,376,246,380,186,975,158,877,984,945,728,295,804,233,291,747,895,823,63,675,505,923,96,254,298,672,60,563,835,942,829,698,538,374,730,861,816,468,264,430,16,193,872,291,504,528,637,403,78,460,462,313,218,516,816,955,674,130,995,566,351,989,177,333,258,296,55,498,518,579,432,638,311,585,883,799,337,960,85,2,910,961,678,828,915,332,90,181,363,242"",
    ""77,546,622,668,220,513,738,901,134,522,656,166,783,347,525,571,879,24,709,265,587,14,787,276,15,611,296,749,780,829,329,108,602,929,840,633,336,729,670,986,935,670,829,996,303,908,996,785,431,428,607,904,868,84,11,626,989,985,640,74,108,293,646,461,848,513,693,354,829,940,49,852,691,687,134,651,820,925,553,644,202,796,633,844,514,548,618,408,210,147,576,400,60,84,522,280,556,889,24,512,99,489,749,895,266,337,760,671,136,382,664,119,549,246,996,323,485,548,441,299,378,100,830,321,651,791,509,945,831,190,644,370,323,242,201,960,455,822,859,52,678,880,759,535,653,779,628,62,637,16,65,463,394,405,151,554,113,351,96,697,839,429,480,278,197,107,947,321,501,54,76,180,748,146,955,218,453,672,40,836,488,224,321,999,668,503,550,105,150,422,692,465,868,512,336,500,613,469,35,78,40,867,163,549,959,356,745,138,807,647,829,377,869,544,756,748,498,306,209,689,919,649,216,820,259,866,782,720,760,121,527,716,181,396,160,652,663,737,183,354,466,127,430,772,874,854,441,885,650,523,345,882,759,337,512,389,572,719,101,275,424,675,969,84,229,138,685,762,70,299,736,774,817,535,306,959,297,753,941,596,84,53,206,448,137,245,212,770,826,11,461,592,14,716,524,944,741,465,7,549,614,664,805,786,398,952,412,463,971,537,680,544,959,196,471,724,871,994,558,475,980,378,894,46,437,483,394,545,58,970,5,871,223,323,587,99,244,322,290,666,897,538,815,723,588,941,724,588,519,943,563,535,626,149,508,327,804,192,820,481,25,715,737,273,670,599,589,143,570,257,121,497,235,265,388,499,988,57,571,110,978,296,467,95,967,100,430,124,531,920,148,802,242,995,13,163,24,117,954,925,568,279,648,76,992,147,214,250,915,541,506,882,495,896,7,860,718,189,300,423,766,762,804,687,109,929,272,966,476,253,39,677,799,392,870,138,266,180,56,454,84,664,899,345,200,230,515,215,648,649,853,791,637,526,730,572,974,148,907,849,475,18,881,182,740,642,538,525,855,113,751,994,2,11,81,677,754,31,249,658,117,843,370,961,775,770,346,712,802,758,869,538,372,314,710,926,92,252,363,205,772,106,918,431,580,192,408,294,13,723,557,705,810,816,456,634,710,651,16,114,454,35,452,88,242,368,381,373,450,353,851,982,857,935,732,502,888,687,882,155,220,212,259,106,705,442,27,159,415,630,71,572,480,844,53,59,866,64,979,451,969,44,999,346,702,822,949,262,44,711,61,944,312,393,226,836,463,764,596,660,862,59,24,951,363,430,691,327,392,818,752,912,835,18,637,670,119,519,181,228,906,389,732,216,106,62,330,274,631,853,180,973,543,971,707,576,455,953,568,932,135,660,492,287,654,769,41,360,431,528,882,268,875,316,1000,302,944,349,968,808,999,418,665,7,225,196,224,599,438,938,850,326,31,340,240,296,254,69,865,494,864,691,994,514,621,504,485,935,442,725,550,140,851,452,530,494,315,158,0,888,754,461,74,812,60,643,102,584,59,567,148,290,14,604,926,204,219,799,585,180,166,242,695,757,206,530,344,317,292,853,221,744,80,908,855,921,295,526,474,388,784,349,18,807,49,836,868,144,122,312,237,54,789,534,408,626,282,586,648,144,354,168,547,27,801,213,480,206,191,359,482,891,615,319,498,561,747,914,688,977,716,301,401,538,68,650,429,384,427,791,993,204,281,40,855,217,615,274,666,295,797,21,738,811,951,553,278,698,318,42,972,475,999,157,559,558,776,776,723,947,921,836,619,166,754,421,235,959,119,318,500,685,627,484,571,369,58,273,480,260,534,84,478,881,526,814,726,757,410,504,913,737,239,799,327,224,197,342,117,451,562,485,768,477,684,830,903,763,466,766,424,974,882,451,147,280,453,839,835,520,449,261,367,326,27,700,603,515,28,615,802,480,30,146,537,564,272,678,111,641,984,335,67,234,286,426,409,900,58,283,844,298,38,500,396,861,16,998,429,90,542,56,924,560,20,984,955,530,611,583,441,198,12,882,531,270,430,42,532,266,619,995,388,674,486,702,733,150,61,572,536,433,340,680,979,743,134,897,575,902,252,703,237,117,758,442,181,963,466,346,104,584,765,600,143,575,334,580,529,270,427,610,683,214,456,718,564,737,297,832,620,741,10,399,106,94,211,73,624,827,685,844,189,482,499,13,26,724,646,739,914,988,759,881,993,712,531,114,110,209"",
    ""28,492,73,139,308,339,357,657,698,184,849,802,528,6,376,362,84,242,281,821,49,702,560,291,295,845,73,504,33,183,597,897,632,462,953,828,826,852,541,516,894,212,418,370,475,553,844,916,75,353,526,906,290,628,498,353,425,842,220,327,865,969,602,887,768,753,652,120,54,87,931,868,624,388,268,178,449,93,989,396,672,694,244,308,259,26,87,590,298,582,926,85,973,798,604,748,558,247,844,25,52,646,70,21,115,801,522,634,345,400,402,731,807,180,270,918,585,972,669,158,370,413,328,290,596,723,167,401,65,888,24,322,480,722,943,94,151,920,919,291,656,804,366,979,166,351,400,404,401,467,213,737,9,752,571,989,216,810,810,951,72,278,671,37,404,544,528,325,139,198,365,189,496,536,756,565,407,125,577,244,135,555,827,401,788,599,806,641,614,165,621,843,272,724,525,420,391,524,284,498,311,823,508,234,173,764,99,63,841,335,771,48,192,610,925,623,880,392,500,598,423,530,386,61,452,216,306,420,368,732,56,22,559,675,314,395,950,880,340,123,409,812,671,39,889,761,280,509,570,3,816,188,406,957,294,93,19,569,2,722,869,919,120,888,698,613,530,154,692,799,952,78,193,797,726,829,101,108,263,46,37,346,768,45,286,951,654,531,604,722,895,666,608,327,318,687,882,627,266,722,77,389,296,950,582,444,879,841,376,769,127,511,409,298,610,980,734,88,685,722,439,106,301,278,735,368,21,475,17,798,437,860,947,780,144,704,350,456,956,979,672,967,645,541,954,246,34,48,48,708,772,925,453,146,218,709,462,542,901,138,465,178,488,854,356,945,965,154,803,160,710,898,746,935,692,478,472,206,337,577,339,999,94,926,372,34,866,914,821,333,938,305,696,118,45,897,518,655,798,290,901,795,600,377,10,157,634,45,608,24,531,504,119,342,68,997,173,494,303,381,195,769,89,546,962,816,623,49,585,357,619,442,102,153,162,924,269,991,775,210,730,782,491,847,534,889,628,74,294,782,711,509,476,6,190,503,43,709,996,179,676,753,897,77,360,783,656,739,785,718,782,926,278,383,53,534,791,344,102,749,111,707,873,56,144,922,458,955,439,96,520,155,263,12,129,306,934,593,447,955,934,996,354,130,262,761,748,264,256,957,226,82,152,66,974,273,879,180,674,939,932,729,809,964,659,238,576,92,407,609,202,218,212,503,546,887,85,344,551,958,301,366,525,26,66,209,626,129,91,34,13,487,356,698,448,376,227,236,437,149,779,423,811,627,651,64,437,755,560,677,253,990,87,373,268,266,422,93,332,103,442,565,110,632,857,504,961,183,458,576,535,927,900,296,50,107,267,802,385,640,214,688,52,717,626,315,966,669,527,264,955,291,267,279,302,365,645,864,641,532,410,38,415,650,422,793,300,768,78,679,281,713,303,42,707,566,160,332,505,916,48,249,870,804,223,92,968,547,36,536,985,872,606,902,448,152,343,451,507,526,547,176,337,636,828,908,832,734,827,481,851,510,315,10,432,94,563,113,888,0,651,516,620,496,544,472,620,596,190,574,123,60,656,384,932,405,174,280,12,716,802,505,988,845,745,649,538,458,230,406,438,826,327,206,147,619,783,635,582,603,650,326,43,398,586,385,853,67,417,680,389,384,222,840,133,783,404,753,438,324,328,384,193,584,171,21,969,961,39,103,56,221,280,890,212,493,646,759,558,728,358,111,542,688,412,609,543,142,773,620,548,282,525,776,201,327,61,211,294,837,30,771,409,463,714,95,955,982,33,379,37,794,447,159,100,30,91,945,60,121,497,401,304,208,766,262,684,142,495,595,819,387,894,795,888,469,742,958,721,554,767,166,978,218,646,598,724,756,699,501,592,855,596,396,716,786,656,78,726,883,938,688,150,18,598,51,531,782,45,168,25,767,396,555,949,808,72,251,862,811,718,236,420,959,700,924,423,311,329,117,116,195,273,630,793,36,517,347,798,826,900,347,937,246,630,548,180,445,281,501,530,357,937,132,9,344,805,975,376,870,239,636,702,143,34,935,724,845,677,156,800,307,170,184,277,216,42,389,944,223,152,147,211,214,435,701,198,293,432,212,377,177,731,848,157,193,193,973,114,415,771,28,744,570,595,781,99,220,498,466,97,979,534,870,687,617,474,819,818,95,316,327,713,571,694,961,437,896,183,651,625,867,135,209,674,532,827,346,331,848,432,952,552,17,666,502,233,958,558,348,645,58,635,458,11,675,791,478,259,343"",
    ""961,794,622,276,770,453,148,257,672,166,903,766,473,958,504,908,342,552,454,566,696,745,494,32,95,454,994,320,119,374,3,731,597,462,176,895,320,169,136,381,592,24,323,740,827,781,882,287,441,467,945,447,483,469,253,853,824,410,670,171,649,983,847,630,865,302,395,251,976,949,901,807,315,123,334,906,589,159,7,553,425,416,304,739,198,812,879,531,366,901,74,776,683,704,619,192,935,422,595,887,848,601,837,505,819,358,789,621,683,305,671,144,896,911,745,852,250,314,641,728,779,816,134,906,693,949,94,336,761,784,417,125,948,218,860,147,279,228,402,880,528,300,200,254,139,906,414,454,349,831,958,326,537,822,744,607,175,716,275,600,938,878,370,354,25,837,48,464,318,491,719,494,560,251,919,886,361,213,690,594,112,443,362,522,988,527,760,853,759,630,414,210,773,761,490,481,941,408,993,841,621,293,132,167,365,985,444,352,159,386,97,950,870,365,743,563,972,394,768,671,775,501,436,190,928,603,681,417,559,226,253,891,72,526,488,1,801,323,213,808,210,183,820,356,799,79,384,350,871,222,241,518,662,528,264,838,627,689,756,616,935,417,95,696,384,292,684,715,56,249,730,552,970,280,47,106,878,740,304,974,369,134,868,134,242,679,56,948,224,751,754,779,459,767,929,576,941,194,207,629,704,42,184,494,729,101,267,258,622,246,883,122,119,419,355,299,852,908,108,613,87,145,220,619,678,742,65,800,312,776,38,461,712,455,283,739,335,739,578,847,792,698,193,343,381,206,661,126,713,946,9,283,784,723,684,505,35,837,551,785,838,904,33,773,423,58,28,646,880,798,937,467,142,126,412,49,100,573,782,674,557,645,953,647,437,624,814,566,689,782,831,794,379,838,971,797,981,40,735,140,536,682,392,558,217,526,50,691,518,599,928,718,443,720,23,171,222,964,840,620,464,650,113,220,939,289,618,616,262,763,173,638,259,188,862,707,669,726,738,119,297,349,900,321,692,529,590,8,786,847,635,555,493,410,932,126,39,961,534,668,804,639,273,677,175,329,352,181,716,671,913,156,347,62,518,267,341,692,363,567,578,249,366,296,673,299,221,228,52,161,816,31,781,569,424,410,498,479,10,756,14,454,493,745,341,100,472,445,362,976,919,12,497,739,288,610,7,763,364,404,942,209,998,722,877,576,954,877,84,100,426,983,75,883,627,972,116,393,461,132,701,597,567,770,954,565,917,758,392,994,378,629,520,736,941,184,588,112,27,166,838,859,701,989,302,904,733,281,98,29,931,802,59,120,132,461,759,806,439,871,957,810,779,893,972,361,759,185,123,92,759,804,623,352,870,509,261,711,132,340,503,216,584,495,44,368,273,947,714,925,56,164,857,394,593,791,456,476,22,372,548,827,518,475,278,851,123,929,468,228,642,17,420,11,882,119,678,488,448,51,24,29,831,793,220,436,954,735,823,261,918,371,119,676,726,288,974,18,45,401,833,530,236,565,243,249,104,815,569,383,513,686,372,780,605,469,979,573,754,651,0,741,166,399,176,827,875,268,714,261,484,983,984,165,243,574,246,900,831,957,815,271,538,953,664,937,608,230,679,914,341,440,161,244,800,859,864,462,969,307,957,124,243,10,854,317,678,341,12,517,990,567,251,739,255,79,959,880,393,439,109,9,812,464,580,805,528,893,458,594,160,559,444,578,718,44,457,515,364,917,273,197,410,751,808,643,585,178,905,90,995,11,449,593,101,476,834,338,440,617,140,972,422,309,241,356,114,815,600,766,929,367,710,299,690,825,150,510,918,605,350,825,530,590,646,711,122,123,640,729,786,489,664,718,242,807,997,96,527,642,657,225,771,364,293,205,798,902,881,365,333,170,918,844,771,484,529,728,546,914,26,622,163,139,597,43,654,38,769,206,268,609,946,775,513,220,658,99,132,380,27,458,934,304,503,616,570,910,660,733,945,698,271,339,154,469,31,161,154,690,687,103,904,797,947,236,283,571,110,594,968,99,56,925,493,244,944,320,638,838,691,870,153,65,299,306,66,576,366,466,941,642,629,378,712,507,177,984,94,463,273,394,117,152,891,911,162,899,890,863,123,916,735,381,618,546,94,680,990,306,107,102,882,744,366,995,476,235,155,508,769,123,720,786,848,250,679,785,655,899,890,942,673,798,951,132,810,396,386,768,479,314,536,147,940,362,922,869,767,162,301,774,286,69,52,259,341,683,3,665,428,80,886,454,517,364,825,224,417,964"",
    ""222,179,190,678,832,676,343,545,173,873,467,320,497,627,888,292,438,778,332,988,710,309,530,980,820,294,485,229,444,364,721,206,654,354,73,7,219,385,509,373,404,157,677,662,613,771,319,490,703,1000,476,129,491,94,403,173,258,447,726,672,878,977,873,462,683,486,740,396,89,934,165,409,891,128,951,439,795,31,443,557,279,36,803,792,510,264,325,696,343,115,963,12,677,757,785,413,872,607,824,415,893,154,297,712,377,837,759,666,612,328,647,246,943,694,426,345,97,374,295,773,641,685,955,919,383,445,898,229,750,38,48,752,346,642,27,958,832,346,631,992,124,491,977,374,918,310,693,578,644,47,732,211,128,636,570,848,262,599,646,878,485,657,878,6,248,19,839,795,347,470,823,233,862,142,692,842,513,587,417,758,729,933,424,842,966,974,551,5,427,332,822,476,752,15,224,66,345,212,429,294,911,528,531,742,436,857,77,585,903,225,147,517,430,697,99,679,810,426,853,99,762,148,564,217,166,557,444,828,860,115,641,535,460,745,901,155,751,876,437,178,926,883,909,530,34,666,121,827,666,137,735,964,195,646,885,883,562,228,216,874,310,903,91,812,955,411,443,68,479,974,953,224,829,634,325,392,165,407,71,771,355,398,21,535,692,621,410,781,555,744,332,920,552,681,717,425,860,27,601,537,746,837,343,884,623,626,589,484,126,803,947,142,704,474,306,319,420,395,388,767,785,526,76,138,974,276,412,315,551,54,622,69,217,390,716,699,699,324,757,611,704,46,596,486,912,63,812,153,112,199,49,463,280,232,858,180,637,425,583,199,591,76,991,8,17,327,141,23,870,965,295,206,486,94,239,444,520,744,512,180,496,147,704,52,244,74,855,717,636,607,853,403,742,184,452,931,798,592,502,258,186,187,132,579,531,687,278,929,358,693,985,462,211,632,101,651,478,460,508,409,937,104,359,340,456,24,732,41,629,686,511,46,479,298,285,611,736,834,536,724,493,5,607,195,363,767,295,56,803,939,985,62,275,66,138,931,792,943,826,396,441,454,817,520,980,512,867,683,867,412,611,706,72,666,345,885,88,62,362,100,767,793,379,126,60,245,566,132,373,597,985,195,314,595,393,195,793,487,121,208,747,92,284,51,963,189,48,292,943,602,756,106,118,904,13,617,346,337,238,589,715,958,113,808,692,190,423,134,382,251,820,748,430,566,642,188,373,182,107,345,343,475,75,965,68,721,743,558,586,654,821,29,937,874,942,639,577,444,519,303,855,654,3,494,940,521,353,622,564,285,469,851,810,933,81,881,295,62,64,536,994,96,558,701,736,882,131,60,783,444,564,748,41,678,762,789,310,750,797,916,872,414,480,690,37,614,698,949,175,574,632,929,573,324,299,177,366,275,100,446,607,399,13,626,623,999,401,459,839,893,958,901,120,758,117,809,296,654,459,75,493,873,648,662,862,670,308,517,716,580,820,756,614,664,858,4,836,630,221,813,959,537,191,266,983,9,875,74,849,837,582,125,219,664,823,721,592,413,461,516,741,0,660,127,33,35,173,815,839,711,513,806,628,933,427,293,984,208,195,118,90,625,636,933,604,104,231,493,442,791,211,484,740,668,133,399,997,242,164,949,276,520,827,290,514,175,62,154,190,36,647,622,453,729,407,120,863,744,476,410,591,927,935,498,605,808,754,97,499,266,956,873,798,309,515,354,442,97,833,409,197,956,340,960,716,890,12,341,137,251,480,293,81,899,700,874,898,763,222,823,742,862,281,354,541,459,239,449,270,652,376,171,507,778,126,496,426,88,306,180,473,819,554,239,537,78,808,139,159,69,133,992,839,639,466,935,437,217,450,515,258,671,612,100,518,202,858,450,456,382,982,367,921,551,149,243,633,427,230,733,132,10,797,549,383,29,450,89,429,850,272,82,545,542,749,936,348,778,721,173,285,595,889,314,239,172,676,948,733,243,715,626,785,462,264,88,142,734,653,401,558,365,484,81,537,960,534,114,221,262,837,631,689,593,461,350,279,765,25,182,679,593,845,868,485,524,90,75,805,644,204,5,152,658,982,652,712,883,756,578,969,400,942,874,378,917,7,473,701,200,560,287,276,122,506,911,198,689,712,593,351,966,435,946,782,993,992,449,548,718,255,923,931,700,283,455,782,191,534,531,148,632,163,291,137,978,718,738,282,629,963,986,445,850,57,602,839,946,825,436,728,784,847,649,55,547,854,855,195,998,661,1,153,875,181,682,772,138,516,929"",
    ""953,487,271,673,239,262,992,813,629,566,175,330,432,293,435,860,351,487,660,460,250,975,348,667,90,12,859,335,710,527,279,148,128,741,13,57,765,398,700,702,582,969,96,706,825,148,639,991,669,352,977,734,795,566,46,555,317,598,826,374,191,696,564,944,939,396,788,742,949,365,40,529,363,207,48,32,608,552,184,237,530,239,472,925,294,708,724,261,554,128,622,85,159,565,985,55,160,931,499,303,112,667,539,737,477,232,853,363,530,276,421,482,830,362,662,599,553,199,354,10,718,318,854,584,181,960,237,337,802,696,455,415,639,588,42,72,856,412,662,350,883,929,767,610,594,994,294,436,367,802,248,331,836,727,553,638,844,370,783,60,624,253,507,391,683,33,138,381,830,902,110,622,263,98,409,496,737,928,732,625,596,56,341,261,140,767,431,377,993,979,735,109,784,570,823,892,279,451,520,805,604,749,349,494,787,197,858,530,988,216,902,958,907,598,120,573,294,744,701,640,47,515,870,174,732,167,710,292,63,665,978,179,228,184,266,209,99,640,679,167,903,304,545,200,586,377,394,481,907,692,966,107,210,375,594,277,501,959,447,747,708,677,390,94,556,299,560,713,374,638,605,778,423,549,940,95,218,33,932,565,975,221,797,915,574,749,50,1000,426,442,901,466,14,844,214,772,13,122,307,621,12,867,75,343,85,715,95,485,841,134,870,953,80,582,353,645,366,803,317,582,883,300,877,39,86,739,241,454,840,867,907,954,770,102,739,415,923,7,993,516,663,326,418,248,493,242,465,991,748,337,310,133,512,440,791,257,929,611,16,186,584,744,126,149,254,681,655,752,699,999,656,98,25,235,847,242,522,745,914,514,973,16,333,330,280,471,519,322,856,364,222,21,616,482,539,740,658,740,89,959,144,516,519,37,530,66,371,116,728,524,783,781,34,729,915,994,831,312,318,781,387,517,418,772,659,791,677,529,372,21,913,985,614,980,968,586,979,217,256,184,780,31,559,680,684,261,664,425,293,952,150,692,223,905,246,346,848,250,186,343,469,721,486,88,245,106,265,412,561,551,87,278,171,672,778,385,431,510,489,268,512,895,106,581,671,824,526,914,574,735,776,208,381,163,10,463,194,736,937,514,333,309,282,348,30,2,152,27,526,686,781,932,336,483,85,471,134,544,209,693,768,837,572,959,341,878,871,584,298,271,236,366,286,29,56,462,232,260,983,63,728,847,129,738,822,748,668,856,326,142,839,36,75,709,411,630,132,26,227,501,534,497,198,907,149,442,411,860,175,501,462,24,452,937,575,33,697,644,941,190,24,230,723,213,361,358,504,538,479,952,126,445,13,655,356,756,341,248,225,119,826,713,88,309,77,945,39,417,820,859,744,498,340,547,73,984,725,547,98,475,236,810,963,766,630,889,60,792,628,4,91,493,1,42,20,838,191,281,788,491,170,166,599,792,529,658,400,745,447,219,789,82,345,841,702,807,939,838,546,765,287,470,944,90,760,612,617,26,138,98,583,38,575,353,25,644,620,295,74,620,166,660,0,354,394,679,163,130,341,415,736,942,465,768,388,711,892,413,127,158,797,185,89,736,588,803,190,898,94,96,683,618,470,264,612,649,244,821,441,708,208,588,891,758,723,927,949,20,23,597,704,339,298,338,161,378,217,660,956,517,210,709,251,882,874,551,823,254,859,262,203,689,374,909,257,590,219,418,695,120,38,169,349,814,81,939,71,676,314,584,355,743,951,51,281,464,738,562,58,169,29,552,318,173,657,338,602,156,117,758,44,544,602,543,974,908,317,865,544,806,342,342,505,477,387,596,811,496,84,819,758,4,258,912,70,383,889,305,159,240,739,699,331,756,35,596,594,493,483,437,668,528,36,864,59,146,38,21,949,359,945,313,138,821,552,415,458,232,172,991,157,800,706,859,113,292,929,658,637,337,482,832,656,243,150,949,397,693,273,711,94,94,636,253,862,915,616,49,981,931,341,625,49,212,925,636,963,875,984,332,284,734,404,515,626,943,251,478,853,477,263,488,181,502,143,977,654,181,190,240,18,865,737,974,614,689,451,547,835,581,115,986,140,386,26,225,247,820,324,645,277,729,1000,890,605,319,146,227,534,841,927,528,752,979,752,459,683,296,650,589,374,577,160,102,879,833,317,920,819,432,801,721,873,488,188,275,714,227,18,223,86,443,664,527,475,260,435,747,86,877,70,26,940,913,110,988,851,423,525,755,250,989,750,502,272,591,101,155,523,803"",
    ""604,555,412,94,828,313,903,949,359,122,883,449,853,17,612,577,217,22,947,84,303,6,120,485,68,393,654,234,610,80,397,448,820,621,74,957,28,120,375,551,471,20,516,736,564,295,635,100,318,309,741,411,912,821,390,399,71,387,716,711,707,643,75,118,793,453,3,137,55,316,969,934,971,994,962,389,916,697,416,962,502,173,63,263,601,406,271,647,868,829,302,69,456,771,402,64,956,18,282,650,190,757,208,154,985,851,932,875,536,984,802,879,631,561,87,234,530,719,997,262,636,642,70,963,735,34,353,181,239,303,407,349,223,6,249,174,21,803,612,897,672,150,554,250,448,503,146,675,14,394,120,300,327,44,799,840,76,342,654,383,719,905,231,783,308,478,506,48,203,729,106,578,304,234,983,920,737,223,749,714,303,757,853,957,759,73,941,272,521,505,419,195,720,153,787,886,536,472,571,298,565,451,87,788,189,954,852,305,803,19,353,834,394,70,142,451,863,943,2,358,819,367,690,231,555,701,20,48,884,250,938,636,946,389,449,439,323,70,428,583,543,235,399,606,248,337,67,681,713,319,867,589,458,568,334,589,473,247,492,686,571,826,495,605,155,467,643,478,810,723,17,18,606,962,693,201,635,902,811,358,440,901,954,531,964,850,454,443,429,762,483,4,384,751,997,266,631,312,461,677,181,160,293,384,811,965,214,278,714,749,724,483,552,749,670,354,545,885,180,591,478,789,639,466,333,40,986,971,817,891,391,4,600,311,427,983,195,660,242,194,226,262,42,182,347,103,284,288,55,78,860,542,915,622,23,454,860,275,781,691,37,638,160,379,35,134,241,325,233,5,440,766,517,272,865,5,103,525,896,182,113,484,347,824,595,559,666,624,389,321,758,196,161,785,54,69,537,322,905,950,696,352,82,138,474,104,708,495,238,75,606,781,631,260,267,448,391,36,39,97,878,449,765,898,539,718,674,508,322,540,807,257,289,714,894,960,682,290,241,144,560,374,752,818,280,354,940,669,679,444,771,85,40,12,781,638,739,566,39,611,129,424,805,554,572,840,385,415,66,711,372,257,264,57,953,446,605,635,487,734,421,552,760,904,34,526,973,231,172,444,589,418,916,483,394,351,45,661,658,586,886,758,648,724,994,974,973,347,603,593,652,650,697,401,18,693,613,762,150,816,863,142,853,230,740,41,103,224,365,275,841,696,655,560,491,907,613,495,570,394,452,673,720,494,224,126,458,676,663,116,616,368,807,352,308,646,61,696,261,355,837,776,715,898,376,102,783,823,11,292,585,871,249,427,597,859,916,792,503,939,645,386,422,723,103,470,190,28,130,172,274,399,656,240,537,293,393,144,53,371,249,796,883,771,528,538,508,183,703,322,124,917,558,487,925,881,757,205,67,139,223,268,624,249,420,754,997,169,513,328,813,112,736,379,250,650,340,827,160,268,467,165,75,919,268,654,178,554,663,451,602,930,458,482,718,354,637,128,392,489,784,920,913,812,974,972,819,506,32,455,329,226,898,660,749,896,68,163,812,496,399,127,354,0,871,732,190,651,707,374,543,991,165,613,875,352,20,365,295,416,241,468,689,48,244,642,847,991,243,512,128,863,611,417,163,237,348,186,910,594,531,164,372,120,739,997,644,180,166,866,840,362,614,30,429,697,200,494,918,782,29,218,458,478,846,688,558,133,713,343,161,134,873,806,585,357,782,130,108,489,788,223,305,690,316,803,58,821,435,993,693,22,978,761,49,484,419,299,961,242,85,497,568,57,425,341,91,7,457,599,810,136,730,268,233,986,994,808,988,950,658,879,239,981,739,12,268,617,657,154,238,908,488,719,507,435,731,109,324,243,128,34,912,785,882,417,16,506,510,273,736,865,247,457,592,500,788,589,571,394,882,164,573,18,900,820,626,332,400,796,792,647,864,176,169,483,411,259,617,345,19,309,411,667,592,268,594,607,721,739,280,73,184,705,512,241,814,344,578,107,28,756,490,247,320,379,732,210,462,6,394,655,103,482,992,591,513,822,44,242,585,27,997,654,605,661,287,155,38,451,151,880,198,351,748,107,852,988,806,69,240,918,862,401,178,426,250,685,82,237,605,232,947,764,113,318,513,655,244,372,149,559,191,315,867,25,724,785,562,528,141,572,526,532,384,539,719,877,948,356,45,441,843,839,565,849,923,67,698,832,584,760,585,355,220,720,134,197,951,798,722,880,652,330,46,289,746,942,889,857,680,282,903,229,636,5,254,469,507,292"",
    ""611,710,275,764,764,924,916,616,506,490,697,197,146,672,155,532,942,288,296,859,396,275,322,377,112,562,312,1,28,503,262,849,185,481,31,203,502,595,441,60,201,993,856,312,193,613,568,229,917,698,629,178,244,919,230,105,458,257,320,640,352,155,414,211,155,649,986,397,276,601,166,251,697,150,781,691,113,553,783,867,210,156,84,312,64,998,905,364,925,908,716,222,94,859,41,565,94,93,131,366,57,499,363,552,426,818,871,721,557,648,389,846,246,365,333,577,81,520,518,625,936,237,220,247,232,168,541,259,772,940,221,583,482,497,657,420,555,67,40,232,984,762,47,136,24,409,711,88,50,396,196,565,727,609,2,579,661,855,889,475,139,767,537,796,876,225,629,13,505,235,437,725,15,128,5,400,76,105,307,352,836,825,209,488,932,21,302,926,387,651,775,185,57,514,491,841,986,131,165,601,968,442,83,94,947,935,762,368,536,178,312,957,531,542,667,313,989,549,712,686,529,521,454,727,831,313,14,218,902,780,410,434,464,659,611,638,38,101,371,834,653,241,131,600,349,697,336,769,90,184,709,555,480,369,726,39,618,285,993,627,15,681,382,445,657,822,864,606,870,101,623,413,927,948,203,53,955,400,713,410,930,549,761,649,451,956,219,993,16,887,78,497,931,507,793,974,95,853,171,749,416,701,236,431,374,48,144,642,156,250,418,735,24,739,483,235,990,407,46,65,560,791,289,102,487,560,950,589,321,63,375,357,913,768,124,760,166,794,632,654,936,678,618,12,650,693,545,19,680,12,895,878,137,524,942,963,533,972,681,598,407,415,815,100,691,24,910,718,351,771,703,583,398,511,212,297,597,916,636,917,889,527,532,509,787,450,365,956,560,28,30,683,677,5,412,842,867,432,723,978,550,228,229,588,823,957,69,155,641,245,904,876,723,345,140,855,456,970,96,5,338,223,708,43,473,279,290,377,26,652,182,795,156,529,556,649,116,501,688,492,161,12,871,805,948,414,559,990,573,604,549,826,216,947,677,613,816,123,194,579,668,832,659,226,176,326,638,2,523,670,421,231,722,399,860,70,958,774,967,928,813,282,491,268,142,917,45,946,849,739,881,330,280,207,125,141,685,941,427,544,650,805,751,22,606,297,681,718,474,864,384,539,668,624,611,496,574,406,425,153,996,962,96,86,118,796,297,330,104,880,820,729,629,8,223,343,84,414,526,427,732,757,843,719,229,874,674,56,832,612,126,239,63,552,257,442,39,990,443,591,521,599,379,262,628,631,467,563,874,46,685,598,298,630,58,318,708,101,856,154,28,583,257,889,298,868,576,327,142,913,397,453,347,367,743,901,963,394,51,708,703,996,814,255,539,143,571,85,675,955,9,711,846,596,615,927,772,86,48,619,405,434,455,508,999,375,429,315,102,265,47,160,824,869,790,419,926,581,415,157,518,239,393,228,185,483,747,885,422,146,556,689,582,810,220,55,612,57,900,523,285,968,69,628,504,332,127,91,266,406,822,614,360,314,716,841,79,494,60,544,176,33,394,871,0,234,445,156,134,486,742,833,331,978,503,557,369,2,621,220,377,528,154,269,53,72,749,68,532,478,438,412,667,881,931,577,730,787,678,619,868,16,805,247,244,888,326,369,200,208,436,148,878,639,987,47,965,343,225,110,978,169,954,810,667,413,209,409,427,906,736,549,70,776,839,97,394,836,521,784,577,991,367,888,464,796,723,705,8,608,529,760,974,859,521,522,262,99,93,110,4,812,104,199,962,985,706,464,839,265,982,478,855,362,135,841,862,28,497,917,113,678,709,46,736,907,756,270,510,830,615,439,2,742,824,647,767,751,254,498,832,471,712,460,757,485,646,551,210,222,968,897,642,682,989,15,329,464,777,295,355,285,954,743,986,192,670,636,299,898,553,869,827,940,215,245,778,714,426,158,756,703,699,395,832,194,587,92,713,928,668,237,59,764,293,418,716,255,208,721,285,5,64,43,824,211,256,276,560,437,739,307,675,7,978,135,564,116,135,309,447,816,285,470,421,262,737,206,738,79,819,730,572,304,286,213,454,156,240,46,919,67,809,758,876,198,664,956,686,633,820,72,670,734,506,86,677,715,24,884,828,657,754,468,755,15,268,17,330,997,25,188,593,16,533,676,101,418,979,716,618,951,197,447,535,911,471,268,951,384,566,898,239,976,776,593,404,756,765,452,556,172,110,747,136,187,244,418,879,535,677,263,613,956,271,736,274,547,691,506"",
    ""111,215,427,731,273,444,982,465,410,64,274,832,909,771,147,685,273,773,17,345,40,706,961,884,246,117,414,850,366,938,438,507,737,902,911,321,260,408,622,167,786,29,46,728,60,967,911,83,762,359,2,7,520,875,979,989,914,322,419,776,214,992,289,337,743,444,597,909,197,709,258,645,817,161,140,152,321,454,199,868,231,178,5,938,582,418,512,579,324,207,295,525,657,578,278,795,865,112,288,807,597,697,714,16,796,683,950,548,35,160,220,555,700,357,464,931,410,901,55,687,424,294,329,507,942,822,985,329,913,513,419,689,387,781,968,635,513,53,362,213,672,100,464,248,863,232,384,474,885,666,930,370,677,727,171,360,379,199,177,511,246,174,514,354,54,763,760,808,163,788,569,781,861,443,794,417,792,452,708,565,741,735,200,802,539,696,409,680,204,520,130,96,369,388,370,217,775,77,934,564,489,141,976,835,962,207,845,570,508,594,417,945,604,712,111,430,111,709,599,299,341,445,63,662,518,64,369,933,153,571,623,155,203,554,92,584,473,4,87,732,493,638,622,134,143,10,137,317,37,316,286,794,188,408,226,937,132,555,374,903,682,951,914,959,581,403,850,173,766,69,7,191,784,175,772,756,523,932,216,877,514,216,958,352,308,101,931,281,900,899,661,961,714,845,340,895,386,868,865,451,687,841,276,200,944,522,784,41,498,914,145,353,537,423,341,628,597,372,863,837,754,167,60,280,188,360,388,916,510,710,252,175,236,130,792,948,348,382,431,895,99,59,434,317,742,487,953,789,100,943,510,993,546,55,413,67,377,977,435,864,806,577,741,232,191,244,652,596,858,187,421,549,249,99,858,293,426,457,172,34,381,259,899,928,550,684,568,855,757,372,310,871,1,679,353,99,474,118,717,297,599,942,208,207,42,108,42,762,210,387,154,858,765,677,455,685,912,795,86,78,113,732,968,956,355,69,902,956,31,594,740,277,922,192,26,428,388,520,196,977,867,853,82,81,972,310,486,341,115,824,192,194,857,362,367,713,555,973,149,885,311,735,345,244,504,949,877,368,26,62,244,662,630,803,425,268,487,54,111,567,433,894,363,881,970,888,659,257,218,824,272,666,588,792,62,990,291,419,260,340,748,638,968,576,638,488,692,909,506,95,958,509,682,392,233,109,941,420,625,418,753,279,355,562,490,412,312,521,98,890,387,220,369,567,469,852,529,180,872,221,423,878,755,245,225,122,321,64,836,575,419,647,464,263,777,942,590,106,757,669,80,244,55,508,412,274,506,24,788,57,623,903,559,605,554,859,236,913,494,45,488,452,218,219,210,170,478,577,748,604,244,256,755,402,771,67,401,172,976,70,342,117,243,316,802,331,881,3,318,957,390,486,125,698,738,721,491,968,194,653,609,858,9,866,300,737,789,720,140,388,104,672,695,792,664,236,68,177,87,422,426,963,914,821,370,281,247,510,195,135,824,716,82,203,746,312,822,768,505,412,211,295,571,894,736,926,956,395,928,880,29,705,512,507,782,923,309,656,643,472,827,35,679,732,234,0,722,648,156,771,224,300,317,801,960,117,791,921,383,833,283,221,641,979,796,469,396,475,595,808,202,546,702,99,157,735,597,244,484,554,361,478,1,519,386,834,191,561,269,442,230,166,248,971,788,469,388,234,505,222,509,150,856,719,457,583,130,147,504,298,810,473,757,42,760,819,437,180,974,540,830,776,149,283,42,106,491,821,203,383,249,809,593,482,625,65,729,198,861,59,855,365,416,377,47,125,351,480,855,676,800,873,158,995,461,338,172,918,849,855,775,809,761,371,813,947,554,260,720,387,78,431,39,358,428,16,114,511,792,121,73,525,172,572,46,310,366,967,157,665,490,378,851,936,864,443,14,859,123,133,361,871,262,80,629,857,364,924,273,741,281,363,63,967,583,72,374,749,531,930,401,220,850,113,856,325,877,602,591,790,281,989,82,36,653,206,858,139,87,440,784,240,373,359,885,952,281,514,680,306,547,916,252,713,217,316,218,6,818,105,571,221,192,4,674,347,902,260,298,975,105,130,20,193,785,50,299,668,627,506,544,129,888,511,398,753,84,987,871,482,93,130,996,240,627,238,946,91,556,288,794,398,875,665,791,361,470,525,592,916,624,898,522,788,606,311,695,501,396,108,292,945,216,521,69,843,710,250,743,198,702,652,29,365,596,978,595,437,382,437,528,429,630,746,842,359,980,677,596,755,793,785,751,652,322,335,876,948,728,117"",
    ""296,94,398,778,149,115,428,710,86,682,306,226,192,159,401,844,315,870,926,117,10,165,269,40,731,90,386,518,156,970,181,26,273,942,893,944,446,619,508,20,918,690,416,967,601,801,520,814,502,766,366,554,949,588,881,450,327,653,136,875,43,721,759,587,673,324,565,545,79,920,837,749,52,783,265,347,992,943,94,136,620,307,181,367,893,968,885,662,480,688,530,762,486,286,132,985,827,939,932,368,718,70,115,190,643,65,533,70,621,110,309,899,863,639,139,685,619,549,218,260,103,434,45,309,23,231,691,65,279,589,74,774,161,261,846,556,707,927,281,64,71,73,508,710,365,78,951,354,87,71,409,383,912,246,714,470,187,733,85,206,14,529,395,840,104,508,419,583,182,491,982,594,815,766,880,842,23,412,523,648,562,192,205,721,843,221,741,176,9,965,953,859,108,721,40,32,7,262,636,333,799,840,410,205,71,913,807,883,734,612,703,162,62,672,622,976,593,830,290,462,644,697,109,29,364,753,466,126,288,840,325,481,292,700,525,646,320,94,587,860,245,252,610,212,996,503,506,297,581,34,959,759,393,47,933,161,164,246,226,269,855,964,81,220,128,569,804,35,247,585,247,649,497,216,489,733,721,675,292,193,340,873,881,643,587,387,880,508,785,606,928,12,480,789,102,481,260,786,690,606,112,329,17,259,789,342,302,172,266,612,215,658,809,382,252,916,643,323,979,472,200,686,894,231,508,258,663,736,469,3,794,527,261,560,457,262,139,229,167,471,568,998,610,102,471,225,662,301,333,129,103,974,325,857,127,18,429,949,15,901,298,933,604,890,743,71,591,74,263,966,974,800,151,603,496,257,133,349,677,79,624,754,615,886,507,185,964,588,855,511,715,575,587,734,487,746,982,833,680,808,682,897,996,840,165,266,195,293,850,46,599,35,790,529,850,671,994,635,242,991,511,561,924,130,148,918,248,118,81,392,473,661,44,753,172,858,781,310,349,461,186,882,977,364,601,807,784,444,511,125,652,115,553,605,289,431,584,512,85,395,379,221,830,27,678,731,204,438,406,470,429,86,170,72,868,434,155,631,723,850,542,983,280,960,931,202,683,860,69,739,396,688,592,848,465,444,813,614,466,824,729,526,547,88,291,30,20,218,869,141,828,512,330,442,479,382,573,201,633,889,249,855,824,414,23,928,177,294,15,57,486,302,161,785,373,206,196,816,360,916,948,293,486,992,659,24,181,282,244,152,737,722,824,454,817,30,459,730,11,886,899,593,553,411,895,692,73,846,275,846,152,145,270,207,780,175,421,19,407,306,129,887,378,503,654,581,236,621,566,332,609,920,632,620,103,890,781,277,593,956,100,510,636,440,776,996,2,543,528,565,590,81,78,432,165,516,539,328,636,659,8,790,529,778,729,210,165,764,684,975,993,289,565,781,337,417,966,647,74,308,720,871,766,264,664,984,366,14,976,451,407,732,499,281,400,295,722,712,424,901,322,6,609,202,343,848,513,42,244,682,988,969,824,29,640,647,469,488,102,620,875,173,163,190,445,722,0,571,197,419,755,493,192,774,964,846,138,140,173,247,164,609,223,906,544,688,582,612,803,517,251,884,78,112,627,709,441,724,352,165,449,9,640,585,226,58,203,564,932,470,754,76,224,945,343,564,430,262,146,876,296,581,596,674,352,638,133,491,179,157,225,460,755,668,565,276,312,130,575,416,140,308,500,867,929,143,634,853,77,641,590,328,797,172,292,552,855,430,494,445,751,278,449,825,420,649,153,974,552,602,169,326,876,44,802,588,35,953,566,159,587,910,23,133,164,993,202,656,752,155,4,29,151,850,841,869,875,236,636,434,320,170,79,438,546,794,515,11,959,902,236,710,932,453,273,557,750,977,570,55,732,922,643,598,312,838,753,914,442,650,933,224,954,51,835,820,381,162,956,840,898,736,606,496,216,776,989,177,424,282,491,270,986,670,656,708,951,917,664,611,983,467,250,582,403,339,428,927,460,869,378,401,592,100,756,857,957,560,958,533,219,640,19,297,252,111,492,866,638,747,429,704,928,21,294,811,931,238,114,796,545,144,780,181,635,407,505,881,992,119,637,136,55,330,550,523,87,37,89,758,633,38,861,132,276,589,484,335,14,276,233,118,976,236,24,785,778,229,988,977,319,60,586,219,811,545,482,719,503,367,855,576,527,41,748,439,696,6,863,345,725,892,856,593,619,489,162,51,50,787,961,231,271,711,700,986,876,261,482,254"",
    ""784,707,206,196,191,895,271,828,648,794,415,377,965,788,993,409,128,339,182,890,933,461,437,896,598,258,226,286,391,149,218,656,726,941,521,720,518,471,146,279,951,553,335,567,644,39,260,844,887,260,623,774,247,825,260,231,24,433,436,832,883,994,930,333,970,613,422,760,717,650,597,97,690,405,681,737,919,243,632,584,215,405,98,98,7,859,812,619,352,518,270,74,449,138,8,808,183,66,862,19,97,208,974,834,457,510,622,997,609,208,403,966,612,981,516,56,822,141,583,187,925,384,481,365,491,42,803,59,605,791,547,952,720,641,437,468,925,213,697,762,362,337,570,709,666,738,335,291,285,267,983,205,714,177,581,554,893,569,345,98,513,177,795,823,87,233,246,998,585,478,916,754,876,448,847,334,245,937,108,497,220,872,132,827,124,616,648,772,640,572,667,613,315,92,683,940,756,447,899,692,347,50,457,981,520,32,773,41,12,179,21,823,832,127,915,214,383,315,121,661,236,480,623,352,18,569,273,355,713,689,785,93,475,379,667,768,63,70,951,922,929,497,436,894,637,87,492,609,222,177,724,682,888,887,46,492,531,665,22,164,214,278,360,216,317,526,763,325,397,576,623,461,501,91,3,382,266,504,349,459,491,841,307,941,491,713,143,641,249,141,348,205,879,174,593,433,3,836,521,629,225,396,340,683,139,219,909,324,931,723,732,635,736,971,814,346,517,721,353,486,656,635,248,890,567,242,460,874,117,659,322,690,270,21,280,343,517,640,395,539,38,424,144,996,927,836,617,594,448,974,11,595,330,103,635,11,633,715,951,960,542,59,742,780,614,484,881,741,87,616,655,467,264,417,774,98,987,254,403,783,292,356,137,932,83,138,400,5,481,76,999,603,732,254,246,411,492,264,29,485,104,839,130,294,733,853,680,353,678,489,542,583,212,568,419,450,227,665,666,860,945,429,137,206,304,771,541,657,648,41,270,383,236,595,940,356,920,583,847,598,281,276,431,550,342,866,845,513,880,473,636,805,645,219,22,749,901,215,667,302,439,794,700,301,812,243,353,899,918,219,564,641,972,628,738,802,838,661,797,279,480,441,309,837,598,528,241,41,317,474,853,327,55,67,644,715,565,354,546,84,201,510,764,294,522,757,460,568,999,848,96,352,34,926,629,886,263,507,28,230,386,140,709,465,852,360,394,472,285,163,760,462,352,752,756,862,716,678,101,256,118,262,850,709,833,855,953,652,320,698,297,627,131,981,628,179,297,963,725,388,266,879,413,327,619,640,487,902,500,167,47,365,110,116,30,862,939,174,825,379,880,998,726,679,720,144,419,213,860,986,607,461,219,499,318,408,650,331,791,568,427,975,164,398,370,20,601,853,366,575,537,433,898,496,593,608,699,285,800,362,590,500,481,699,932,267,329,562,872,692,777,465,609,279,678,586,927,942,827,61,938,47,957,312,327,665,300,942,59,698,571,264,227,658,603,326,745,672,96,78,681,419,606,271,118,986,282,340,970,357,726,378,103,971,85,553,22,626,584,596,268,815,130,651,156,648,571,0,75,889,357,845,729,982,678,301,522,383,276,657,164,535,509,477,235,649,366,824,872,808,590,61,871,81,441,74,715,977,663,386,750,633,184,785,239,912,729,424,836,561,606,591,951,545,840,400,506,931,917,774,543,526,325,933,889,643,747,196,560,804,56,460,10,961,315,167,557,74,951,715,751,149,907,537,540,186,552,667,696,12,295,795,7,48,812,125,62,788,19,685,673,868,79,616,722,705,500,148,644,725,51,87,328,657,920,634,553,827,215,515,884,11,810,630,76,245,504,557,314,87,224,787,908,444,165,839,405,727,120,137,120,180,823,595,197,181,262,583,573,171,243,684,214,864,720,380,740,571,303,567,786,651,125,774,915,764,739,33,55,486,940,612,849,201,501,690,566,599,304,187,925,641,763,96,738,474,991,901,826,296,166,138,876,589,425,793,24,734,483,940,516,701,386,286,379,716,123,934,615,208,804,749,411,4,789,192,789,668,913,323,424,582,279,331,758,659,495,745,889,332,269,416,316,547,105,674,188,855,143,836,639,888,808,562,818,334,832,618,821,291,511,647,229,299,46,421,300,21,192,623,399,931,473,75,298,223,795,379,458,122,224,49,745,834,880,763,469,443,310,656,813,304,303,31,760,710,779,797,418,778,101,201,982,722,639,23,845,118,876,107,371,167,407,361,896,477,403,911,307,557,122,164,554,912,705,3,228,878,979,844"",","""967,326,953,10,607,53,947,209,22,925,728,350,357,111,473,482,611,916,898,236,92,644,372,359,769,392,544,730,251,977,914,219,213,177,828,362,430,301,106,483,647,664,881,767,592,375,964,161,171,480,956,461,192,189,23,409,714,357,867,918,430,557,913,736,168,395,418,483,77,512,355,688,394,435,208,543,981,432,209,407,223,157,433,143,378,70,316,419,592,385,221,371,478,784,607,180,239,792,57,752,26,731,224,196,171,368,789,722,877,148,997,399,845,200,693,343,533,863,168,706,336,66,917,517,420,54,480,977,718,681,921,286,170,589,72,292,891,858,636,696,173,681,414,941,926,230,564,722,299,771,674,819,656,376,93,381,711,752,667,942,216,863,743,294,397,811,478,399,275,579,275,79,622,389,52,655,786,90,560,150,929,404,431,106,258,91,69,862,420,44,766,600,256,810,677,596,790,905,417,217,994,741,441,100,382,545,248,7,75,559,669,579,9,262,655,95,619,98,566,344,738,455,655,701,138,142,335,748,685,230,869,864,916,433,339,989,732,153,785,6,992,810,354,143,159,737,874,479,108,807,619,706,562,16,417,669,846,132,455,741,527,517,872,493,633,837,902,506,638,803,369,18,403,624,279,383,98,999,96,829,724,420,154,99,481,786,391,893,704,498,256,959,779,367,821,958,7,196,86,213,841,363,517,666,144,248,916,956,934,569,663,165,545,295,220,839,553,225,32,518,339,482,147,160,179,383,76,297,677,946,492,51,978,163,731,644,302,836,770,557,612,168,111,945,439,606,158,128,653,814,872,951,611,545,310,586,943,295,542,327,975,55,701,314,114,364,54,960,858,831,87,548,638,8,378,576,227,566,18,820,262,775,473,704,570,563,158,80,227,928,823,933,302,890,625,213,732,946,638,513,743,23,320,939,276,152,98,884,648,728,488,869,789,462,265,66,345,805,518,977,333,982,60,791,591,332,940,894,281,251,769,42,206,710,841,68,810,462,605,114,151,643,33,776,548,585,750,902,711,667,572,969,94,301,300,491,667,407,909,870,502,250,441,416,323,932,743,120,409,502,633,304,541,296,532,755,324,813,403,312,53,753,277,411,339,389,894,23,1,951,571,764,610,303,444,976,60,685,304,489,359,491,757,97,899,634,313,242,810,413,474,298,979,978,769,268,935,303,525,237,845,301,445,901,367,370,282,1,702,901,190,522,122,390,596,412,151,808,592,742,648,635,389,798,801,495,870,592,626,398,957,657,537,578,671,882,488,457,333,816,641,377,316,568,577,331,886,28,689,241,843,729,195,316,738,309,867,726,711,925,197,976,171,171,585,742,505,846,891,917,213,467,915,744,762,578,235,280,525,322,439,442,345,308,16,603,998,392,243,299,604,477,524,692,117,709,68,555,932,362,592,275,991,625,763,620,30,643,517,286,932,660,411,965,661,147,963,647,61,831,576,983,944,172,583,303,335,628,338,416,702,721,638,847,138,683,278,474,693,515,374,899,935,734,88,592,222,911,589,646,163,326,829,96,710,708,70,329,59,190,714,839,341,707,134,156,197,75,0,758,835,185,321,262,422,550,902,685,635,893,263,371,951,59,637,858,198,218,920,22,757,180,501,789,681,925,661,78,203,523,929,824,486,232,9,358,842,481,920,659,644,83,452,871,297,265,481,186,848,850,249,318,5,30,314,538,358,718,342,181,424,959,456,684,850,343,214,37,896,358,715,888,224,112,536,194,618,868,163,89,213,63,38,766,480,753,420,302,145,354,766,215,715,382,429,287,857,325,664,390,706,720,932,962,636,883,669,726,625,971,274,870,577,994,126,663,937,831,187,49,283,368,735,752,244,738,261,848,918,199,916,448,361,528,373,653,104,103,821,303,838,542,407,821,9,631,334,506,347,564,599,298,242,588,660,782,321,429,232,793,971,481,366,953,88,146,448,917,175,447,909,739,53,194,498,822,817,101,116,472,917,657,809,672,212,266,336,542,882,616,92,443,606,531,985,489,319,165,391,965,223,60,65,964,38,682,30,107,304,740,9,527,885,934,461,362,622,164,740,204,13,147,630,778,404,726,792,198,374,129,429,21,430,621,729,29,212,752,435,505,791,696,506,984,221,769,110,289,281,985,710,148,535,814,643,712,857,141,113,274,974,646,901,13,903,376,474,547,331,982,153,615,505,900,911,760,213,399,501,104,270,307,98,115,926,763,665,525,203,986,365,465,241,892,854,767,897,726,518,256,740,593,474,564,746,497,507,973,152,165"","
"/*
 * Copyright 2010-2015 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.codegen

import org.jetbrains.kotlin.codegen.coroutines.INITIAL_DESCRIPTOR_FOR_SUSPEND_FUNCTION
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.descriptors.annotations.Annotations
import org.jetbrains.kotlin.descriptors.impl.FunctionDescriptorImpl
import org.jetbrains.kotlin.name.Name
import java.util.*

class AccessorForFunctionDescriptor(
    override val calleeDescriptor: FunctionDescriptor,
    containingDeclaration: DeclarationDescriptor,
    override val superCallTarget: ClassDescriptor?,
    private val nameSuffix: String,
    override val accessorKind: AccessorKind
) : AbstractAccessorForFunctionDescriptor(containingDeclaration, Name.identifier(""access$$nameSuffix"")),
    AccessorForCallableDescriptor<FunctionDescriptor> {

    init {
        initialize(
            calleeDescriptor.extensionReceiverParameter?.copy(this),
            if (calleeDescriptor is ConstructorDescriptor || calleeDescriptor.isJvmStaticInObjectOrClassOrInterface())
                null
            else
                calleeDescriptor.dispatchReceiverParameter,
            calleeDescriptor.contextReceiverParameters.map { p -> p.copy(this) },
            copyTypeParameters(calleeDescriptor),
            copyValueParameters(calleeDescriptor),
            calleeDescriptor.returnType,","Modality.FINAL,"
"// LANGUAGE: -ProhibitSimplificationOfNonTrivialConstBooleanExpressions
// DIAGNOSTICS: -UNUSED_VARIABLE

fun test_1() {
    while (true) {

    }
    val x = 1
}

fun test_2() {
    while (true || false) {

    }
    val x = 1
}

fun test_3() {
    while (1 == 1) {

    }
    val x = 1
}

fun test_4() {
    while (false) {
        val x = 1
    }
    val y = 2
}

fun test_5() {
    while (false && true) {
        val x = 1
    }
    val y = 2
}

fun test_6() {
    do {

    } while (true)
    val x = 1
}

fun test_7() {
    do {

    } while (true || false)
    val x = 1
}

fun test_8() {",do {
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer.core

import org.jetbrains.kotlin.commonizer.CommonizerSettings
import org.jetbrains.kotlin.commonizer.OptimisticNumberCommonizationEnabledKey
import org.jetbrains.kotlin.commonizer.PlatformIntegerCommonizationEnabledKey
import org.jetbrains.kotlin.commonizer.cir.*
import org.jetbrains.kotlin.commonizer.mergedtree.*
import org.jetbrains.kotlin.commonizer.utils.isUnderKotlinNativeSyntheticPackages
import org.jetbrains.kotlin.commonizer.utils.safeCastValues
import org.jetbrains.kotlin.commonizer.utils.singleDistinctValueOrNull
import org.jetbrains.kotlin.utils.addToStdlib.ifTrue
import org.jetbrains.kotlin.utils.addToStdlib.safeAs

internal class ClassOrTypeAliasTypeCommonizer(
    private val typeCommonizer: TypeCommonizer,
    private val classifiers: CirKnownClassifiers,
    private val isOptimisticNumberTypeCommonizationEnabled: Boolean,
    private val isPlatformIntegerCommonizationEnabled: Boolean,
) : NullableSingleInvocationCommonizer<CirClassOrTypeAliasType> {

    constructor(typeCommonizer: TypeCommonizer, classifiers: CirKnownClassifiers, settings: CommonizerSettings) : this(
        typeCommonizer, classifiers,
        settings.getSetting(OptimisticNumberCommonizationEnabledKey),
        settings.getSetting(PlatformIntegerCommonizationEnabledKey),
    )

    private val isMarkedNullableCommonizer = TypeNullabilityCommonizer(typeCommonizer.context)
    private val platformIntegerCommonizer = PlatformIntegerCommonizer(typeCommonizer, classifiers)
    private val typeDistanceMeasurement = TypeDistanceMeasurement(typeCommonizer.context)

    override fun invoke(values: List<CirClassOrTypeAliasType>): CirClassOrTypeAliasType? {
        if (values.isEmpty()) return null
        val expansions = values.map { it.expandedType() }
        val isMarkedNullable = isMarkedNullableCommonizer.commonize(expansions.map { it.isMarkedNullable }) ?: return null

        val substitutedTypes = substituteTypesIfNecessary(values)

        if (substitutedTypes == null) {
            val integerCommonizationResultIfApplicable = isPlatformIntegerCommonizationEnabled.ifTrue {
                platformIntegerCommonizer(expansions)?.makeNullableIfNecessary(isMarkedNullable)
            } ?: isOptimisticNumberTypeCommonizationEnabled.ifTrue {
                OptimisticNumbersTypeCommonizer.commonize(expansions)?.makeNullableIfNecessary(isMarkedNullable)
            }

            return integerCommonizationResultIfApplicable
        }

        val classifierId = substitutedTypes.singleDistinctValueOrNull { it.classifierId } ?: return null

        val arguments = TypeArgumentListCommonizer(typeCommonizer).commonize(substitutedTypes.map { it.arguments }) ?: return null

        val outerTypes = substitutedTypes.safeCastValues<CirClassOrTypeAliasType, CirClassType>()?.map { it.outerType }
        val outerType = when {
            outerTypes == null -> null
            outerTypes.all { it == null } -> null
            outerTypes.any { it == null } -> return null
            else -> invoke(outerTypes.map { checkNotNull(it) }) as? CirClassType ?: return null
        }

        /*",Classifiers under this package (forward declarations) can always be used in common
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.jvm.diagnostics

enum class JvmDeclarationOriginKind {
    OTHER,
    PACKAGE_PART,
    INTERFACE_DEFAULT_IMPL,","CLASS_MEMBER_DELEGATION_TO_DEFAULT_IMPL,"
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.checkers.declaration

import org.jetbrains.kotlin.KtFakeSourceElementKind
import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.extractArgumentsTypeRefAndSource
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.resolve.fullyExpandedType
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.fir.types.*
import org.jetbrains.kotlin.types.Variance

object FirProjectionRelationChecker : FirBasicDeclarationChecker(MppCheckerKind.Common) {
    override fun check(declaration: FirDeclaration, context: CheckerContext, reporter: DiagnosticReporter) {
        if (declaration is FirPropertyAccessor) {
            return
        }

        if (declaration is FirCallableDeclaration) {
            checkTypeRef(declaration.returnTypeRef, context, reporter)
        }

        when (declaration) {
            is FirClass -> {
                for (it in declaration.superTypeRefs) {
                    checkTypeRef(it, context, reporter)
                }
            }
            is FirTypeAlias ->
                checkTypeRef(declaration.expandedTypeRef, context, reporter)
            else -> {}
        }
    }

    private fun checkTypeRef(
        typeRef: FirTypeRef,
        context: CheckerContext,
        reporter: DiagnosticReporter
    ) {
        if (typeRef.source?.kind?.shouldSkipErrorTypeReporting != false) return
        val type = typeRef.coneTypeSafe<ConeClassLikeType>()
        val fullyExpandedType = type?.fullyExpandedType(context.session) ?: return
        val declaration = fullyExpandedType.toSymbol(context.session) as? FirRegularClassSymbol ?: return
        val typeParameters = declaration.typeParameterSymbols
        val typeArguments = type.typeArguments

        val size = minOf(typeParameters.size, typeArguments.size)

        val typeRefAndSourcesForArguments = extractArgumentsTypeRefAndSource(typeRef) ?: return
        for (it in 0 until size) {
            val proto = typeParameters[it]
            val actual = typeArguments[it]
            val fullyExpandedProjection = fullyExpandedType.typeArguments[it]

            val protoVariance = proto.variance

            val projectionRelation = if (fullyExpandedProjection is ConeKotlinTypeConflictingProjection ||",actual is ConeKotlinTypeProjectionIn && protoVariance == Variance.OUT_VARIANCE ||
")
        runProcess(konanc.absolutePath, source.absolutePath, *compilation.getCompilerArgs()) {
            timeout = konancTimeout
        }
        val runResult: RunProcessResult = with(testRunSettings) {
            executor.runProcess(kexe.absolutePath) {
                timeout = Duration.parse(""1m"")
            }
        }
        assertEquals(""Hello, world!"", runResult.stdout)
    }

    @Test
    fun testDriverVersion() {
        Assumptions.assumeFalse(HostManager.hostIsMingw &&
                                        testRunSettings.get<CacheMode>() == CacheMode.WithoutCache &&
                                        testRunSettings.get<OptimizationMode>() == OptimizationMode.DEBUG
        ) // KT-65963
        // No need to test with different GC schedulers
        Assumptions.assumeFalse(testRunSettings.get<GCScheduler>() == GCScheduler.AGGRESSIVE)

        val module = TestModule.Exclusive(""moduleName"", emptySet(), emptySet(), emptySet())
        val kexe = buildDir.resolve(""kexe.kexe"").also { it.delete() }
        val compilation = ExecutableCompilation(
            settings = testRunSettings,
            freeCompilerArgs = TestCompilerArgs(listOf(""-version"")),
            sourceModules = listOf(module),
            extras = TestCase.NoTestRunnerExtras(""main""),
            dependencies = emptyList(),
            expectedArtifact = TestCompilationArtifact.Executable(kexe),
            tryPassSystemCacheDirectory = true
        )
        runProcess(konanc.absolutePath, source.absolutePath, *compilation.getCompilerArgs()) {
            timeout = konancTimeout
        }
        assertFalse(kexe.exists())
    }

    @Test
    fun testOverrideKonanProperties() {
        // Only test with -opt enabled
        Assumptions.assumeTrue(testRunSettings.get<OptimizationMode>() == OptimizationMode.OPT)
        // No need to test with different GC schedulers
        Assumptions.assumeFalse(testRunSettings.get<GCScheduler>() == GCScheduler.AGGRESSIVE)

        val module = TestModule.Exclusive(""moduleName"", emptySet(), emptySet(), emptySet())
        val kexe = buildDir.resolve(""kexe.kexe"").also { it.delete() }
        val compilation = ExecutableCompilation(
            settings = testRunSettings,
            freeCompilerArgs = TestCompilerArgs(
                listOf(
                    ""-Xverbose-phases=MandatoryBitcodeLLVMPostprocessingPhase"",
                    if (HostManager.hostIsMingw)
                        ""-Xoverride-konan-properties=\""llvmInlineThreshold=76\""""
                    else ""-Xoverride-konan-properties=llvmInlineThreshold=76""
                )),
            sourceModules = listOf(module),
            extras = TestCase.NoTestRunnerExtras(""main""),
            dependencies = emptyList(),
            expectedArtifact = TestCompilationArtifact.Executable(kexe),
            tryPassSystemCacheDirectory = true
        )
        val compilationResult = runProcess(konanc.absolutePath, source.absolutePath, *compilation.getCompilerArgs()) {
            timeout = konancTimeout
        }","val expected = ""inline_threshold: 76"""
"// files not matching the pattern should not be affected
        assertEquals(
            200,
            statsFolder.listFiles()?.count { !it.name.matches(BuildSessionLogger.STATISTICS_FILE_NAME_PATTERN) },
            ""Some files which should not be affected, were removed""
        )

        assertEquals(
            maxFiles,
            statsFolder.listFiles()?.count { it.name.matches(BuildSessionLogger.STATISTICS_FILE_NAME_PATTERN) },
            ""Some files which should not be affected, were removed""
        )
    }

    @Test
    fun testReadWriteMetrics() {
        val buildId = ""test""
        val logger = BuildSessionLogger(rootFolder)
        logger.report(StringMetrics.KOTLIN_COMPILER_VERSION, ""1.2.3.4-snapshot"")

        logger.startBuildSession(buildId)
        val reportFile = rootFolder.resolve(BuildSessionLogger.Companion.STATISTICS_FOLDER_NAME)
            .resolve(buildId + BuildSessionLogger.Companion.PROFILE_FILE_NAME_SUFFIX)

        reportFile.createNewFile()
        reportFile.appendText(""${StringMetrics.USE_FIR.name}=true\n"")

        logger.finishBuildSession()
        assertEquals(1, statFilesCount())

        val statFile = rootFolder.listFiles()?.single()?.listFiles()?.single() ?: fail(""Could not find stat file"")
        statFile.appendBytes(""break format of the file"".toByteArray()) //this line should be filtered by MetricsContainer.readFromFile

        logger.startBuildSession(buildId)
        logger.finishBuildSession()

        val metrics = ArrayList<MetricsContainer>()
        MetricsContainer.readFromFile(statFile) {
            metrics.add(it)
        }

        assertEquals(2, metrics.size, ""Invalid number of MerticContainers was read"")
        assertEquals(
            ""true"",
            metrics[0].getMetric(StringMetrics.USE_FIR)?.getValue()
        )

        assertEquals(
            ""1.2.3"",
            metrics[0].getMetric(StringMetrics.KOTLIN_COMPILER_VERSION)?.getValue()
        )

        assertEquals(
            null,
            metrics[1].getMetric(StringMetrics.KOTLIN_COMPILER_VERSION)?.getValue()
        )
    }

    @Test
    fun testSaveAndReadAllMetrics() {
        val logger = BuildSessionLogger(rootFolder)
        logger.startBuildSession(""test"")
        for (metric in StringMetrics.values()) {
            logger.report(metric, ""value"")","logger.report(metric, metric.name)"
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.calls

import org.jetbrains.kotlin.builtins.getReturnTypeFromFunctionType
import org.jetbrains.kotlin.builtins.getValueParameterTypesFromFunctionType
import org.jetbrains.kotlin.builtins.isFunctionOrSuspendFunctionType
import org.jetbrains.kotlin.config.LanguageFeature
import org.jetbrains.kotlin.contracts.EffectSystem
import org.jetbrains.kotlin.descriptors.CallableDescriptor
import org.jetbrains.kotlin.descriptors.ModuleDescriptor
import org.jetbrains.kotlin.descriptors.ValueParameterDescriptor
import org.jetbrains.kotlin.diagnostics.Errors
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.resolve.*
import org.jetbrains.kotlin.resolve.BindingContext.CONSTRAINT_SYSTEM_COMPLETER
import org.jetbrains.kotlin.resolve.calls.checkers.CallChecker
import org.jetbrains.kotlin.resolve.calls.checkers.CallCheckerContext
import org.jetbrains.kotlin.resolve.calls.context.BasicCallResolutionContext
import org.jetbrains.kotlin.resolve.calls.context.CallCandidateResolutionContext
import org.jetbrains.kotlin.resolve.calls.context.CallPosition
import org.jetbrains.kotlin.resolve.calls.context.CheckArgumentTypesMode
import org.jetbrains.kotlin.resolve.calls.inference.ConstraintSystem
import org.jetbrains.kotlin.resolve.calls.inference.InferenceErrorData
import org.jetbrains.kotlin.resolve.calls.inference.constraintPosition.ConstraintPositionKind.*
import org.jetbrains.kotlin.resolve.calls.inference.filterConstraintsOut
import org.jetbrains.kotlin.resolve.calls.inference.toHandle
import org.jetbrains.kotlin.resolve.calls.model.*
import org.jetbrains.kotlin.resolve.calls.results.OverloadResolutionResultsImpl
import org.jetbrains.kotlin.resolve.calls.results.ResolutionStatus
import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowInfo",import org.jetbrains.kotlin.resolve.calls.smartcasts.DataFlowValueFactory
"// FILE: JavaBaseClass.java
public class JavaBaseClass {
    public String getMissingField() {
        return ""1"";
    }

    private Int privateField = 1;

    public String getPrivateField() {
        return ""1"";
    }

}

// FILE: EmptySubclass.java

public class EmptySubclass extends JavaBaseClass {
}

// FILE: KotlinSubclassOfJavaGetterOverrides.kt

class KotlinSubclassOfJavaGetterOverrides : JavaBaseClass() {
    fun consumeInt(x: Int) {}
    fun consumeString(x: String) {}

    init {
        consumeString(super.missingField)
        consumeInt(<!ARGUMENT_TYPE_MISMATCH!>super.missingField<!>)
    }

    override fun getMissingField(): String {
        return ""1""
    }

    init {
        consumeString(super.privateField)
        consumeInt(<!ARGUMENT_TYPE_MISMATCH!>super.privateField<!>)
    }

    override fun getPrivateField(): String {
        return ""1""
    }

}

class KotlinSubclassOfJavaSubclassGetterOverridesInBase : EmptySubclass() {
    fun consumeInt(x: Int) {}
    fun consumeString(x: String) {}

    init {
        consumeString(super.missingField)
        consumeInt(<!ARGUMENT_TYPE_MISMATCH!>super.missingField<!>)
    }

    override fun getMissingField(): String {","return ""1"""
"object CirDeserializers {
    private fun annotations(
        hasAnnotations: Boolean,
        typeResolver: CirTypeResolver,
        annotations: () -> List<KmAnnotation>,
    ): List<CirAnnotation> {
        return if (!hasAnnotations)
            emptyList()
        else
            annotations().compactMap { annotation(it, typeResolver) }
    }

    private fun annotation(source: KmAnnotation, typeResolver: CirTypeResolver): CirAnnotation {
        val classId = CirEntityId.create(source.className)
        val clazz: CirProvided.RegularClass = typeResolver.resolveClassifier(classId)

        val type = CirClassType.createInterned(
            classId = classId,
            outerType = null, // annotation class can't be inner class
            arguments = clazz.typeParameters.compactMap { typeParameter ->
                CirRegularTypeProjection(
                    projectionKind = typeParameter.variance,
                    type = CirTypeParameterType.createInterned(
                        index = typeParameter.index,
                        isMarkedNullable = false
                    )
                )
            },
            isMarkedNullable = false
        )

        val allValueArguments: Map<String, KmAnnotationArgument> = source.arguments
        if (allValueArguments.isEmpty())
            return CirAnnotation.createInterned(type = type, constantValueArguments = emptyMap(), annotationValueArguments = emptyMap())

        val constantValueArguments: MutableMap<CirName, CirConstantValue> = CommonizerMap(allValueArguments.size)
        val annotationValueArguments: MutableMap<CirName, CirAnnotation> = CommonizerMap(allValueArguments.size)

        allValueArguments.forEach { (name, constantValue) ->
            val cirName = CirName.create(name)
            if (constantValue is KmAnnotationArgument.AnnotationValue)
                annotationValueArguments[cirName] = annotation(source = constantValue.annotation, typeResolver)
            else
                constantValueArguments[cirName] = constantValue(
                    constantValue = constantValue,
                    constantName = cirName,
                    owner = source,
                )
        }

        return CirAnnotation.createInterned(
            type = type,
            constantValueArguments = constantValueArguments.compact(),
            annotationValueArguments = annotationValueArguments.compact()
        )
    }

    private fun typeParameter(source: KmTypeParameter, typeResolver: CirTypeResolver): CirTypeParameter = CirTypeParameter(
        annotations = annotations(true, typeResolver, source::annotations),
        name = CirName.create(source.name),
        isReified = source.isReified,
        variance = variance(source.variance),
        upperBounds = source.filteredUpperBounds.compactMap { type(it, typeResolver) }
    )",private fun extensionReceiver(
// EXPECTED_REACHABLE_NODES: 1282,package foo
"}

private fun createTempDir(prefix: String, parent: File): File =
        File(Files.createTempDirectory(Paths.get(parent.absolutePath), prefix).toString())

private fun File.deleteAtomicallyIfPossible(tmpDirectory: File) {
    // Try to atomically delete the old directory.
    val tmpToDelete = Files.createTempFile(Paths.get(tmpDirectory.absolutePath), null, null).toFile()
    if (renameAtomic(this.absolutePath, tmpToDelete.absolutePath, replaceExisting = true)) {
        tmpToDelete.deleteRecursively()
    } else {
        // Can't move to a tmp directory -> delete in a regular way.
        this.deleteRecursively()
    }
}

private fun topoSort(defFiles: List<DefFile>): List<DefFile> {
    // Do DFS toposort.
    val markGray = mutableSetOf<DefFile>()
    val markBlack = mutableSetOf<DefFile>()
    val result = mutableListOf<DefFile>()

    fun visit(def: DefFile) {
        if (markBlack.contains(def)) return
        if (markGray.contains(def)) throw Error(""$def is part of cycle"")
        markGray += def
        def.depends.forEach {
            visit(it)
        }
        markGray -= def
        markBlack += def
        result += def
    }

    var index = 0
    while (markBlack.size < defFiles.size) {
        visit(defFiles[index++])
    }
    return result
}

private fun generateLibrary(
        target: KonanTarget,
        cinteropOptions: CInteropOptions,
        def: DefFile,
        directories: DirectoriesInfo,
        tmpDirectory: File,
        rebuild: Boolean,
        logger: Logger
) = with(directories) {
    val defFile = inputDirectory.child(""${def.name}.def"")
    val outKlib = outputDirectory.child(def.libraryName)

    if (outKlib.exists && !rebuild) {
        logger.verbose(""Skip generating ${def.name} as it's already generated"")
        return
    }

    val tmpKlib = tmpDirectory.child(def.libraryName)

    try {
        val cinteropArgs = arrayOf(
                ""-o"", tmpKlib.absolutePath,
                ""-target"", target.visibleName,
                ""-def"", defFile.absolutePath,","""-compiler-option"", ""-fmodules-cache-path=${tmpDirectory.child(""clangModulesCache"").absolutePath}"","
"// FILE: ClassWithExternalAnnotatedMembers.java
import org.jetbrains.annotations.NotNull;

public class ClassWithExternalAnnotatedMembers {
    public void method(String s) {
    }",public void method(@NotNull Integer i) {
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package kotlin.jdk7.test

import java.io.FileOutputStream
import java.nio.file.*
import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import java.util.zip.ZipOutputStream
import kotlin.io.path.*
import kotlin.jdk7.test.PathTreeWalkTest.Companion.createTestFiles
import kotlin.jdk7.test.PathTreeWalkTest.Companion.referenceFilenames
import kotlin.jdk7.test.PathTreeWalkTest.Companion.referenceFilesOnly
import kotlin.jdk7.test.PathTreeWalkTest.Companion.testVisitedFiles
import kotlin.test.*

class FileVisitorBuilderTest : AbstractPathTest() {
    @Test
    fun visitOnce() {
        val basedir = createTestFiles().cleanupRecursively()

        val preVisit = hashSetOf<Path>()
        val postVisit = hashSetOf<Path>()",val files = hashSetOf<Path>()
"values = javaTargetNames.map {
                    AnnotationValue.EnumValue(
                        callableId = CallableId(
                            classId = JvmStandardClassIds.Annotations.Java.ElementType,
                            callableName = Name.identifier(it),
                        ),
                        sourcePsi = null,
                    )
                },
                sourcePsi = null,
            )
        )
    )
}

private fun AnnotationValue.mapToJavaTarget(): String? {
    if (this !is AnnotationValue.EnumValue) return null

    val callableId = callableId ?: return null
    if (callableId.classId != StandardClassIds.AnnotationTarget) return null
    return when (callableId.callableName.asString()) {
        AnnotationTarget.CLASS.name -> ElementType.TYPE
        AnnotationTarget.ANNOTATION_CLASS.name -> ElementType.ANNOTATION_TYPE
        AnnotationTarget.FIELD.name -> ElementType.FIELD
        AnnotationTarget.LOCAL_VARIABLE.name -> ElementType.LOCAL_VARIABLE
        AnnotationTarget.VALUE_PARAMETER.name -> ElementType.PARAMETER
        AnnotationTarget.CONSTRUCTOR.name -> ElementType.CONSTRUCTOR
        AnnotationTarget.FUNCTION.name, AnnotationTarget.PROPERTY_GETTER.name, AnnotationTarget.PROPERTY_SETTER.name -> ElementType.METHOD
        AnnotationTarget.TYPE_PARAMETER.name -> ElementType.TYPE_PARAMETER
        AnnotationTarget.TYPE.name -> ElementType.TYPE_USE
        else -> null
    }?.name
}

private fun GranularAnnotationsBox.tryConvertToJavaAnnotation(
    qualifiedName: String,
    javaQualifier: String,
    kotlinQualifier: String,
    owner: PsiElement,
    argumentsComputer: SymbolLightJavaAnnotation.() -> List<AnnotationArgument> = { emptyList() },
): PsiAnnotation? {
    if (qualifiedName != javaQualifier) return null
    if (hasAnnotation(owner, javaQualifier)) return null

    val originalLightAnnotation = findAnnotation(
        owner,
        kotlinQualifier,
        withAdditionalAnnotations = false,
    ) as? SymbolLightLazyAnnotation ?: return null

    return SymbolLightJavaAnnotation(
        originalLightAnnotation = originalLightAnnotation,
        javaQualifier = javaQualifier,
        argumentsComputer = argumentsComputer,
        owner = owner,
    )
}

private fun SymbolLightLazyAnnotation.tryConvertToJavaAnnotation(
    javaQualifier: String,
    kotlinQualifier: String,
    owner: PsiElement,
    argumentsComputer: SymbolLightJavaAnnotation.() -> List<AnnotationArgument> = { emptyList() },
): PsiAnnotation? {
    if (qualifiedName != kotlinQualifier) return null",return SymbolLightJavaAnnotation(
"// !DIAGNOSTICS: -UNUSED_PARAMETER
@DslMarker
@Target(AnnotationTarget.TYPE)
annotation class Ann1

@DslMarker
@Target(AnnotationTarget.TYPE)
annotation class Ann2

@DslMarker
@Target(AnnotationTarget.TYPE)
annotation class Ann3

class A {
    operator fun B.invoke() {}

    val B.y: D get() = D()
}

class B

class C {
    operator fun D.invoke() {}

    val D.x: B get() = B()
}

class D

fun foo(x: (@Ann1 A).() -> Unit) {}
fun bar(x: (@Ann2 B).() -> Unit) {}
fun baz(x: (@Ann3 C).() -> Unit) {}
fun foo1(x: (@Ann1 D).() -> Unit) {}
fun foo2(x: (@Ann2 D).() -> Unit) {}
fun foo3(x: (@Ann3 D).() -> Unit) {}",fun test() {
"} else null

    if (a != null && a.B19 != null && a.B19.C19 != null && a.B19.C19.D19 != null && a.B19.C19.D19.x != null) {
        a.B19.C19.D19.x
        a.B19.C19.D19.x.equals(null)
        a.B19.C19.D19.x.propT
        a.B19.C19.D19.x.propAny
        a.B19.C19.D19.x.propNullableT
        a.B19.C19.D19.x.propNullableAny
        a.B19.C19.D19.x.funT()
        a.B19.C19.D19.x.funAny()
        a.B19.C19.D19.x.funNullableT()
        a.B19.C19.D19.x.funNullableAny()
    }
}

// TESTCASE NUMBER: 20
fun case_20(b: Boolean) {
    val a = object {
        val B19 = object {
            val C19 = object {
                val D19 =  if (b) {
                    object {}
                } else null
            }
        }
    }

    if (a.B19.C19.D19 !== null) {
        a.B19.C19.D19
        a.B19.C19.D19.equals(null)
        a.B19.C19.D19.propT
        a.B19.C19.D19.propAny
        a.B19.C19.D19.propNullableT
        a.B19.C19.D19.propNullableAny
        a.B19.C19.D19.funT()
        a.B19.C19.D19.funAny()
        a.B19.C19.D19.funNullableT()
        a.B19.C19.D19.funNullableAny()
    }
}

// TESTCASE NUMBER: 21
fun case_21() {
    if (EnumClassWithNullableProperty.B.prop_1 !== null) {
        EnumClassWithNullableProperty.B.prop_1
        EnumClassWithNullableProperty.B.prop_1.equals(null)
        EnumClassWithNullableProperty.B.prop_1.propT
        EnumClassWithNullableProperty.B.prop_1.propAny
        EnumClassWithNullableProperty.B.prop_1.propNullableT
        EnumClassWithNullableProperty.B.prop_1.propNullableAny
        EnumClassWithNullableProperty.B.prop_1.funT()
        EnumClassWithNullableProperty.B.prop_1.funAny()
        EnumClassWithNullableProperty.B.prop_1.funNullableT()
        EnumClassWithNullableProperty.B.prop_1.funNullableAny()
    }
}

// TESTCASE NUMBER: 22
fun case_22(a: (() -> Unit)?) {
    if (a != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit"")!>a()<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit"")!>a()<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit"")!>a()<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit"")!>a()<!>.propAny","<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit"")!>a()<!>.propNullableT"
"// !DIAGNOSTICS: -UNUSED_PARAMETER

interface Bound1",interface Bound2
"defaultProject(gradleVersion) {
            build(""assemble"")

            subProject(""lib"").kotlinSourcesDir().resolve(""bar/A.kt"").modify {
                it.replace(""fun a() {}"", ""fun a() {}\nfun newA() {}"")
            }

            build(""assemble"") {
                val expectedSources = getExpectedKotlinSourcesForDefaultProject(
                    libSources = listOf(""bar/A.kt"", ""bar/B.kt""),
                    appSources = listOf(""foo/AA.kt"", ""foo/AAA.kt"", ""foo/BB.kt"")
                )
                assertCompiledKotlinSources(expectedSources, output)
            }
        }
    }

    @DisplayName(""Lib: Non ABI change in method body"")
    @GradleTest
    open fun testNonAbiChangeInLib_changeMethodBody(gradleVersion: GradleVersion) {
        defaultProject(gradleVersion) {
            build(""assemble"")

            changeMethodBodyInLib()

            build(""assemble"") {
                assertTasksExecuted("":lib:$compileKotlinTaskName"")
                assertTasksUpToDate("":app:$compileKotlinTaskName"")
                assertCompiledKotlinSources(
                    getExpectedKotlinSourcesForDefaultProject(libSources = listOf(""bar/A.kt"")),
                    output
                )
            }
        }
    }

    @DisplayName(""Add dependency in lib subproject"")
    @GradleTest
    open fun testAddDependencyInLib(gradleVersion: GradleVersion) {
        defaultProject(gradleVersion) {
            build(""assemble"")

            testAddDependencyInLib_modifyProject()

            build(""assemble"") {
                assertTasksExecuted("":lib:$compileKotlinTaskName"")
                assertTasksUpToDate("":app:$compileKotlinTaskName"")
                // Lib compilation is incremental (no files are recompiled)
                assertCompiledKotlinSources(emptyList(), output)
            }
        }
    }

    protected fun TestProject.testAddDependencyInLib_modifyProject() {
        subProject(""lib"").buildGradle.modify {
            """"""
            $it

            dependencies {
                $additionalLibDependencies
            }
            """""".trimIndent()
        }
    }","@DisplayName(""after lib project clean"")"
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.resolve.transformers.body.resolve

import org.jetbrains.kotlin.fir.FirTargetElement
import org.jetbrains.kotlin.fir.expressions.*
import org.jetbrains.kotlin.fir.expressions.impl.FirElseIfTrueCondition
import org.jetbrains.kotlin.fir.expressions.impl.FirEmptyExpressionBlock
import org.jetbrains.kotlin.fir.references.FirResolvedNamedReference
import org.jetbrains.kotlin.fir.resolve.ResolutionMode
import org.jetbrains.kotlin.fir.resolve.calls.isUnitOrFlexibleUnit
import org.jetbrains.kotlin.fir.resolve.fullyExpandedType
import org.jetbrains.kotlin.fir.resolve.transformWhenSubjectExpressionUsingSmartcastInfo
import org.jetbrains.kotlin.fir.resolve.transformers.FirSyntheticCallGenerator
import org.jetbrains.kotlin.fir.resolve.transformers.FirWhenExhaustivenessTransformer
import org.jetbrains.kotlin.fir.resolve.withExpectedType
import org.jetbrains.kotlin.fir.types.*
import org.jetbrains.kotlin.fir.visitors.transformSingle

class FirControlFlowStatementsResolveTransformer(transformer: FirAbstractBodyResolveTransformerDispatcher) :
    FirPartialBodyResolveTransformer(transformer) {

    private val syntheticCallGenerator: FirSyntheticCallGenerator get() = components.syntheticCallGenerator
    private val whenExhaustivenessTransformer = FirWhenExhaustivenessTransformer(components)


    // ------------------------------- Loops -------------------------------

    override fun transformWhileLoop(whileLoop: FirWhileLoop, data: ResolutionMode): FirStatement {
        val context = ResolutionMode.ContextIndependent
        return whileLoop.also(dataFlowAnalyzer::enterWhileLoop)
            .transformCondition(transformer, withExpectedType(session.builtinTypes.booleanType))
            .also(dataFlowAnalyzer::exitWhileLoopCondition)
            .transformBlock(transformer, context).also(dataFlowAnalyzer::exitWhileLoop)
            .transformOtherChildren(transformer, context)
    }

    override fun transformDoWhileLoop(doWhileLoop: FirDoWhileLoop, data: ResolutionMode): FirStatement {
        // Do-while has a specific scope structure (its block and condition effectively share the scope)
        return context.forBlock(session) {
            val context = ResolutionMode.ContextIndependent",doWhileLoop.also(dataFlowAnalyzer::enterDoWhileLoop)
"p(this, Variance.INVARIANT) { label }
    }

    private fun filterAnnotations(annotations: List<IrConstructorCall>, container: IrAnnotationContainer): List<IrConstructorCall> =
        annotations.filter { options.customDumpStrategy.shouldPrintAnnotation(it, container) }

    private fun IrAnnotationContainer.printAnnotationsWithNoIndent() {
        filterAnnotations(annotations, this).forEach {
            it.printAnAnnotationWithNoIndent()
            p.printWithNoIndent("" "")
        }
    }

    private fun IrAnnotationContainer.printlnAnnotations(prefix: String = """") {
        filterAnnotations(annotations, this).forEach {
            p.printIndent()
            it.printAnAnnotationWithNoIndent(prefix)
            p.printlnWithNoIndent()
        }
    }

    private fun IrConstructorCall.printAnAnnotationWithNoIndent(prefix: String = """") {
        p.printWithNoIndent(""@"" + (if (prefix.isEmpty()) """" else ""$prefix:""))
        visitConstructorCall(this, null)
    }

    private fun IrTypeParametersContainer.printWhereClauseIfNeededWithNoIndent() {
        if (typeParameters.none { it.superTypes.size > 1 }) return

        p.printWithNoIndent("" where "")

        var first = true
        typeParameters.forEach {
            if (it.superTypes.size > 1) {
                // TODO no test with more than one generic parameter with more supertypes
                first = it.printWhereClauseTypesWithNoIndent(first)
            }
        }
    }

    private fun IrTypeParameter.printWhereClauseTypesWithNoIndent(first: Boolean): Boolean {
        var myFirst = first
        superTypes.ordered().forEach { type ->
            if (!myFirst) {
                p.printWithNoIndent("", "")
            } else {
                myFirst = false
            }

            p.printWithNoIndent(name.asString())
            p.printWithNoIndent("" : "")
            type.printTypeWithNoIndent()
        }

        return myFirst
    }

    private fun IrType.printTypeWithNoIndent() {
        // TODO don't print `Any?` as upper bound?
        printAnnotationsWithNoIndent()
        when (this) {
            is IrSimpleType -> {
                // TODO abbreviation

                val dnn = classifier is IrTypeParameterSymbol && nullability == SimpleTypeNullability.DEFINITELY_NOT_NULL",if (dnn) {
"package org.jetbrains.kotlin.gradle.dsl

import org.gradle.api.Action

/**
 * A plugin DSL extension for configuring kapt annotation processing.
 *
 * Use the extension in your build script in the `kapt` block:
 * ```kotlin
 * kapt {
 *    // Your extension configuration
 * }
 * ```
 *
 * See also [Kapt compiler plugin documentation](https://kotlinlang.org/docs/kapt.html).
 */
interface KaptExtensionConfig {

    /**
     * Also loads annotation processors from compile classpath.
     *
     * Default: `null`
     */
    var includeCompileClasspath: Boolean?

    /**
     * Skips analyzing code bodies, if possible.
     *
     * Default: `true`
     */
    var useLightAnalysis: Boolean

    /**
     * Replaces any generated error types with error types from the generated sources.
     *
     * Default: `false`
     */
    var correctErrorTypes: Boolean

    /**
     * Adds initializers to fields whose corresponding primary constructor parameters have a default value specified.
     *
     * Default: `false`
     */
    var dumpDefaultParameterValues: Boolean

    /**
     * Maps diagnostics reported on kapt stubs to their original locations in Kotlin sources.
     *
     * Default: `false`
     */
    var mapDiagnosticLocations: Boolean

    /**
     * Reports any incompatibility errors found during stub generation.
     *
     * Default: `false`
     */
    var strictMode: Boolean

    /**
     * Strips `@Metadata` annotations from stubs.
     *
     * Default: `false`
     */",var stripMetadata: Boolean
"// FIR_IDENTICAL
// FILE: ClassWithExternalAnnotatedMembers.java
import org.jetbrains.annotations.NotNull;

public class ClassWithExternalAnnotatedMembers {
    public String externalNotNullField;

    @NotNull
    public String explicitNotNullField;

    public static String staticExternalNotNullField;

    @NotNull
    public static String staticExplicitNotNullField;
}

// FILE: usage.kt
fun test() {
    val x = ClassWithExternalAnnotatedMembers()
    x.externalNotNullField<!UNNECESSARY_SAFE_CALL!>?.<!>foo()
    x.explicitNotNullField<!UNNECESSARY_SAFE_CALL!>?.<!>foo()

    ClassWithExternalAnnotatedMembers.staticExternalNotNullField<!UNNECESSARY_SAFE_CALL!>?.<!>foo()
    ClassWithExternalAnnotatedMembers.staticExplicitNotNullField<!UNNECESSARY_SAFE_CALL!>?.<!>foo()
}

fun String.foo() {

}

// FILE: annotations.xml
<root>
    <item name='ClassWithExternalAnnotatedMembers externalNotNullField'>
        <annotation name='org.jetbrains.annotations.NotNull'/>",</item>
"/**
     * Calculates the remainder of truncating division of this value (dividend) by the other value (divisor).
     *
     * The result is either zero or has the same sign as the _dividend_ and has the absolute value less than the absolute value of the divisor.
     */
    @SinceKotlin(""1.1"")
    @kotlin.internal.IntrinsicConstEvaluation
    public operator fun rem(other: Int): Float

    /**
     * Calculates the remainder of truncating division of this value (dividend) by the other value (divisor).
     *
     * The result is either zero or has the same sign as the _dividend_ and has the absolute value less than the absolute value of the divisor.
     */
    @SinceKotlin(""1.1"")
    @kotlin.internal.IntrinsicConstEvaluation
    public operator fun rem(other: Long): Float

    /**
     * Calculates the remainder of truncating division of this value (dividend) by the other value (divisor).
     *
     * The result is either zero or has the same sign as the _dividend_ and has the absolute value less than the absolute value of the divisor.
     */
    @SinceKotlin(""1.1"")
    @kotlin.internal.IntrinsicConstEvaluation
    public operator fun rem(other: Float): Float

    /**
     * Calculates the remainder of truncating division of this value (dividend) by the other value (divisor).
     *
     * The result is either zero or has the same sign as the _dividend_ and has the absolute value less than the absolute value of the divisor.
     */
    @SinceKotlin(""1.1"")
    @kotlin.internal.IntrinsicConstEvaluation
    public operator fun rem(other: Double): Double

    /**
     * Returns this value incremented by one.
     *
     * @sample samples.misc.Builtins.inc
     */
    public operator fun inc(): Float

    /**
     * Returns this value decremented by one.
     *
     * @sample samples.misc.Builtins.dec
     */
    public operator fun dec(): Float

    /** Returns this value. */
    @kotlin.internal.IntrinsicConstEvaluation
    public operator fun unaryPlus(): Float

    /** Returns the negative of this value. */
    @kotlin.internal.IntrinsicConstEvaluation
    public operator fun unaryMinus(): Float

    /**
     * Converts this [Float] value to [Byte].
     *
     * The resulting `Byte` value is equal to `this.toInt().toByte()`.
     */
    @Deprecated(""Unclear conversion. To achieve the same result convert to Int explicitly and then to Byte."", ReplaceWith(""toInt().toByte()""))","@DeprecatedSinceKotlin(warningSince = ""1.3"", errorSince = ""1.5"")"
"// WITH_STDLIB
// JVM_ABI_K1_K2_DIFF: KT-63864

import kotlin.test.*",val log = StringBuilder()
"// TARGET_BACKEND: JVM
// WITH_STDLIB
// MODULE: lib
// FILE: Foo.java

class Foo {
    public static final int i = 2;
    public static final short s = 2;
    public static final float f = 2f;
    public static final double d = 2.0;
    public static final long l = 2L;
    public static final byte b = 2;
    public static final boolean bool = true;
    public static final char c = 'c';
    public static final String str = ""str"";
    public static final int charAsInt = '3';
    public static final char intAsChar = 3;
}

// MODULE: main(lib)
// FILE: 1.kt

@Ann(Foo.i, Foo.s, Foo.f, Foo.d, Foo.l, Foo.b, Foo.bool, Foo.c, Foo.str, Foo.charAsInt, Foo.intAsChar) class MyClass

fun box(): String {
    val ann = MyClass::class.java.getAnnotation(Ann::class.java)
    if (ann == null) return ""fail: cannot find Ann on MyClass""
    if (ann.i != 2) return ""fail: annotation parameter i should be 2, but was ${ann.i}""
    if (ann.s != 2.toShort()) return ""fail: annotation parameter i should be 2, but was ${ann.i}""
    if (ann.f != 2.toFloat()) return ""fail: annotation parameter i should be 2, but was ${ann.i}""
    if (ann.d != 2.toDouble()) return ""fail: annotation parameter i should be 2, but was ${ann.i}""
    if (ann.l != 2.toLong()) return ""fail: annotation parameter i should be 2, but was ${ann.i}""
    if (ann.b != 2.toByte()) return ""fail: annotation parameter i should be 2, but was ${ann.i}""
    if (!ann.bool) return ""fail: annotation parameter i should be true, but was ${ann.i}""
    if (ann.c != 'c') return ""fail: annotation parameter i should be c, but was ${ann.i}""
    if (ann.str != ""str"") return ""fail: annotation parameter i should be str, but was ${ann.i}""
    if (ann.i2 != '3'.toInt()) return ""fail: annotation parameter i2 should be ${'3'.toInt()}, but was ${ann.i}""
    if (ann.c2 != 3.toChar()) return ""fail: annotation parameter c2 should be 3, but was ${ann.i}""
    return ""OK""
}",@Retention(AnnotationRetention.RUNTIME)
"if (settings.prependSuiteName) ""${parent.fullNameWithoutRoot}.$it""
            else it
        }

        val parsedName = ParsedTestName(finalTestName, parent.localId)
        val fullTestName = if (testNameSuffix == null) parsedName.methodName
        else ""${parsedName.methodName}[$testNameSuffix]""

        open(
            ts, TestNode(
                parent, parsedName.className, parsedName.classDisplayName, parsedName.methodName,
                displayName = fullTestName,
                localId = testName,
                ignored = isIgnored
            )
        )
    }

    private fun endTest(ts: Long, testName: String) {
        close(ts, testName)
    }

    private fun TestNode.failure(
        message: TestFailed,
        isAssertionFailure: Boolean = true,
    ) {
        hasFailures = true

        val stacktrace = buildString {
            if (message.stacktrace != null) {
                append(message.stacktrace)
            }

            if (settings.treatFailedTestOutputAsStacktrace) {
                append(stackTraceOutput)
                stackTraceOutput.setLength(0)
            }
        }.let { processStackTrace(it) }

        val parsedStackTrace = settings.stackTraceParser(stacktrace)

        val failMessage = parsedStackTrace?.message ?: message.failureMessage
        val exceptionClassName = failMessage?.let { extractExceptionClassName(it) } ?: ""Unknown""
        val rawFailure = KotlinTestFailure(
            exceptionClassName,
            failMessage,
            stacktrace,
            patchStackTrace(this, parsedStackTrace?.stackTrace),
            message.expected,
            message.actual,
        )
        testReporter.reportFailure(results, descriptor.id, rawFailure, isAssertionFailure)
    }

    private fun extractExceptionClassName(message: String): String =
        message.substringBefore(':').trim()

    /**
     * Required for org.gradle.api.internal.tasks.testing.logging.ShortExceptionFormatter.printException
     * In JS Stacktraces we have short class name, while filter using FQN
     * So, let replace short class name with FQN for current test
     */
    private fun patchStackTrace(node: TestNode, stackTrace: List<StackTraceElement>?): List<StackTraceElement>? =
        stackTrace?.map {
            if (it.className == node.classDisplayName) StackTraceElement(","node.className,"
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package kotlin.text.regex

/**
 * Greedy quantifier over constructions that consume a fixed number of characters.
 */
open internal class FixedLengthQuantifierSet(
    val quantifier: Quantifier,","innerSet: AbstractSet,"
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.wasm.ir.convertors

import org.jetbrains.kotlin.wasm.ir.*
import org.jetbrains.kotlin.wasm.ir.debug.DebugData
import org.jetbrains.kotlin.wasm.ir.debug.DebugInformation
import org.jetbrains.kotlin.wasm.ir.debug.DebugInformationConsumer
import org.jetbrains.kotlin.wasm.ir.debug.DebugInformationGenerator
import org.jetbrains.kotlin.wasm.ir.source.location.SourceLocation
import org.jetbrains.kotlin.wasm.ir.source.location.SourceLocationMappingToText

open class SExpressionBuilder {
    protected val stringBuilder = StringBuilderWithLocations()
    protected var indent = 0

    protected inline fun indented(body: () -> Unit) {
        indent++
        body()
        indent--
    }

    protected fun newLine() {
        stringBuilder.appendLine()
        repeat(indent) { stringBuilder.append(""    "") }
    }

    protected inline fun newLineList(name: String, body: () -> Unit) {
        newLine()
        stringBuilder.append(""($name"")
        indented { body() }
        stringBuilder.append("")"")
    }

    protected inline fun sameLineList(name: String, body: () -> Unit) {
        stringBuilder.append("" ($name"")
        body()
        stringBuilder.append("")"")
    }",protected fun appendElement(value: String) {
"// WITH_STDLIB

// FILE: test.kt",fun foo() {
"}
}

private fun JvmIrBuilder.normalizeArgument(expression: IrExpression): IrExpression {
    val type = expression.type
    if (type.isByte() || type.isShort()) {
        // There is no special append or valueOf function for byte and short on the JVM.
        return irImplicitCast(expression, context.irBuiltIns.intType)
    }

    if (expression is IrConst<*> && expression.kind == IrConstKind.String && (expression.value as String).length == 1) {
        // PSI2IR generates const Strings for 1-length literals in string templates (e.g., the space between x and y in ""$x $y"").
        // We want to use the more efficient `append(Char)` function in such cases. This mirrors the behavior of the non-IR backend.
        //
        // In addition, this also means `append(Char)` will be used for the space in the following case: `x + "" "" + y`.
        // The non-IR backend will still use `append(String)` in this case.
        // NB KT-50091 shows an outlier where this might be actually less efficient, but in general we prefer `Char`.
        return irChar((expression.value as String)[0])
    }

    val typeParameterSymbol = type.classifierOrNull as? IrTypeParameterSymbol
    if (typeParameterSymbol != null) {
        // Upcast type parameter to upper bound with specialized 'append' function
        val upperBound = typeParameterSymbol.owner.representativeUpperBound
        if (upperBound.classifierOrNull == context.irBuiltIns.stringClass) {
            //  T <: String || T <: String? =>
            //      upcast to 'String?'
            return irImplicitCast(expression, context.irBuiltIns.stringType.makeNullable())
        }
        if (!type.isNullable()) {
            if (upperBound.isByte() || upperBound.isShort()) {
                //  Expression type is not null,
                //  T <: Byte || T <: Short =>
                //      upcast to Int
                return irImplicitCast(expression, context.irBuiltIns.intType)
            } else if (upperBound.isPrimitiveType()) {
                //  Expression type is not null,
                //  T <: P, P is primitive type (other than 'Byte' or 'Short') =>
                //      upcast to P
                return irImplicitCast(expression, upperBound)
            }
        }
    }

    return expression
}


private fun JvmIrBuilder.lowerInlineClassArgument(expression: IrExpression): IrExpression? {
    if (InlineClassAbi.unboxType(expression.type) == null)
        return null
    val toStringFunction = expression.type.classOrNull?.owner?.toStringFunction
        ?.let { (it as? IrAttributeContainer)?.attributeOwnerId as? IrFunction ?: it }
        ?: return null
    val toStringReplacement = backendContext.inlineClassReplacements.getReplacementFunction(toStringFunction)
        ?: return null
    // `C?` can only be unboxed if it wraps a reference type `T!!`, in which case the unboxed type
    // is `T?`. We can't pass that to `C.toString-impl` without checking for `null`.
    return if (expression.type.isNullable())
        irLetS(expression) {
            irIfNull(context.irBuiltIns.stringType, irGet(it.owner), irString(null.toString()), irCall(toStringReplacement).apply {
                putValueArgument(0, irGet(it.owner))
            })
        }
    else","irCall(toStringReplacement).apply { putValueArgument(0, expression) }"
"if (a.s != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?"")!>a.s<!>.funNullableAny()
    if (a.s != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any & kotlin.Any?"")!>a.s<!>
}

// TESTCASE NUMBER: 30
sealed class Case30(a: Int?, val b: Float?, private val c: Unit?, protected val d: String?, internal val e: Char?, public val f: Any?) {
    val x: Char? = '.'
    private val y: Unit? = kotlin.Unit
    protected val z: Int? = 12
    public val u: String? = ""...""
    val s: Any?
    val v: Int?
    val w: Number?
    val t: String? = if (u != null) this.u else null

    init {
        if (a != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>a<!>.equals(null)
        if (a != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>a<!>.propT
        if (a != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>a<!>.propAny
        if (a != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>a<!>.propNullableT
        if (a != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>a<!>.propNullableAny
        if (a != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>a<!>.funT()
        if (a != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>a<!>.funAny()
        if (a != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>a<!>.funNullableT()
        if (a != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>a<!>.funNullableAny()
        if (a != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>a<!>

        if (b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.equals(null)

        if (b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.propT

        if (b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.propAny

        if (b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>.propNullableT

        if (b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>.propNullableAny

        if (b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.funT()

        if (b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.funAny()

        if (b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>.funNullableT()

        if (b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>.funNullableAny()
        if (b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float""), DEBUG_INFO_SMARTCAST!>this.b<!>.equals(null)
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float""), DEBUG_INFO_SMARTCAST!>this.b<!>.propT
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float""), DEBUG_INFO_SMARTCAST!>this.b<!>.propAny
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>this.b<!>.propNullableT
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>this.b<!>.propNullableAny
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float""), DEBUG_INFO_SMARTCAST!>this.b<!>.funT()
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float""), DEBUG_INFO_SMARTCAST!>this.b<!>.funAny()
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>this.b<!>.funNullableT()
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>this.b<!>.funNullableAny()
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>this.b<!>
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.equals(null)
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.propT
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.propAny
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>.propNullableT
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>.propNullableAny
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.funT()
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.funAny()
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>.funNullableT()
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>.funNullableAny()
        if (this.b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>","if (b != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float""), DEBUG_INFO_SMARTCAST!>this.b<!>.equals(null)"
"""y"",
                ""ax""
            ),
            *failuresForEqualAndUnequalRight(
                ""bx"",
                ""by"",
                ""ax""
            ),
            *failuresForUnequalRight(x, ""an""),
            *failuresForUnequalRight(""x"", ""an""),
            *failuresForUnequalRight(""bx"", ""an"")
        )

        println(""        else -> \""OK\"""")
        println(""    }"")
        println(""}"")
    }

    private fun failuresForEqualAndUnequalRight(equalLhs: String, unequalLhs: String, rhs: String) =
        arrayOf(
            ""$equalLhs != $rhs"",
            ""$unequalLhs == $rhs"",
            ""!($equalLhs == $rhs)"",
            ""!($unequalLhs != $rhs)""
        )

    private fun failuresForUnequalRight(unequalLhs: String, rhs: String) =
        arrayOf(
            ""$unequalLhs == $rhs"",
            ""!($unequalLhs != $rhs)""
        )


    @JvmStatic
    fun main(args: Array<String>) {
        if (!TEST_DATA_DIR.exists()) throw AssertionError(""${TEST_DATA_DIR.path} doesn't exist"")

        FileUtil.delete(GENERATED_DIR)
        GENERATED_DIR.mkdirs()

        generateBoxedVsPrimitiveTest(
            ""Boolean"",
            ""true"",
            ""false""
        )
        generateBoxedVsPrimitiveTest(""Char"", ""'0'"", ""'1'"")
        generateBoxedVsPrimitiveTest(
            ""Byte"",
            ""0.toByte()"",
            ""1.toByte()""
        )
        generateBoxedVsPrimitiveTest(
            ""Short"",
            ""0.toShort()"",
            ""1.toShort()""
        )
        generateBoxedVsPrimitiveTest(""Int"", ""0"", ""1"")
        generateBoxedVsPrimitiveTest(""Long"", ""0L"", ""1L"")

        generatePrimitiveVsBoxedTest(
            ""Boolean"",
            ""true"",
            ""false""
        )
        generatePrimitiveVsBoxedTest(""Char"", ""'0'"", ""'1'"")",generatePrimitiveVsBoxedTest(
"val initializer = originalDeclaration.initializer ?: IrConstImpl.defaultValueForType(
            originalDeclaration.startOffset,
            originalDeclaration.endOffset,
            originalDeclaration.type
        )

        val boxClass = context.wasmSymbols.findClosureBoxClass(originalDeclaration.type)
        val constructorSymbol = boxClass.constructors.first()

        val irCall =
            IrConstructorCallImpl(
                startOffset = initializer.startOffset,
                endOffset = initializer.endOffset,
                type = boxClass.defaultType,
                symbol = constructorSymbol,
                typeArgumentsCount = boxClass.owner.typeParameters.size,
                constructorTypeArgumentsCount = constructorSymbol.owner.typeParameters.size,
                valueArgumentsCount = constructorSymbol.owner.valueParameters.size
            ).apply {
                putValueArgument(0, initializer)
            }

        return IrVariableImpl(
            startOffset = originalDeclaration.startOffset,
            endOffset = originalDeclaration.endOffset,
            origin = originalDeclaration.origin,
            symbol = IrVariableSymbolImpl(),
            name = originalDeclaration.name,
            type = irCall.type,
            isVar = false,
            isConst = false,
            isLateinit = false
        ).also {
            it.parent = originalDeclaration.parent
            it.initializer = irCall
        }
    }

    override fun defineSharedValue(originalDeclaration: IrVariable, sharedVariableDeclaration: IrVariable) = sharedVariableDeclaration

    override fun getSharedValue(sharedVariableSymbol: IrValueSymbol, originalGet: IrGetValue): IrExpression {
        val boxClass = sharedVariableSymbol.owner.type.classOrFail.owner
        val valueProperty = boxClass.declarations.firstIsInstance<IrProperty>()

        check(valueProperty.name.asString() == ""value"")
        val propertyGetter = valueProperty.getter!!

        val propertyGet = IrCallImpl(
            startOffset = originalGet.startOffset,
            endOffset = originalGet.endOffset,
            type = propertyGetter.returnType,
            symbol = propertyGetter.symbol,
            typeArgumentsCount = 0,
            valueArgumentsCount = 0,
            origin = originalGet.origin
        ).also {
            it.dispatchReceiver = IrGetValueImpl(
                startOffset = originalGet.startOffset,
                endOffset = originalGet.endOffset,
                type = boxClass.defaultType,
                symbol = sharedVariableSymbol,
                origin = originalGet.origin
            )
        }",return IrTypeOperatorCallImpl(
"@AfterEach
    fun cleanupTemporaryDirectories() {
        try {
            _testServices?.temporaryDirectoryManager?.cleanupTemporaryDirectories()
        } catch (e: IOException) {
            println(""Failed to clean temporary directories: ${e.message}\n${e.stackTrace}"")
        }
    }

    private fun createTestConfiguration(): TestConfiguration {
        val testConfiguration = testConfiguration(testDataPath.toString(), configure)
        Disposer.register(disposable, testConfiguration.rootDisposable)
        return testConfiguration
    }

    private fun createAndRegisterTestModuleStructure(testConfiguration: TestConfiguration) {
        val moduleStructure = testConfiguration.moduleStructureExtractor.splitTestDataByModules(
            testDataPath.toString(),
            testConfiguration.directives,
        )

        testServices.register(TestModuleStructure::class, moduleStructure)
    }

    private fun prepareToTheAnalysis(testConfiguration: TestConfiguration) {
        val moduleStructure = testServices.moduleStructure
        val dependencyProvider = DependencyProviderImpl(testServices, moduleStructure.modules)
        testServices.registerDependencyProvider(dependencyProvider)

        testConfiguration.preAnalysisHandlers.forEach { preprocessor -> preprocessor.preprocessModuleStructure(moduleStructure) }
        testConfiguration.preAnalysisHandlers.forEach { preprocessor -> preprocessor.prepareSealedClassInheritors(moduleStructure) }

        testServices.ktTestModuleStructure.mainModules.forEach { ktTestModule ->
            configurator.prepareFilesInModule(ktTestModule, testServices)
        }
    }

    private fun isDependentModeDisabledForTheTest(): Boolean =
        AnalysisApiTestDirectives.DISABLE_DEPENDED_MODE in testServices.moduleStructure.allDirectives

    private fun isFe10DisabledForTheTest(): Boolean =
        AnalysisApiTestDirectives.IGNORE_FE10 in testServices.moduleStructure.allDirectives

    private fun isFirDisabledForTheTest(): Boolean =
        AnalysisApiTestDirectives.IGNORE_FIR in testServices.moduleStructure.allDirectives

    protected fun <R> analyseForTest(contextElement: KtElement, action: KtAnalysisSession.(KtElement) -> R): R {
        return if (configurator.analyseInDependentSession) {
            val originalContainingFile = contextElement.containingKtFile
            val fileCopy = originalContainingFile.copy() as KtFile

            analyzeCopy(fileCopy, DanglingFileResolutionMode.IGNORE_SELF) {
                action(PsiTreeUtil.findSameElementInCopy<KtElement>(contextElement, fileCopy))
            }
        } else {
            analyze(contextElement, action = { action(contextElement) })
        }
    }

    @BeforeEach
    fun initTestInfo(testInfo: TestInfo) {
        this.testInfo = KotlinTestInfo(
            className = testInfo.testClass.orElseGet(null)?.name ?: ""_undefined_"",
            methodName = testInfo.testMethod.orElseGet(null)?.name ?: ""_testUndefined_"",",tags = testInfo.tags
"* Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.noarg

import org.jetbrains.kotlin.backend.common.extensions.IrGenerationExtension
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.extensions.AnnotationBasedExtension
import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.builders.declarations.buildConstructor
import org.jetbrains.kotlin.ir.declarations.IrClass
import org.jetbrains.kotlin.ir.declarations.IrConstructor
import org.jetbrains.kotlin.ir.declarations.IrModuleFragment
import org.jetbrains.kotlin.ir.declarations.createBlockBody
import org.jetbrains.kotlin.ir.descriptors.toIrBasedDescriptor
import org.jetbrains.kotlin.ir.expressions.impl.IrDelegatingConstructorCallImpl
import org.jetbrains.kotlin.ir.expressions.impl.IrInstanceInitializerCallImpl
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.types.getClass
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.ir.visitors.IrElementVisitorVoid
import org.jetbrains.kotlin.name.JvmStandardClassIds.JVM_OVERLOADS_FQ_NAME
import org.jetbrains.kotlin.psi.KtModifierListOwner

class NoArgIrGenerationExtension(
    private val annotations: List<String>,
    private val invokeInitializers: Boolean,
) : IrGenerationExtension {
    override fun generate(moduleFragment: IrModuleFragment, pluginContext: IrPluginContext) {
        moduleFragment.accept(NoArgIrTransformer(pluginContext, annotations, invokeInitializers), null)
    }
}

private class NoArgIrTransformer(
    private val context: IrPluginContext,
    private val annotations: List<String>,
    private val invokeInitializers: Boolean,
) : AnnotationBasedExtension, IrElementVisitorVoid {
    override fun getAnnotationFqNames(modifierListOwner: KtModifierListOwner?): List<String> = annotations

    override fun visitElement(element: IrElement) {
        element.acceptChildren(this, null)
    }

    override fun visitClass(declaration: IrClass) {
        super.visitClass(declaration)

        if (needsNoargConstructor(declaration)) {
            declaration.declarations.add(getOrGenerateNoArgConstructor(declaration))
        }
    }

    private val noArgConstructors = mutableMapOf<IrClass, IrConstructor>()

    private fun getOrGenerateNoArgConstructor(klass: IrClass): IrConstructor = noArgConstructors.getOrPut(klass) {
        val superClass =
            klass.superTypes.mapNotNull(IrType::getClass).singleOrNull { it.kind == ClassKind.CLASS }
                ?: context.irBuiltIns.anyClass.owner

        val superConstructor =
            if (needsNoargConstructor(superClass))
                getOrGenerateNoArgConstructor(superClass)
            else superClass.constructors.singleOrNull { it.isZeroParameterConstructor() }","?: error(""No noarg super constructor for ${klass.render()}:\n"" + superClass.constructors.joinToString(""\n"") { it.render() })"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.low.level.api.fir.util

import org.jetbrains.kotlin.analysis.low.level.api.fir.api.FirDesignation
import org.jetbrains.kotlin.analysis.low.level.api.fir.api.patchDesignationPathIfNeeded
import org.jetbrains.kotlin.fir.FirElement
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.packageFqName
import org.jetbrains.kotlin.fir.psi
import org.jetbrains.kotlin.fir.visitors.FirVisitorVoid
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.psi.KtDeclaration
import org.jetbrains.kotlin.psi.psiUtil.containingClassOrObject
import org.jetbrains.kotlin.utils.exceptions.requireWithAttachment
import org.jetbrains.kotlin.utils.ifEmpty

internal object FirElementFinder {
    fun findClassifierWithClassId(
        firFile: FirFile,
        classId: ClassId,
    ): FirClassLikeDeclaration? = collectDesignationPath(
        firFile = firFile,
        containerClassId = classId.outerClassId,
        expectedDeclarationAcceptor = { it is FirClassLikeDeclaration && it.symbol.name == classId.shortClassName },
    )?.target?.let { it as FirClassLikeDeclaration }

    fun collectDesignationPath(
        firFile: FirFile,
        declarationContainerClassId: ClassId?,
        targetMemberDeclaration: FirDeclaration,
    ): FirDesignation? = collectDesignationPath(
        firFile = firFile,
        containerClassId = declarationContainerClassId,
        expectedDeclarationAcceptor = { it == targetMemberDeclaration },
    )

    fun findDeclaration(firFile: FirFile, nonLocalDeclaration: KtDeclaration): FirDeclaration? = collectDesignationPath(
        firFile = firFile,
        nonLocalDeclaration = nonLocalDeclaration,
    )?.declarationTarget

    fun findPathToDeclarationWithTarget(
        firFile: FirFile,
        nonLocalDeclaration: KtDeclaration,
    ): List<FirDeclaration>? = collectDesignationPath(
        firFile = firFile,
        nonLocalDeclaration = nonLocalDeclaration,
    )?.let { it.path + it.declarationTarget }

    fun collectDesignationPath(
        firFile: FirFile,
        nonLocalDeclaration: KtDeclaration,
    ): FirDesignation? = collectDesignationPath(
        firFile = firFile,","containerClassId = nonLocalDeclaration.containingClassOrObject?.getClassId(),"
"""CompositeProvider@TopDownAnalyzerForJvm for dependencies ${dependenciesContext.module}""
                )
            )
            dependenciesContext.module
        }

        val partProvider = packagePartProvider(sourceModuleSearchScope).let { fragment ->
            if (targetIds == null || incrementalComponents == null) fragment
            else IncrementalPackagePartProvider(fragment, targetIds.map(incrementalComponents::getIncrementalCache))
        }

        // Note that it's necessary to create container for sources _after_ creation of container for dependencies because
        // CliLightClassGenerationSupport#initialize is invoked when container is created, so only the last module descriptor is going
        // to be stored in CliLightClassGenerationSupport, and it better be the source one (otherwise light classes would not be found)
        // TODO: get rid of duplicate invocation of CodeAnalyzerInitializer#initialize, or refactor CliLightClassGenerationSupport
        val container = createContainerForLazyResolveWithJava(
            jvmPlatform,
            moduleContext, trace, declarationProviderFactory(storageManager, files), sourceModuleSearchScope, moduleClassResolver,
            targetEnvironment, lookupTracker, expectActualTracker, inlineConstTracker, enumWhenTracker,
            partProvider, languageVersionSettings,
            useBuiltInsProvider = true,
            configureJavaClassFinder = configureJavaClassFinder,
            javaClassTracker = configuration[ClassicFrontendSpecificJvmConfigurationKeys.JAVA_CLASSES_TRACKER],
            implicitsResolutionFilter = implicitsResolutionFilter
        ).apply {
            initJvmBuiltInsForTopDownAnalysis()
            (partProvider as? IncrementalPackagePartProvider)?.deserializationConfiguration = get()
        }

        moduleClassResolver.sourceCodeResolver = container.get()
        val additionalProviders = ArrayList<PackageFragmentProvider>()

        if (incrementalComponents != null) {
            targetIds?.mapTo(additionalProviders) { targetId ->
                IncrementalPackageFragmentProvider(
                    files, module, storageManager, container.get<DeserializationComponentsForJava>().components,
                    incrementalComponents.getIncrementalCache(targetId), targetId, container.get()
                )
            }
        }

        additionalProviders.add(container.get<JavaDescriptorResolver>().packageFragmentProvider)

        // TODO: consider putting extension package fragment providers into the dependency module
        PackageFragmentProviderExtension.getInstances(project).mapNotNullTo(additionalProviders) { extension ->
            extension.getPackageFragmentProvider(project, module, storageManager, trace, null, lookupTracker)
        }

        val klibModules = getKlibModules(klibList, dependencyModule)

        // TODO: remove dependencyModule from friends
        module.setDependencies(
            listOf(module, dependencyModule, fallbackBuiltIns) + klibModules + explicitModuleDependencyList,
            setOf(dependencyModule) + explicitModuleFriendsList,
        )
        module.initialize(
            CompositePackageFragmentProvider(
                listOf(
                    container.get<KotlinCodeAnalyzer>().packageFragmentProvider,
                    container.get<OptionalAnnotationPackageFragmentProvider>()
                ) + additionalProviders,
                ""CompositeProvider@TopDownAnalzyerForJvm for $module""
            )
        )",return container
"val hasExtensionReceiver: Boolean,
    val contextReceiverCount: Int,
    val hasVarargs: Boolean,
    val numDefaults: Int,
    val isExpect: Boolean,
    val isSyntheticMember: Boolean,
    val valueParameterTypes: List<TypeWithConversion?>,
) {
    val isGeneric = typeParameters.isNotEmpty()

    constructor(
        origin: T,
        typeParameters: Collection<TypeParameterMarker>,
        valueParameterTypes: List<KotlinTypeMarker?>,
        hasExtensionReceiver: Boolean,
        contextReceiverCount: Int,
        hasVarargs: Boolean,
        numDefaults: Int,
        isExpect: Boolean,
        isSyntheticMember: Boolean,
    ) : this(
        origin, typeParameters, hasExtensionReceiver, contextReceiverCount, hasVarargs, numDefaults, isExpect,
        isSyntheticMember, valueParameterTypes.map(::TypeWithConversion)
    )

    companion object
}


interface SimpleConstraintSystem {
    fun registerTypeVariables(typeParameters: Collection<TypeParameterMarker>): TypeSubstitutorMarker
    fun addSubtypeConstraint(subType: KotlinTypeMarker, superType: KotlinTypeMarker)
    fun hasContradiction(): Boolean

    // todo hack for migration
    val captureFromArgument get() = false

    val context: TypeSystemInferenceExtensionContext
}

private fun <T> SimpleConstraintSystem.isValueParameterTypeNotLessSpecific(
    specific: FlatSignature<T>,
    general: FlatSignature<T>,
    callbacks: SpecificityComparisonCallbacks,
    specificityComparator: TypeSpecificityComparator,
    typeKindSelector: (TypeWithConversion?) -> KotlinTypeMarker?
): Boolean {
    val typeParameters = general.typeParameters
    val typeSubstitutor = registerTypeVariables(typeParameters)

    val specificContextReceiverCount = specific.contextReceiverCount
    val generalContextReceiverCount = general.contextReceiverCount

    var specificValueParameterTypes = specific.valueParameterTypes
    var generalValueParameterTypes = general.valueParameterTypes

    if (specificContextReceiverCount != generalContextReceiverCount) {
        specificValueParameterTypes = specificValueParameterTypes.drop(specificContextReceiverCount)
        generalValueParameterTypes = generalValueParameterTypes.drop(generalContextReceiverCount)
    }

    for (index in specificValueParameterTypes.indices) {
        val specificType = typeKindSelector(specificValueParameterTypes[index]) ?: continue
        val generalType = typeKindSelector(generalValueParameterTypes[index]) ?: continue","if (specificityComparator.isDefinitelyLessSpecific(specificType, generalType)) {"
"libraries,
        friendLibraries,
        incrementalDataProvider,
        lookupTracker,
        isCommonSource = { groupedSources.isCommonSourceForLt(it) },
        fileBelongsToModule = { file, it -> groupedSources.fileBelongsToModuleForLt(file, it) },
        buildResolveAndCheckFir = { session, files ->
            buildResolveAndCheckFirViaLightTree(session, files, diagnosticsReporter, null)
        },
        useWasmPlatform = useWasmPlatform,
    )
    output.runPlatformCheckers(diagnosticsReporter)
    return AnalyzedFirOutput(output)
}

fun transformFirToIr(
    moduleStructure: ModulesStructure,
    firOutputs: List<ModuleCompilerAnalyzedOutput>,
    diagnosticsReporter: PendingDiagnosticsCollectorWithSuppress,
): Fir2IrActualizedResult {
    val fir2IrExtensions = Fir2IrExtensions.Default

    var builtInsModule: KotlinBuiltIns? = null
    val dependencies = mutableListOf<ModuleDescriptorImpl>()

    val librariesDescriptors = moduleStructure.allDependencies.map { resolvedLibrary ->
        val storageManager = LockBasedStorageManager(""ModulesStructure"")

        val moduleDescriptor = JsFactories.DefaultDeserializedDescriptorFactory.createDescriptorOptionalBuiltIns(
            resolvedLibrary,
            moduleStructure.compilerConfiguration.languageVersionSettings,
            storageManager,
            builtInsModule,
            packageAccessHandler = null,
            lookupTracker = LookupTracker.DO_NOTHING
        )
        dependencies += moduleDescriptor
        moduleDescriptor.setDependencies(ArrayList(dependencies))

        val isBuiltIns = resolvedLibrary.unresolvedDependencies.isEmpty()
        if (isBuiltIns) builtInsModule = moduleDescriptor.builtIns

        moduleDescriptor
    }

    val firResult = FirResult(firOutputs)
    return firResult.convertToIrAndActualize(
        fir2IrExtensions,
        Fir2IrConfiguration.forKlibCompilation(moduleStructure.compilerConfiguration, diagnosticsReporter),
        IrGenerationExtension.getInstances(moduleStructure.project),
        irMangler = JsManglerIr,
        firMangler = FirJsKotlinMangler,
        visibilityConverter = Fir2IrVisibilityConverter.Default,
        kotlinBuiltIns = builtInsModule ?: DefaultBuiltIns.Instance,
        actualizerTypeContextProvider = ::IrTypeSystemContextImpl,
        specialAnnotationsProvider = null,
        extraActualDeclarationExtractorInitializer = { null },
    ) { irModuleFragment ->
        (irModuleFragment.descriptor as? FirModuleDescriptor)?.let { it.allDependencyModules = librariesDescriptors }
    }
}

fun serializeFirKlib(
    moduleStructure: ModulesStructure,
    firOutputs: List<ModuleCompilerAnalyzedOutput>,","fir2IrActualizedResult: Fir2IrActualizedResult,"
"// Probably arrayOf(SomeUnresolvedType::class, ...)
        if (constantValue is List<*>) {
            val callArgs = unwrapArgumentExpression()
            // So we make sure something is absent in the constant value
            if (callArgs != null && callArgs.size > constantValue.size) {
                val literalExpressions = mapJList(callArgs, ::tryParseTypeLiteralExpression)
                if (literalExpressions.size == callArgs.size) {
                    return treeMaker.NewArray(null, null, literalExpressions)
                }
            }
        }

        return convertLiteralExpression(containingClass, constantValue)
    }

    private fun tryParseReferenceToIntConstant(expression: KtExpression?): JCExpression? {
        val bindingContext = kaptContext.bindingContext

        val expressionToResolve = when (expression) {
            is KtDotQualifiedExpression -> expression.selectorExpression
            else -> expression
        }

        val resolvedCall = expressionToResolve.getResolvedCall(bindingContext) ?: return null
        // Disable inlining only for Java statics
        val resultingDescriptor = resolvedCall.resultingDescriptor.takeIf { it.source is JavaSourceElement } ?: return null
        val fqName = resultingDescriptor.fqNameOrNull()?.takeIf { isValidQualifiedName(it) } ?: return null
        return treeMaker.FqName(fqName)
    }

    private fun convertValueOfPrimitiveTypeOrString(value: Any?): JCExpression? {
        fun specialFpValueNumerator(value: Double): Double = if (value.isNaN()) 0.0 else 1.0 * value.sign
        return when (value) {
            is Char -> treeMaker.Literal(TypeTag.CHAR, value.code)
            is Byte -> treeMaker.TypeCast(treeMaker.TypeIdent(TypeTag.BYTE), treeMaker.Literal(TypeTag.INT, value.toInt()))
            is Short -> treeMaker.TypeCast(treeMaker.TypeIdent(TypeTag.SHORT), treeMaker.Literal(TypeTag.INT, value.toInt()))
            is Boolean, is Int, is Long, is String -> treeMaker.Literal(value)
            is Float ->
                when {
                    value.isFinite() -> treeMaker.Literal(value)
                    else -> treeMaker.Binary(
                        Tag.DIV,
                        treeMaker.Literal(specialFpValueNumerator(value.toDouble()).toFloat()),
                        treeMaker.Literal(0.0F)
                    )
                }

            is Double ->
                when {
                    value.isFinite() -> treeMaker.Literal(value)
                    else -> treeMaker.Binary(Tag.DIV, treeMaker.Literal(specialFpValueNumerator(value)), treeMaker.Literal(0.0))
                }

            else -> null
        }
    }

    private fun checkIfAnnotationValueMatches(asm: Any?, desc: ConstantValue<*>): Boolean {
        return when (asm) {
            null -> desc.value == null
            is Char -> desc is CharValue && desc.value == asm
            is Byte -> desc is ByteValue && desc.value == asm
            is Short -> desc is ShortValue && desc.value == asm
            is Boolean -> desc is BooleanValue && desc.value == asm
            is Int -> desc is IntValue && desc.value == asm",is Long -> desc is LongValue && desc.value == asm
"append('.')
            append(renderName(possiblyInnerType.classifierDescriptor.name, false))
        } ?: append(renderTypeConstructor(possiblyInnerType.classifierDescriptor.typeConstructor))

        append(renderTypeArguments(possiblyInnerType.arguments))
    }

    override fun renderTypeConstructor(typeConstructor: TypeConstructor): String = when (val cd = typeConstructor.declarationDescriptor) {
        is TypeParameterDescriptor, is ClassDescriptor, is TypeAliasDescriptor -> renderClassifierName(cd)
        null -> {
            if (typeConstructor is IntersectionTypeConstructor) {
                typeConstructor.makeDebugNameForIntersectionType { if (it is StubTypeForBuilderInference) it.originalTypeVariable else it }
            } else typeConstructor.toString()
        }
        else -> error(""Unexpected classifier: "" + cd::class.java)
    }

    override fun renderTypeProjection(typeProjection: TypeProjection) = buildString {
        appendTypeProjections(listOf(typeProjection))
    }

    private fun StringBuilder.appendTypeProjections(typeProjections: List<TypeProjection>) {
        typeProjections.joinTo(this, "", "") {
            if (it.isStarProjection) {
                ""*""
            } else {
                val type = renderType(it.type)
                if (it.projectionKind == Variance.INVARIANT) type else ""${it.projectionKind} $type""
            }
        }
    }

    private fun StringBuilder.renderFunctionType(type: KotlinType) {
        val lengthBefore = length
        // we need special renderer to skip @ExtensionFunctionType and @ContextFunctionTypeParams
        with(functionTypeAnnotationsRenderer) {
            renderAnnotations(type)
        }
        val hasAnnotations = length != lengthBefore

        val receiverType = type.getReceiverTypeFromFunctionType()
        val contextReceiversTypes = type.getContextReceiverTypesFromFunctionType()
        if (contextReceiversTypes.isNotEmpty()) {
            append(""context("")
            val withoutLast = contextReceiversTypes.subList(0, contextReceiversTypes.lastIndex)
            for (contextReceiverType in withoutLast) {
                renderNormalizedType(contextReceiverType)
                append("", "")
            }
            renderNormalizedType(contextReceiversTypes.last())
            append("") "")
        }

        val isSuspend = type.isSuspendFunctionType
        val isNullable = type.isMarkedNullable

        val needParenthesis = isNullable || (hasAnnotations && receiverType != null)
        if (needParenthesis) {
            if (isSuspend) {
                insert(lengthBefore, '(')
            } else {
                if (hasAnnotations) {
                    assert(last().isWhitespace())
                    if (get(lastIndex - 1) != ')') {
                        // last annotation rendered without parenthesis - need to add them otherwise parsing will be incorrect","insert(lastIndex, ""()"")"
"analysisSession.getScopeSessionFor(analysisSession.useSiteSession),
            CallableCopyTypeCalculator.DoNothing,
            requiredMembersPhase = FirResolvePhase.STATUS,
        ) ?: return emptyList()

        return buildList {
            scope.processFunctionsByName(OperatorNameConventions.EQUALS) { functionSymbol ->
                val parameterSymbol = functionSymbol.valueParameterSymbols.singleOrNull()
                if (parameterSymbol != null && parameterSymbol.fir.returnTypeRef.coneType.fullyExpandedType(session).isNullableAny) {
                    add(functionSymbol.buildSymbol(symbolBuilder))
                }
            }
        }
    }

    private fun getSymbolByDelegatedConstructorCall(
        expression: KtSimpleNameExpression,
        adjustedResolutionExpression: KtElement,
        fir: FirDelegatedConstructorCall,
        session: FirSession,
        symbolBuilder: KtSymbolByFirBuilder
    ): Collection<KtSymbol> {
        if (expression != adjustedResolutionExpression) {
            // Type alias detection.
            //
            // If we adjusted resolution to get a constructor instead of a class, we need to undo that
            // if the class is defined as a type alias. We can detect that situation when the constructed type
            // is different from the return type of the constructor.
            //
            // TODO: This seems a little indirect. Is there a better way to do this? For FE1.0 there is
            // a special `TypeAliasConstructorDescriptor` for this case. For FIR there is
            // FirConstructor.originalConstructorIfTypeAlias but that doesn't seem to help here as it
            // is null for the constructors we get.
            val constructedType = fir.constructedTypeRef.coneType
            val constructorReturnType = fir.calleeReference.toResolvedConstructorSymbol()?.resolvedReturnTypeRef?.type
            if (constructedType.classId != constructorReturnType?.classId) {
                return getSymbolsForResolvedTypeRef(fir.constructedTypeRef as FirResolvedTypeRef, expression, session, symbolBuilder)
            }
        }
        return getSymbolsByResolvable(fir, expression, session, symbolBuilder)
    }

    private fun getSymbolsForPackageDirective(
        expression: KtSimpleNameExpression,
        symbolBuilder: KtSymbolByFirBuilder
    ): List<KtFirPackageSymbol> {
        return listOfNotNull(getPackageSymbolFor(expression, symbolBuilder, forQualifiedType = false))
    }


    private fun getSymbolByResolvedNameReference(
        fir: FirResolvedNamedReference,
        expression: KtSimpleNameExpression,
        analysisSession: KtFirAnalysisSession,
        session: FirSession,
        symbolBuilder: KtSymbolByFirBuilder
    ): Collection<KtSymbol> {
        val parentAsCall = expression.parent as? KtCallExpression
        if (parentAsCall != null) {
            val firCall = parentAsCall.getOrBuildFir(analysisSession.firResolveSession)?.unwrapSafeCall()

            if (firCall is FirResolvable) {
                return getSymbolsByResolvable(firCall, expression, session, symbolBuilder)
            }
        }","return fir.toTargetSymbol(session, symbolBuilder)"
"@GradleTest
    fun testInternalTest(gradleVersion: GradleVersion) {
        project(""internalTest"", gradleVersion) {
            build(""build"") {
                assertTasksExecuted("":compileKotlin"", "":compileTestKotlin"")
            }
        }
    }

    @DisplayName(""KT-35341: symlinked build dir"")
    @DisabledOnOs(OS.WINDOWS, disabledReason = ""Windows requires SeSymbolicLink privilege and we can't grant it"")
    @GradleTest
    fun symlinkedBuildDir(
        gradleVersion: GradleVersion,
        @TempDir tempDir: Path,
    ) {
        project(""internalTest"", gradleVersion) {
            val externalBuildDir = tempDir.resolve(""externalBuild"")
            externalBuildDir.createSymbolicLinkPointingTo(projectPath.resolve(""build""))

            build(""build"") {
                assertTasksExecuted("":compileKotlin"", "":compileTestKotlin"")
            }
        }
    }

    @DisplayName(""'java-library' plugin compatibility"")
    @GradleTest
    fun testJavaLibraryCompatibility(gradleVersion: GradleVersion) {
        project(""javaLibraryProject"", gradleVersion) {
            val compileKotlinTasks = arrayOf("":libA:compileKotlin"", "":libB:compileKotlin"", "":app:compileKotlin"")
            build(""build"") {
                assertTasksExecuted(*compileKotlinTasks)
                assertOutputDoesNotContain(""Could not register Kotlin output"")
            }

            // Modify a library source and its usage and re-build the project:
            listOf(
                subProject(""libA"").kotlinSourcesDir().resolve(""HelloA.kt""),
                subProject(""libB"").kotlinSourcesDir().resolve(""HelloB.kt""),
                subProject(""app"").kotlinSourcesDir().resolve(""App.kt"")
            ).forEach { sourceFile ->
                sourceFile.modify {
                    it.replace(""helloA"", ""helloA1"")
                        .replace(""helloB"", ""helloB1"")
                }
            }

            build(""build"") {
                assertOutputDoesNotContain(""Could not register Kotlin output"")
                assertTasksExecuted(*compileKotlinTasks)
            }
        }
    }

    @DisplayName(""Default Kotlin version is not affected by transitive dependencies"")
    @GradleTest
    fun testDefaultKotlinVersionIsNotAffectedByTransitiveDependencies(gradleVersion: GradleVersion) {
        project(""simpleProject"", gradleVersion) {
            // Add a dependency with an explicit lower Kotlin version that has a kotlin-stdlib transitive dependency:
            buildGradle.appendText(""\ndependencies { implementation 'org.jetbrains.kotlin:kotlin-reflect:1.5.32' }"")
            testResolveAllConfigurations { unresolvedConfigurations, buildResult ->
                assertTrue(""Unresolved configurations: $unresolvedConfigurations"") { unresolvedConfigurations.isEmpty() }
                buildResult.assertOutputContains("">> :compileClasspath --> kotlin-reflect-1.5.32.jar"")
                // Check that the default newer Kotlin version still wins for 'kotlin-stdlib':",buildResult.assertOutputContains(
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.android

import org.gradle.util.GradleVersion
import org.jetbrains.kotlin.gradle.Kapt3BaseIT
import org.jetbrains.kotlin.gradle.testbase.*
import org.jetbrains.kotlin.gradle.util.*
import org.junit.jupiter.api.DisplayName
import kotlin.io.path.appendText
import kotlin.io.path.writeText

@DisplayName(""android with kapt3 tests"")
@AndroidGradlePluginTests
open class Kapt3AndroidIT : Kapt3BaseIT() {
    @DisplayName(""KT-15001"")
    @GradleAndroidTest
    fun testKt15001(
        gradleVersion: GradleVersion,
        agpVersion: String,","jdkVersion: JdkVersions.ProvidedJdk,"
"public infix fun kotlin.ranges.LongProgression.step(step: kotlin.Long): kotlin.ranges.LongProgression

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
public infix fun kotlin.ranges.UIntProgression.step(step: kotlin.Int): kotlin.ranges.UIntProgression

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
public infix fun kotlin.ranges.ULongProgression.step(step: kotlin.Long): kotlin.ranges.ULongProgression

public infix fun kotlin.Byte.until(to: kotlin.Byte): kotlin.ranges.IntRange

public infix fun kotlin.Byte.until(to: kotlin.Int): kotlin.ranges.IntRange

public infix fun kotlin.Byte.until(to: kotlin.Long): kotlin.ranges.LongRange

public infix fun kotlin.Byte.until(to: kotlin.Short): kotlin.ranges.IntRange

public infix fun kotlin.Char.until(to: kotlin.Char): kotlin.ranges.CharRange

public infix fun kotlin.Int.until(to: kotlin.Byte): kotlin.ranges.IntRange

public infix fun kotlin.Int.until(to: kotlin.Int): kotlin.ranges.IntRange

public infix fun kotlin.Int.until(to: kotlin.Long): kotlin.ranges.LongRange

public infix fun kotlin.Int.until(to: kotlin.Short): kotlin.ranges.IntRange

public infix fun kotlin.Long.until(to: kotlin.Byte): kotlin.ranges.LongRange

public infix fun kotlin.Long.until(to: kotlin.Int): kotlin.ranges.LongRange

public infix fun kotlin.Long.until(to: kotlin.Long): kotlin.ranges.LongRange

public infix fun kotlin.Long.until(to: kotlin.Short): kotlin.ranges.LongRange

public infix fun kotlin.Short.until(to: kotlin.Byte): kotlin.ranges.IntRange

public infix fun kotlin.Short.until(to: kotlin.Int): kotlin.ranges.IntRange

public infix fun kotlin.Short.until(to: kotlin.Long): kotlin.ranges.LongRange

public infix fun kotlin.Short.until(to: kotlin.Short): kotlin.ranges.IntRange

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
public infix fun kotlin.UByte.until(to: kotlin.UByte): kotlin.ranges.UIntRange

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
public infix fun kotlin.UInt.until(to: kotlin.UInt): kotlin.ranges.UIntRange

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
public infix fun kotlin.ULong.until(to: kotlin.ULong): kotlin.ranges.ULongRange

@kotlin.SinceKotlin(version = ""1.5"")
@kotlin.WasExperimental(markerClass = {kotlin.ExperimentalUnsignedTypes::class})
public infix fun kotlin.UShort.until(to: kotlin.UShort): kotlin.ranges.UIntRange

public open class CharProgression : kotlin.collections.Iterable<kotlin.Char> {
    public final val first: kotlin.Char { get; }

    public final val last: kotlin.Char { get; }",public final val step: kotlin.Int { get; }
"// TARGET_BACKEND: JVM

// FILE: JavaClass.java

public class JavaClass {

    private boolean value;

    public boolean isValue() {
        return value;
    }

    public void setValue(Boolean value) {
        this.value = value;
    }
}

// FILE: kotlin.kt

fun box(): String {
    val javaClass = JavaClass()

    if (javaClass.isValue != false) return ""fail 1""

    javaClass.isValue = true","if (javaClass.isValue != true) return ""fail 2"""
"class A {
    fun bar() {",<!UNRESOLVED_REFERENCE!>div<!> <!UNRESOLVED_REFERENCE!>{
"}

    @Test
    fun testKaptOutputs() {
        val incAptCache = tmpDir.newFolder()
        val classesDir = tmpDir.newFolder()
        val destinationDir = tmpDir.newFolder()
        val generatedKotlinSources = tmpDir.newFolder()

        val task = configureKapt {
            this.incAptCache.fileValue(incAptCache)
            this.classesDir.fileValue(classesDir)
            this.destinationDir.fileValue(destinationDir)
            kotlinSourcesDestinationDir.fileValue(generatedKotlinSources)
        }

        assertEquals(incAptCache, task.incAptCache.get().asFile)
        assertEquals(classesDir, task.classesDir.get().asFile)
        assertEquals(destinationDir, task.destinationDir.get().asFile)
        assertEquals(generatedKotlinSources, task.kotlinSourcesDestinationDir.get().asFile)
    }

    @Test
    fun testClasspath() {
        val compiledSources = tmpDir.newFolder()
        val classpath = tmpDir.newFolder()
        val includeCompileClasspath = false

        val task = configureKapt {
            this.compiledSources.from(compiledSources)
            this.classpath.from(classpath)
            this.includeCompileClasspath.set(includeCompileClasspath)
        }

        assertEquals(setOf(compiledSources), task.compiledSources.files)
        assertEquals(setOf(classpath), task.classpath.files)
        assertEquals(includeCompileClasspath, task.includeCompileClasspath.get())
    }

    @Test
    fun testOptions() {
        val sourceCompatibility = ""11""
        val addJdkClassesToMissingClasspathSnapshot = true

        val task = configureKapt {
            defaultJavaSourceCompatibility.set(sourceCompatibility)
            addJdkClassesToClasspath.set(addJdkClassesToMissingClasspathSnapshot)
        }

        assertEquals(sourceCompatibility, task.defaultJavaSourceCompatibility.get())
        assertEquals(addJdkClassesToMissingClasspathSnapshot, task.addJdkClassesToClasspath.get())
    }

    @Test
    fun testKaptExtension() {
        plugin.kaptExtension.useBuildCache = false
        plugin.kaptExtension.includeCompileClasspath = true

        val task = configureKapt {}
        assertEquals(false, task.useBuildCache)
        assertEquals(true, task.includeCompileClasspath.get())
    }

    @Test
    fun testGenerateStubs() {",val task = plugin.registerKaptGenerateStubsTask(GENERATE_STUBS).get()
fun foo(x: Int) = x,fun bar(x: Comparable<Int>) = if (x is Int) foo(x) else 0
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_ANONYMOUS_PARAMETER
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*

fun nonSuspend() {}",suspend fun foo() {
"/**
 * @return the value of zero-terminated UTF-8-encoded C string constructed from given [kotlin.String].
 */
@ExperimentalForeignApi
public val String.utf8: CValues<ByteVar>
    get() = CString(encodeToUtf8(this))

/**
 * Convert this list of Kotlin strings to C array of C strings,
 * allocating memory for the array and C strings with given [AutofreeScope].
 */
@ExperimentalForeignApi
public fun List<String>.toCStringArray(autofreeScope: AutofreeScope): CPointer<CPointerVar<ByteVar>> =
        autofreeScope.allocArrayOf(this.map { it.cstr.getPointer(autofreeScope) })

/**
 * Convert this array of Kotlin strings to C array of C strings,
 * allocating memory for the array and C strings with given [AutofreeScope].
 */
@ExperimentalForeignApi
public fun Array<String>.toCStringArray(autofreeScope: AutofreeScope): CPointer<CPointerVar<ByteVar>> =
        autofreeScope.allocArrayOf(this.map { it.cstr.getPointer(autofreeScope) })


@ExperimentalForeignApi
private class U16CString(val chars: CharArray): CValues<UShortVar>() {
    override val size get() = 2 * (chars.size + 1)

    override val align get() = 2

    // Optimization to avoid unneeded virtual calls in base class implementation.
    override fun getPointer(scope: AutofreeScope): CPointer<UShortVar> {
        return place(interpretCPointer(scope.alloc(size, align).rawPtr)!!)
    }

    override fun place(placement: CPointer<UShortVar>): CPointer<UShortVar> {
        nativeMemUtils.putCharArray(chars, placement.pointed, chars.size)
        // TODO: fix, after KT-29627 is fixed.
        nativeMemUtils.putShort((placement + chars.size)!!.pointed, 0)
        return placement
    }
}

/**
 * @return the value of zero-terminated UTF-16-encoded C string constructed from given [kotlin.String].
 */
@ExperimentalForeignApi
public val String.wcstr: CValues<UShortVar>
    get() = U16CString(this.toCharArray())

/**
 * @return the value of zero-terminated UTF-16-encoded C string constructed from given [kotlin.String].
 */
@ExperimentalForeignApi
public val String.utf16: CValues<UShortVar>
    get() = U16CString(this.toCharArray())

@ExperimentalForeignApi
private class U32CString(val chars: CharArray) : CValues<IntVar>() {
    override val size get() = 4 * (chars.size + 1)

    override val align get() = 4

    // Optimization to avoid unneeded virtual calls in base class implementation.
    override fun getPointer(scope: AutofreeScope): CPointer<IntVar> {","return place(interpretCPointer(scope.alloc(size, align).rawPtr)!!)"
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.codegen.optimization

import org.jetbrains.kotlin.codegen.optimization.common.nodeType
import org.jetbrains.kotlin.codegen.optimization.transformer.MethodTransformer
import org.jetbrains.org.objectweb.asm.Opcodes
import org.jetbrains.org.objectweb.asm.tree.AbstractInsnNode
import org.jetbrains.org.objectweb.asm.tree.JumpInsnNode
import org.jetbrains.org.objectweb.asm.tree.MethodNode

class NegatedJumpsMethodTransformer : MethodTransformer() {
    override fun transform(internalClassName: String, methodNode: MethodNode) {
        val insnList = methodNode.instructions

        // Replace sequence of instructions such as
        //      IF_ICMPLT L1            = insn
        //      GOTO L2                 = next1
        //    L1:                       = next2
        // with
        //      IF_ICMPGE L2            = negatedJumpInsn
        //    L1:                       = next2
        for (insn in insnList.toArray()) {
            if (insn.nodeType != AbstractInsnNode.JUMP_INSN || insn.opcode == Opcodes.GOTO) continue
            val next1 = insn.next ?: continue
            if (next1.opcode != Opcodes.GOTO) continue
            val next2 = next1.next ?: continue
            if (next2 != (insn as JumpInsnNode).label) continue

            val negatedJumpInsn = JumpInsnNode(negateConditionalJumpOpcode(insn.opcode), (next1 as JumpInsnNode).label)
            insnList.insertBefore(insn, negatedJumpInsn)
            insnList.remove(insn)
            insnList.remove(next1)
        }
    }

    private val negatedConditionalJumpOpcode = IntArray(255).also { a ->
        fun negated(opcode1: Int, opcode2: Int) {",a[opcode1] = opcode2
"// DO NOT EDIT MANUALLY!
// Generated by org/jetbrains/kotlin/generators/arguments/GenerateGradleOptions.kt
// To regenerate run 'generateGradleOptions' task
@file:Suppress(""RemoveRedundantQualifierName"", ""Deprecation"", ""Deprecation_Error"", ""DuplicatedCode"")

package org.jetbrains.kotlin.gradle.dsl",internal object KotlinMultiplatformCommonCompilerOptionsHelper {
"@CheckForNull
@TypeQualifierDefault({ElementType.FIELD})
public @interface FieldsAreNullable {
}

// FILE: A.java
import javax.annotation.CheckForNull;
import javax.annotation.Nullable;
import javax.annotation.Nonnull;

@NonNullApi
public class A {
    public String field = null;

    public String foo(String x, @CheckForNull CharSequence y) {
        return """";
    }

    @NullableApi
    public String foobar(String x, @Nonnull CharSequence y) {
        return """";
    }

    public String bar() {
        return """";
    }

    @Nullable
    public java.util.List<String> baz() {
        return null;
    }

    @NullableApi
    public class B {
        public String field = null;

        public String foo(String x, @Nonnull CharSequence y) {
            return """";
        }

        @NonNullApi
        public String foobar(String x, @Nullable CharSequence y) {
            return """";
        }

        public String bar() {
            return """";
        }

        @Nullable
        public java.util.List<String> baz() {
            return null;
        }
    }

    @FieldsAreNullable
    public class C {
        public String field = null;

        public String foo(String x, @Nullable CharSequence y) {
            return """";
        }

        @NullableApi
        public String foobar(String x, @Nullable CharSequence y) {","return """";"
"for (i in 0.toInt() .. 4.toLong()) sb.append(i); sb.appendLine()
    for (i in 0.toLong() .. 4.toByte()) sb.append(i); sb.appendLine()
    for (i in 0.toLong() .. 4.toShort()) sb.append(i); sb.appendLine()
    for (i in 0.toLong() .. 4.toInt()) sb.append(i); sb.appendLine()
    for (i in 0.toLong() .. 4.toLong()) sb.append(i); sb.appendLine()
    for (i in 0.toByte() until 4.toByte()) sb.append(i); sb.appendLine()
    for (i in 0.toByte() until 4.toShort()) sb.append(i); sb.appendLine()
    for (i in 0.toByte() until 4.toInt()) sb.append(i); sb.appendLine()
    for (i in 0.toByte() until 4.toLong()) sb.append(i); sb.appendLine()
    for (i in 0.toShort() until 4.toByte()) sb.append(i); sb.appendLine()
    for (i in 0.toShort() until 4.toShort()) sb.append(i); sb.appendLine()
    for (i in 0.toShort() until 4.toInt()) sb.append(i); sb.appendLine()
    for (i in 0.toShort() until 4.toLong()) sb.append(i); sb.appendLine()
    for (i in 0.toInt() until 4.toByte()) sb.append(i); sb.appendLine()
    for (i in 0.toInt() until 4.toShort()) sb.append(i); sb.appendLine()
    for (i in 0.toInt() until 4.toInt()) sb.append(i); sb.appendLine()
    for (i in 0.toInt() until 4.toLong()) sb.append(i); sb.appendLine()
    for (i in 0.toLong() until 4.toByte()) sb.append(i); sb.appendLine()
    for (i in 0.toLong() until 4.toShort()) sb.append(i); sb.appendLine()
    for (i in 0.toLong() until 4.toInt()) sb.append(i); sb.appendLine()
    for (i in 0.toLong() until 4.toLong()) sb.append(i); sb.appendLine()
    for (i in 4.toByte() downTo 0.toByte()) sb.append(i); sb.appendLine()
    for (i in 4.toByte() downTo 0.toShort()) sb.append(i); sb.appendLine()
    for (i in 4.toByte() downTo 0.toInt()) sb.append(i); sb.appendLine()
    for (i in 4.toByte() downTo 0.toLong()) sb.append(i); sb.appendLine()
    for (i in 4.toShort() downTo 0.toByte()) sb.append(i); sb.appendLine()
    for (i in 4.toShort() downTo 0.toShort()) sb.append(i); sb.appendLine()
    for (i in 4.toShort() downTo 0.toInt()) sb.append(i); sb.appendLine()
    for (i in 4.toShort() downTo 0.toLong()) sb.append(i); sb.appendLine()
    for (i in 4.toInt() downTo 0.toByte()) sb.append(i); sb.appendLine()
    for (i in 4.toInt() downTo 0.toShort()) sb.append(i); sb.appendLine()
    for (i in 4.toInt() downTo 0.toInt()) sb.append(i); sb.appendLine()
    for (i in 4.toInt() downTo 0.toLong()) sb.append(i); sb.appendLine()
    for (i in 4.toLong() downTo 0.toByte()) sb.append(i); sb.appendLine()
    for (i in 4.toLong() downTo 0.toShort()) sb.append(i); sb.appendLine()
    for (i in 4.toLong() downTo 0.toInt()) sb.append(i); sb.appendLine()
    for (i in 4.toLong() downTo 0.toLong()) sb.append(i); sb.appendLine()
    for (i in 'a' .. 'd') sb.append(i); sb.appendLine()
    for (i in 'a' until 'd') sb.append(i); sb.appendLine()
    for (i in 'd' downTo 'a') sb.append(i); sb.appendLine()

    for (i in 0.toByte() .. 4.toByte() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toByte() .. 4.toShort() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toByte() .. 4.toInt() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toByte() .. 4.toLong() step 2L) sb.append(i); sb.appendLine()
    for (i in 0.toShort() .. 4.toByte() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toShort() .. 4.toShort() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toShort() .. 4.toInt() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toShort() .. 4.toLong() step 2L) sb.append(i); sb.appendLine()
    for (i in 0.toInt() .. 4.toByte() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toInt() .. 4.toShort() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toInt() .. 4.toInt() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toInt() .. 4.toLong() step 2L) sb.append(i); sb.appendLine()
    for (i in 0.toLong() .. 4.toByte() step 2L) sb.append(i); sb.appendLine()
    for (i in 0.toLong() .. 4.toShort() step 2L) sb.append(i); sb.appendLine()
    for (i in 0.toLong() .. 4.toInt() step 2L) sb.append(i); sb.appendLine()
    for (i in 0.toLong() .. 4.toLong() step 2L) sb.append(i); sb.appendLine()
    for (i in 0.toByte() until 4.toByte() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toByte() until 4.toShort() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toByte() until 4.toInt() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toByte() until 4.toLong() step 2L) sb.append(i); sb.appendLine()
    for (i in 0.toShort() until 4.toByte() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toShort() until 4.toShort() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toShort() until 4.toInt() step 2) sb.append(i); sb.appendLine()
    for (i in 0.toShort() until 4.toLong() step 2L) sb.append(i); sb.appendLine()",for (i in 0.toInt() until 4.toByte() step 2) sb.append(i); sb.appendLine()
"@Test
    fun testJvmTarget() {
        jvmTargetTestImpl(""1.8"", 52)
        jvmTargetTestImpl(""9"", 53)
        jvmTargetTestImpl(""17"", 61)
    }

    @Test
    fun testCompiledScriptClassLoader() {
        val script = ""val x = 1""
        val scriptCompilationConfiguration = createJvmCompilationConfigurationFromTemplate<SimpleScriptTemplate>()
        val compiler = JvmScriptCompiler(defaultJvmScriptingHostConfiguration)
        val compiledScript = runBlocking {
            val res = compiler(script.toScriptSource(), scriptCompilationConfiguration).throwOnFailure()
            (res as ResultWithDiagnostics.Success<CompiledScript>).value
        }
        val compiledScriptClass = runBlocking { compiledScript.getClass(null).throwOnFailure().valueOrNull()!! }
        val classLoader = compiledScriptClass.java.classLoader

        Assert.assertTrue(classLoader is CompiledScriptClassLoader)
        val anotherClass = classLoader.loadClass(compiledScriptClass.qualifiedName)

        Assert.assertEquals(compiledScriptClass.java, anotherClass)

        val classResourceName = compiledScriptClass.qualifiedName!!.replace('.', '/') + "".class""
        val classAsResourceUrl = classLoader.getResource(classResourceName)
        val classAssResourceStream = classLoader.getResourceAsStream(classResourceName)

        Assert.assertNotNull(classAsResourceUrl)
        Assert.assertNotNull(classAssResourceStream)

        val classAsResourceData = classAsResourceUrl!!.openConnection().getInputStream().readBytes()
        val classAsResourceStreamData = classAssResourceStream!!.readBytes()

        Assert.assertArrayEquals(classAsResourceData, classAsResourceStreamData)

        // TODO: consider testing getResources as well
    }
}

internal fun runScriptFromJar(jar: File): List<String> {
    val javaExecutable = File(File(System.getProperty(""java.home""), ""bin""), ""java"")
    val args = listOf(javaExecutable.absolutePath, ""-jar"", jar.path)
    val processBuilder = ProcessBuilder(args)
    processBuilder.redirectErrorStream(true)
    val r = run {
        val process = processBuilder.start()
        process.waitFor(10, TimeUnit.SECONDS)
        val out = process.inputStream.reader().readText()
        if (process.isAlive) {
            process.destroyForcibly()
            ""Error: timeout, killing script process\n$out""
        } else {
            out
        }
    }.trim()
    return r.lineSequence().map { it.trim() }.toList()
}

fun <T> ResultWithDiagnostics<T>.throwOnFailure(): ResultWithDiagnostics<T> = apply {
    if (this is ResultWithDiagnostics.Failure) {
        val firstExceptionFromReports = reports.find { it.exception != null }?.exception
        throw Exception(
            ""Compilation/evaluation failed:\n  ${reports.joinToString(""\n  "") { it.exception?.toString() ?: it.message }}"",",firstExceptionFromReports
"// !DIAGNOSTICS: -UNUSED_PARAMETER

@Target(AnnotationTarget.EXPRESSION)
@Retention(AnnotationRetention.SOURCE)
annotation class Ann1

@Target(AnnotationTarget.EXPRESSION)
@Retention(AnnotationRetention.SOURCE)
annotation class Ann2(val x: String)

fun bar() {}
fun bar(block: () -> Unit) {}

fun foo(y: IntArray) {
    @Ann1 bar()
    @Ann1 bar() { }
    @Ann1 bar { }

    @Ann2("""") bar()
    @Ann2("""") bar() { }
    @Ann2("""") bar { }

    @Ann1 @Ann2("""") bar()

    var x = 1

    @Ann1 ++x
    @Ann1 x++
    @Ann2("""") ++x
    @Ann2("""") x++","@Ann1 @Ann2("""") ++x"
")

class K1CompilerFacade(environment: KotlinCoreEnvironment) : KotlinCompilerFacade(environment) {
    override fun analyze(
        platformFiles: List<SourceFile>,
        commonFiles: List<SourceFile>
    ): K1AnalysisResult {
        val allKtFiles = platformFiles.map { it.toKtFile(environment.project) } +
            commonFiles.map {
                it.toKtFile(environment.project).also { ktFile ->
                    ktFile.isCommonSource = true
                }
            }

        val result = TopDownAnalyzerFacadeForJVM.analyzeFilesWithJavaIntegration(
            environment.project,
            allKtFiles,
            CliBindingTrace(environment.project),
            environment.configuration,
            environment::createPackagePartProvider
        )

        try {
            result.throwIfError()
        } catch (e: Exception) {
            throw TestsCompilerError(e)
        }

        return K1AnalysisResult(allKtFiles, result.moduleDescriptor, result.bindingContext)
    }

    private fun frontend(
        platformFiles: List<SourceFile>,
        commonFiles: List<SourceFile>
    ): K1FrontendResult {
        val analysisResult = analyze(platformFiles, commonFiles)

        // `analyze` only throws if the analysis itself failed, since we use it to test code
        // with errors. That's why we have to check for errors before we run psi2ir.
        try {
            AnalyzingUtils.throwExceptionOnErrors(analysisResult.bindingContext)
        } catch (e: Exception) {
            throw TestsCompilerError(e)
        }

        val codegenFactory = JvmIrCodegenFactory(
            environment.configuration,
            environment.configuration.get(CLIConfigurationKeys.PHASE_CONFIG)
        )

        val state = GenerationState.Builder(
            environment.project,
            ClassBuilderFactories.TEST,
            analysisResult.moduleDescriptor,
            analysisResult.bindingContext,
            analysisResult.files,
            environment.configuration
        ).isIrBackend(true).codegenFactory(codegenFactory).build()

        state.beforeCompile()

        val psi2irInput = CodegenFactory.IrConversionInput.fromGenerationStateAndFiles(
            state,
            analysisResult.files
        )",val backendInput = codegenFactory.convertToIr(psi2irInput)
"// FIR_IDENTICAL
// KT-399 Type argument inference not implemented for CALL_EXPRESSION

fun <T> getSameTypeChecker(obj: T) : Function1<Any,Boolean> {
    return { a : Any -> a is <!CANNOT_CHECK_FOR_ERASED!>T<!> }
}

fun box() : String {","if(getSameTypeChecker<String>(""lala"")(10)) return ""fail"""
"builder(callableReferenceAccess) {
            parents += qualifiedAccessExpressionBuilder
            defaultNull(""explicitReceiver"")
            defaultNoReceivers()
            defaultFalse(""hasQuestionMarkAtLHS"")
        }

        builder(componentCall) {
            parents += callBuilder
            defaultNoReceivers(notNullExplicitReceiver = true)
            default(""argumentList"") {
                value = ""FirEmptyArgumentList""
            }
            additionalImports(emptyArgumentListType)
        }

        builder(whileLoop) {
            parents += loopBuilder
            defaultNull(""label"")
        }

        builder(doWhileLoop) {
            parents += loopBuilder
            defaultNull(""label"")
        }

        builder(errorExpression) {
            defaultNull(""expression"")
        }

        builder(errorLoop) {
            defaultNull(""label"")
        }

        builder(delegatedConstructorCall, type = ""FirDelegatedConstructorCallImpl"") {
            parents += callBuilder
            default(""argumentList"") {
                value = ""FirEmptyArgumentList""
            }
            defaultNull(""dispatchReceiver"")
            additionalImports(emptyArgumentListType)
        }

        val configurationForFunctionCallBuilder: LeafBuilderConfigurationContext.() -> Unit = {
            parents += abstractFunctionCallBuilder
            defaultNoReceivers()
            openBuilder()
            default(""argumentList"") {
                value = ""FirEmptyArgumentList""
            }
            additionalImports(emptyArgumentListType)
        }

        builder(functionCall) {
            configurationForFunctionCallBuilder()
            default(""origin"") {
                value = ""FirFunctionCallOrigin.Regular""
            }
        }
        builder(integerLiteralOperatorCall, config = configurationForFunctionCallBuilder)
        builder(implicitInvokeCall) {
            configurationForFunctionCallBuilder()
            defaultFalse(""isCallWithExplicitReceiver"")
        }",builder(getClassCall) {
"// !DIAGNOSTICS: -UNUSED_EXPRESSION
// SKIP_TXT

/*
 * KOTLIN DIAGNOSTICS NOT LINKED SPEC TEST (POSITIVE)
 *
 * SECTIONS: dfa
 * NUMBER: 35
 * DESCRIPTION: Raw data flow analysis test
 * HELPERS: classes, objects, typealiases, enumClasses, interfaces, sealedClasses
 */

/*
 * TESTCASE NUMBER: 1
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-30756
 */
fun case_1(x: Any?) {
    while (true) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!> ?: return
    }

    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!><!UNSAFE_CALL!>.<!>equals(10)
}

// TESTCASE NUMBER: 2
fun case_2(x: Any?) {
    while (true) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!> ?: return
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Any"")!>x<!>
    }

    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!>
    <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!><!UNSAFE_CALL!>.<!>equals(10)
}

/*
 * TESTCASE NUMBER: 3
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-30756, KT-35668
 */
fun case_3(x: Any?) {",while (true) {
"override fun visitFunctionExpression(expression: IrFunctionExpression, data: Nothing?) {
        visitFunctionExpression(expression)
    }

    fun visitFunctionExpression(expression: IrFunctionExpression) {
        visitExpression(expression)
    }

    override fun visitGetClass(expression: IrGetClass, data: Nothing?) {
        visitGetClass(expression)
    }

    fun visitGetClass(expression: IrGetClass) {
        visitExpression(expression)
    }

    override fun visitInstanceInitializerCall(expression: IrInstanceInitializerCall, data: Nothing?) {
        visitInstanceInitializerCall(expression)
    }

    fun visitInstanceInitializerCall(expression: IrInstanceInitializerCall) {
        visitExpression(expression)
    }

    override fun visitLoop(loop: IrLoop, data: Nothing?) {
        visitLoop(loop)
    }

    fun visitLoop(loop: IrLoop) {
        visitExpression(loop)
    }

    override fun visitWhileLoop(loop: IrWhileLoop, data: Nothing?) {
        visitWhileLoop(loop)
    }

    fun visitWhileLoop(loop: IrWhileLoop) {
        visitLoop(loop)
    }

    override fun visitDoWhileLoop(loop: IrDoWhileLoop, data: Nothing?) {
        visitDoWhileLoop(loop)
    }

    fun visitDoWhileLoop(loop: IrDoWhileLoop) {
        visitLoop(loop)
    }

    override fun visitReturn(expression: IrReturn, data: Nothing?) {
        visitReturn(expression)
    }

    fun visitReturn(expression: IrReturn) {
        visitExpression(expression)
    }

    override fun visitStringConcatenation(expression: IrStringConcatenation, data: Nothing?) {
        visitStringConcatenation(expression)
    }

    fun visitStringConcatenation(expression: IrStringConcatenation) {
        visitExpression(expression)
    }","override fun visitSuspensionPoint(expression: IrSuspensionPoint, data: Nothing?) {"
"if (!isCompanionObject(klass)) {
            if (!startFromName) renderSpaceIfNeeded(builder)
            renderName(klass, builder, true)
        } else {
            renderCompanionObjectName(klass, builder)
        }

        if (isEnumEntry) return

        val typeParameters = klass.declaredTypeParameters
        renderTypeParameters(typeParameters, builder, false)
        renderCapturedTypeParametersIfRequired(klass, builder)

        if (!klass.kind.isSingleton && classWithPrimaryConstructor) {
            val primaryConstructor = klass.unsubstitutedPrimaryConstructor
            if (primaryConstructor != null) {
                builder.append("" "")
                builder.renderAnnotations(primaryConstructor)
                renderVisibility(primaryConstructor.visibility, builder)
                builder.append(renderKeyword(""constructor""))
                renderValueParameters(primaryConstructor.valueParameters, primaryConstructor.hasSynthesizedParameterNames(), builder)
            }
        }

        renderSuperTypes(klass, builder)
        renderWhereSuffix(typeParameters, builder)
    }

    private fun renderSuperTypes(klass: ClassDescriptor, builder: StringBuilder) {
        if (withoutSuperTypes) return

        if (KotlinBuiltIns.isNothing(klass.defaultType)) return

        val supertypes = klass.typeConstructor.supertypes
        if (supertypes.isEmpty() || supertypes.size == 1 && KotlinBuiltIns.isAnyOrNullableAny(supertypes.iterator().next())) return

        renderSpaceIfNeeded(builder)
        builder.append("": "")
        supertypes.joinTo(builder, "", "") { renderType(it) }
    }

    private fun renderClassKindPrefix(klass: ClassDescriptor, builder: StringBuilder) {
        builder.append(renderKeyword(getClassifierKindPrefix(klass)))
    }


    /* OTHER */
    private fun renderPackageView(packageView: PackageViewDescriptor, builder: StringBuilder) {
        renderPackageHeader(packageView.fqName, ""package"", builder)
        if (debugMode) {
            builder.append("" in context of "")
            renderName(packageView.module, builder, false)
        }
    }

    private fun renderPackageFragment(fragment: PackageFragmentDescriptor, builder: StringBuilder) {
        renderPackageHeader(fragment.fqName, ""package-fragment"", builder)
        if (debugMode) {
            builder.append("" in "")
            renderName(fragment.containingDeclaration, builder, false)
        }
    }

    private fun renderPackageHeader(fqName: FqName, fragmentOrView: String, builder: StringBuilder) {",builder.append(renderKeyword(fragmentOrView))
"// MODULE: lib
// FILE: A.kt
// VERSION: 1

open class N {
    fun bar() = ""something in N""
}

class X {","fun foo() = ""with companion"""
"/*
 * Copyright 2010-2023 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:ExcludedFromCodegen
@file:Suppress(""unused"", ""NON_ABSTRACT_FUNCTION_WITH_NO_BODY"", ""INLINE_CLASS_IN_EXTERNAL_DECLARATION"", ""UNUSED_PARAMETER"")


package kotlin.wasm.internal

@WasmOp(WasmOp.UNREACHABLE)
internal fun wasm_unreachable(): Nothing =
    implementedAsIntrinsic

@Suppress(""REIFIED_TYPE_PARAMETER_NO_INLINE"")
internal fun <reified To> wasm_ref_cast_null(a: Any?): To =
    implementedAsIntrinsic

@Suppress(""REIFIED_TYPE_PARAMETER_NO_INLINE"")
internal fun <reified To> wasm_ref_test(a: Any?): Boolean =
    implementedAsIntrinsic

@Suppress(""REIFIED_TYPE_PARAMETER_NO_INLINE"")
@WasmOp(WasmOp.REF_TEST_NULL)
internal fun <reified To> wasm_ref_test_null(a: Any?): Boolean =
    implementedAsIntrinsic

internal fun <T> wasm_array_copy(destination: T, destinationIndex: Int, source: T, sourceIndex: Int, length: Int): Unit =
    implementedAsIntrinsic

internal fun <T> array_new_data0(address: Int, length: Int): T =
    implementedAsIntrinsic

@WasmOp(WasmOp.I32_EQ)
internal fun wasm_i32_eq(a: Int, b: Int): Boolean =
    implementedAsIntrinsic

@WasmOp(WasmOp.I32_NE)
internal fun wasm_i32_ne(a: Int, b: Int): Boolean =
    implementedAsIntrinsic

@WasmOp(WasmOp.I32_LT_S)
internal fun wasm_i32_lt_s(a: Int, b: Int): Boolean =
    implementedAsIntrinsic

@WasmOp(WasmOp.I32_LT_U)
internal fun wasm_i32_lt_u(a: Int, b: Int): Boolean =
    implementedAsIntrinsic

@WasmOp(WasmOp.I32_GT_S)
internal fun wasm_i32_gt_s(a: Int, b: Int): Boolean =
    implementedAsIntrinsic

@WasmOp(WasmOp.I32_GT_U)
internal fun wasm_i32_gt_u(a: Int, b: Int): Boolean =",implementedAsIntrinsic
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.test.services

import org.jetbrains.kotlin.codeMetaInfo.CodeMetaInfoParser
import org.jetbrains.kotlin.codeMetaInfo.CodeMetaInfoRenderer
import org.jetbrains.kotlin.codeMetaInfo.model.CodeMetaInfo
import org.jetbrains.kotlin.codeMetaInfo.model.ParsedCodeMetaInfo
import org.jetbrains.kotlin.test.model.TestFile
import org.jetbrains.kotlin.test.model.TestModule

class GlobalMetadataInfoHandler(
    private val testServices: TestServices,
    private val processors: List<AdditionalMetaInfoProcessor>
) : TestService {
    private lateinit var existingInfosPerFile: Map<TestFile, List<ParsedCodeMetaInfo>>

    private val infosPerFile: MutableMap<TestFile, MutableList<CodeMetaInfo>> =
        mutableMapOf<TestFile, MutableList<CodeMetaInfo>>().withDefault { mutableListOf() }

    private val existingInfosPerFilePerInfoCache = mutableMapOf<Pair<TestFile, CodeMetaInfo>, List<ParsedCodeMetaInfo>>()

    @OptIn(ExperimentalStdlibApi::class)
    fun parseExistingMetadataInfosFromAllSources() {
        existingInfosPerFile = buildMap {
            for (file in testServices.moduleStructure.modules.flatMap { it.files }) {
                put(file, CodeMetaInfoParser.getCodeMetaInfoFromText(file.originalContent))
            }
        }
    }

    fun getExistingMetaInfosForFile(file: TestFile): List<ParsedCodeMetaInfo> {
        return existingInfosPerFile.getValue(file)
    }

    fun getReportedMetaInfosForFile(file: TestFile): List<CodeMetaInfo> {
        return infosPerFile.getValue(file)
    }","fun getExistingMetaInfosForActualMetadata(file: TestFile, metaInfo: CodeMetaInfo): List<ParsedCodeMetaInfo> {"
"interface A<T : A<T>> {
    val symbol: ASymbol<T>
}

interface B<T : B<T>> : A<T> {
    override val symbol: BSymbol<T>
}

interface C : B<C> {",fun foo()
") {

    override fun equals(other: Any?): Boolean {
        if (other !is CInteropCommonizerDependent) return false
        if (this.target != other.target) return false
        if (this.scopes != other.scopes) return false
        if (this.interops != other.interops) return false
        return true
    }

    override fun hashCode(): Int {
        var result = target.hashCode()
        result = 31 * result + scopes.hashCode()
        result = 31 * result + interops.hashCode()
        return result
    }

    init {
        require(target.targets.isNotEmpty()) { ""CInteropCommonizerDependent.target.targets.size can't be empty"" }
        require(scopes.isNotEmpty()) { ""CInteropCommonizerDependent.scopes can't be empty"" }
        require(interops.isNotEmpty()) { ""CInteropCommonizerDependent.interops can't be empty"" }
    }

    companion object Factory
}

@OptIn(UnsafeApi::class)
internal fun CInteropCommonizerDependent.Factory.from(
    target: SharedCommonizerTarget,
    compilations: Set<KotlinNativeCompilation>
): CInteropCommonizerDependent? {
    target.targets.ifEmpty { return null }

    /*
     Filter out compilations that have their associate also in the set of compilations
     e.g. do not include '*test' if their main counterpart is also present.
     *test and *main compilations will be included when build authors declare a *Test dependsOn *Main source set relationship.
     This relationship should not be declared, but we try to be lenient towards it here.
      */
    val filteredCompilations = compilations.filter { compilation ->
        compilation.allAssociatedCompilations.none { associatedCompilation -> associatedCompilation in compilations }
    }.ifEmpty { return null }.toSet()

    val scopes: Set<Scope> = filteredCompilations
        .map { compilation -> Scope.create(compilation) }.toSet()
        .ifEmpty { return null }

    val interops: Set<CInteropIdentifier> = filteredCompilations
        .flatMap { compilation -> compilation.cinterops.ifEmpty { return null } }
        .map { cinterop -> cinterop.identifier }.toSet()

    return CInteropCommonizerDependent(target, scopes, interops)
}

internal suspend fun CInteropCommonizerDependent.Factory.from(compilation: KotlinSharedNativeCompilation): CInteropCommonizerDependent? {
    return from(
        compilation.commonizerTarget.await() as? SharedCommonizerTarget ?: return null,
        compilation.getImplicitlyDependingNativeCompilations()
    )
}

internal suspend fun CInteropCommonizerDependent.Factory.from(sourceSet: KotlinSourceSet): CInteropCommonizerDependent? {
    return from(
        target = sourceSet.commonizerTarget.await() as? SharedCommonizerTarget ?: return null,
        compilations = sourceSet.internal.compilations",.filterIsInstance<KotlinNativeCompilation>().toSet()
"}
        } else {
            if (useImplicitReceiverAsBuiltinInvokeArgument) {
                if (AbstractTypeChecker.RUN_SLOW_ASSERTIONS) {
                    val session = context.session
                    val fullyExpandedType = explicitReceiver.type.fullyExpandedType(session)
                    require(
                        (session.typeApproximator.approximateToSuperType(
                            fullyExpandedType,
                            TypeApproximatorConfiguration.FinalApproximationAfterResolutionAndInference
                        ) ?: fullyExpandedType).isExtensionFunctionType
                    )
                }
                manager.enqueueResolverTask {
                    task.runResolverForBuiltinInvokeExtensionWithImplicitArgument(
                        invokeFunctionInfo, explicitReceiver,
                    )
                }
            }

            manager.enqueueResolverTask {
                task.runResolverForInvoke(
                    invokeFunctionInfo, explicitReceiver,
                )
            }
        }
    }

    // For calls having a form of ""x.(f)()""
    fun enqueueResolveTasksForImplicitInvokeCall(info: CallInfo, receiverExpression: FirExpression) {
        val explicitReceiverValue = ExpressionReceiverValue(receiverExpression)
        val task = createInvokeFunctionResolveTask(info, TowerGroup.EmptyRootForInvokeReceiver)
        manager.enqueueResolverTask {
            task.runResolverForInvoke(
                info, explicitReceiverValue,
            )
        }
        manager.enqueueResolverTask {
            task.runResolverForBuiltinInvokeExtensionWithExplicitArgument(
                info, explicitReceiverValue,
            )
        }
        manager.enqueueResolverTask {
            task.runResolverForBuiltinInvokeExtensionWithImplicitArgument(
                info, explicitReceiverValue,
            )
        }
    }

    private fun createInvokeFunctionResolveTask(
        info: CallInfo,
        receiverGroup: TowerGroup,
        candidateFactory: CandidateFactory = candidateFactoriesAndCollectors.candidateFactory
    ): InvokeFunctionResolveTask = InvokeFunctionResolveTask(
        components,
        manager,
        TowerDataElementsForName(info.name, components.towerDataContext),
        receiverGroup,
        candidateFactoriesAndCollectors.resultCollector,
        candidateFactory,
    )
}


private fun BodyResolveComponents.createExplicitReceiverForInvoke(","candidate: Candidate,"
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package org.jetbrains.kotlin.commonizer.cir
"}
        }

        current = current.containingDeclaration ?: return null
    }
}

internal val PropertyDescriptor.getterCallableIdIfNotLocal: CallableId?
    get() {
        if (this is SyntheticPropertyDescriptor) {
            return getMethod.callableIdIfNotLocal
        }

        return null
    }

internal val PropertyDescriptor.setterCallableIdIfNotLocal: CallableId?
    get() {
        if (this is SyntheticPropertyDescriptor) {
            val setMethod = this.setMethod
            if (setMethod != null) {
                return setMethod.callableIdIfNotLocal
            }
        }

        return null
    }

internal fun getSymbolDescriptor(symbol: KtSymbol): DeclarationDescriptor? {
    return when (symbol) {
        is KtFe10DescSymbol<*> -> symbol.descriptor
        is KtFe10PsiSymbol<*, *> -> symbol.descriptor
        is KtFe10DescSyntheticFieldSymbol -> symbol.descriptor
        else -> null
    }
}

internal val ClassifierDescriptor.classId: ClassId?
    get() = when (val owner = containingDeclaration) {
        is PackageFragmentDescriptor -> ClassId(owner.fqName, name)
        is ClassifierDescriptorWithTypeParameters -> owner.classId?.createNestedClassId(name)
        else -> null
    }

internal val ClassifierDescriptor.maybeLocalClassId: ClassId
    get() = classId ?: ClassId(containingPackage() ?: FqName.ROOT, FqName.topLevel(this.name), isLocal = true)

internal fun ClassDescriptor.getSupertypesWithAny(): Collection<KotlinType> {
    val supertypes = typeConstructor.supertypes
    if (isInterfaceLike) {
        return supertypes
    }

    val hasClassSupertype = supertypes.any { (it.constructor.declarationDescriptor as? ClassDescriptor)?.kind == ClassKind.CLASS }
    return if (hasClassSupertype) supertypes else listOf(builtIns.anyType) + supertypes
}


internal fun CallableMemberDescriptor.getSymbolPointerSignature(): String {
    return DescriptorRenderer.FQ_NAMES_IN_TYPES.render(this)
}

internal fun createKtInitializerValue(
    initializer: KtExpression?,
    propertyDescriptor: PropertyDescriptor?,","analysisContext: Fe10AnalysisContext,"
"analyze(argument)
        }

        val variableForFixation = variableFixationFinder.findFirstVariableForFixation(
            this, getOrderedAllTypeVariables(collectVariablesFromContext, topLevelAtoms), postponedArguments, completionMode, topLevelType
        )

        // continue completion (rerun stages) only if ready for fixation variables with proper constraints have appeared
        // (after analysing a lambda with the builder inference)
        // otherwise we don't continue and report ""not enough type information"" error
        return variableForFixation?.isReady == true
    }

    private fun transformToAtomWithNewFunctionalExpectedType(
        c: ConstraintSystemCompletionContext,
        argument: PostponedAtomWithRevisableExpectedType,
        diagnosticsHolder: KotlinDiagnosticsHolder
    ): Boolean = with(c) {
        val revisedExpectedType: UnwrappedType = argument.revisedExpectedType
            ?.takeIf { it.isFunctionOrKFunctionWithAnySuspendability() } as UnwrappedType? ?: return false

        when (argument) {
            is PostponedCallableReferenceAtom ->
                CallableReferenceWithRevisedExpectedTypeAtom(argument.atom, revisedExpectedType).also {
                    argument.setAnalyzedResults(null, listOf(it))
                }
            is LambdaWithTypeVariableAsExpectedTypeAtom ->
                argument.transformToResolvedLambda(c.getBuilder(), diagnosticsHolder, revisedExpectedType)
            else -> throw IllegalStateException(""Unsupported postponed argument type of $argument"")
        }

        return true
    }

    private fun ConstraintSystemCompletionContext.fixNextReadyVariable(
        completionMode: ConstraintSystemCompletionMode,
        topLevelAtoms: List<ResolvedAtom>,
        topLevelType: UnwrappedType,
        collectVariablesFromContext: Boolean,
        postponedArguments: List<PostponedResolvedAtom>,
        diagnosticsHolder: KotlinDiagnosticsHolder
    ): Boolean {
        val variableForFixation = variableFixationFinder.findFirstVariableForFixation(
            this,
            getOrderedAllTypeVariables(collectVariablesFromContext, topLevelAtoms),
            postponedArguments,
            completionMode,
            topLevelType
        ) ?: return false

        if (!variableForFixation.isReady) return false

        fixVariable(this, notFixedTypeVariables.getValue(variableForFixation.variable), topLevelAtoms, diagnosticsHolder)

        return true
    }

    private fun ConstraintSystemCompletionContext.reportNotEnoughTypeInformation(
        completionMode: ConstraintSystemCompletionMode,
        topLevelAtoms: List<ResolvedAtom>,
        topLevelType: UnwrappedType,
        collectVariablesFromContext: Boolean,
        postponedArguments: List<PostponedResolvedAtom>,
        diagnosticsHolder: KotlinDiagnosticsHolder
    ) {",while (true) {
"// EXPECTED_REACHABLE_NODES: 1432
// !LANGUAGE: -ProhibitGenericArrayClassLiteral
import kotlin.reflect.KClass

fun box(): String {
    check(js(""Object""), Any::class)
    check(js(""String""), String::class)
    check(js(""Boolean""), Boolean::class)","check(js(""Error""), Throwable::class)"
"enum class Foo(val a: Int = 1, val b: String = ""a"") {
  A(),
  B(2, ""b""),","C(b = ""b""),"
"private val staticScope = LazyJavaStaticClassScope(c, jClass, this)
    override fun getStaticScope(): MemberScope = staticScope

    override fun getUnsubstitutedPrimaryConstructor(): ClassConstructorDescriptor? = null

    override fun getCompanionObjectDescriptor(): ClassDescriptor? = null

    override fun getUnsubstitutedMemberScope() = super.getUnsubstitutedMemberScope() as LazyJavaClassMemberScope
    override fun getConstructors() = unsubstitutedMemberScope.constructors()

    override fun getDeclaredTypeParameters(): List<TypeParameterDescriptor> = declaredTypeParameters

    override fun getDefaultFunctionTypeForSamInterface(): SimpleType? =
        c.components.samConversionResolver.resolveFunctionTypeIfSamInterface(this)

    override fun isDefinitelyNotSamInterface(): Boolean {
        if (classKind != ClassKind.INTERFACE) return true

        // From the definition of function interfaces in the Java specification (pt. 9.8):
        // ""methods that are members of I that do not have the same signature as any public instance method of the class Object""
        // It means that if an interface declares `int hashCode()` then the method won't be taken into account when
        // checking if the interface is SAM.
        // We make here a conservative check just filtering out methods by name.
        // If we ignore a method with wrong signature (different from one in Object) it's not very bad,
        // we'll just say that the interface MAY BE a SAM when it's not and then more detailed check will be applied.
        var foundSamMethod = false
        for (method in jClass.methods) {
            if (method.isAbstract && method.typeParameters.isEmpty() &&
                method.name.identifier !in PUBLIC_METHOD_NAMES_IN_OBJECT
            ) {
                // found 2nd method candidate
                if (foundSamMethod) {
                    return true
                }
                foundSamMethod = true
            }
        }

        // If we have default methods the interface could be a SAM even while a super interface has more than one abstract method
        if (jClass.methods.any { !it.isAbstract && it.typeParameters.isEmpty() }) return false

        // Check if any of the super-interfaces contain too many methods to be a SAM
        return typeConstructor.supertypes.any {
            (it.constructor.declarationDescriptor as? SyntheticJavaClassDescriptor)?.isDefinitelyNotSamInterface == true
        }
    }

    override fun getSealedSubclasses(): Collection<ClassDescriptor> = sealedSubclasses

    override fun getValueClassRepresentation(): ValueClassRepresentation<SimpleType>? = null

    override fun getContainingDeclaration(): DeclarationDescriptor {
        return outerClass
    }

    private val sourceElement = c.components.sourceElementFactory.source(jClass)

    override fun getSource(): SourceElement = sourceElement

    override fun isExternal(): Boolean = false

    override fun toString() = ""Lazy Java class ${this.fqNameUnsafe}""

    private inner class FakeJavaClass : JavaClass {",override val name: Name
"// MODULE: m1-common
// FILE: common.kt",open class Base {
"val type = ExportedType.InlineInterfaceType(
            listOf(nameProperty, ordinalProperty)
        )

        return ExportedProperty(
            name = name,
            type = ExportedType.IntersectionType(exportType(parentClass.defaultType), type),
            mutable = false,
            isMember = true,
            isStatic = true,
            isProtected = parentClass.visibility == DescriptorVisibilities.PROTECTED,
            irGetter = context.mapping.enumEntryToGetInstanceFun[irEnumEntry]
                ?: error(""Unable to find get instance fun for ${field.fqNameWhenAvailable}""),
        )
    }

    private fun classExportability(klass: IrClass): Exportability {
        when (klass.kind) {
            ClassKind.ANNOTATION_CLASS ->
                return Exportability.Prohibited(""Class ${klass.fqNameWhenAvailable} with kind: ${klass.kind}"")

            ClassKind.OBJECT,
            ClassKind.CLASS,
            ClassKind.INTERFACE,
            ClassKind.ENUM_CLASS,
            ClassKind.ENUM_ENTRY -> {
            }
        }

        if (klass.isJsImplicitExport()) {
            return Exportability.Implicit
        }

        if (klass.isSingleFieldValueClass)
            return Exportability.Prohibited(""Inline class ${klass.fqNameWhenAvailable}"")

        return Exportability.Allowed
    }

    private fun exportDeclarationImplicitly(klass: IrClass, superTypes: Iterable<IrType>): ExportedDeclaration {
        val typeParameters = klass.typeParameters.memoryOptimizedMap(::exportTypeParameter)
        val superInterfaces = superTypes
            .filter { (it.classifierOrFail.owner as? IrDeclaration)?.isExportedImplicitlyOrExplicitly(context) ?: false }
            .map { exportType(it) }
            .memoryOptimizedFilter { it !is ExportedType.ErrorType }

        val name = klass.getExportedIdentifier()
        val (members, nestedClasses) = exportClassDeclarations(klass, superTypes)
        return ExportedRegularClass(
            name = name,
            isInterface = true,
            isAbstract = false,
            superClasses = emptyList(),
            superInterfaces = superInterfaces,
            typeParameters = typeParameters,
            members = members,
            nestedClasses = nestedClasses,
            ir = klass
        )
    }

    private fun exportOrdinaryClass(klass: IrClass, superTypes: Iterable<IrType>): ExportedDeclaration? {
        when (val exportability = classExportability(klass)) {
            is Exportability.Prohibited -> error(exportability.reason)
            Exportability.NotNeeded -> return null","Exportability.Implicit -> return exportDeclarationImplicitly(klass, superTypes)"
"var extensionPrefix = """"
            if (fieldDescriptor.isExtension) {
                extensionPrefix = when {
                    fieldDescriptor in jvm -> ""jvmExt_""
                    fieldDescriptor in js -> ""jsExt_""
                    fieldDescriptor in java -> ""javaExt_""
                    fieldDescriptor in builtIns -> ""builtInsExt_""
                    fieldDescriptor in klib -> ""klibExt_""
                    else -> error(""Unknown extension"")
                }
            }
            return (extensionPrefix + fieldDescriptor.name.javaName + (if (fieldDescriptor.isRepeated) ""List"" else """"))
                .replace(""[A-Z]"".toRegex()) { ""_"" + it.value }
                .uppercase()
        }
    }

    private val allMessages: MutableSet<Descriptors.Descriptor> = linkedSetOf()
    private val messagesToProcess: Queue<Descriptors.Descriptor> = LinkedList()
    private val repeatedFields: MutableSet<Descriptors.FieldDescriptor> = linkedSetOf()

    fun generate(): String {
        val sb = StringBuilder()
        val p = Printer(sb)
        p.println(File(""license/COPYRIGHT_HEADER.txt"").readText())
        p.println()
        p.println(""@file:Suppress(\""UNUSED_PARAMETER\"")"")
        p.println()
        p.println(""package org.jetbrains.kotlin.incremental"")
        p.println()

        p.println(""import org.jetbrains.kotlin.library.metadata.KlibMetadataProtoBuf"")
        p.println(""import org.jetbrains.kotlin.metadata.ProtoBuf"")
        p.println(""import org.jetbrains.kotlin.metadata.builtins.BuiltInsProtoBuf"")
        p.println(""import org.jetbrains.kotlin.metadata.deserialization.NameResolver"")
        p.println(""import org.jetbrains.kotlin.metadata.java.JavaClassProtoBuf"")
        p.println(""import org.jetbrains.kotlin.metadata.js.JsProtoBuf"")
        p.println(""import org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf"")
        p.println(""import org.jetbrains.kotlin.metadata.serialization.Interner"")
        p.println(""import org.jetbrains.kotlin.name.ClassId"")
        p.println(""import org.jetbrains.kotlin.serialization.deserialization.getClassId"")
        p.println(""import java.util.*"")
        p.println()
        p.println(""/** This file is generated by org.jetbrains.kotlin.generators.protobuf.GenerateProtoBufCompare. DO NOT MODIFY MANUALLY */"")
        p.println()

        p.println(""open class ProtoCompareGenerated("")
        p.pushIndent()
        p.println(""val oldNameResolver: NameResolver,"")
        p.println(""val newNameResolver: NameResolver,"")
        p.println(""oldTypeTable: ProtoBuf.TypeTable?,"")
        p.println(""newTypeTable: ProtoBuf.TypeTable?"")
        p.popIndent()
        p.println("") {"")
        p.pushIndent()

        p.println(""private val strings = Interner<String>()"")
        p.println(""val $OLD_PREFIX${STRING_INDEXES_NAME}Map: MutableMap<Int, Int> = hashMapOf()"")
        p.println(""val $NEW_PREFIX${STRING_INDEXES_NAME}Map: MutableMap<Int, Int> = hashMapOf()"")
        p.println(""val $OLD_PREFIX${CLASS_ID_INDEXES_NAME}Map: MutableMap<Int, Int> = hashMapOf()"")
        p.println(""val $NEW_PREFIX${CLASS_ID_INDEXES_NAME}Map: MutableMap<Int, Int> = hashMapOf()"")
        p.println(""val oldTypeTable: ProtoBuf.TypeTable = oldTypeTable ?: ProtoBuf.TypeTable.getDefaultInstance()"")
        p.println(""val newTypeTable: ProtoBuf.TypeTable = newTypeTable ?: ProtoBuf.TypeTable.getDefaultInstance()"")

        p.println()","p.println(""private val classIds = Interner<ClassId>()"")"
"import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.primaryConstructorSuperTypePlatformSupport
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors
import org.jetbrains.kotlin.fir.declarations.FirClass
import org.jetbrains.kotlin.fir.declarations.FirRegularClass
import org.jetbrains.kotlin.fir.declarations.primaryConstructorIfAny
import org.jetbrains.kotlin.fir.declarations.utils.isErrorPrimaryConstructor
import org.jetbrains.kotlin.fir.declarations.utils.isInterface
import org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol
import org.jetbrains.kotlin.fir.types.coneType
import org.jetbrains.kotlin.fir.types.impl.FirImplicitAnyTypeRef
import org.jetbrains.kotlin.fir.types.toRegularClassSymbol
import org.jetbrains.kotlin.utils.addToStdlib.lastIsInstanceOrNull

/** Checker on super type declarations in the primary constructor of a class declaration. */
object FirPrimaryConstructorSuperTypeChecker : FirClassChecker(MppCheckerKind.Common) {
    override fun check(declaration: FirClass, context: CheckerContext, reporter: DiagnosticReporter) {
        if (declaration.isInterface) {
            with(SourceNavigator.forElement(declaration)) {
                for (superTypeRef in declaration.superTypeRefs) {
                    if (superTypeRef.isInConstructorCallee()) {
                        reporter.reportOn(superTypeRef.source, FirErrors.SUPERTYPE_INITIALIZED_IN_INTERFACE, context)
                    }
                }
            }
            return
        }

        if (declaration.classKind.isEnumEntry) return

        val primaryConstructorSymbol = declaration.primaryConstructorIfAny(context.session)

        if (primaryConstructorSymbol == null || primaryConstructorSymbol.isErrorPrimaryConstructor) {
            checkSupertypeInitializedWithoutPrimaryConstructor(declaration, reporter, context)
        } else {
            checkSuperTypeNotInitialized(primaryConstructorSymbol, declaration, context, reporter)
        }
    }

    /**
     *  SUPERTYPE_NOT_INITIALIZED is reported on code like the following. It's skipped if `A` has `()` after it, in which case any
     *  diagnostics for that constructor call will be reported, if applicable.
     *
     *  ```
     *  open class A
     *  class B : <!SUPERTYPE_NOT_INITIALIZED>A<!>
     *  ```
     */
    private fun checkSuperTypeNotInitialized(
        primaryConstructorSymbol: FirConstructorSymbol,
        regularClass: FirClass,
        context: CheckerContext,
        reporter: DiagnosticReporter
    ) {
        val containingClass = context.containingDeclarations.lastIsInstanceOrNull<FirRegularClass>()
        val delegatedConstructorCall = primaryConstructorSymbol.resolvedDelegatedConstructorCall ?: return
        // No need to check implicit call to the constructor of `kotlin.Any`.
        val constructedTypeRef = delegatedConstructorCall.constructedTypeRef
        if (constructedTypeRef is FirImplicitAnyTypeRef) return
        val superClassSymbol = constructedTypeRef.coneType.toRegularClassSymbol(context.session) ?: return
        // Subclassing a singleton should be reported as SINGLETON_IN_SUPERTYPE
        if (superClassSymbol.classKind.isSingleton) return
        if (regularClass.isEffectivelyExpect(containingClass, context) ||
            regularClass.isEffectivelyExternal(containingClass, context)
        ) {",return
"/**
 * Returns the number of elements in this array.
 */
@kotlin.internal.InlineOnly
public inline fun BooleanArray.count(): Int {
    return size
}

/**
 * Returns the number of elements in this array.
 */
@kotlin.internal.InlineOnly
public inline fun CharArray.count(): Int {
    return size
}

/**
 * Returns the number of elements matching the given [predicate].
 */
public inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {
    var count = 0
    for (element in this) if (predicate(element)) ++count
    return count
}

/**
 * Returns the number of elements matching the given [predicate].
 */
public inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {
    var count = 0
    for (element in this) if (predicate(element)) ++count
    return count
}

/**
 * Returns the number of elements matching the given [predicate].
 */
public inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {
    var count = 0
    for (element in this) if (predicate(element)) ++count
    return count
}

/**
 * Returns the number of elements matching the given [predicate].
 */
public inline fun IntArray.count(predicate: (Int) -> Boolean): Int {
    var count = 0
    for (element in this) if (predicate(element)) ++count
    return count
}

/**
 * Returns the number of elements matching the given [predicate].
 */
public inline fun LongArray.count(predicate: (Long) -> Boolean): Int {
    var count = 0
    for (element in this) if (predicate(element)) ++count
    return count
}

/**
 * Returns the number of elements matching the given [predicate].
 */
public inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {",var count = 0
"/*
 * Copyright 2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress(","""unused"","
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.analysis.low.level.api.fir.test.configurators",import com.intellij.openapi.Disposable
"return callStack.pushCompoundInstruction(constructorCall)
        }

        callStack.pushState(expression.toPrimitive())
    }

    private fun interpretVariable(variable: IrVariable) {
        callStack.storeState(variable.symbol, callStack.popState())
        callStack.pushState(getUnitState())
    }

    private fun interpretSetValue(expression: IrSetValue) {
        callStack.rewriteState(expression.symbol, callStack.popState())
        callStack.pushState(getUnitState())
    }

    private fun interpretReturn(expression: IrReturn) {
        callStack.returnFromFrameWithResult(expression)
    }

    private fun interpretWhile(loop: IrWhileLoop) {
        val result = callStack.popState().asBoolean()
        callStack.dropSubFrame()
        if (result) {
            callStack.newSubFrame(loop)
            callStack.pushSimpleInstruction(loop)
            callStack.pushCompoundInstruction(loop.condition)
            callStack.pushCompoundInstruction(loop.body)
        }
    }

    private fun interpretDoWhile(loop: IrDoWhileLoop) {
        val result = callStack.popState().asBoolean()
        callStack.dropSubFrame()
        if (result) {
            callStack.newSubFrame(loop)
            callStack.pushSimpleInstruction(loop)
            callStack.pushCompoundInstruction(loop.condition)
            callStack.pushCompoundInstruction(loop.body)
        }
    }

    @Suppress(""UNUSED_PARAMETER"")
    private fun interpretWhen(whenExpression: IrWhen) {
        // This method is reachable only if none of the branches were selected.
        // In that case, we just return `Unit` result that will be dropped later.
        callStack.dropSubFrame()
        callStack.pushState(getUnitState())
    }

    private fun interpretBranch(branch: IrBranch) {
        val result = callStack.popState().asBoolean()
        if (result) {
            callStack.dropSubFrame() // drop entire `when` expression from frame
            callStack.pushCompoundInstruction(branch.result)
        }
    }

    private fun interpretSetField(expression: IrSetField) {
        val receiver = (expression.receiver as IrDeclarationReference).symbol
        val propertySymbol = expression.symbol.owner.correspondingPropertySymbol!!
        callStack.loadState(receiver).apply { this.setField(propertySymbol, callStack.popState()) }
        callStack.pushState(getUnitState())
    }",private fun interpretGetField(expression: IrGetField) {
"import kotlin.reflect.KProperty

class Delegate {","operator fun provideDelegate(instance: Any?, property: KProperty<*>): Delegate = this"
"<!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>
            equals(null)
            propT
            propAny
            propNullableT
            propNullableAny
            funT()
            funAny()
            funNullableT()
            funNullableAny()
            get()
            ip1test1()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.get()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>.ip1test1()
        }
        also {
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.get()
            <!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>it<!>.ip1test1()
        }
    }
}

/*
 * TESTCASE NUMBER: 51
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28785
 */
fun <T> T?.case_51() where T : Inv<T>, T: InterfaceWithTypeParameter1<out T>? {
    if (this != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.get()
        <!DEBUG_INFO_EXPRESSION_TYPE(""T? & T?!!"")!>this<!>.ip1test1()

        equals(this)
        get()
        ip1test1()
        apply {","<!DEBUG_INFO_EXPRESSION_TYPE(""T"")!>this<!>"
"// IGNORE_BACKEND_K2: JVM_IR, JS_IR, JS_IR_ES6, NATIVE, WASM
// FIR status: Disabling of StrictOnlyInputTypesChecks is not supported by FIR
// WITH_STDLIB
// SKIP_TXT
// !LANGUAGE: -StrictOnlyInputTypesChecks

import kotlin.experimental.ExperimentalTypeInference

fun <K> K.bar3(): K = null as K
fun <K> K.foo3(): K = null as K

fun bar2(): Int = 1
fun foo2(): Float = 1f

fun <K> bar4(): K = null as K",fun <K> foo4(): K = null as K
"/*
 * Copyright 2010-2016 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.js.inline.clean

import org.jetbrains.kotlin.js.backend.ast.*
import org.jetbrains.kotlin.js.backend.ast.metadata.SideEffectKind
import org.jetbrains.kotlin.js.backend.ast.metadata.constant
import org.jetbrains.kotlin.js.backend.ast.metadata.sideEffects
import org.jetbrains.kotlin.js.backend.ast.metadata.synthetic
import org.jetbrains.kotlin.js.inline.util.collectFreeVariables

internal class RedundantVariableDeclarationElimination(private val root: JsStatement) {
    private val usages = mutableSetOf<JsName>()
    private var hasChanges = false

    fun apply(): Boolean {
        analyze()
        perform()
        return hasChanges
    }

    private fun analyze() {
        object : JsVisitorWithContextImpl() {
            override fun visit(x: JsNameRef, ctx: JsContext<*>): Boolean {
                val name = x.name
                if (name != null && x.qualifier == null) {
                    usages += name
                }
                return super.visit(x, ctx)
            }

            override fun visit(x: JsBreak, ctx: JsContext<*>) = false

            override fun visit(x: JsContinue, ctx: JsContext<*>) = false

            override fun visit(x: JsFunction, ctx: JsContext<*>): Boolean {
                usages += x.collectFreeVariables()
                return false
            }
        }.accept(root)
    }

    private fun perform() {
        object : JsVisitorWithContextImpl() {
            override fun endVisit(x: JsVars, ctx: JsContext<*>) {
                if (x.synthetic) {",if (
"else -> {}
            }
        }
        return if (smartCastTypeToUse != null && result != null) {
            KtSmartCastedReceiverValue(result, smartCastTypeToUse.toKtType(analysisContext))
        } else {
            result
        }
    }

    private fun createSignature(symbol: KtSymbol, resultingDescriptor: CallableDescriptor): KtCallableSignature<*>? {
        val returnType = if (resultingDescriptor is ValueParameterDescriptor && resultingDescriptor.isVararg) {
            val arrayType = resultingDescriptor.returnType ?: return null
            analysisContext.builtIns.getArrayElementType(arrayType)
        } else {
            resultingDescriptor.returnType
        }
        val ktReturnType = returnType?.toKtType(analysisContext) ?: return null
        val receiverType = if (resultingDescriptor.isSynthesizedPropertyFromJavaAccessors()) {
            // FE1.0 represents synthesized properties as an extension property of the Java class. Hence the extension receiver type should
            // always be null
            null
        } else {
            resultingDescriptor.extensionReceiverParameter?.returnType?.toKtType(analysisContext)
        }
        return when (symbol) {
            is KtVariableLikeSymbol -> KtFe10VariableLikeSignature(symbol, ktReturnType, receiverType)
            is KtFunctionLikeSymbol -> KtFe10FunctionLikeSignature(
                symbol,
                ktReturnType,
                receiverType,
                @Suppress(""UNCHECKED_CAST"")
                symbol.valueParameters.zip(resultingDescriptor.valueParameters).map { (symbol, resultingDescriptor) ->
                    createSignature(symbol, resultingDescriptor) as KtVariableLikeSignature<KtValueParameterSymbol>
                })
            else -> error(""unexpected callable symbol $this"")
        }
    }

    private fun CallableDescriptor?.isSynthesizedPropertyFromJavaAccessors() =
        this is PropertyDescriptor && kind == CallableMemberDescriptor.Kind.SYNTHESIZED

    private fun ResolvedCall<*>.createArgumentMapping(signature: KtFunctionLikeSignature<*>): LinkedHashMap<KtExpression, KtVariableLikeSignature<KtValueParameterSymbol>> {
        val parameterSignatureByName = signature.valueParameters.associateBy {
            // ResolvedCall.valueArguments have their names affected by the `@ParameterName` annotations,
            // so we use `name` instead of `symbol.name`
            it.name
        }
        val result = LinkedHashMap<KtExpression, KtVariableLikeSignature<KtValueParameterSymbol>>()
        for ((parameter, arguments) in valueArguments) {
            val parameterSymbol = KtFe10DescValueParameterSymbol(parameter, analysisContext)

            for (argument in arguments.arguments) {
                val expression = argument.getArgumentExpression() ?: continue
                result[expression] = parameterSignatureByName[parameterSymbol.name] ?: continue
            }
        }
        return result
    }

    private fun createCallInfo(
        context: BindingContext,
        psi: KtElement,
        ktCall: KtCall,
        resolvedCalls: List<ResolvedCall<*>>,",diagnostics: Diagnostics = context.diagnostics
"private inline fun <K : Comparable<K>> expectMinMaxBy(min: Char, max: Char, elements: CharSequence, selector: (Char) -> K) {
        assertEquals(min, elements.minBy(selector))
        assertEquals(min, elements.minByOrNull(selector))
        assertEquals(max, elements.maxBy(selector))
        assertEquals(max, elements.maxByOrNull(selector))
    }

    @Test
    fun minMaxBy() {
        expectMinMaxBy('a', 'a', StringBuilder(charArrayOf('a').concatToString()), { it })
        expectMinMaxBy('a', 'b', StringBuilder(charArrayOf('a', 'b').concatToString()), { it })
        expectMinMaxBy('a', Char.MAX_VALUE, StringBuilder(charArrayOf('a', 'b', Char.MAX_VALUE).concatToString()), { it })

    }

    @Test
    fun minMaxByEmpty() {
        val empty = StringBuilder()
        assertNull(empty.minByOrNull { it.toString() })
        assertNull(empty.maxByOrNull { it.toString() })
        assertFailsWith<NoSuchElementException> { empty.minBy { it.toString() } }
        assertFailsWith<NoSuchElementException> { empty.maxBy { it.toString() } }                       
    }

    @Test 
    fun minBySelectorEvaluateOnce() {
        val source = StringBuilder(charArrayOf('a', 'b', Char.MAX_VALUE).concatToString())
        var c = 0
        source.minBy { c++ }
        assertEquals(3, c)
        c = 0
        source.minByOrNull { c++ }
        assertEquals(3, c)
    }

    @Test 
    fun maxBySelectorEvaluateOnce() {
        val source = StringBuilder(charArrayOf('a', 'b', Char.MAX_VALUE).concatToString())
        var c = 0
        source.maxBy { c++ }
        assertEquals(3, c)
        c = 0
        source.maxByOrNull { c++ }
        assertEquals(3, c)
    }
    
    
    private inline fun <R : Comparable<R>> expectMinMaxOf(min: R, max: R, elements: CharSequence, selector: (Char) -> R) {
        assertEquals(min, elements.minOf(selector))
        assertEquals(min, elements.minOfOrNull(selector))
        assertEquals(max, elements.maxOf(selector))
        assertEquals(max, elements.maxOfOrNull(selector))
    }
    
    @Test
    fun minMaxOf() {
        expectMinMaxOf(""_"" + 'a', ""_"" + 'a', StringBuilder(charArrayOf('a').concatToString()), { ""_$it"" })
        expectMinMaxOf(""_"" + 'a', ""_"" + 'b', StringBuilder(charArrayOf('a', 'b').concatToString()), { ""_$it"" })
        expectMinMaxOf(""_"" + 'a', ""_"" + Char.MAX_VALUE, StringBuilder(charArrayOf('a', 'b', Char.MAX_VALUE).concatToString()), { ""_$it"" })

    }
    
    @Test",fun minMaxOfDouble() {
"/*
 * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.plugin.mpp

import com.google.gson.GsonBuilder
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import com.google.gson.stream.JsonWriter
import org.gradle.api.Project
import org.gradle.api.plugins.ExtensionAware
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.Internal
import org.gradle.api.tasks.Nested
import org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension
import org.jetbrains.kotlin.gradle.dsl.multiplatformExtension
import org.jetbrains.kotlin.gradle.plugin.KotlinPluginLifecycle
import org.jetbrains.kotlin.gradle.plugin.KotlinProjectSetupCoroutine
import org.jetbrains.kotlin.gradle.plugin.await
import org.jetbrains.kotlin.gradle.plugin.sources.KotlinDependencyScope
import org.jetbrains.kotlin.gradle.plugin.sources.sourceSetDependencyConfigurationByScope
import org.jetbrains.kotlin.gradle.targets.metadata.dependsOnClosureWithInterCompilationDependencies
import org.jetbrains.kotlin.gradle.targets.metadata.getPublishedPlatformCompilations
import org.jetbrains.kotlin.gradle.targets.metadata.isNativeSourceSet
import org.jetbrains.kotlin.gradle.targets.native.internal.CInteropCommonizerCompositeMetadataJarBundling.cinteropMetadataDirectoryPath
import org.jetbrains.kotlin.gradle.utils.*
import org.w3c.dom.Document
import org.w3c.dom.Element
import org.w3c.dom.Node
import org.w3c.dom.NodeList
import java.io.Serializable
import java.io.StringWriter
import javax.xml.parsers.DocumentBuilderFactory

// FIXME support module classifiers for PM2.0 or drop this class in favor of KotlinModuleIdentifier
open class ModuleDependencyIdentifier(
    open val groupId: String?,
    open val moduleId: String,
) : Serializable {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is ModuleDependencyIdentifier) return false

        if (groupId != other.groupId) return false
        if (moduleId != other.moduleId) return false

        return true
    }

    override fun hashCode(): Int {
        var result = groupId?.hashCode() ?: 0",result = 31 * result + moduleId.hashCode()
"}

class JsonBoolean private constructor(val value: Boolean) : JsonNode() {
    private val stringValue = value.toString()

    override fun write(writer: Writer) {
        writer.append(stringValue)
    }

    companion object {
        val TRUE = JsonBoolean(true)
        val FALSE = JsonBoolean(false)

        fun of(value: Boolean): JsonBoolean = if (value) TRUE else FALSE
    }
}

data class JsonObject(val properties: MutableMap<String, JsonNode>) : JsonNode() {
    constructor(vararg properties: Pair<String, JsonNode>) : this(properties.toMap().toMutableMap())

    override fun write(writer: Writer) {
        writer.append('{')
        var first = true
        for ((key, value) in properties) {
            if (!first) {
                writer.append(',')
            }
            first = false
            JsonString(key).write(writer)
            writer.append(':')
            value.write(writer)
        }
        writer.append('}')
    }

    override fun toString(): String = super.toString()
}

data class JsonArray(val elements: MutableList<JsonNode>) : JsonNode() {
    constructor(vararg elements: JsonNode) : this(elements.toMutableList())

    override fun write(writer: Writer) {
        writer.append('[')
        var first = true
        for (element in elements) {
            if (!first) {
                writer.append(',')
            }
            first = false
            element.write(writer)
        }
        writer.append(']')
    }
}

data class JsonString(val value: String) : JsonNode() {
    override fun write(writer: Writer) {
        writer.append('""')
        for (c in value) {
            when (c) {
                '\\' -> writer.append(""\\\\"")
                '""' -> writer.append(""\\\"""")
                '\r' -> writer.append(""\\r"")
                '\n' -> writer.append(""\\n"")
                '\t' -> writer.append(""\\t"")","'\b' -> writer.append(""\\b"")"
"this += file(customNativeHome).resolve(""konan/lib/kotlin-native-compiler-embeddable.jar"")
                        this += file(customNativeHome).resolve(""konan/lib/trove4j.jar"")
                    }

                    customCompilerDependencies.flatMapTo(this) { it.files }
                }
            }

            computeLazy(COMPILER_PLUGINS) {
                compilerPluginDependencies.forEach(::dependsOn)
                lazyClassPath { compilerPluginDependencies.flatMapTo(this) { it.files } }
            }

            computeLazy(CUSTOM_KLIBS) {
                customTestDependencies.forEach(::dependsOn)
                lazyClassPath { customTestDependencies.flatMapTo(this) { it.files } }
            }

            compute(TEST_KIND) {
                readFromGradle(FORCE_STANDALONE)?.let { ""STANDALONE"" }
            }

            // Pass Gradle properties as JVM properties so test process can read them.
            compute(TEST_TARGET)
            compute(TEST_MODE)
            compute(COMPILE_ONLY)
            compute(OPTIMIZATION_MODE)
            compute(USE_THREAD_STATE_CHECKER)
            compute(GC_TYPE)
            compute(GC_SCHEDULER)
            compute(ALLOCATOR)
            compute(CACHE_MODE)
            compute(EXECUTION_TIMEOUT)
            compute(SANITIZER)
            compute(SHARED_TEST_EXECUTION)
            compute(EAGER_GROUP_CREATION)

            // Pass whether tests are running at TeamCity.
            computePrivate(TEAMCITY) { kotlinBuildProperties.isTeamcityBuild.toString() }
        }

        // Pass the current Gradle task name so test can use it in logging.
        environment(""GRADLE_TASK_NAME"", path)

        useJUnitPlatform {
            tag?.let { includeTags(it) }
        }

        if (!allowParallelExecution) {
            systemProperty(""junit.jupiter.execution.parallel.enabled"", ""false"")
        }

        doFirst {
            logger.info(
                buildString {
                    appendLine(""$path parallel test execution parameters:"")
                    append(""  Available CPU cores = $availableCpuCores"")
                    systemProperties.filterKeys { it.startsWith(""junit.jupiter"") }.toSortedMap().forEach { (key, value) ->
                        append(""\n  $key = $value"")
                    }
                }
            )

            // Compute lazy properties and apply them all as JVM process properties.
            // This forces to resolve the necessary configurations.",computedTestProperties.resolveAndApplyToTask()
"PlexusWagonProvider(container)
        )
        locator.setServices(
            WagonConfigurator::class.java,
            PlexusWagonConfigurator(container)
        )

        locator.getService(RepositorySystem::class.java)
    }

    private val repositorySystemSession: RepositorySystemSession by lazy {
        val localRepo = LocalRepository(localRepoPath)
        MavenRepositorySystemUtils.newSession().also {
            it.localRepositoryManager = repositorySystem.newLocalRepositoryManager(it, localRepo)
        }
    }

    fun resolve(
        roots: List<Artifact>,
        scope: String,
        kind: ResolutionKind,
        filter: DependencyFilter?,
        classifier: String? = null,
        extension: String? = null,
    ): ResultWithDiagnostics<List<File>> {
        if (kind == ResolutionKind.NON_TRANSITIVE) return resolveArtifacts(roots).asSuccess()

        val isOptional = kind == ResolutionKind.TRANSITIVE_PARTIAL
        val requests = resolveTree(roots, scope, isOptional, filter, classifier, extension)

        val artifactResults = try {
            synchronized(this) {
                repositorySystem.resolveArtifacts(
                    repositorySystemSession,
                    requests
                )
            }
        } catch (resolutionException: ArtifactResolutionException) {
            if (isOptional) {
                resolutionException.results
            } else {
                return makeResolveFailureResult(listOf(resolutionException.message.orEmpty()), null, resolutionException)
            }
        }

        return IterableResultsCollector<File>().run {
            for (artifactResult in artifactResults) {
                if (artifactResult.isResolved) {
                    addValue(artifactResult.artifact.file)
                } else {
                    for (exception in artifactResult.exceptions) {
                        addDiagnostic(
                            ScriptDiagnostic(
                                ScriptDiagnostic.unspecifiedError,
                                ""Unable to resolve artifact ${artifactResult.request.artifact}"",
                                exception = exception
                            )
                        )
                    }
                }
            }
            getResult()
        }
    }",private fun resolveTree(
"is IrReturnableBlockSymbol -> useReturnableExpressionAsType(returnTarget.owner.type)
    }

    override fun IrExpression.useExpressionAsType(actualType: IrType, expectedType: IrType): IrExpression {
        // // TODO: Default parameters are passed as nulls and they need not to be unboxed. Fix this

        if (actualType.makeNotNull().isNothing())
            return this

        if (actualType.isUnit() && (!expectedType.isUnit() || this is IrCall)) {
            // Don't materialize Unit if value is known to be proper Unit on runtime
            if (!this.isGetUnit(irBuiltIns)) {
                val unitValue = JsIrBuilder.buildGetObjectValue(actualType, context.irBuiltIns.unitClass)
                return JsIrBuilder.buildComposite(actualType, listOf(this, unitValue))
            }
        }

        if (expectedType.isUnit()) return this

        val actualInlinedClass = icUtils.getInlinedClass(actualType)
        val expectedInlinedClass = icUtils.getInlinedClass(expectedType)

        // Mimicking behaviour of current JS backend
        // TODO: Revisit
        if (
            (actualType is IrDynamicType && expectedType.makeNotNull().isChar()) ||
            (actualType.makeNotNull().isChar() && expectedType is IrDynamicType)
        ) return this

        val function = when {
            actualInlinedClass == null && expectedInlinedClass == null -> return this
            actualInlinedClass != null && expectedInlinedClass == null -> icUtils.boxIntrinsic
            actualInlinedClass == null && expectedInlinedClass != null -> icUtils.unboxIntrinsic
            else -> return this
        }

        return buildSafeCall(this, actualType, expectedType) { arg ->
            JsIrBuilder.buildCall(
                function,
                expectedType,
                typeArguments = listOf(actualType, expectedType)
            ).also {
                it.putValueArgument(0, arg)
            }
        }
    }

    private fun buildSafeCall(
        arg: IrExpression,
        actualType: IrType,
        resultType: IrType,
        call: (IrExpression) -> IrExpression
    ): IrExpression {
        // Safe call is only needed if we cast from Nullable type to Nullable type.
        // Otherwise, null value cannot occur.
        if (!actualType.isNullable() || !resultType.isNullable())
            return call(arg)

        return JsIrBuilder.run {
            // TODO: Set parent of local variables
            val tmp = buildVar(actualType, parent = null, initializer = arg)
            val nullCheck = buildIfElse(
                type = resultType,
                cond = buildCall(irBuiltIns.eqeqSymbol).apply {
                    putValueArgument(0, buildGetValue(tmp.symbol))","putValueArgument(1, buildNull(irBuiltIns.nothingNType))"
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:OptIn(ExternalKotlinTargetApi::class)

package org.jetbrains.kotlin.gradle.plugin.mpp.external

import org.gradle.api.artifacts.Configuration
import org.gradle.api.attributes.Category",import org.gradle.api.attributes.Usage
"true
                    ),
                    result = IrBlockImpl(
                        expression.endOffset,
                        expression.endOffset,
                        context.irBuiltIns.unitType,
                        null,
                        emptyList()
                    )
                )
            )
        }

        forEachWith(transformed.branches, condScopes, resultScopes) { it, condScope, resultScope ->
            // If the conditional block doesn't have a composable call in it, we don't need
            // to generate a group around it because we will be generating one around the entire
            // if statement
            if (needsWrappingGroup && condScope.hasComposableCalls) {
                it.condition = it.condition.asReplaceGroup(condScope)
            }
            if (
                // if no wrapping group but more than one result have calls, we have to have every
                // result be a group so that we have a consistent number of groups during execution
                (resultsWithCalls > 1 && !needsWrappingGroup) ||
                // if we are wrapping the if with a group, then we only need to add a group when
                // the block has composable calls
                (needsWrappingGroup && resultScope.hasComposableCalls)
            ) {
                it.result = it.result.asReplaceGroup(resultScope)
            }

            if (resultsWithCalls == 1 && resultScope.hasComposableCalls) {
                // Realize all groups in the branch result with a conditional call - making sure
                // that nested control structures are wrapped correctly.
                resultScope.realizeCoalescableGroup()
            }
        }

        return when {
            resultsWithCalls == 1 || needsWrappingGroup -> transformed.asCoalescableGroup(whenScope)
            else -> transformed
        }
    }

    sealed class Scope(val name: String) {
        var parent: Scope? = null
        var level: Int = 0

        open val isInComposable get() = false
        open val functionScope: FunctionScope? get() = parent?.functionScope
        open val fileScope: FileScope? get() = parent?.fileScope
        open val nearestComposer: IrValueParameter? get() = parent?.nearestComposer

        val myComposer: IrValueParameter get() = nearestComposer
            ?: error(""Not in a composable function"")

        open class SourceLocation(val element: IrElement) {
            open val repeatable: Boolean
                get() = false
            var used = false
                private set
            fun markUsed() { used = true }
        }

        class RootScope : Scope(""<root>"")",class FunctionScope(
"}
}

// Wraps a non-null aware parceler to handle nullable types.
class IrNullAwareParcelSerializer(private val serializer: IrParcelSerializer) : IrParcelSerializer {
    override fun AndroidIrBuilder.readParcel(parcel: IrValueDeclaration): IrExpression {
        val nonNullResult = readParcelWith(serializer, parcel)
        return irIfThenElse(
            nonNullResult.type.makeNullable(),
            irEquals(parcelReadInt(irGet(parcel)), irInt(0)),
            irNull(),
            nonNullResult
        )
    }

    override fun AndroidIrBuilder.writeParcel(parcel: IrValueDeclaration, flags: IrValueDeclaration, value: IrExpression): IrExpression {
        return irLetS(value) { irValueSymbol ->
            irIfNull(
                context.irBuiltIns.unitType,
                irGet(irValueSymbol.owner),
                parcelWriteInt(irGet(parcel), irInt(0)),
                irBlock {
                    +parcelWriteInt(irGet(parcel), irInt(1))
                    +writeParcelWith(serializer, parcel, flags, irGet(irValueSymbol.owner))
                }
            )
        }
    }
}

// Parcel serializer for object classes. We avoid empty parcels by writing a dummy value. Not null-safe.
class IrObjectParcelSerializer(private val objectClass: IrClass) : IrParcelSerializer {
    override fun AndroidIrBuilder.readParcel(parcel: IrValueDeclaration): IrExpression
    // Avoid empty parcels
    {
        return irBlock {
            +parcelReadInt(irGet(parcel))
            +irGetObject(objectClass.symbol)
        }
    }

    override fun AndroidIrBuilder.writeParcel(parcel: IrValueDeclaration, flags: IrValueDeclaration, value: IrExpression): IrExpression {
        return parcelWriteInt(irGet(parcel), irInt(1))
    }
}

// Parcel serializer for classes with a default constructor. We avoid empty parcels by writing a dummy value. Not null-safe.
class IrNoParameterClassParcelSerializer(private val irClass: IrClass) : IrParcelSerializer {
    override fun AndroidIrBuilder.readParcel(parcel: IrValueDeclaration): IrExpression {
        val defaultConstructor = irClass.primaryConstructor!!
        return irBlock {
            +parcelReadInt(irGet(parcel))
            +irCall(defaultConstructor)
        }
    }

    override fun AndroidIrBuilder.writeParcel(parcel: IrValueDeclaration, flags: IrValueDeclaration, value: IrExpression): IrExpression {
        return parcelWriteInt(irGet(parcel), irInt(1))
    }
}

// Parcel serializer for enum classes. Not null-safe.
class IrEnumParcelSerializer(enumClass: IrClass) : IrParcelSerializer {
    override fun AndroidIrBuilder.readParcel(parcel: IrValueDeclaration): IrExpression {
        return irCall(enumValueOf).apply {","putValueArgument(0, parcelReadString(irGet(parcel)))"
"// FIR_IDENTICAL
// !CHECK_TYPE

// KT-1410 Compiler does automatically infer type argument when using variance
//+JDK",package d
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"")

package org.jetbrains.kotlin.fir.expressions.impl

import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.FirImplementationDetail
import org.jetbrains.kotlin.fir.MutableOrEmptyList
import org.jetbrains.kotlin.fir.builder.toMutableOrEmpty",import org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic
"if (extensionReceiver !== explicitReceiver && extensionReceiver !== dispatchReceiver) {
            extensionReceiver = extensionReceiver?.transform(transformer, data)
        }
        transformCalleeReference(transformer, data)
        return this
    }

    override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirCallableReferenceAccessImpl {
        annotations.transformInplace(transformer, data)
        return this
    }

    override fun <D> transformTypeArguments(transformer: FirTransformer<D>, data: D): FirCallableReferenceAccessImpl {
        typeArguments.transformInplace(transformer, data)
        return this
    }

    override fun <D> transformExplicitReceiver(transformer: FirTransformer<D>, data: D): FirCallableReferenceAccessImpl {
        explicitReceiver = explicitReceiver?.transform(transformer, data)
        return this
    }

    override fun <D> transformCalleeReference(transformer: FirTransformer<D>, data: D): FirCallableReferenceAccessImpl {
        calleeReference = calleeReference.transform(transformer, data)
        return this
    }

    override fun replaceConeTypeOrNull(newConeTypeOrNull: ConeKotlinType?) {
        coneTypeOrNull = newConeTypeOrNull
    }

    override fun replaceAnnotations(newAnnotations: List<FirAnnotation>) {
        annotations = newAnnotations.toMutableOrEmpty()
    }

    override fun replaceContextReceiverArguments(newContextReceiverArguments: List<FirExpression>) {
        contextReceiverArguments = newContextReceiverArguments.toMutableOrEmpty()
    }

    override fun replaceTypeArguments(newTypeArguments: List<FirTypeProjection>) {
        typeArguments = newTypeArguments.toMutableOrEmpty()
    }

    override fun replaceExplicitReceiver(newExplicitReceiver: FirExpression?) {
        explicitReceiver = newExplicitReceiver
    }

    override fun replaceDispatchReceiver(newDispatchReceiver: FirExpression?) {
        dispatchReceiver = newDispatchReceiver
    }

    override fun replaceExtensionReceiver(newExtensionReceiver: FirExpression?) {
        extensionReceiver = newExtensionReceiver
    }

    @FirImplementationDetail
    override fun replaceSource(newSource: KtSourceElement?) {
        source = newSource
    }

    override fun replaceNonFatalDiagnostics(newNonFatalDiagnostics: List<ConeDiagnostic>) {
        nonFatalDiagnostics = newNonFatalDiagnostics.toMutableOrEmpty()
    }

    override fun replaceCalleeReference(newCalleeReference: FirNamedReference) {",calleeReference = newCalleeReference
"first.add(element)
                } else {
                    second.add(element)
                }
            }
            return Pair(first, second)
            """"""
        }

        specialFor(CharSequences, Strings) {
            doc {
                """"""
                Splits the original ${f.collection} into pair of ${f.collection}s,
                where *first* ${f.collection} contains characters for which [predicate] yielded `true`,
                while *second* ${f.collection} contains characters for which [predicate] yielded `false`.
                """"""
            }
            returns(""Pair<SELF, SELF>"")
        }
        body(CharSequences, Strings) {
            val toString = if (f == Strings) "".toString()"" else """"
            """"""
            val first = StringBuilder()
            val second = StringBuilder()
            for (element in this) {
                if (predicate(element)) {
                    first.append(element)
                } else {
                    second.append(element)
                }
            }
            return Pair(first$toString, second$toString)
            """"""
        }
    }

    val f_windowed_transform = fn(""windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R)"") {
        include(Iterables, Sequences, CharSequences)
    } builder {
        since(""1.2"")
        doc {
            """"""
            Returns a ${f.mapResult} of results of applying the given [transform] function to
            an each ${f.viewResult} representing a view over the window of the given [size]
            sliding along this ${f.collection} with the given [step].

            Note that the ${f.viewResult} passed to the [transform] function is ephemeral and is valid only inside that function.
            You should not store it or allow it to escape in some way, unless you made a snapshot of it.
            Several last ${f.viewResult.pluralize()} may have fewer ${f.element.pluralize()} than the given [size].

            Both [size] and [step] must be positive and can be greater than the number of elements in this ${f.collection}.
            @param size the number of elements to take in each window
            @param step the number of elements to move the window forward by on an each step, by default 1
            @param partialWindows controls whether or not to keep partial windows in the end if any,
            by default `false` which means partial windows won't be preserved
            """"""
        }
        sample(""samples.collections.Sequences.Transformations.averageWindows"")

        typeParam(""R"")
        returns(""List<R>"")

        body {
            """"""
            checkWindowSizeStep(size, step)",if (this is RandomAccess && this is List) {
"// TARGET_BACKEND: JVM

// WITH_REFLECT

import kotlin.reflect.*
import kotlin.reflect.full.*

class A {
    val foo: String = ""member""
    val Unit.foo: String get() = ""extension""
}

fun box(): String {
    run {
        val foo: KProperty1<A, *> = A::class.memberProperties.single()
        assert(foo.name == ""foo"") { ""Fail name: $foo (${foo.name})"" }
        assert(foo.get(A()) == ""member"") { ""Fail value: ${foo.get(A())}"" }
    }",run {
"// NI_EXPECTED_FILE

// FILE: a.kt
package a
    val foo = bar()

    fun bar() = <!DEBUG_INFO_MISSING_UNRESOLVED, TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM_ERROR!>foo<!>

// FILE: b.kt",package b
"@Another.Foo class ClassMarkedWithBar {
    class NonMarkedClass {
        class NonMarkedClass
        @Foo class ClassMarkedWithFoo
        @Bar class ClassMarkedWithAnotherFoo
        @Another.Foo class ClassMarkedWithBar
        @Another.Bar class ClassMarkedWithAnotherBar
    }
    @Foo class ClassMarkedWithFoo
    @Bar class ClassMarkedWithAnotherFoo
    @Another.Foo class ClassMarkedWithBar
    @Another.Bar class ClassMarkedWithAnotherBar
}
@Another.Bar class ClassMarkedWithAnotherBar {
    class NonMarkedClass {
        class NonMarkedClass
        @Foo class ClassMarkedWithFoo
        @Bar class ClassMarkedWithAnotherFoo
        @Another.Foo class ClassMarkedWithBar
        @Another.Bar class ClassMarkedWithAnotherBar
    }
    @Foo class ClassMarkedWithFoo
    @Bar class ClassMarkedWithAnotherFoo
    @Another.Foo class ClassMarkedWithBar
    @Another.Bar class ClassMarkedWithAnotherBar
}

class ClassWithConstructorMarkedWithFoo @Foo constructor()
class ClassWithConstructorMarkedWithAnotherFoo @Another.Foo constructor()
class ClassWithConstructorMarkedWithBar @Bar constructor()
class ClassWithConstructorMarkedWithAnotherBar @Another.Bar constructor()

fun nonMarkedFunction(): String = """"
@Foo fun functionMarkedWithFoo(): String = """"
@Bar fun functionMarkedWithAnotherFoo(): String = """"
@Another.Foo fun functionMarkedWithBar(): String = """"
@Another.Bar fun functionMarkedWithAnotherBar(): String = """"

var nonMarkedProperty: String get() = """"
    set(_) = Unit

@Foo var propertyWholeMarkedWithFoo: String get() = """"
    set(_) = Unit
@Another.Foo var propertyWholeMarkedWithAnotherFoo: String get() = """"
    set(_) = Unit
@Bar var propertyWholeMarkedWithBar: String get() = """"
    set(_) = Unit
@Another.Bar var propertyWholeMarkedWithAnotherBar: String get() = """"
    set(_) = Unit

var propertyGetterMarkedWithFoo: String @Foo get() = """"
    set(_) = Unit
var propertyGetterMarkedWithAnotherFoo: String @Another.Foo get() = """"
    set(_) = Unit
var propertyGetterMarkedWithBar: String @Bar get() = """"
    set(_) = Unit
var propertyGetterMarkedWithAnotherBar: String @Another.Bar get() = """"
    set(_) = Unit

var propertySetterMarkedWithFoo: String get() = """"
    @Foo set(_) = Unit
var propertySetterMarkedWithAnotherFoo: String get() = """"
    @Another.Foo set(_) = Unit
var propertySetterMarkedWithBar: String get() = """"
    @Bar set(_) = Unit","var propertySetterMarkedWithAnotherBar: String get() = """""
"// WITH_STDLIB
// WITH_COROUTINES
import helpers.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*

class Controller {
    suspend fun suspendHere(): String = suspendCoroutineUninterceptedOrReturn { x ->
        x.resume(""OK"")",COROUTINE_SUSPENDED
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.resolve.calls

import org.jetbrains.kotlin.config.LanguageFeature.ForbidSyntheticPropertiesWithoutBaseJavaGetter
import org.jetbrains.kotlin.fir.*
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.declarations.synthetic.FirSyntheticProperty
import org.jetbrains.kotlin.fir.declarations.synthetic.buildSyntheticProperty",import org.jetbrains.kotlin.fir.declarations.utils.isStatic
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""PackageDirectoryMismatch"") // Old package for compatibility
package org.jetbrains.kotlin.gradle.plugin.mpp

import org.jetbrains.kotlin.gradle.plugin.hierarchy.KotlinSourceSetTreeClassifier
import org.jetbrains.kotlin.gradle.plugin.hierarchy.KotlinSourceSetTreeClassifier.Property
import org.jetbrains.kotlin.gradle.plugin.hierarchy.sourceSetTreeClassifier
import org.jetbrains.kotlin.gradle.plugin.mpp.compilationImpl.DefaultKotlinCompilationFriendPathsResolver
import org.jetbrains.kotlin.gradle.plugin.mpp.compilationImpl.DefaultKotlinCompilationPreConfigure
import org.jetbrains.kotlin.gradle.plugin.mpp.compilationImpl.KotlinAndroidCompilationAssociator
import org.jetbrains.kotlin.gradle.plugin.mpp.compilationImpl.KotlinCompilationLanguageSettingsConfigurator
import org.jetbrains.kotlin.gradle.plugin.mpp.compilationImpl.factory.AndroidCompilationSourceSetsContainerFactory
import org.jetbrains.kotlin.gradle.plugin.mpp.compilationImpl.factory.KotlinCompilationImplFactory
import org.jetbrains.kotlin.gradle.plugin.mpp.compilationImpl.factory.KotlinJvmCompilerOptionsFactory
import org.jetbrains.kotlin.gradle.plugin.sources.android.AndroidVariantType
import org.jetbrains.kotlin.gradle.plugin.sources.android.type
import org.jetbrains.kotlin.gradle.utils.*

class KotlinJvmAndroidCompilationFactory internal constructor(
    override val target: KotlinAndroidTarget,
    @Suppress(""TYPEALIAS_EXPANSION_DEPRECATION"") private val variant: DeprecatedAndroidBaseVariant,
) : KotlinCompilationFactory<KotlinJvmAndroidCompilation> {

    override val itemClass: Class<KotlinJvmAndroidCompilation>
        get() = KotlinJvmAndroidCompilation::class.java

    private val compilationImplFactory: KotlinCompilationImplFactory = KotlinCompilationImplFactory(
        compilerOptionsFactory = KotlinJvmCompilerOptionsFactory,
        compilationFriendPathsResolver = DefaultKotlinCompilationFriendPathsResolver(
            friendArtifactResolver = DefaultKotlinCompilationFriendPathsResolver.FriendArtifactResolver.composite(
                DefaultKotlinCompilationFriendPathsResolver.DefaultFriendArtifactResolver,
                DefaultKotlinCompilationFriendPathsResolver.AdditionalAndroidFriendArtifactResolver
            )
        ),
        compilationAssociator = KotlinAndroidCompilationAssociator,
        compilationSourceSetsContainerFactory = AndroidCompilationSourceSetsContainerFactory(target, variant),
        preConfigureAction = if (target.isMultiplatformProject) {
            DefaultKotlinCompilationPreConfigure",} else {
"<!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<T>"")!>it<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<T>"")!>it<!>.ip1test1()
        }
    }
}

// TESTCASE NUMBER: 26
fun <T : InterfaceWithTypeParameter1<T>> case_26(x: InterfaceWithTypeParameter1<in T>?) {
    if (x != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T> & InterfaceWithTypeParameter1<in T>?"")!>x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T> & InterfaceWithTypeParameter1<in T>?"")!>x<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T> & InterfaceWithTypeParameter1<in T>?"")!>x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T> & InterfaceWithTypeParameter1<in T>?"")!>x<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T> & InterfaceWithTypeParameter1<in T>?"")!>x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T> & InterfaceWithTypeParameter1<in T>?"")!>x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T> & InterfaceWithTypeParameter1<in T>?"")!>x<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T> & InterfaceWithTypeParameter1<in T>?"")!>x<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T> & InterfaceWithTypeParameter1<in T>?"")!>x<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T> & InterfaceWithTypeParameter1<in T>?"")!>x<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T> & InterfaceWithTypeParameter1<in T>?"")!>x<!>.ip1test1()

        x.equals(null)

        x.propT

        x.propAny

        x.propNullableT

        x.propNullableAny

        x.funT()

        x.funAny()

        x.funNullableT()

        x.funNullableAny()
        x.ip1test1()
        x.apply {
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>""), DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>this<!>
            equals(null)
            propT
            propAny
            propNullableT
            propNullableAny
            funT()
            funAny()
            funNullableT()
            funNullableAny()
            ip1test1()
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>""), DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>this<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>""), DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>this<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>""), DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>this<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>""), DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>this<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>""), DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>this<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>""), DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>this<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>""), DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>this<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>""), DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>this<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>""), DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>this<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>""), DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>this<!>.ip1test1()
        }
        x.also {
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>it<!>
            <!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>it<!>.equals(null)","<!DEBUG_INFO_EXPRESSION_TYPE(""InterfaceWithTypeParameter1<in T>"")!>it<!>.propT"
package app,"fun linuxX64Test() = ""test"""
"if (<!SENSELESS_COMPARISON!>v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.funAny()
        if (<!SENSELESS_COMPARISON!>v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.funNullableT()
        if (<!SENSELESS_COMPARISON!>v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.funNullableAny()
        if (<!SENSELESS_COMPARISON!>v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>
        if (<!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.equals(null)
        if (<!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.propT
        if (<!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.propAny
        if (<!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.propNullableT
        if (<!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.propNullableAny
        if (<!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.funT()
        if (<!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.funAny()
        if (<!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.funNullableT()
        if (<!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.funNullableAny()
        if (<!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.equals(null)
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.propT
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.propAny
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.propNullableT
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.propNullableAny
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.funT()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>v<!>.funAny()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.funNullableT()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>.funNullableAny()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>v<!>
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.equals(null)
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.propT
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.propAny
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>.propNullableT
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>.propNullableAny
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.funT()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int""), DEBUG_INFO_SMARTCAST!>this.v<!>.funAny()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>.funNullableT()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>.funNullableAny()
        if (<!SENSELESS_COMPARISON!>v != null<!> || <!SENSELESS_COMPARISON!>this.v != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>this.v<!>

        w = if (<!SENSELESS_COMPARISON!>null != null<!>) 10 else null
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.equals(null)
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propT
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propAny
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableT
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableAny
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funT()
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funAny()
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableT()
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableAny()
        if (w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.equals(null)
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propT
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propAny
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableT
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableAny
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funT()
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funAny()
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableT()
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableAny()
        if (this.w != null) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.equals(null)
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propT
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.propAny
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableT
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.propNullableAny
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funT()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?""), DEBUG_INFO_SMARTCAST!>w<!>.funAny()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableT()
        if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>.funNullableAny()","if (w != null || <!SENSELESS_COMPARISON!>this.w != null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!>w<!>"
"import kotlin.test.*


class UnsignedArraysTest {

    @Test
    fun collectionBehavior() {
        compare(listOf<UByte>(), ubyteArrayOf()) { collectionBehavior() }
        compare(listOf<UShort>(1u), ushortArrayOf(1u)) { collectionBehavior() }
        compare(listOf<UInt>(1u, 2u), uintArrayOf(1u, 2u)) { collectionBehavior() }
        compare(listOf<ULong>(1u, 2u, 3u), ulongArrayOf(1u, 2u, 3u)) { collectionBehavior() }
    }

    @Test
    fun ubyteArrayInit() {
        val zeroArray = UByteArray(42)
        assertEquals(42, zeroArray.size)
        for (index in zeroArray.indices) {
            assertEquals(0u, zeroArray[index])
        }

        val initArray = UByteArray(42) { it.toUByte() }
        for (index in initArray.indices) {
            assertEquals(index.toUByte(), initArray[index])
        }
    }

    @Test
    fun ushortArrayInit() {
        val zeroArray = UShortArray(42)
        assertEquals(42, zeroArray.size)
        for (index in zeroArray.indices) {
            assertEquals(0u, zeroArray[index])
        }

        val initArray = UShortArray(42) { it.toUShort() }
        for (index in initArray.indices) {
            assertEquals(index.toUShort(), initArray[index])
        }
    }

    @Test
    fun uintArrayInit() {
        val zeroArray = UIntArray(42)
        assertEquals(42, zeroArray.size)
        for (index in zeroArray.indices) {
            assertEquals(0u, zeroArray[index])
        }

        val initArray = UIntArray(42) { it.toUInt() }
        for (index in initArray.indices) {
            assertEquals(index.toUInt(), initArray[index])
        }
    }

    @Test
    fun ulongArrayInit() {
        val zeroArray = ULongArray(42)
        assertEquals(42, zeroArray.size)
        for (index in zeroArray.indices) {
            assertEquals(0u, zeroArray[index])
        }

        val initArray = ULongArray(42) { it.toULong() }
        for (index in initArray.indices) {","assertEquals(index.toULong(), initArray[index])"
"// EXPECTED_REACHABLE_NODES: 1285
package foo

var global: String = """"

class A {
    var prop: Int = 0
}

fun bar(s: String, index: Int): Int {
    global += s
    return index
}

val baz: Int
    get() {
        global += "":baz:""; return 1
    }

fun box(): String {
    val a = arrayOf(0,1,2,3)


    global = """"","a[bar(""A"", 1)] = try { global += ""B""; 10 } finally {}"
"// WITH_STDLIB
// WORKS_WHEN_VALUE_CLASS
// LANGUAGE: +ValueClasses
// JVM_ABI_K1_K2_DIFF: KT-63864

interface IFooList {
    fun foo(): List<String>
}

interface IFooMutableList {
    fun foo(): MutableList<String>
}

OPTIONAL_JVM_INLINE_ANNOTATION
value class AL(val t: MutableList<String>) : MutableList<String> {
    override val size: Int get() = t.size
    override fun get(index: Int): String = t.get(index)
    override fun set(index: Int, element: String): String = t.set(index, element)
    override fun contains(element: String): Boolean = t.contains(element)
    override fun containsAll(elements: Collection<String>): Boolean = t.containsAll(elements)
    override fun indexOf(element: String): Int = t.indexOf(element)
    override fun isEmpty(): Boolean = t.isEmpty()
    override fun iterator(): MutableIterator<String> = t.iterator()
    override fun lastIndexOf(element: String): Int = t.lastIndexOf(element)
    override fun add(element: String): Boolean = t.add(element)
    override fun add(index: Int, element: String) = t.add(index, element)
    override fun addAll(index: Int, elements: Collection<String>): Boolean = t.addAll(index, elements)
    override fun addAll(elements: Collection<String>): Boolean = t.addAll(elements)
    override fun listIterator(): MutableListIterator<String> = t.listIterator()
    override fun listIterator(index: Int): MutableListIterator<String> = t.listIterator(index)
    override fun clear() { t.clear() }
    override fun remove(element: String): Boolean = t.remove(element)
    override fun removeAll(elements: Collection<String>): Boolean = t.removeAll(elements)
    override fun removeAt(index: Int): String = t.removeAt(index)
    override fun retainAll(elements: Collection<String>): Boolean = t.retainAll(elements)
    override fun subList(fromIndex: Int, toIndex: Int): MutableList<String> = t.subList(fromIndex, toIndex)
}

class Test : IFooList, IFooMutableList {
    val arr = arrayListOf<String>()
    override fun foo() = AL(arr)
}

fun box(): String {
    val t1: IFooList = Test()
    val list1 = t1.foo()
    if (list1 !is AL) throw AssertionError(""list1: $list1"")

    val t2: IFooMutableList = Test()
    val list2 = t2.foo()","if (list2 !is AL) throw AssertionError(""list2: $list2"")"
"}

        val runtimeKlibsNames =
            listOfNotNull(
                System.getProperty(""kotlin.wasm$suffix.stdlib.path"")!!,
                System.getProperty(""kotlin.wasm$suffix.kotlin.test.path"")!!
            ).map {
                File(it).absolutePath
            }

        val runtimeKlibs = loadKlib(JsFactories, runtimeKlibsNames, configuration)
        val transitiveLibraries = getDependencies(module, testServices, DependencyRelation.RegularDependency)
        val friendLibraries = getDependencies(module, testServices, DependencyRelation.FriendDependency)
        val allDependencies = runtimeKlibs + dependencyDescriptors + friendLibraries + friendsDescriptors + transitiveLibraries

        val builtInModuleDescriptor = allDependencies.firstNotNullOfOrNull { it.builtIns }?.builtInsModule
        val analyzerFacade = TopDownAnalyzerFacadeForWasm.facadeFor(configuration.get(WasmConfigurationKeys.WASM_TARGET))

        return analyzerFacade.analyzeFiles(
            files,
            project,
            configuration,
            allDependencies,
            friendsDescriptors + friendLibraries,
            compilerEnvironment,
            thisIsBuiltInsModule = builtInModuleDescriptor == null,
            customBuiltInsModule = builtInModuleDescriptor
        )
    }

    private fun performNativeModuleResolve(
        module: TestModule,
        project: Project,
        configuration: CompilerConfiguration,
        compilerEnvironment: TargetEnvironment,
        files: List<KtFile>,
        dependencyDescriptors: List<ModuleDescriptorImpl>,
        friendsDescriptors: List<ModuleDescriptorImpl>,
        dependsOnDescriptors: List<ModuleDescriptorImpl>,
    ): AnalysisResult {
        val moduleTrace = NoScopeRecordCliBindingTrace(project)
        val runtimeKlibsNames = NativeEnvironmentConfigurator.getRuntimePathsForModule(module, testServices)
        val nativeFactories = KlibMetadataFactories(::KonanBuiltIns, NullFlexibleTypeDeserializer)
        val runtimeKlibs = loadKlib(nativeFactories, runtimeKlibsNames, configuration).mapNotNull { it as? ModuleDescriptorImpl }
        val stdlibBuiltInsModule = runtimeKlibs.single { it.name == Name.special(""<stdlib>"") }.builtIns.builtInsModule

        val moduleContext = createModuleContext(
            module, project,
            dependencyDescriptors = dependencyDescriptors + runtimeKlibs,
            friendsDescriptors = friendsDescriptors,
            dependsOnDescriptors = dependsOnDescriptors,
            capabilities = mapOf(
                // provides `klibModuleOrigin` capability needed in `ModuleDescriptor.isFromInteropLibrary()`
                KlibModuleOrigin.CAPABILITY to CurrentKlibModuleOrigin,
            ),
        ) {
            KonanBuiltIns(it).apply {
                builtInsModule = stdlibBuiltInsModule
            }
        }
        return FakeTopDownAnalyzerFacadeForNative.analyzeFilesWithGivenTrace(
            files,
            moduleTrace,
            moduleContext,
            module.languageVersionSettings,",compilerEnvironment
"// Please make sure that this test is consistent with the blackbox test ""annotationsOnNonExistentAccessors.kt""

import kotlin.reflect.KProperty

annotation class Ann
annotation class AnnRepeat

class Foo(
    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!> private val y0: Int,
    <!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!> private vararg val y1: String
) {",<!ANNOTATION_TARGETS_NON_EXISTENT_ACCESSOR!>@get:Ann<!>
"// FIR_IDENTICAL
// !DIAGNOSTICS: -UNUSED_PARAMETER
// JSR305_GLOBAL_REPORT: warn

// KT-6829 False warning on map to @Nullable

// FILE: J.java
public class J {",@MyNullable
"body.buildStructNew(context.referenceGcType(klassSymbol), location)
        body.commentPreviousInstr { ""box"" }
    }

    private fun generateCall(call: IrFunctionAccessExpression) {
        val location = call.getSourceLocation()

        // Box intrinsic has an additional klass ID argument.
        // Processing it separately
        if (call.symbol == wasmSymbols.boxBoolean) {
            generateBox(call.getValueArgument(0)!!, irBuiltIns.booleanType)
            return
        }
        if (call.symbol == wasmSymbols.boxIntrinsic) {
            val type = call.getTypeArgument(0)!!
            if (type == irBuiltIns.booleanType) {
                generateExpression(call.getValueArgument(0)!!)
                body.buildCall(context.referenceFunction(context.backendContext.wasmSymbols.getBoxedBoolean), location)
            } else {
                generateBox(call.getValueArgument(0)!!, type)
            }
            return
        }

        // Some intrinsics are a special case because we want to remove them completely, including their arguments.
        if (!backendContext.configuration.getNotNull(WasmConfigurationKeys.WASM_ENABLE_ARRAY_RANGE_CHECKS)) {
            if (call.symbol == wasmSymbols.rangeCheck) {
                body.buildGetUnit()
                return
            }
        }
        if (!backendContext.configuration.getNotNull(WasmConfigurationKeys.WASM_ENABLE_ASSERTS)) {
            if (call.symbol in wasmSymbols.assertFuncs) {
                body.buildGetUnit()
                return
            }
        }

        val function: IrFunction = call.symbol.owner.realOverrideTarget

        call.dispatchReceiver?.let { generateExpression(it) }
        call.extensionReceiver?.let { generateExpression(it) }
        for (i in 0 until call.valueArgumentsCount) {
            generateExpression(call.getValueArgument(i)!!)
        }

        if (tryToGenerateIntrinsicCall(call, function)) {
            if (function.returnType.isUnit())
                body.buildGetUnit()
            return
        }

        // We skip now calling any ctor because it is empty
        if (function.symbol.owner.hasWasmPrimitiveConstructorAnnotation()) return

        val isSuperCall = call is IrCall && call.superQualifierSymbol != null
        if (function is IrSimpleFunction && function.isOverridable && !isSuperCall) {
            // Generating index for indirect call
            val klass = function.parentAsClass
            if (!klass.isInterface) {
                val classMetadata = context.getClassMetadata(klass.symbol)
                val vfSlot = classMetadata.virtualMethods.indexOfFirst { it.function == function }
                // Dispatch receiver should be simple and without side effects at this point
                // TODO: Verify
                val receiver = call.dispatchReceiver!!",generateExpression(receiver)
"// FIR_IDENTICAL
sealed class Sealed(val x: Int) {
    object First: Sealed(12)
    open class NonFirst(x: Int, val y: Int): Sealed(x) {
        object Second: NonFirst(34, 2)","object Third: NonFirst(56, 3)"
"|2 [1.0] #0[1.0]
        |${'\t'}/some/path/libb.klib
        |
        """""".trimMargin()

        ResolvedDependenciesSupport.deserialize(originalText) { lineNo, _ ->
            assertEquals(3, lineNo)
            throw MyException()
        }

        fail()
    }

    @Test(expected = MyException::class)
    fun failure3() {
        // Version not specified.
        val originalText = """"""
        |0 \
        |1 org.sample:liba,org.sample:liba-native[2.0] #0[2.0] #2[1.0]
        |${'\t'}/some/path/liba.klib
        |2 org.sample:libb,org.sample:libb-native #0[1.0]
        |${'\t'}/some/path/libb.klib
        |
        """""".trimMargin()

        ResolvedDependenciesSupport.deserialize(originalText) { lineNo, _ ->
            assertEquals(3, lineNo)
            throw MyException()
        }

        fail()
    }

    @Test(expected = MyException::class)
    fun failure4() {
        // Source code module ID not specified.
        val originalText = """"""
        |0
        |1 org.sample:liba,org.sample:liba-native[2.0] #0[2.0] #2[1.0]
        |${'\t'}/some/path/liba.klib
        |2 org.sample:libb,org.sample:libb-native #0[1.0]
        |${'\t'}/some/path/libb.klib
        |
        """""".trimMargin()

        ResolvedDependenciesSupport.deserialize(originalText) { lineNo, _ ->
            assertEquals(0, lineNo)
            throw MyException()
        }

        fail()
    }

    @Test(expected = MyException::class)
    fun failure5() {
        // Source code module ID not specified.
        val originalText = """"""
        |1 org.sample:liba,org.sample:liba-native[2.0] #0[2.0] #2[1.0]
        |${'\t'}/some/path/liba.klib
        |2 org.sample:libb,org.sample:libb-native #0[1.0]
        |${'\t'}/some/path/libb.klib
        |
        """""".trimMargin()

        ResolvedDependenciesSupport.deserialize(originalText) { lineNo, _ ->","assertEquals(0, lineNo)"
"package org.jetbrains.kotlin

import com.google.gson.annotations.Expose
import java.io.PrintWriter
import java.io.StringWriter",import org.gradle.api.Project
"}

        return null
    }

    private fun generateWhen(
        startOffset: Int,
        endOffset: Int,
        origin: IrStatementOrigin?,
        subjectVariable: IrVariable?,
        branches: List<IrBranch>,
        resultType: IrType
    ): IrExpression {
        // Note: ELVIS origin is set only on wrapping block
        val irWhen = IrWhenImpl(startOffset, endOffset, resultType, origin.takeIf { it != IrStatementOrigin.ELVIS }, branches)
        return if (subjectVariable == null) {
            irWhen
        } else {
            IrBlockImpl(startOffset, endOffset, irWhen.type, origin, listOf(subjectVariable, irWhen))
        }
    }

    private fun generateWhenSubjectVariable(whenExpression: FirWhenExpression): IrVariable? {
        val subjectVariable = whenExpression.subjectVariable
        val subjectExpression = whenExpression.subject
        return when {
            subjectVariable != null -> subjectVariable.accept(this, null) as IrVariable
            subjectExpression != null -> {
                applyParentFromStackTo(callablesGenerator.declareTemporaryVariable(convertToIrExpression(subjectExpression), ""subject""))
            }
            else -> null
        }
    }

    private fun FirWhenBranch.toIrWhenBranch(whenExpressionType: ConeKotlinType): IrBranch {
        return convertWithOffsets { startOffset, _ ->
            val condition = condition
            val irResult = convertToIrExpression(result).insertImplicitCast(result, result.resolvedType, whenExpressionType)
            if (condition is FirElseIfTrueCondition) {
                IrElseBranchImpl(IrConstImpl.boolean(irResult.startOffset, irResult.endOffset, irBuiltIns.booleanType, true), irResult)
            } else {
                IrBranchImpl(startOffset, irResult.endOffset, convertToIrExpression(condition), irResult)
            }
        }
    }

    override fun visitWhenSubjectExpression(whenSubjectExpression: FirWhenSubjectExpression, data: Any?): IrElement {
        val lastSubjectVariable = conversionScope.lastWhenSubject()
        return whenSubjectExpression.convertWithOffsets { startOffset, endOffset ->
            IrGetValueImpl(startOffset, endOffset, lastSubjectVariable.type, lastSubjectVariable.symbol)
        }
    }

    private val loopMap = mutableMapOf<FirLoop, IrLoop>()

    override fun visitDoWhileLoop(doWhileLoop: FirDoWhileLoop, data: Any?): IrElement {
        val irLoop = doWhileLoop.convertWithOffsets { startOffset, endOffset ->
            IrDoWhileLoopImpl(
                startOffset, endOffset, irBuiltIns.unitType,
                IrStatementOrigin.DO_WHILE_LOOP
            ).apply {
                loopMap[doWhileLoop] = this
                label = doWhileLoop.label?.name
                body = runUnless(doWhileLoop.block is FirEmptyExpressionBlock) {
                    Fir2IrImplicitCastInserter.coerceToUnitIfNeeded(","doWhileLoop.block.convertToIrExpressionOrBlock(origin),"
"modifier.applySetup(setupFile)

        localPropertiesFile.propertiesFileContentAssertions { fileContents, properties ->
            assertContainsMarkersOnce(fileContents)
            val expectedProperties = setupFile.properties + initialContent.mapValues { it.value.value }
            assertEquals(expectedProperties.size, properties.size)
            for ((key, value) in expectedProperties) {
                assertEquals(value, properties[key])
            }
            assertContainsExactTimes(fileContents, ""#alreadySetProperty=newValue the property is overridden by 'oldValue3'"", 1)
        }
    }

    /**
     * Checks that a file like
     * ```
     * a=1
     * b=2
     * c=3
     * #header
     * d=4
     * #footer
     * e=5
     * ```
     * is being transformed into
     * ```
     * a=1
     * b=2
     * c=3
     * e=5
     * #header
     * d=10
     * #footer
     * ```
     */
    @Test
    @DisplayName(""sync should override automatically set properties"")
    fun testSyncingOverrideAutomaticallySetValues() {
        val initialContent = mapOf(
            ""oldProperty1"" to PropertyValue.Configured(""oldValue1""),
            ""oldProperty2"" to PropertyValue.Configured(""oldValue2""),
            ""alreadySetProperty"" to PropertyValue.Configured(""oldValue3""),
        )
        fillInitialLocalPropertiesFile(initialContent)

        modifier.applySetup(setupFile)

        val newProperties = mapOf(
            ""newManualProperty"" to PropertyValue.Configured(""5""),
            ""otherAlreadySetProperty"" to PropertyValue.Configured(""5""),
        )
        fillInitialLocalPropertiesFile(newProperties)

        val anotherSetupFile = SetupFile(
            mapOf(
                ""newProperty2"" to ""other"", // a new value
                ""newProperty3"" to ""someOtherValue"", // a new record
                ""otherAlreadySetProperty"" to ""someOtherValue"",
            )
        )

        modifier.applySetup(anotherSetupFile)

        localPropertiesFile.propertiesFileContentAssertions { fileContents, properties ->
            assertContainsMarkersOnce(fileContents)",val expectedProperties =
"fun foo() {
    a?.b++",a?.b?.c++
"}
}

@JvmInline
value class S(val x1: String, val x2: String) {
    var nonNullTest: Z
        get() = Z(global.x1 + x1.toUInt(), global.x2 + x2.toInt())
        set(value) {
            global = Z(this.x1.toUInt() + value.x1, this.x2.toInt() + value.x2)
        }

    var nullableTest: Z?
        get() = Z(global.x1 + x1.toUInt(), global.x2 + x2.toInt())
        set(value) {
            global = Z(this.x1.toUInt() + value!!.x1, this.x2.toInt() + value!!.x2)
        }
}

@JvmInline
value class A(val x1: Any, val x2: Any) {
    var nonNullTest: Z
        get() = Z(global.x1 + this.x1 as UInt, global.x2 + this.x2 as Int)
        set(value) {
            global = Z(this.x1 as UInt + value.x1, this.x2 as Int + value.x2)
        }

    var nullableTest: Z?
        get() = Z(global.x1 + this.x1 as UInt, global.x2 + this.x2 as Int)
        set(value) {
            global = Z(this.x1 as UInt + value!!.x1, this.x2 as Int + value!!.x2)
        }

}

fun box(): String {
    val zZero = Z(0U, 0)
    val zOne = Z(1U, -1)
    val zTwo = Z(2U, -2)
    val zThree = Z(3U, -3)
    val zFour = Z(4U, -4)

    val sOne = S(""1"", ""-1"")

    val aOne = A(1U, -1)

    global = zZero
    assertEquals(zOne, Z::nonNullTest.call(zOne))
    assertEquals(zOne, zOne::nonNullTest.call())
    assertEquals(zOne, Z::nonNullTest.getter.call(zOne))
    assertEquals(zOne, zOne::nonNullTest.getter.call())
    Z::nonNullTest.setter.call(zOne, zTwo)
    assertEquals(zThree, global)
    zOne::nonNullTest.setter.call(zThree)
    assertEquals(zFour, global)

    global = zZero
    assertEquals(zOne, Z::nullableTest.call(zOne))
    assertEquals(zOne, zOne::nullableTest.call())
    assertEquals(zOne, Z::nullableTest.getter.call(zOne))
    assertEquals(zOne, zOne::nullableTest.getter.call())
    Z::nullableTest.setter.call(zOne, zTwo)
    assertEquals(zThree, global)
    zOne::nullableTest.setter.call(zThree)
    assertEquals(zFour, global)",global = zZero
"// EXPECTED_REACHABLE_NODES: 1282
package foo

// CHECK_LABELS_COUNT: function=box name=block count=2

fun box(): String {
    var i = 0
    var j = 0

    js(""""""
        block: {
            i++;",break block;
"}
                        else -> typeRef
                    }
                    containingFunctionSymbol = constructorSymbol
                    name = field.name
                    annotationBuilder = { emptyList() }
                    isVararg = false
                    isFromSource = true
                }
            }
        }

        return builder.build().apply {
            containingClassForStaticMemberAttr = classSymbol.toLookupTag()
        }
    }
}

private class JavaTypeParameterStub(val original: JavaTypeParameter) : JavaTypeParameter {
    override val name: Name
        get() = original.name
    override val isFromSource: Boolean
        get() = true
    override val annotations: Collection<JavaAnnotation>
        get() = original.annotations
    override val isDeprecatedInJavaDoc: Boolean
        get() = original.isDeprecatedInJavaDoc

    override fun findAnnotation(fqName: FqName): JavaAnnotation? {
        return original.findAnnotation(fqName)
    }

    override val upperBounds: Collection<JavaClassifierType>
        get() = original.upperBounds
}

private class JavaClassifierTypeStub(
    val original: JavaClassifierType,
    override val typeArguments: List<JavaType?>,
) : JavaClassifierType {
    override val annotations: Collection<JavaAnnotation>
        get() = original.annotations
    override val isDeprecatedInJavaDoc: Boolean
        get() = original.isDeprecatedInJavaDoc
    override val classifier: JavaClassifier?
        get() = original.classifier
    override val isRaw: Boolean
        get() = original.isRaw
    override val classifierQualifiedName: String
        get() = original.classifierQualifiedName
    override val presentableText: String
        get() = original.presentableText
}

private class JavaTypeParameterTypeStub(
    override val classifier: JavaTypeParameter
) : JavaClassifierType {
    override val annotations: Collection<JavaAnnotation>
        get() = emptyList()
    override val isDeprecatedInJavaDoc: Boolean
        get() = false
    override val typeArguments: List<JavaType?>
        get() = emptyList()
    override val isRaw: Boolean
        get() = false",override val classifierQualifiedName: String
"val SAMPLER_CUBE: Int
        val VERTEX_ATTRIB_ARRAY_ENABLED: Int
        val VERTEX_ATTRIB_ARRAY_SIZE: Int
        val VERTEX_ATTRIB_ARRAY_STRIDE: Int
        val VERTEX_ATTRIB_ARRAY_TYPE: Int
        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int
        val VERTEX_ATTRIB_ARRAY_POINTER: Int
        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int
        val IMPLEMENTATION_COLOR_READ_TYPE: Int
        val IMPLEMENTATION_COLOR_READ_FORMAT: Int
        val COMPILE_STATUS: Int
        val LOW_FLOAT: Int
        val MEDIUM_FLOAT: Int
        val HIGH_FLOAT: Int
        val LOW_INT: Int
        val MEDIUM_INT: Int
        val HIGH_INT: Int
        val FRAMEBUFFER: Int
        val RENDERBUFFER: Int
        val RGBA4: Int
        val RGB5_A1: Int
        val RGB565: Int
        val DEPTH_COMPONENT16: Int
        val STENCIL_INDEX: Int
        val STENCIL_INDEX8: Int
        val DEPTH_STENCIL: Int
        val RENDERBUFFER_WIDTH: Int
        val RENDERBUFFER_HEIGHT: Int
        val RENDERBUFFER_INTERNAL_FORMAT: Int
        val RENDERBUFFER_RED_SIZE: Int
        val RENDERBUFFER_GREEN_SIZE: Int
        val RENDERBUFFER_BLUE_SIZE: Int
        val RENDERBUFFER_ALPHA_SIZE: Int
        val RENDERBUFFER_DEPTH_SIZE: Int
        val RENDERBUFFER_STENCIL_SIZE: Int
        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int
        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int
        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int
        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int
        val COLOR_ATTACHMENT0: Int
        val DEPTH_ATTACHMENT: Int
        val STENCIL_ATTACHMENT: Int
        val DEPTH_STENCIL_ATTACHMENT: Int
        val NONE: Int
        val FRAMEBUFFER_COMPLETE: Int
        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int
        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int
        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int
        val FRAMEBUFFER_UNSUPPORTED: Int
        val FRAMEBUFFER_BINDING: Int
        val RENDERBUFFER_BINDING: Int
        val MAX_RENDERBUFFER_SIZE: Int
        val INVALID_FRAMEBUFFER_OPERATION: Int
        val UNPACK_FLIP_Y_WEBGL: Int
        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int
        val CONTEXT_LOST_WEBGL: Int
        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int
        val BROWSER_DEFAULT_WEBGL: Int
    }
}

/**
 * Exposes the JavaScript [WebGLContextEvent](https://developer.mozilla.org/en/docs/Web/API/WebGLContextEvent) to Kotlin
 */
public external open class WebGLContextEvent(type: String, eventInit: WebGLContextEventInit = definedExternally) : Event, JsAny {",open val statusMessage: String
"}

//TESTCASE NUMBER: 18
fun case_18(a: DeepObject.A.B.C.D.E.F.G.J?) {
    if (a != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J & DeepObject.A.B.C.D.E.F.G.J?"")!>a<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J & DeepObject.A.B.C.D.E.F.G.J?""), DEBUG_INFO_SMARTCAST!>a<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J & DeepObject.A.B.C.D.E.F.G.J?""), DEBUG_INFO_SMARTCAST!>a<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J & DeepObject.A.B.C.D.E.F.G.J?""), DEBUG_INFO_SMARTCAST!>a<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J & DeepObject.A.B.C.D.E.F.G.J?"")!>a<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J & DeepObject.A.B.C.D.E.F.G.J?"")!>a<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J & DeepObject.A.B.C.D.E.F.G.J?""), DEBUG_INFO_SMARTCAST!>a<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J & DeepObject.A.B.C.D.E.F.G.J?""), DEBUG_INFO_SMARTCAST!>a<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J & DeepObject.A.B.C.D.E.F.G.J?"")!>a<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J & DeepObject.A.B.C.D.E.F.G.J?"")!>a<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 19
fun case_19(b: Boolean) {
    val a = if (b) {
        object {
            val B19 = if (b) {
                object {
                    val C19 = if (b) {
                        object {
                            val D19 = if (b) {
                                object {
                                    val x: Number? = 10
                                }
                            } else null
                        }
                    } else null
                }
            } else null
        }
    } else null

    if (a != null && <!DEBUG_INFO_SMARTCAST!>a<!>.B19 != null && <!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19 != null && <!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19 != null && <!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 20
fun case_20(b: Boolean) {
    val a = object {
        val B19 = object {
            val C19 = object {
                val D19 =  if (b) {
                    object {}
                } else null
            }
        }
    }

    if (a.B19.C19.D19 !== null) {","<!DEBUG_INFO_EXPRESSION_TYPE(""case_20.`<no name provided>`.B19.`<no name provided>`.C19.`<no name provided>`.D19.`<no name provided>` & case_20.`<no name provided>`.B19.`<no name provided>`.C19.`<no name provided>`.D19.`<no name provided>`?"")!>a.B19.C19.D19<!>"
"// FILE: 1.kt

package test

interface A {
    fun run()
}

class B(val o: String, val k: String) {

    inline fun testNested(crossinline f: (String) -> Unit, crossinline f2: (String) -> Unit) {
        object : A {
            override fun run() {
                f(o)
                f2(k)
            }
        }.run()
    }

    inline fun test(crossinline f: (String) -> Unit) {
        call {
            {
                testNested ({ it -> { f(it + o) }.let { it() } }) { it -> { f(it + k) }.let { it() } }
            }.let { it() }
        }
    }",inline fun call(f: () -> Unit) {
"total += A376.a
    total += A377.a
    total += A378.a
    total += A379.a
    total += A380.a
    total += A381.a
    total += A382.a
    total += A383.a
    total += A384.a
    total += A385.a
    total += A386.a
    total += A387.a
    total += A388.a
    total += A389.a
    total += A390.a
    total += A391.a
    total += A392.a
    total += A393.a
    total += A394.a
    total += A395.a
    total += A396.a
    total += A397.a
    total += A398.a
    total += A399.a
    total += A400.a
    total += A401.a
    total += A402.a
    total += A403.a
    total += A404.a
    total += A405.a
    total += A406.a
    total += A407.a
    total += A408.a
    total += A409.a
    total += A410.a
    total += A411.a
    total += A412.a
    total += A413.a
    total += A414.a
    total += A415.a
    total += A416.a
    total += A417.a
    total += A418.a
    total += A419.a
    total += A420.a
    total += A421.a
    total += A422.a
    total += A423.a
    total += A424.a
    total += A425.a
    total += A426.a
    total += A427.a
    total += A428.a
    total += A429.a
    total += A430.a
    total += A431.a
    total += A432.a
    total += A433.a
    total += A434.a
    total += A435.a
    total += A436.a
    total += A437.a
    total += A438.a
    total += A439.a
    total += A440.a",total += A441.a
"package foo.bar

/*p:foo.bar*/fun testOperators(a: /*p:foo.bar*/A, b: /*p:foo.bar*/Int) {
    var d = /*p:foo.bar(A)*/a

    /*p:foo.bar(A)*/d/*p:foo.bar(A) p:foo.bar.A(inc)*/++
    /*p:foo.bar(A) p:foo.bar.A(inc)*/++/*p:foo.bar(A)*/d
    /*p:foo.bar(A)*/d/*p:foo.bar(A) p:foo.bar(dec) p:foo.bar.A(dec)*/--
    /*p:foo.bar(A) p:foo.bar(dec) p:foo.bar.A(dec)*/--/*p:foo.bar(A)*/d

    /*p:foo.bar(A) p:foo.bar.A(plus)*/a + b
    /*p:foo.bar(A) p:foo.bar(minus) p:foo.bar.A(minus)*/a - b
    /*p:foo.bar(not) p:foo.bar.A(not)*/!/*p:foo.bar(A)*/a

    // for val",/*p:foo.bar(A) p:foo.bar(times) p:foo.bar.A(times) p:foo.bar.A(timesAssign)*/a *= b
"import org.jetbrains.kotlin.diagnostics.Diagnostic
import org.jetbrains.kotlin.diagnostics.Errors
import org.jetbrains.kotlin.metadata.ProtoBuf
import org.jetbrains.kotlin.resolve.annotations.argumentValue
import org.jetbrains.kotlin.resolve.constants.StringValue
import org.jetbrains.kotlin.resolve.deprecation.DeprecationLevelValue.*

fun DescriptorBasedDeprecationInfo.deprecatedByOverriddenMessage(): String? = (this as? DeprecatedByOverridden)?.additionalMessage()

fun DescriptorBasedDeprecationInfo.deprecatedByAnnotationReplaceWithExpression(): String? = (this as? DeprecatedByAnnotation)?.replaceWithValue

// The function extracts value of warningSince/errorSince/hiddenSince from DeprecatedSinceKotlin annotation
fun AnnotationDescriptor.getSinceVersion(name: String): ApiVersion? =
    (argumentValue(name) as? StringValue)?.value?.takeUnless(String::isEmpty)?.let(ApiVersion.Companion::parse)

fun computeLevelForDeprecatedSinceKotlin(annotation: AnnotationDescriptor, apiVersion: ApiVersion): DeprecationLevelValue? {
    val hiddenSince = annotation.getSinceVersion(""hiddenSince"")
    if (hiddenSince != null && apiVersion >= hiddenSince) return HIDDEN

    val errorSince = annotation.getSinceVersion(""errorSince"")
    if (errorSince != null && apiVersion >= errorSince) return ERROR

    val warningSince = annotation.getSinceVersion(""warningSince"")
    if (warningSince != null && apiVersion >= warningSince) return WARNING

    return null
}

internal fun createDeprecationDiagnostic(
    element: PsiElement,
    deprecation: DescriptorBasedDeprecationInfo,
    languageVersionSettings: LanguageVersionSettings,
    forceWarningForSimpleDeprecation: Boolean = false,
): Diagnostic {
    val targetOriginal = deprecation.target.original
    return when (deprecation) {
        is DeprecatedByVersionRequirement -> {
            val factory = when (deprecation.deprecationLevel) {
                WARNING -> Errors.VERSION_REQUIREMENT_DEPRECATION
                ERROR, HIDDEN -> Errors.VERSION_REQUIREMENT_DEPRECATION_ERROR
            }
            val currentVersionString = when (deprecation.versionRequirement.kind) {
                ProtoBuf.VersionRequirement.VersionKind.COMPILER_VERSION -> KotlinCompilerVersion.VERSION
                ProtoBuf.VersionRequirement.VersionKind.LANGUAGE_VERSION -> languageVersionSettings.languageVersion.versionString
                ProtoBuf.VersionRequirement.VersionKind.API_VERSION -> languageVersionSettings.apiVersion.versionString
            }
            factory.on(
                element, targetOriginal, deprecation.versionRequirement.version,
                currentVersionString to deprecation.message
            )
        }

        is DeprecatedTypealiasByAnnotation -> {
            val factory = when (deprecation.deprecationLevel) {
                WARNING -> Errors.TYPEALIAS_EXPANSION_DEPRECATION
                ERROR, HIDDEN -> Errors.TYPEALIAS_EXPANSION_DEPRECATION_ERROR
            }
            factory.on(element, deprecation.typeAliasTarget.original, deprecation.nested.target.original, deprecation.nested.message ?: """")
        }

        else -> {
            val factory = if (forceWarningForSimpleDeprecation) Errors.DEPRECATION else when (deprecation.deprecationLevel) {
                WARNING -> Errors.DEPRECATION
                ERROR, HIDDEN -> Errors.DEPRECATION_ERROR
            }","factory.on(element, targetOriginal, deprecation.message ?: """")"
"// CHECK_BYTECODE_LISTING
// FIR_IDENTICAL
// WITH_STDLIB
// TARGET_BACKEND: JVM_IR
// LANGUAGE: +ValueClasses

@JvmInline
value class DPoint(val x: Double, val y: Double) {
    init {
        require(x != 0.0 && y != 0.0)
    }
}

fun tryOk() = try {
    DPoint(1.0, 2.0)
} catch(_: Throwable) {
    DPoint(0.0, 3.0)
} finally {
    DPoint(4.0, 5.0)
}

fun tryFail1() = try {
    DPoint(0.0, 1.0)
} catch(_: Throwable) {
    DPoint(2.0, 3.0)
} finally {
    DPoint(4.0, 5.0)
}

fun tryFail2() = try {
    DPoint(1.0, 2.0)",} catch(_: Throwable) {
"// LANGUAGE: -ProhibitImplementingVarByInheritedVal

interface IVal {
    val a: String
}",interface IVar {
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */",package org.jetbrains.kotlin.backend.konan
// FILE: test_NestedClassAndMaterializeMember.kt,package test
"package test

@Retention(AnnotationRetention.RUNTIME)
annotation class Runtime

@Retention(AnnotationRetention.SOURCE)",annotation class Source
"// TARGET_BACKEND: JVM

// FILE: J.java

public class J extends A {

    public boolean okField = false;

    public int getValProp() {
        return 123;
    }

    public int getVarProp() {
        return 456;
    }

    public void setVarProp(int x) {
        okField = true;
    }

    public int isProp() {
        return 789;
    }

    public void setProp(int x) {
        okField = true;
    }
}

// FILE: test.kt

open class A {
    open val valProp: Int = -1
    open var varProp: Int = -1
    open var isProp: Int = -1
}

class B : J() {
    override val valProp: Int = super.valProp + 1
    override var varProp: Int
        set(value) {
            super.varProp = value
        }
        get() = super.varProp + 1

    override var isProp: Int",set(value) {
"visitSingletonReference(expression, data)

    fun visitGetEnumValue(expression: IrGetEnumValue, data: D): R =
        visitSingletonReference(expression, data)

    fun visitRawFunctionReference(expression: IrRawFunctionReference, data: D): R =
        visitDeclarationReference(expression, data)

    fun visitContainerExpression(expression: IrContainerExpression, data: D): R =
        visitExpression(expression, data)

    fun visitBlock(expression: IrBlock, data: D): R =
        visitContainerExpression(expression, data)

    fun visitComposite(expression: IrComposite, data: D): R =
        visitContainerExpression(expression, data)

    fun visitReturnableBlock(expression: IrReturnableBlock, data: D): R =
        visitBlock(expression, data)

    fun visitInlinedFunctionBlock(inlinedBlock: IrInlinedFunctionBlock, data: D): R =
        visitBlock(inlinedBlock, data)

    fun visitSyntheticBody(body: IrSyntheticBody, data: D): R =
        visitBody(body, data)

    fun visitBreakContinue(jump: IrBreakContinue, data: D): R =
        visitExpression(jump, data)

    fun visitBreak(jump: IrBreak, data: D): R =
        visitBreakContinue(jump, data)

    fun visitContinue(jump: IrContinue, data: D): R =
        visitBreakContinue(jump, data)

    fun visitCall(expression: IrCall, data: D): R =
        visitFunctionAccess(expression, data)

    fun visitCallableReference(expression: IrCallableReference<*>, data: D): R =
        visitMemberAccess(expression, data)

    fun visitFunctionReference(expression: IrFunctionReference, data: D): R =
        visitCallableReference(expression, data)

    fun visitPropertyReference(expression: IrPropertyReference, data: D): R =
        visitCallableReference(expression, data)

    fun visitLocalDelegatedPropertyReference(expression: IrLocalDelegatedPropertyReference, data: D): R =
        visitCallableReference(expression, data)

    fun visitClassReference(expression: IrClassReference, data: D): R =
        visitDeclarationReference(expression, data)

    fun visitConst(expression: IrConst<*>, data: D): R =
        visitExpression(expression, data)

    fun visitConstantValue(expression: IrConstantValue, data: D): R =
        visitExpression(expression, data)

    fun visitConstantPrimitive(expression: IrConstantPrimitive, data: D): R =
        visitConstantValue(expression, data)

    fun visitConstantObject(expression: IrConstantObject, data: D): R =
        visitConstantValue(expression, data)","fun visitConstantArray(expression: IrConstantArray, data: D): R ="
"}.orEmpty()

    return toKtAnnotationApplication(builder, index, arguments)
}

private fun FirAnnotation.asKtAnnotationApplicationForTargetAnnotation(
    builder: KtSymbolByFirBuilder,
    index: Int,
): KtAnnotationApplicationWithArgumentsInfo = asKtAnnotationApplicationForAnnotationWithEnumArgument(
    builder = builder,
    index = index,
    expectedEnumClassId = StandardClassIds.AnnotationTarget,
    annotationParameterName = StandardClassIds.Annotations.ParameterNames.targetAllowedTargets,
    nameMapper = { KotlinTarget.valueOrNull(it)?.name },
)

private fun FirAnnotation.asKtAnnotationApplicationForJavaTargetAnnotation(
    builder: KtSymbolByFirBuilder,
    index: Int,
): KtAnnotationApplicationWithArgumentsInfo = asKtAnnotationApplicationForAnnotationWithEnumArgument(
    builder = builder,
    index = index,
    expectedEnumClassId = JvmStandardClassIds.Annotations.Java.ElementType,
    annotationParameterName = StandardClassIds.Annotations.ParameterNames.value,
    nameMapper = { ElementType.entries.firstOrNull { enumValue -> enumValue.name == it }?.name },
)

private fun <T> FirAnnotation.findFromRawArguments(expectedEnumClass: ClassId, transformer: (String) -> T?): Set<T> = buildSet {
    fun addIfMatching(arg: FirExpression) {
        if (arg !is FirQualifiedAccessExpression) return
        val callableSymbol = arg.calleeReference.toResolvedCallableSymbol() ?: return
        if (callableSymbol.containingClassLookupTag()?.classId != expectedEnumClass) return
        val identifier = callableSymbol.callableId.callableName.identifier
        transformer(identifier)?.let(::add)
    }

    if (this@findFromRawArguments is FirAnnotationCall) {
        for (arg in argumentList.arguments) {
            arg.unwrapAndFlattenArgument(flattenArrays = true).forEach(::addIfMatching)
        }
    }
}

internal fun annotations(
    firSymbol: FirBasedSymbol<*>,
    builder: KtSymbolByFirBuilder,
    annotationContainer: FirAnnotationContainer = firSymbol.fir,
): List<KtAnnotationApplicationWithArgumentsInfo> =
    annotationContainer.resolvedAnnotationsWithArguments(firSymbol).mapIndexed { index, annotation ->
        annotation.toKtAnnotationApplication(builder, index)
    }

internal fun annotationInfos(
    firSymbol: FirBasedSymbol<*>,
    useSiteSession: FirSession,
    token: KtLifetimeToken,
    annotationContainer: FirAnnotationContainer = firSymbol.fir,
): List<KtAnnotationApplicationInfo> = annotationContainer.resolvedAnnotationsWithClassIds(firSymbol).mapIndexed { index, annotation ->
    annotation.toKtAnnotationInfo(useSiteSession, index, token)
}

internal fun annotationClassIds(
    firSymbol: FirBasedSymbol<*>,
    useSiteSession: FirSession,
    annotationContainer: FirAnnotationContainer = firSymbol.fir,",): Collection<ClassId> = annotationContainer.resolvedAnnotationsWithClassIds(firSymbol).mapNotNull {
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer

import org.jetbrains.kotlin.commonizer.konan.NativeManifestDataProvider
import org.jetbrains.kotlin.commonizer.mergedtree.CirFictitiousFunctionClassifiers
import org.jetbrains.kotlin.commonizer.mergedtree.CirProvidedClassifiers
import org.jetbrains.kotlin.commonizer.mergedtree.CirProvidedClassifiersByModules
import org.jetbrains.kotlin.commonizer.stats.StatsCollector
import org.jetbrains.kotlin.storage.LockBasedStorageManager
import org.jetbrains.kotlin.storage.StorageManager
import org.jetbrains.kotlin.util.Logger

data class CommonizerParameters(
    val outputTargets: Set<SharedCommonizerTarget>,
    val manifestProvider: TargetDependent<NativeManifestDataProvider>,
    val dependenciesProvider: TargetDependent<ModulesProvider?>,
    val targetProviders: TargetDependent<TargetProvider?>,
    val resultsConsumer: ResultsConsumer,
    val storageManager: StorageManager = LockBasedStorageManager.NO_LOCKS,
    val statsCollector: StatsCollector? = null,
    val logger: Logger? = null,
    val settings: CommonizerSettings,
)",internal fun CommonizerParameters.dependencyClassifiers(target: CommonizerTarget): CirProvidedClassifiers {
"// TARGET_BACKEND: WASM
// USE_NEW_EXCEPTION_HANDLING_PROPOSAL
// TODO: remove the test when KT-66906 will be resolved
class MyString {
    var s = """"
    operator fun plus(x : String) : MyString {
        s += x
        return this
    }

    override fun toString(): String {
        return s
    }
}


fun test1() : MyString {
    var r = MyString()
    try {
        r + ""Try1""

        try {
            r + ""Try2""
            if (true)
                return r
        } finally {","r + ""Finally2"""
"// FIR_IDENTICAL
// FILE: a.kt
// KT-355 Resolve imports after all symbols are built",package a
"analyze(file) {
            val foo = file.getFunctionOrFail(""foo"")
            assertEquals(listOf(""IllegalStateException"", ""RuntimeException""), foo.definedThrows.mapName())
        }
    }

    @Test
    fun `test - effective and defined classes throws`() {
        val file = inlineSourceCodeAnalysis.createKtFile(
            """"""
            abstract class A {
                @Throws(IllegalStateException::class)
                abstract fun foo()
            }
            
            class B : A() {
                @Throws(RuntimeException::class)
                override fun foo() = Unit
            }
            class C : B() {
                @Throws(IndexOutOfBoundsException::class)
                override fun foo() = Unit
            }
            """""".trimIndent()
        )

        analyze(file) {

            val fooA = file.getClassOrFail(""A"").getMemberScope().getFunctionOrFail(""foo"")
            assertEquals(listOf(""IllegalStateException""), fooA.effectiveThrows.mapName())
            assertEquals(listOf(""IllegalStateException""), fooA.definedThrows.mapName())

            val fooB = file.getClassOrFail(""B"").getMemberScope().getFunctionOrFail(""foo"")
            assertEquals(listOf(""IllegalStateException""), fooB.effectiveThrows.mapName())
            assertEquals(listOf(""RuntimeException""), fooB.definedThrows.mapName())

            val fooC = file.getClassOrFail(""C"").getMemberScope().getFunctionOrFail(""foo"")
            assertEquals(listOf(""IllegalStateException""), fooC.effectiveThrows.mapName())
            assertEquals(listOf(""IndexOutOfBoundsException""), fooC.definedThrows.mapName())
        }
    }

    @Test
    fun `test - constructor throws`() {
        val file = inlineSourceCodeAnalysis.createKtFile(
            """"""
            class Foo @Throws(IllegalStateException::class) constructor()
            """""".trimIndent()
        )

        analyze(file) {
            val foo = file.getClassOrFail(""Foo"").getMemberScope().getConstructors().first()
            assertEquals(listOf(""IllegalStateException""), foo.effectiveThrows.mapName())
            assertEquals(listOf(""IllegalStateException""), foo.definedThrows.mapName())
        }
    }

    @Test
    fun `test - non throws annotation`() {
        val file = inlineSourceCodeAnalysis.createKtFile(
            """"""
            annotation class NonThrows(vararg val exceptionClasses: KClass<out Throwable>)

            @Throws(RuntimeException::class)",@NonThrows(IllegalStateException::class)
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.checkers.declaration

import org.jetbrains.kotlin.config.LanguageFeature
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.FirElement
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext
import org.jetbrains.kotlin.fir.analysis.checkers.getContainingClassSymbol
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SELF_CALL_IN_NESTED_OBJECT_CONSTRUCTOR_ERROR
import org.jetbrains.kotlin.fir.declarations.FirRegularClass
import org.jetbrains.kotlin.fir.declarations.fullyExpandedClass
import org.jetbrains.kotlin.fir.expressions.*
import org.jetbrains.kotlin.fir.languageVersionSettings
import org.jetbrains.kotlin.fir.resolve.getSuperClassSymbolOrAny
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.fir.visitors.FirVisitor

object FirObjectConstructorChecker : FirRegularClassChecker(MppCheckerKind.Common) {
    override fun check(declaration: FirRegularClass, context: CheckerContext, reporter: DiagnosticReporter) {
        if (!context.session.languageVersionSettings.supportsFeature(LanguageFeature.ProhibitSelfCallsInNestedObjects))
            return

        if (declaration.classKind != ClassKind.OBJECT)
            return

        val objectSymbol = declaration.symbol
        // Temporary restriction till KT-66754 will be accepted
        if (objectSymbol.getContainingClassSymbol(context.session) != objectSymbol.getSuperClassSymbolOrAny(context.session))
            return",objectSymbol.primaryConstructorSymbol(context.session)?.resolvedDelegatedConstructorCall
"fun print(v: Any?) {}

fun foo() {
    val array = intArrayOf(1,2,3)

    var count = 0
    for (element in array) if (element > 0) count++
    while (count > 0) if (count > 0) count++",if (count == 1)
"// FILE: util.kt
const val FLAG = true
const val OTHER_FLAG = false

fun doStuff1() {}
fun doStuff2() {}",fun doStuff3() {}
"val x = <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int?"")!><!DEBUG_INFO_EXPRESSION_TYPE(""((kotlin.Float) -> kotlin.Int?)? & (kotlin.Float) -> kotlin.Int?""), DEBUG_INFO_SMARTCAST!>a<!>(<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>)<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""((kotlin.Float) -> kotlin.Int?)? & (kotlin.Float) -> kotlin.Int?""), DEBUG_INFO_SMARTCAST!>a<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""((kotlin.Float) -> kotlin.Int?)? & (kotlin.Float) -> kotlin.Int?""), DEBUG_INFO_SMARTCAST!>a<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""((kotlin.Float) -> kotlin.Int?)? & (kotlin.Float) -> kotlin.Int?""), DEBUG_INFO_SMARTCAST!>a<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""((kotlin.Float) -> kotlin.Int?)? & (kotlin.Float) -> kotlin.Int?"")!>a<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""((kotlin.Float) -> kotlin.Int?)? & (kotlin.Float) -> kotlin.Int?"")!>a<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""((kotlin.Float) -> kotlin.Int?)? & (kotlin.Float) -> kotlin.Int?""), DEBUG_INFO_SMARTCAST!>a<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""((kotlin.Float) -> kotlin.Int?)? & (kotlin.Float) -> kotlin.Int?""), DEBUG_INFO_SMARTCAST!>a<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""((kotlin.Float) -> kotlin.Int?)? & (kotlin.Float) -> kotlin.Int?"")!>a<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""((kotlin.Float) -> kotlin.Int?)? & (kotlin.Float) -> kotlin.Int?"")!>a<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?""), DEBUG_INFO_SMARTCAST!>b<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Float & kotlin.Float?"")!>b<!>.funNullableAny()
        if (x == null == true || (c != null && !<!DEBUG_INFO_SMARTCAST!>c<!>)) {

        } else {
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>x<!>
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>x<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>x<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>x<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>x<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>x<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>x<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?""), DEBUG_INFO_SMARTCAST!>x<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>x<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Int & kotlin.Int?"")!>x<!>.funNullableAny()
        }
    }
}

// TESTCASE NUMBER: 13
fun case_13(b: Boolean, c: Boolean, d: Boolean) {
    val a = if (b) {
        object {
            val B19 = if (b) {
                object {
                    val C19 = if (b) {
                        object {
                            val D19 = if (b) {
                                object {
                                    val x: Number? = 10
                                }
                            } else null
                        }
                    } else null
                }
            } else null
        }
    } else null

    if ((a == null || <!DEBUG_INFO_SMARTCAST!>a<!>.B19 == null || <!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19 == null || <!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19 == null || <!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x == null || b || c || !d) && true) {

    } else {
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number & kotlin.Number?"")!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.propNullableAny","<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number""), DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!><!DEBUG_INFO_SMARTCAST!>a<!>.B19<!>.C19<!>.D19<!>.x<!>.funT()"
"/*
 * Copyright 2010-2020 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.backend.common.overrides

import org.jetbrains.kotlin.backend.common.linkage.partial.ImplementAsErrorThrowingStubs
import org.jetbrains.kotlin.backend.common.linkage.partial.PartialLinkageSupportForLinker
import org.jetbrains.kotlin.backend.common.serialization.CompatibilityMode
import org.jetbrains.kotlin.backend.common.serialization.DeclarationTable
import org.jetbrains.kotlin.backend.common.serialization.GlobalDeclarationTable
import org.jetbrains.kotlin.backend.common.serialization.signature.IdSignatureFactory
import org.jetbrains.kotlin.backend.common.serialization.signature.PublicIdSignatureComputer
import org.jetbrains.kotlin.ir.IrBuiltIns
import org.jetbrains.kotlin.ir.builders.declarations.buildFun
import org.jetbrains.kotlin.ir.builders.declarations.buildProperty",import org.jetbrains.kotlin.ir.builders.declarations.buildTypeParameter
"private val globalMetadataInfoHandler: GlobalMetadataInfoHandler
        get() = testServices.globalMetadataInfoHandler

    private val diagnosticsService: DiagnosticsService
        get() = testServices.diagnosticsService

    private val reporter = ClassicDiagnosticReporter(testServices)

    override fun processModule(module: TestModule, info: ClassicFrontendOutputArtifact) {
        var allDiagnostics = info.analysisResult.bindingContext.diagnostics.toList()
        if (AdditionalFilesDirectives.CHECK_TYPE in module.directives) {
            allDiagnostics = allDiagnostics.filter { it.factory.name != Errors.UNDERSCORE_USAGE_WITHOUT_BACKTICKS.name }
        }
        if (LanguageSettingsDirectives.API_VERSION in module.directives) {
            allDiagnostics = allDiagnostics.filter { it.factory.name != Errors.NEWER_VERSION_IN_SINCE_KOTLIN.name }
        }

        val diagnosticsPerFile = allDiagnostics.groupBy { it.psiFile }
        val withNewInferenceModeEnabled = testServices.withNewInferenceModeEnabled()
        val configuration = reporter.createConfiguration(module)

        for ((file, ktFile) in info.ktFiles) {
            val diagnostics = diagnosticsPerFile[ktFile] ?: emptyList()
            for (diagnostic in diagnostics) {
                if (!diagnostic.isValid) continue
                if (!diagnosticsService.shouldRenderDiagnostic(module, diagnostic.factory.name, diagnostic.severity)) continue
                reporter.reportDiagnostic(diagnostic, module, file, configuration, withNewInferenceModeEnabled)
            }
            for (errorElement in AnalyzingUtils.getSyntaxErrorRanges(ktFile)) {
                reporter.reportDiagnostic(SyntaxErrorDiagnostic(errorElement), module, file, configuration, withNewInferenceModeEnabled)
            }
            processDebugInfoDiagnostics(configuration, module, file, ktFile, info, withNewInferenceModeEnabled)
        }
    }

    private fun processDebugInfoDiagnostics(
        configuration: DiagnosticsRenderingConfiguration,
        module: TestModule,
        file: TestFile,
        ktFile: KtFile,
        info: ClassicFrontendOutputArtifact,
        withNewInferenceModeEnabled: Boolean
    ) {
        val diagnosedRanges = globalMetadataInfoHandler.getExistingMetaInfosForFile(file)
            .groupBy(
                keySelector = { it.start..it.end },
                valueTransform = { it.tag }
            )
            .mapValues { (_, it) -> it.toMutableSet() }
        val debugAnnotations = CheckerTestUtil.getDebugInfoDiagnostics(
            ktFile,
            info.analysisResult.bindingContext,
            markDynamicCalls = MARK_DYNAMIC_CALLS in module.directives,
            dynamicCallDescriptors = mutableListOf(),
            configuration,
            dataFlowValueFactory = DataFlowValueFactoryImpl(info.languageVersionSettings),
            info.analysisResult.moduleDescriptor as ModuleDescriptorImpl,
            diagnosedRanges = diagnosedRanges
        )
        val onlyExplicitlyDefined = DiagnosticsDirectives.REPORT_ONLY_EXPLICITLY_DEFINED_DEBUG_INFO in module.directives
        for (debugAnnotation in debugAnnotations) {
            val factory = debugAnnotation.diagnostic.factory
            if (!diagnosticsService.shouldRenderDiagnostic(module, factory.name, factory.severity)) continue
            if (onlyExplicitlyDefined && !debugAnnotation.diagnostic.textRanges.any { it.startOffset..it.endOffset in diagnosedRanges }) {",continue
"import org.jetbrains.kotlin.analysis.api.descriptors.Fe10AnalysisContext
import org.jetbrains.kotlin.analysis.api.descriptors.Fe10AnalysisFacade.AnalysisMode
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.calculateHashCode
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.KtFe10DescKotlinPropertySymbol
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.descriptorBased.base.toKtType
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.isEqualTo
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.pointers.KtFe10NeverRestoringSymbolPointer
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.psiBased.base.KtFe10PsiSymbol
import org.jetbrains.kotlin.analysis.api.descriptors.symbols.psiBased.base.createErrorType
import org.jetbrains.kotlin.analysis.api.descriptors.utils.cached
import org.jetbrains.kotlin.analysis.api.lifetime.withValidityAssertion
import org.jetbrains.kotlin.analysis.api.symbols.KtKotlinPropertySymbol
import org.jetbrains.kotlin.analysis.api.symbols.KtValueParameterSymbol
import org.jetbrains.kotlin.analysis.api.symbols.pointers.KtPsiBasedSymbolPointer
import org.jetbrains.kotlin.analysis.api.symbols.pointers.KtSymbolPointer
import org.jetbrains.kotlin.analysis.api.types.KtType
import org.jetbrains.kotlin.descriptors.ValueParameterDescriptor
import org.jetbrains.kotlin.descriptors.VariableDescriptor
import org.jetbrains.kotlin.descriptors.impl.PropertyDescriptorImpl
import org.jetbrains.kotlin.lexer.KtTokens
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.name.SpecialNames
import org.jetbrains.kotlin.psi.KtParameter
import org.jetbrains.kotlin.resolve.BindingContext

internal class KtFe10PsiValueParameterSymbol(
    override val psi: KtParameter,
    override val analysisContext: Fe10AnalysisContext
) : KtValueParameterSymbol(), KtFe10PsiSymbol<KtParameter, VariableDescriptor> {
    override val descriptor: VariableDescriptor? by cached {
        val bindingContext = analysisContext.analyze(psi, AnalysisMode.PARTIAL)
        bindingContext[BindingContext.VALUE_PARAMETER, psi]
    }

    override val generatedPrimaryConstructorProperty: KtKotlinPropertySymbol? by cached {
        val bindingContext = analysisContext.analyze(psi, AnalysisMode.PARTIAL)
        val propertyDescriptor = bindingContext[BindingContext.PRIMARY_CONSTRUCTOR_PARAMETER, psi] ?: return@cached null

        KtFe10DescKotlinPropertySymbol(propertyDescriptor as PropertyDescriptorImpl, analysisContext)
    }

    override val hasDefaultValue: Boolean
        get() = withValidityAssertion { psi.hasDefaultValue() }

    override val isVararg: Boolean
        get() = withValidityAssertion { psi.isVarArg }

    override val isCrossinline: Boolean
        get() = withValidityAssertion { psi.hasModifier(KtTokens.CROSSINLINE_KEYWORD) }

    override val isNoinline: Boolean
        get() = withValidityAssertion { psi.hasModifier(KtTokens.NOINLINE_KEYWORD) }

    override val isImplicitLambdaParameter: Boolean
        get() = withValidityAssertion { false }

    override val returnType: KtType
        get() = withValidityAssertion {
            val type = (descriptor as? ValueParameterDescriptor)?.varargElementType ?: descriptor?.type
            return type?.toKtType(analysisContext) ?: createErrorType()
        }

    override val name: Name
        get() = withValidityAssertion {",if (psi.destructuringDeclaration != null) SpecialNames.DESTRUCT
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.konan.test.blackbox.support.group

import org.jetbrains.kotlin.konan.target.Architecture
import org.jetbrains.kotlin.konan.target.Family
import org.jetbrains.kotlin.konan.test.blackbox.support.ClassLevelProperty
import org.jetbrains.kotlin.konan.test.blackbox.support.TestDirectives
import org.jetbrains.kotlin.konan.test.blackbox.support.settings.CacheMode
import org.jetbrains.kotlin.konan.test.blackbox.support.settings.GCScheduler
import org.jetbrains.kotlin.konan.test.blackbox.support.settings.GCType
import org.jetbrains.kotlin.konan.test.blackbox.support.settings.KotlinNativeTargets
import org.jetbrains.kotlin.konan.test.blackbox.support.settings.OptimizationMode
import org.jetbrains.kotlin.konan.test.blackbox.support.settings.PipelineType
import org.jetbrains.kotlin.konan.test.blackbox.support.settings.Settings
import org.jetbrains.kotlin.konan.test.blackbox.support.settings.TestMode
import org.jetbrains.kotlin.konan.test.blackbox.support.settings.ThreadStateChecker
import org.jetbrains.kotlin.test.Directives
import org.jetbrains.kotlin.test.TargetBackend",import org.jetbrains.kotlin.test.directives.CodegenTestDirectives
"// FIR_IDENTICAL
// LANGUAGE: -ProhibitDefaultArgumentsInExpectActualizedByFakeOverride
// MODULE: m1-common
// FILE: common.kt
expect class Foo {",fun foo(param: Int = 1)
"package org.jetbrains.kotlin.objcexport.tests

import org.intellij.lang.annotations.Language
import org.jetbrains.kotlin.backend.konan.objcexport.ObjCExportStub
import org.jetbrains.kotlin.backend.konan.testUtils.HeaderGenerator
import org.jetbrains.kotlin.objcexport.analysisApiUtils.hasErrorTypes
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import java.nio.file.Path
import kotlin.io.path.writeText",import kotlin.test.assertFalse
"session: LLFirSession,
    override val extensions: List<KtResolveExtension>,
) : LLFirResolveExtensionTool() {
    init {
        require(extensions.isNotEmpty())
    }

    private val fileProvider = LLFirResolveExtensionsFileProvider(extensions)

    override val packageFilter = LLFirResolveExtensionToolPackageFilter(extensions)

    override val declarationProvider: LLFirResolveExtensionToolDeclarationProvider =
        LLFirResolveExtensionToolDeclarationProvider(fileProvider, session.ktModule)

    override val packageProvider: KotlinPackageProvider = LLFirResolveExtensionToolPackageProvider(packageFilter)

    override val shadowedSearchScope by lazy {
        forbidAnalysis {
            GlobalSearchScope.union(extensions.mapTo(mutableSetOf()) { it.getShadowedScope() })
        }
    }

    override val symbolNamesProvider: FirSymbolNamesProvider = LLFirResolveExtensionToolSymbolNamesProvider(packageFilter, fileProvider)
}

private class LLFirResolveExtensionToolSymbolNamesProvider(
    private val packageFilter: LLFirResolveExtensionToolPackageFilter,
    private val fileProvider: LLFirResolveExtensionsFileProvider,
) : FirSymbolNamesProvider() {
    override fun getPackageNames(): Set<String> = forbidAnalysis {
        packageFilter.getAllPackages().mapToSetOrEmpty(FqName::asString)
    }

    override val hasSpecificClassifierPackageNamesComputation: Boolean get() = false
    override val hasSpecificCallablePackageNamesComputation: Boolean get() = false

    override fun getTopLevelClassifierNamesInPackage(packageFqName: FqName): Set<Name> = forbidAnalysis {
        if (!packageFilter.packageExists(packageFqName)) return emptySet()
        fileProvider.getFilesByPackage(packageFqName).flatMap { it.getTopLevelClassifierNames() }.toSet()
    }

    override fun getTopLevelCallableNamesInPackage(packageFqName: FqName): Set<Name> = forbidAnalysis {
        if (!packageFilter.packageExists(packageFqName)) return emptySet()
        fileProvider.getFilesByPackage(packageFqName)
            .flatMapTo(mutableSetOf()) { it.getTopLevelCallableNames() }
    }

    override fun mayHaveTopLevelClassifier(classId: ClassId): Boolean = forbidAnalysis {
        if (!packageFilter.packageExists(classId.packageFqName)) return false

        fileProvider.getFilesByPackage(classId.packageFqName)
            .any { it.mayHaveTopLevelClassifier(classId.getTopLevelShortClassName()) }
    }

    override fun mayHaveTopLevelCallable(packageFqName: FqName, name: Name): Boolean = forbidAnalysis {
        if (!packageFilter.packageExists(packageFqName)) return false

        fileProvider.getFilesByPackage(packageFqName)
            .any { it.mayHaveTopLevelCallable(name) }
    }
}

class LLFirResolveExtensionToolPackageFilter(
    private val extensions: List<KtResolveExtension>
) {","private val packageSubPackages: Map<FqName, Set<Name>> by lazy {"
"}
                    )
                    qualifier.add(firQualifier)

                    ktQualifier = ktQualifier!!.qualifier
                    referenceExpression = ktQualifier?.referenceExpression
                } while (referenceExpression != null)

                qualifier.reverse()
            }
        }

        override fun visitAnnotationEntry(annotationEntry: KtAnnotationEntry, data: FirElement?): FirElement {
            return buildAnnotationCall {
                source = annotationEntry.toFirSourceElement()
                useSiteTarget = annotationEntry.useSiteTarget?.getAnnotationUseSiteTarget()
                annotationTypeRef = annotationEntry.typeReference.toFirOrErrorType()
                annotationEntry.extractArgumentsTo(this)
                val name = (annotationTypeRef as? FirUserTypeRef)?.qualifier?.last()?.name ?: Name.special(""<no-annotation-name>"")
                calleeReference = buildSimpleNamedReference {
                    source = (annotationEntry.typeReference?.typeElement as? KtUserType)?.referenceExpression?.toFirSourceElement()
                    this.name = name
                }
                typeArguments.appendTypeArguments(annotationEntry.typeArguments)
                containingDeclarationSymbol = context.containerSymbol
            }
        }

        override fun visitTypeProjection(typeProjection: KtTypeProjection, data: FirElement?): FirElement {
            val projectionKind = typeProjection.projectionKind
            val projectionSource = typeProjection.toFirSourceElement()
            if (projectionKind == KtProjectionKind.STAR) {
                return buildStarProjection {
                    source = projectionSource
                }
            }
            val argumentList = typeProjection.parent as? KtTypeArgumentList
            val typeReference = typeProjection.typeReference
            if (argumentList?.parent is KtCallExpression && typeReference?.isPlaceholder == true) {
                return buildPlaceholderProjection {
                    source = projectionSource
                }
            }
            val firType = typeReference.toFirOrErrorType()
            return buildTypeProjectionWithVariance {
                source = projectionSource
                typeRef = firType
                variance = when (projectionKind) {
                    KtProjectionKind.IN -> Variance.IN_VARIANCE
                    KtProjectionKind.OUT -> Variance.OUT_VARIANCE
                    KtProjectionKind.NONE -> Variance.INVARIANT
                    KtProjectionKind.STAR -> shouldNotBeCalled()
                }
            }
        }

        override fun visitBlockExpression(expression: KtBlockExpression, data: FirElement?): FirElement {
            return configureBlockWithoutBuilding(expression).build()
        }

        private fun configureBlockWithoutBuilding(expression: KtBlockExpression, kind: KtFakeSourceElementKind? = null): FirBlockBuilder {
            return FirBlockBuilder().apply {
                source = expression.toFirSourceElement(kind)
                for (statement in expression.statements) {
                    val firStatement = statement.toFirStatement { ""Statement expected: ${statement.text}"" }",val isForLoopBlock =
"import org.jetbrains.kotlin.swiftexport.standalone.klib.KlibScope
import org.junit.jupiter.api.Test
import java.nio.file.Path
import kotlin.io.path.writeText
import kotlin.test.assertContains
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class KlibScopeTests : AbstractNativeSimpleTest() {

    @Test
    fun `smoke single function`() {
        withKlibScope(
            source = """"""
                fun foo() {}
            """""".trimIndent()
        ) {
            val symbol = getAllSymbols().single()
            assertTrue(symbol is KtFunctionSymbol)
            assertEquals(""foo"", symbol.name.asString())
        }
    }

    @Test
    fun `smoke empty file`() {
        withKlibScope(source = """") {
            val symbols = getAllSymbols()
            val classifiersNames = getPossibleClassifierNames()
            val callableNames = getPossibleCallableNames()
            assertTrue(symbols.toList().isEmpty())
            assertTrue(classifiersNames.toList().isEmpty())
            assertTrue(callableNames.toList().isEmpty())
        }
    }

    private val simpleContentWithCollisions: String = """"""
        fun foo(): Int = 42
        
        fun bar() {}

        interface foo {}

        interface bar {} 
    """""".trimIndent()

    @Test
    fun `callable name filter`() {
        withKlibScope(source = simpleContentWithCollisions) {
            val symbol = getCallableSymbols { it.asString() == ""foo"" }.single()
            assertTrue(symbol is KtFunctionSymbol)
            assertEquals(""foo"", symbol.name.asString())
        }
    }

    @Test
    fun `classifier name filter`() {
        withKlibScope(source = simpleContentWithCollisions) {
            val symbol = getClassifierSymbols { it.asString() == ""foo"" }.single()
            assertTrue(symbol is KtNamedSymbol)
            assertEquals(""foo"", symbol.name.asString())
        }
    }

    @Test
    fun `possible classifier names`() {",withKlibScope(source = simpleContentWithCollisions) {
"val delegatedProperty1: Int by lazy { 42 }
val delegatedProperty2: Int by lazy { 42 }
val delegatedProperty3: Int by mapOf(""delegatedProperty3"" to 42)
val delegatedProperty4: Int by mapOf(""delegatedProperty4"" to 42)

lateinit var lateinitProperty1: String
lateinit var lateinitProperty2: String

inline val inlineProperty1 get() = 42
inline val inlineProperty2 get() = 42
inline val inlineProperty3 get() = 42

inline var inlineProperty4
    get() = 42
    set(value) = Unit
inline var inlineProperty5
    get() = 42
    set(value) = Unit
inline var inlineProperty6
    get() = 42",set(value) = Unit
"constraint.run {
                when (size) {
                    0 -> null
                    1 -> single()
                    else -> reduce(ExportedType::IntersectionType)
                }
            }
        )
    }

    private val currentlyProcessedTypes = hashSetOf<IrType>()

    private fun exportType(type: IrType, shouldCalculateExportedSupertypeForImplicit: Boolean = true): ExportedType {
        if (type is IrDynamicType || type in currentlyProcessedTypes)
            return ExportedType.Primitive.Any

        if (type !is IrSimpleType)
            return ExportedType.ErrorType(""NonSimpleType ${type.render()}"")

        currentlyProcessedTypes.add(type)

        val classifier = type.classifier
        val isMarkedNullable = type.isMarkedNullable()
        val nonNullType = type.makeNotNull() as IrSimpleType

        val exportedType = when {
            nonNullType.isBoolean() -> ExportedType.Primitive.Boolean
            nonNullType.isPrimitiveType() && (!nonNullType.isLong() && !nonNullType.isChar()) ->
                ExportedType.Primitive.Number

            nonNullType.isByteArray() -> ExportedType.Primitive.ByteArray
            nonNullType.isShortArray() -> ExportedType.Primitive.ShortArray
            nonNullType.isIntArray() -> ExportedType.Primitive.IntArray
            nonNullType.isFloatArray() -> ExportedType.Primitive.FloatArray
            nonNullType.isDoubleArray() -> ExportedType.Primitive.DoubleArray

            // TODO: Cover these in frontend
            nonNullType.isBooleanArray() -> ExportedType.ErrorType(""BooleanArray"")
            nonNullType.isLongArray() -> ExportedType.ErrorType(""LongArray"")
            nonNullType.isCharArray() -> ExportedType.ErrorType(""CharArray"")

            nonNullType.isString() -> ExportedType.Primitive.String
            nonNullType.isThrowable() -> ExportedType.Primitive.Throwable
            nonNullType.isAny() -> ExportedType.Primitive.Any  // TODO: Should we wrap Any in a Nullable type?
            nonNullType.isUnit() -> ExportedType.Primitive.Unit
            nonNullType.isNothing() -> ExportedType.Primitive.Nothing
            nonNullType.isArray() -> ExportedType.Array(exportTypeArgument(nonNullType.arguments[0]))
            nonNullType.isSuspendFunction() -> ExportedType.ErrorType(""Suspend functions are not supported"")
            nonNullType.isFunction() -> ExportedType.Function(
                parameterTypes = nonNullType.arguments.dropLast(1).memoryOptimizedMap { exportTypeArgument(it) },
                returnType = exportTypeArgument(nonNullType.arguments.last())
            )

            classifier is IrTypeParameterSymbol -> ExportedType.TypeParameter(classifier.owner.name.identifier)

            classifier is IrClassSymbol -> {
                val klass = classifier.owner
                val isExported = klass.isExportedImplicitlyOrExplicitly(context)
                val isImplicitlyExported = !isExported && !klass.isExternal
                val isNonExportedExternal = klass.isExternal && !isExported
                val name = klass.getFqNameWithJsNameWhenAvailable(!isNonExportedExternal && generateNamespacesForPackages).asString()

                val exportedSupertype = runIf(shouldCalculateExportedSupertypeForImplicit && isImplicitlyExported) {
                    val transitiveExportedType = nonNullType.collectSuperTransitiveHierarchy()
                    if (transitiveExportedType.isEmpty()) return@runIf null",transitiveExportedType.memoryOptimizedMap(::exportType).reduce(ExportedType::IntersectionType)
"val x = 1

class A {
    val b = 2
}

fun box(): Int {
    when (""abc"".length) {
        x -> return 0
        else -> A()
    }

    if (x == 0) return 1

    val a = A()","when (""cde"".length) {"
"TBoolean: Boolean,
        TChar: Char,
        TByte: Byte,
        TShort: Short,
        TInt: Int,
        TLong: Long,
        TFloat: Float,
        TDouble: Double,
        // unsigned integer types
        TUByte: UByte,
        TUShort: UShort,
        TUInt: UInt,
        TULong: ULong,
        // string types
        TString: String,
        // function types
        TFunction: () -> Unit,
        // external types
        TExternalInterface: ExternalInterface,
        TExternalOpenClass: ExternalOpenClass,
        TExternalObject: ExternalObject,
        // correct type parameter
        TCorrectTypeParameter: TExternalInterface
> correctJsInteropTypesAsFunctionTypeParameterUpperBounds(
    boolean: TBoolean,
    char: TChar,
    byte: TByte,
    short: TShort,
    int: TInt,
    long: TLong,
    float: TFloat,
    double: TDouble,
    uByte: TUByte,
    uShort: TUShort,
    uInt: TUInt,
    uLong: TULong,
    string: TString,
    function: TFunction,
    externalInterface: TExternalInterface,
    externalOpenClass: TExternalOpenClass,
    externalObject: TExternalObject,
    correctTypeParameter: TCorrectTypeParameter
)

external class CorrectJsInteropTypesAsClassTypeParameterUpperBounds<
        // primitive types
        TBoolean: Boolean,
        TChar: Char,
        TByte: Byte,
        TShort: Short,
        TInt: Int,
        TLong: Long,
        TFloat: Float,
        TDouble: Double,
        // unsigned integer types
        TUByte: UByte,
        TUShort: UShort,
        TUInt: UInt,
        TULong: ULong,
        // string types
        TString: String,
        // function types
        TFunction: () -> Unit,
        // external types
        TExternalInterface: ExternalInterface,","TExternalOpenClass: ExternalOpenClass,"
"// TARGET_BACKEND: JVM
// WITH_STDLIB

// JVM_ABI_K1_K2_DIFF: KT-63864

// FILE: test.kt
fun box(): String {
    Foo(
            logged(""i"", try { 1 } catch (e: Exception) { 42 }),
            logged(""j"", 2)
    )

    val result = log.toString()
    if (result != ""ij<clinit><init>"") return ""Fail: '$result'""","return ""OK"""
"irEnumEntry: IrEnumEntry,
        selector: String
): ObjCExportCodeGenerator.ObjCToKotlinMethodAdapter {
    val bridgeName = ""${irEnumEntry.parentAsClass.computeTypeInfoSymbolName()}.${irEnumEntry.name.asString()}""
    return generateObjCToKotlinSyntheticGetter(selector, bridgeName) {
        initRuntimeIfNeeded() // For instance methods it gets called when allocating.

        val value = getEnumEntry(irEnumEntry, ExceptionHandler.Caller)
        autoreleaseAndRet(kotlinReferenceToRetainedObjC(value))
    }
}

private fun ObjCExportCodeGenerator.createEnumValuesOrEntriesAdapter(
        function: IrFunction,
        selector: String
): ObjCExportCodeGenerator.ObjCToKotlinMethodAdapter {
    val methodBridge = MethodBridge(
        returnBridge = MethodBridge.ReturnValue.Mapped(ReferenceBridge),
        receiver = MethodBridgeReceiver.Static,
        valueParameters = emptyList()
    )

    val imp = generateObjCImp(function, function, methodBridge, isVirtual = false)

    return objCToKotlinMethodAdapter(selector, methodBridge, imp)
}

private fun ObjCExportCodeGenerator.createThrowableAsErrorAdapter(): ObjCExportCodeGenerator.ObjCToKotlinMethodAdapter {
    val methodBridge = MethodBridge(
        returnBridge = MethodBridge.ReturnValue.Mapped(ReferenceBridge),
        receiver = MethodBridgeReceiver.Instance,
        valueParameters = emptyList()
    )

    val imp = generateObjCImpBy(methodBridge, suffix = ""ThrowableAsError"") {
        val exception = objCReferenceToKotlin(param(0), Lifetime.ARGUMENT)
        ret(callFromBridge(llvm.Kotlin_ObjCExport_WrapExceptionToNSError, listOf(exception)))
    }

    val selector = ObjCExportNamer.kotlinThrowableAsErrorMethodName
    return objCToKotlinMethodAdapter(selector, methodBridge, imp)
}

private fun objCFunctionType(generationState: NativeGenerationState, methodBridge: MethodBridge): LlvmFunctionSignature {
    val paramTypes = methodBridge.paramBridges.map { it.toLlvmParamType(generationState.llvm) }
    val returnType = methodBridge.returnBridge.toLlvmRetType(generationState)
    return LlvmFunctionSignature(returnType, paramTypes, isVararg = false)
}

private fun ObjCValueType.toLlvmType(llvm: CodegenLlvmHelpers): LLVMTypeRef = when (this) {
    ObjCValueType.BOOL -> llvm.int8Type
    ObjCValueType.UNICHAR -> llvm.int16Type
    ObjCValueType.CHAR -> llvm.int8Type
    ObjCValueType.SHORT -> llvm.int16Type
    ObjCValueType.INT -> llvm.int32Type
    ObjCValueType.LONG_LONG -> llvm.int64Type
    ObjCValueType.UNSIGNED_CHAR -> llvm.int8Type
    ObjCValueType.UNSIGNED_SHORT -> llvm.int16Type
    ObjCValueType.UNSIGNED_INT -> llvm.int32Type
    ObjCValueType.UNSIGNED_LONG_LONG -> llvm.int64Type
    ObjCValueType.FLOAT -> llvm.floatType
    ObjCValueType.DOUBLE -> llvm.doubleType
    ObjCValueType.POINTER -> llvm.int8PtrType
}",private fun MethodBridgeParameter.toLlvmParamType(llvm: CodegenLlvmHelpers): LlvmParamType = when (this) {
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js.lower

import org.jetbrains.kotlin.backend.common.lower.DefaultParameterInjector
import org.jetbrains.kotlin.ir.UNDEFINED_OFFSET
import org.jetbrains.kotlin.ir.backend.js.JsIrBackendContext
import org.jetbrains.kotlin.ir.backend.js.JsLoweredDeclarationOrigin
import org.jetbrains.kotlin.ir.backend.js.JsStatementOrigins
import org.jetbrains.kotlin.ir.backend.js.export.isExported
import org.jetbrains.kotlin.ir.backend.js.utils.getVoid
import org.jetbrains.kotlin.ir.backend.js.utils.jsConstructorReference
import org.jetbrains.kotlin.ir.builders.IrBlockBuilder
import org.jetbrains.kotlin.ir.declarations.IrFunction
import org.jetbrains.kotlin.ir.declarations.IrValueParameter
import org.jetbrains.kotlin.ir.expressions.IrCall
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.expressions.IrFunctionAccessExpression
import org.jetbrains.kotlin.ir.expressions.impl.IrCallImpl
import org.jetbrains.kotlin.ir.symbols.IrClassSymbol
import org.jetbrains.kotlin.ir.util.isTopLevel
import org.jetbrains.kotlin.ir.util.isVararg

class JsDefaultParameterInjector(context: JsIrBackendContext) :
    DefaultParameterInjector<JsIrBackendContext>(
        context,
        factory = JsDefaultArgumentFunctionFactory(context),
        skipExternalMethods = true,",forceSetOverrideSymbols = false
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package kotlin.jvm.internal.markers

public interface KMappedMarker

public interface KMutableIterable : KMappedMarker

public interface KMutableCollection : KMutableIterable",public interface KMutableList : KMutableCollection
"import org.jetbrains.kotlin.ir.objcinterop.canObjCClassMethodBeCalledVirtually
import org.jetbrains.kotlin.ir.objcinterop.isKotlinObjCClass
import org.jetbrains.kotlin.ir.objcinterop.isObjCClassMethod
import org.jetbrains.kotlin.ir.symbols.IrFieldSymbol
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.ir.visitors.IrElementVisitorVoid
import org.jetbrains.kotlin.ir.visitors.acceptChildrenVoid
import org.jetbrains.kotlin.ir.visitors.acceptVoid

internal class OverriddenFunctionInfo(
        val function: IrSimpleFunction,
        val overriddenFunction: IrSimpleFunction
) {
    val needBridge: Boolean
        get() = function.target.needBridgeTo(overriddenFunction)

    val bridgeDirections: BridgeDirections
        get() = function.target.bridgeDirectionsTo(overriddenFunction)

    val canBeCalledVirtually: Boolean
        get() {
            if (overriddenFunction.isObjCClassMethod()) {
                return function.canObjCClassMethodBeCalledVirtually(overriddenFunction)
            }

            return overriddenFunction.isOverridable
        }

    val inheritsBridge: Boolean
        get() = !function.isReal
                && function.target.overrides(overriddenFunction)
                && function.bridgeDirectionsTo(overriddenFunction).allNotNeeded()

    fun getImplementation(context: Context): IrSimpleFunction? {
        val target = function.target
        val implementation = if (!needBridge)
            target
        else {
            val bridgeOwner = if (inheritsBridge) {
                target // Bridge is inherited from superclass.
            } else {
                function
            }
            context.bridgesSupport.getBridge(OverriddenFunctionInfo(bridgeOwner, overriddenFunction))
        }
        return if (implementation.modality == Modality.ABSTRACT) null else implementation
    }

    override fun toString(): String {
        return ""(descriptor=$function, overriddenDescriptor=$overriddenFunction)""
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is OverriddenFunctionInfo) return false

        if (function != other.function) return false
        if (overriddenFunction != other.overriddenFunction) return false

        return true
    }

    override fun hashCode(): Int {
        var result = function.hashCode()",result = 31 * result + overriddenFunction.hashCode()
"// !DIAGNOSTICS: -DEBUG_INFO_SMARTCAST
package a

import java.util.Date
import java.util.Comparator

fun foo() {

    val c: Comparator<Date?> = comparator { date1, date2 ->
        if (date1 != null && date2 != null) {
            date1.compareTo(date2) * -11
        } else {
            11
        }
    }
}

fun bar(i: Int, a: <!UNRESOLVED_REFERENCE!>U<!>) {",val r = if (true) i else <!DEBUG_INFO_ELEMENT_WITH_ERROR_TYPE!>a<!>
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/fir/tree/tree-generator/Readme.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"")

package org.jetbrains.kotlin.fir.expressions.impl

import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.fir.MutableOrEmptyList
import org.jetbrains.kotlin.fir.builder.toMutableOrEmpty
import org.jetbrains.kotlin.fir.expressions.*
import org.jetbrains.kotlin.fir.types.ConeKotlinType
import org.jetbrains.kotlin.fir.types.FirTypeRef
import org.jetbrains.kotlin.fir.visitors.FirTransformer
import org.jetbrains.kotlin.fir.visitors.FirVisitor
import org.jetbrains.kotlin.fir.visitors.transformInplace

@OptIn(UnresolvedExpressionTypeAccess::class)
internal class FirTypeOperatorCallImpl(
    override val source: KtSourceElement?,
    @property:UnresolvedExpressionTypeAccess
    override var coneTypeOrNull: ConeKotlinType?,
    override var annotations: MutableOrEmptyList<FirAnnotation>,
    override var argumentList: FirArgumentList,
    override val operation: FirOperation,
    override var conversionTypeRef: FirTypeRef,
) : FirTypeOperatorCall() {
    override var argFromStubType: Boolean = false

    override fun <R, D> acceptChildren(visitor: FirVisitor<R, D>, data: D) {
        annotations.forEach { it.accept(visitor, data) }
        argumentList.accept(visitor, data)
        conversionTypeRef.accept(visitor, data)
    }

    override fun <D> transformChildren(transformer: FirTransformer<D>, data: D): FirTypeOperatorCallImpl {
        transformConversionTypeRef(transformer, data)
        transformOtherChildren(transformer, data)
        return this
    }

    override fun <D> transformAnnotations(transformer: FirTransformer<D>, data: D): FirTypeOperatorCallImpl {
        annotations.transformInplace(transformer, data)",return this
"// FIR_IDENTICAL
import kotlin.contracts.*

@Suppress(""OPT_IN_USAGE_ERROR"", ""OPT_IN_USAGE_FUTURE_ERROR"")
fun exactlyOnce(f: () -> Unit) {
    contract {
        callsInPlace(f, InvocationKind.EXACTLY_ONCE)
    }
    f()
}

fun test() {
    var s: String? = """"
    if (s != null) {
        val block: () -> Unit
        exactlyOnce {
            block = { s = null }
        }",block()
"var useFastJarFileSystem = false
        set(value) {
            checkFrozen()
            field = value
        }

    @Argument(
        value = ""-Xsuppress-missing-builtins-error"",
        description = """"""Suppress the ""cannot access built-in declaration"" error (useful with '-no-stdlib').""""""
    )
    var suppressMissingBuiltinsError = false
        set(value) {
            checkFrozen()
            field = value
        }

    @Argument(
        value = ""-Xscript-resolver-environment"",
        valueDescription = ""<key=value[,]>"",
        description = ""Set the script resolver environment in key-value pairs (the value can be quoted and escaped).""
    )
    var scriptResolverEnvironment: Array<String>? = null
        set(value) {
            checkFrozen()
            field = value
        }

    // Javac options
    @Argument(value = ""-Xuse-javac"", description = ""Use javac for Java source and class file analysis."")
    var useJavac = false
        set(value) {
            checkFrozen()
            field = value
        }

    @Argument(value = ""-Xcompile-java"", description = ""Reuse 'javac' analysis and compile Java source files."")
    var compileJava = false
        set(value) {
            checkFrozen()
            field = value
        }

    @Argument(
        value = ""-Xjavac-arguments"",
        valueDescription = ""<option[,]>"",
        description = ""Java compiler arguments.""
    )
    var javacArguments: Array<String>? = null
        set(value) {
            checkFrozen()
            field = value
        }


    @Argument(
        value = ""-Xjava-source-roots"",
        valueDescription = ""<path>"",
        description = ""Paths to directories with Java source files.""
    )
    var javaSourceRoots: Array<String>? = null
        set(value) {
            checkFrozen()
            field = value
        }",@Argument(
"@file:Suppress(""unused"")",import kotlinx.cinterop.pointed
"// SKIP_TXT

class ExcA : Exception()

class ExcB : Exception()

fun test2() {
    val s: String? = try {
        """"
    }
    catch (e: ExcA) {
        null
    }
    catch (e: ExcB) <!TYPE_MISMATCH!>{
        10
    }<!>
    s<!UNSAFE_CALL!>.<!>length
}

fun test3() {
    val s: String? = try {
        """"
    }
    catch (e: ExcA) {
        null
    }
    catch (e: ExcB) {
        return
    }
    s<!UNSAFE_CALL!>.<!>length
}

fun test4() {
    val s: String? = try {
        """"
    }
    catch (e: ExcA) {
        null
    }
    finally {
        """"
    }",s<!UNSAFE_CALL!>.<!>length
"// WITH_STDLIB
// WORKS_WHEN_VALUE_CLASS
// LANGUAGE: +ValueClasses

class BoxT<T>(val boxed: T)
class BoxAny(val boxed: Any?)
class BoxFoo(val boxed: IFoo?)

interface IFoo

OPTIONAL_JVM_INLINE_ANNOTATION
value class Str(val value: String) : IFoo

OPTIONAL_JVM_INLINE_ANNOTATION
value class Str2(val value: Str): IFoo

OPTIONAL_JVM_INLINE_ANNOTATION
value class StrArr(val value: Array<String>): IFoo

fun boxToTypeParameter(x: Str?) = BoxT(x)
fun boxToNullableAny(x: Str?) = BoxAny(x)
fun boxToNullableInterface(x: Str?) = BoxFoo(x)

fun box2ToTypeParameter(x: Str2?) = BoxT(x)
fun box2ToNullableAny(x: Str2?) = BoxAny(x)
fun box2ToNullableInterface(x: Str2?) = BoxFoo(x)

fun boxArrToTypeParameter(x: StrArr?) = BoxT(x)
fun boxArrToNullableAny(x: StrArr?) = BoxAny(x)
fun boxArrToNullableInterface(x: StrArr?) = BoxFoo(x)

fun box(): String {
    if (boxToNullableAny(null).boxed != null) throw AssertionError()
    if (boxToTypeParameter(null).boxed != null) throw AssertionError()
    if (boxToNullableInterface(null).boxed != null) throw AssertionError()

    if (box2ToNullableAny(null).boxed != null) throw AssertionError()",if (box2ToTypeParameter(null).boxed != null) throw AssertionError()
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.targets.js.nodejs

import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.Task
import org.gradle.api.file.RegularFile
import org.gradle.api.plugins.BasePlugin
import org.gradle.api.provider.Provider
import org.gradle.api.tasks.TaskProvider
import org.jetbrains.kotlin.gradle.plugin.PropertiesProvider
import org.jetbrains.kotlin.gradle.plugin.internal.configurationTimePropertiesAccessor
import org.jetbrains.kotlin.gradle.plugin.internal.usedAtConfigurationTime
import org.jetbrains.kotlin.gradle.plugin.variantImplementationFactory
import org.jetbrains.kotlin.gradle.targets.js.MultiplePluginDeclarationDetector
import org.jetbrains.kotlin.gradle.targets.js.npm.*
import org.jetbrains.kotlin.gradle.targets.js.npm.resolver.KotlinRootNpmResolver
import org.jetbrains.kotlin.gradle.targets.js.npm.resolver.PACKAGE_JSON_UMBRELLA_TASK_NAME
import org.jetbrains.kotlin.gradle.targets.js.npm.resolver.implementing
import org.jetbrains.kotlin.gradle.targets.js.npm.tasks.KotlinNpmCachesSetup
import org.jetbrains.kotlin.gradle.targets.js.npm.tasks.KotlinNpmInstallTask
import org.jetbrains.kotlin.gradle.targets.js.npm.tasks.RootPackageJsonTask
import org.jetbrains.kotlin.gradle.targets.js.yarn.YarnPlugin
import org.jetbrains.kotlin.gradle.tasks.CleanDataTask
import org.jetbrains.kotlin.gradle.tasks.registerTask
import org.jetbrains.kotlin.gradle.utils.castIsolatedKotlinPluginClassLoaderAware
import org.jetbrains.kotlin.gradle.utils.getFile
import org.jetbrains.kotlin.gradle.utils.onlyIfCompat
import org.jetbrains.kotlin.gradle.utils.providerWithLazyConvention

open class NodeJsRootPlugin : Plugin<Project> {
    override fun apply(project: Project) {
        MultiplePluginDeclarationDetector.detect(project)

        project.plugins.apply(BasePlugin::class.java)

        check(project == project.rootProject) {
            ""NodeJsRootPlugin can be applied only to root project""
        }

        val nodeJs = project.extensions.create(
            NodeJsRootExtension.EXTENSION_NAME,
            NodeJsRootExtension::class.java,
            project
        )

        val npm = project.extensions.create(
            NpmExtension.EXTENSION_NAME,
            NpmExtension::class.java,
            project
        )

        addPlatform(project, nodeJs)

        npm.nodeJsEnvironment.value(
            project.provider {
                nodeJs.requireConfigured()
            }
        ).disallowChanges()",nodeJs.packageManagerExtension.convention(
"/*
 * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the LICENSE file.
 */
// JVM_ABI_K1_K2_DIFF: KT-63864
// !LANGUAGE:-ProhibitComparisonOfIncompatibleEnums
// WITH_STDLIB

import kotlin.test.*

val sb = StringBuilder()",enum class EnumA {
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.calls.tower

import org.jetbrains.kotlin.config.LanguageVersionSettings
import org.jetbrains.kotlin.descriptors.*
import org.jetbrains.kotlin.psi.KtExpression
import org.jetbrains.kotlin.psi.ValueArgument
import org.jetbrains.kotlin.resolve.calls.inference.components.FreshVariableNewTypeSubstitutor
import org.jetbrains.kotlin.resolve.calls.inference.components.NewTypeSubstitutor
import org.jetbrains.kotlin.resolve.calls.inference.model.*
import org.jetbrains.kotlin.resolve.calls.model.*
import org.jetbrains.kotlin.resolve.calls.results.ResolutionStatus
import org.jetbrains.kotlin.resolve.calls.tasks.ExplicitReceiverKind
import org.jetbrains.kotlin.resolve.calls.util.toResolutionStatus
import org.jetbrains.kotlin.resolve.constants.IntegerValueTypeConstant
import org.jetbrains.kotlin.resolve.scopes.receivers.CastImplicitClassReceiver
import org.jetbrains.kotlin.resolve.scopes.receivers.ImplicitClassReceiver
import org.jetbrains.kotlin.resolve.scopes.receivers.ReceiverValue
import org.jetbrains.kotlin.types.*

class NewResolvedCallImpl<D : CallableDescriptor>(
    override val resolvedCallAtom: ResolvedCallAtom,
    substitutor: NewTypeSubstitutor?,
    diagnostics: Collection<KotlinCallDiagnostic>,
    override val typeApproximator: TypeApproximator,
    override val languageVersionSettings: LanguageVersionSettings,
) : NewAbstractResolvedCall<D>() {
    override val psiKotlinCall: PSIKotlinCall = resolvedCallAtom.atom.psiKotlinCall
    override val kotlinCall: KotlinCall = resolvedCallAtom.atom

    override val freshSubstitutor: FreshVariableNewTypeSubstitutor
        get() = resolvedCallAtom.freshVariablesSubstitutor

    override val argumentMappingByOriginal: Map<ValueParameterDescriptor, ResolvedCallArgument>
        get() = resolvedCallAtom.argumentMappingByOriginal

    override var diagnostics: Collection<KotlinCallDiagnostic> = diagnostics
        private set

    private lateinit var resultingDescriptor: D
    private lateinit var typeArguments: List<UnwrappedType>
    private var smartCastDispatchReceiverType: KotlinType? = null
    private var expectedTypeForSamConvertedArgumentMap: Map<ValueArgument, UnwrappedType>? = null
    private var expectedTypeForSuspendConvertedArgumentMap: Map<ValueArgument, UnwrappedType>? = null
    private var expectedTypeForUnitConvertedArgumentMap: Map<ValueArgument, UnwrappedType>? = null
    private var argumentTypeForConstantConvertedMap: Map<KtExpression, IntegerValueTypeConstant>? = null
    private var extensionReceiver = resolvedCallAtom.extensionReceiverArgument?.receiver?.receiverValue",private var dispatchReceiver = resolvedCallAtom.dispatchReceiverArgument?.receiver?.receiverValue
"private fun Set<IrDeclaration>.computeTag(declaration: IrDeclaration): String? {
        // Use LEGACY here because the declaration may come from an old klib, in which its `IdSignature.CommonSignature`
        // doesn't have `description`, but only `id`. Hence, we always render the signature with `id` instead of `description`,
        // because otherwise there may be a mismatch when we're computing the tag first for the IrDeclaration deserialized from klib,
        // and then for the same declaration but constructed from a descriptor.
        //
        // The former won't have `description` in its `IdSignature`, the latter will have it,
        // which will result in different renders unless we use the LEGACY renderer.
        val tag = (backendContext.irFactory as IdSignatureRetriever).declarationSignature(declaration)?.render(IdSignatureRenderer.LEGACY)

        if (tag == null && !contains(declaration)) {
            error(""signature for ${declaration.render()} not found"")
        }

        return tag
    }

    private fun JsIrProgramFragment.computeAndSaveNameBindings(
        definitions: Set<IrDeclaration>,
        nameGenerator: JsNameLinkingNamer
    ) {
        nameGenerator.nameMap.entries.forEach { (declaration, name) ->
            definitions.computeTag(declaration)?.let { tag ->
                nameBindings[tag] = name
                if (isBuiltInClass(declaration) || checkIsFunctionInterface(declaration.symbol.signature)) {
                    optionalCrossModuleImports += tag
                }
            }
        }
    }

    private fun JsIrProgramFragment.computeAndSaveImports(
        definitions: Set<IrDeclaration>,
        nameGenerator: JsNameLinkingNamer
    ) {
        nameGenerator.imports.entries.forEach { (declaration, importExpression) ->
            val tag = definitions.computeTag(declaration) ?: error(""No tag for imported declaration ${declaration.render()}"")
            imports[tag] = importExpression
            optionalCrossModuleImports += tag
        }
    }

    private fun JsIrProgramFragment.computeAndSaveDefinitions(
        definitions: Set<IrDeclaration>,
        fileExports: IrFileExports,
    ) {
        fileExports.file.declarations.forEach {
            definitions.computeTag(it)?.let { tag ->
                this.definitions += tag
            }

            if (it is IrClass && it.isInterface) {
                it.declarations.forEach {
                    definitions.computeTag(it)?.let { tag ->
                        this.definitions += tag
                    }
                }
            }
        }
    }

    private fun IrFile.couldBeSkipped(): Boolean = declarations.all { it.origin == JsCodeOutliningLowering.OUTLINED_JS_CODE_ORIGIN }
}

private fun generateWrappedModuleBody(","granularity: JsGenerationGranularity,"
"// IGNORE_BACKEND: NATIVE
// IGNORE_BACKEND: WASM
// IGNORE_BACKEND: JS, JS_IR, JS_IR_ES6
// IGNORE_LIGHT_ANALYSIS

// CHECK_TYPE_WITH_EXACT

class Buildee<CT> {
    fun yield(arg: CT) {}
    fun materialize(): CT = 42 as CT
}

fun <FT> build(
    instructions: Buildee<FT>.() -> Unit
): Buildee<FT> {
    return Buildee<FT>().apply(instructions)
}

// test 1: PTV is in consuming position (yield-case)
fun testYield() {
    fun testBasicCase() {
        val arg: Int = 42
        val buildee = build {
            yield(arg)
        }
        checkExactType<Buildee<Int>>(buildee)
    }

    fun testLiterals() {
        fun test1() {
            val buildee = build {
                yield(42)
            }
            checkExactType<Buildee<Int>>(buildee)
        }
        fun test2() {
            val buildee = build {
                yield(0x13)
            }
            checkExactType<Buildee<Int>>(buildee)
        }
        fun test3() {
            val buildee = build {
                yield(0b1000)
            }
            checkExactType<Buildee<Int>>(buildee)
        }

        test1()
        test2()
        test3()
    }",testBasicCase()
"/*
 * KOTLIN DIAGNOSTICS NOT LINKED SPEC TEST (NEGATIVE)
 *
 * SECTIONS: dfa
 * NUMBER: 1
 * DESCRIPTION: Raw data flow analysis test
 * HELPERS: classes, objects, functions, typealiases, properties, enumClasses, interfaces, sealedClasses
 */

// TESTCASE NUMBER: 1
fun case_1(x: Any?) {
    if (x != <!USELESS_IS_CHECK!>null is Boolean<!>) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!><!UNSAFE_CALL!>.<!>equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!><!UNSAFE_CALL!>.<!>propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!><!UNSAFE_CALL!>.<!>funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any?"")!>x<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 3
fun case_3() {
    if (<!SENSELESS_COMPARISON!>Object.prop_1 == null !== null<!>)
    else {
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>Object.prop_1<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>Object.prop_1<!><!UNSAFE_CALL!>.<!>equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>Object.prop_1<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>Object.prop_1<!><!UNSAFE_CALL!>.<!>propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>Object.prop_1<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>Object.prop_1<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>Object.prop_1<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>Object.prop_1<!><!UNSAFE_CALL!>.<!>funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>Object.prop_1<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>Object.prop_1<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 4
fun case_4(x: Char?) {
    if (x != null || <!USELESS_IS_CHECK!>false is Boolean<!>) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char?"")!>x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char?"")!>x<!><!UNSAFE_CALL!>.<!>equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char?"")!>x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char?"")!>x<!><!UNSAFE_CALL!>.<!>propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char?"")!>x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char?"")!>x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char?"")!>x<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char?"")!>x<!><!UNSAFE_CALL!>.<!>funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char?"")!>x<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Char?"")!>x<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 5
fun case_5() {
    val x: Unit? = null

    if (<!EQUALITY_NOT_APPLICABLE!>x !== <!USELESS_IS_CHECK!>null is Boolean?<!><!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit?"")!>x<!>
    if (<!SENSELESS_COMPARISON!>x !== null == null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit?"")!>x<!><!UNSAFE_CALL!>.<!>equals(null)","if (<!SENSELESS_COMPARISON!>x !== null == null<!>) <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Unit?"")!>x<!>.propT"
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.native.checkers

import org.jetbrains.kotlin.KtFakeSourceElementKind
import org.jetbrains.kotlin.KtSourceElement
import org.jetbrains.kotlin.diagnostics.DiagnosticReporter
import org.jetbrains.kotlin.diagnostics.reportOn
import org.jetbrains.kotlin.fir.analysis.checkers.MppCheckerKind
import org.jetbrains.kotlin.fir.analysis.checkers.context.CheckerContext",import org.jetbrains.kotlin.fir.analysis.checkers.declaration.FirBasicDeclarationChecker
// WITH_STDLIB,"@file:JvmName(""TestKt"")"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.backend.utils

import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.backend.Fir2IrComponents
import org.jetbrains.kotlin.fir.declarations.FirCallableDeclaration
import org.jetbrains.kotlin.fir.declarations.FirDeclarationOrigin
import org.jetbrains.kotlin.fir.declarations.fullyExpandedClass
import org.jetbrains.kotlin.fir.declarations.synthetic.FirSyntheticProperty
import org.jetbrains.kotlin.fir.declarations.utils.isStatic
import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.expressions.FirExpression
import org.jetbrains.kotlin.fir.expressions.FirResolvedQualifier
import org.jetbrains.kotlin.fir.expressions.FirSmartCastExpression
import org.jetbrains.kotlin.fir.references.FirReference
import org.jetbrains.kotlin.fir.references.FirResolvedNamedReference
import org.jetbrains.kotlin.fir.resolve.calls.FirSimpleSyntheticPropertySymbol
import org.jetbrains.kotlin.fir.resolve.findClassRepresentation
import org.jetbrains.kotlin.fir.resolve.toSymbol
import org.jetbrains.kotlin.fir.scopes.impl.originalConstructorIfTypeAlias
import org.jetbrains.kotlin.fir.symbols.ConeClassLikeLookupTag
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.fir.symbols.impl.*
import org.jetbrains.kotlin.fir.types.ConeClassLikeType
import org.jetbrains.kotlin.fir.types.ConeDynamicType
import org.jetbrains.kotlin.fir.types.coneType
import org.jetbrains.kotlin.fir.types.resolvedType
import org.jetbrains.kotlin.fir.unwrapUseSiteSubstitutionOverrides
import org.jetbrains.kotlin.ir.symbols.IrClassifierSymbol
import org.jetbrains.kotlin.ir.symbols.IrSymbol
import kotlin.contracts.ExperimentalContracts
import kotlin.contracts.contract

enum class ConversionTypeOrigin(val forSetter: Boolean) {
    DEFAULT(forSetter = false),
    SETTER(forSetter = true);
}

fun FirClassifierSymbol<*>.toSymbol(
    c: Fir2IrComponents,
    typeOrigin: ConversionTypeOrigin = ConversionTypeOrigin.DEFAULT,
    handleAnnotations: ((List<FirAnnotation>) -> Unit)? = null
): IrClassifierSymbol = with(c) {
    val symbol = this@toSymbol
    when (symbol) {
        is FirTypeParameterSymbol -> {
            classifierStorage.getIrTypeParameterSymbol(symbol, typeOrigin)
        }

        is FirTypeAliasSymbol -> {
            handleAnnotations?.invoke(symbol.fir.expandedTypeRef.annotations)
            val coneClassLikeType = symbol.fir.expandedTypeRef.coneType as ConeClassLikeType
            coneClassLikeType.lookupTag.toSymbol(session)
                ?.toSymbol(c, typeOrigin, handleAnnotations)",?: classifiersGenerator.createIrClassForNotFoundClass(coneClassLikeType.lookupTag).symbol
"// FIR_IDENTICAL
// !LANGUAGE: +RestrictRetentionForExpressionAnnotations

@Target(AnnotationTarget.EXPRESSION)",@Retention(AnnotationRetention.SOURCE)
"interface Z {

    fun testFun() : String {",return privateFun()
"abstract class BuildMetaInfo {
    enum class CustomKeys {
        LANGUAGE_VERSION_STRING, IS_EAP, METADATA_VERSION_STRING, PLUGIN_CLASSPATHS, API_VERSION_STRING
    }

    fun obtainReasonForRebuild(currentCompilerArgumentsMap: Map<String, String>, previousCompilerArgsMap: Map<String, String>): String? {
        if (currentCompilerArgumentsMap.keys != previousCompilerArgsMap.keys) {
            return ""Compiler arguments version was changed""
        }

        val changedCompilerArguments = currentCompilerArgumentsMap.mapNotNull {
            val key = it.key
            val previousValue = previousCompilerArgsMap[it.key] ?: return@mapNotNull key
            val currentValue = it.value
            return@mapNotNull if (compareIsChanged(key, currentValue, previousValue)) key else null
        }

        if (changedCompilerArguments.isNotEmpty()) {
            val rebuildReason = when (changedCompilerArguments.size) {
                1 -> ""One of compiler arguments was changed: ""
                else -> ""Some compiler arguments were changed: ""
            } + changedCompilerArguments.joinToReadableString()
            return rebuildReason
        }
        return null
    }

    private fun compareIsChanged(key: String, currentValue: String, previousValue: String): Boolean {
        // check for specific key changes
        checkIfPlatformSpecificCompilerArgumentWasChanged(key, currentValue, previousValue)?.let { comparisonResult ->
            return comparisonResult
        }
        when (key) {
            CustomKeys.LANGUAGE_VERSION_STRING.name ->
                return LanguageVersion.fromVersionString(currentValue) != LanguageVersion.fromVersionString(previousValue)
            CustomKeys.API_VERSION_STRING.name -> return ApiVersion.parse(currentValue) != ApiVersion.parse(previousValue)
            CustomKeys.PLUGIN_CLASSPATHS.name -> return !PluginClasspathComparator(previousValue, currentValue).equals()
        }

        // check keys that are sensitive for true -> false change
        if (key in argumentsListForSpecialCheck) {
            return previousValue == ""true"" && currentValue != ""true""
        }

        // compare all other change-sensitive values
        if (previousValue != currentValue) {
            return true
        }

        return false
    }

    open fun checkIfPlatformSpecificCompilerArgumentWasChanged(key: String, currentValue: String, previousValue: String): Boolean? {
        return null
    }

    open fun createPropertiesMapFromCompilerArguments(args: CommonCompilerArguments): Map<String, String> {
        val resultMap = transformClassToPropertiesMap(args, excludedProperties).toMutableMap()
        val languageVersion = args.languageVersion?.let { LanguageVersion.fromVersionString(it) }
            ?: LanguageVersion.LATEST_STABLE
        val languageVersionSting = languageVersion.versionString
        resultMap[CustomKeys.LANGUAGE_VERSION_STRING.name] = languageVersionSting

        val isEAP = languageVersion.isPreRelease()",resultMap[CustomKeys.IS_EAP.name] = isEAP.toString()
"/*
 * KOTLIN DIAGNOSTICS SPEC TEST (POSITIVE)
 *
 * SPEC VERSION: 0.1-100
 * MAIN LINK: expressions, constant-literals, real-literals -> paragraph 3 -> sentence 1
 * NUMBER: 2
 * DESCRIPTION: Real literals with omitted a whole-number part and an exponent mark.
 */

// TESTCASE NUMBER: 1
val value_1 = .0e0

// TESTCASE NUMBER: 2
val value_2 = .0e-00

// TESTCASE NUMBER: 3",val value_3 = .0E000
"// TARGET_BACKEND: JVM
// JVM_TARGET: 1.8
// LANGUAGE: +ProhibitUsingNullableTypeParameterAgainstNotNullAnnotated
// ISSUE: KT-55357

// MODULE: lib
// FILE: J.java
import org.jetbrains.annotations.NotNull;

public interface J {
    @NotNull
    <T> T foo();
}

// FILE: JImpl.java
public class JImpl implements J {
    public <T> T foo() {","return (T) ""OK"";"
"is FirResolvedQualifier -> {
                if (resolvedToCompanionObject) return null
                this.symbol as? FirClassSymbol<*>
            }
            else -> this.resolvedType.fullyExpandedType(session).toClassSymbol(session)
        } ?: return null

        /**
         * class Some {
         *     companion object {
         *         val x: Int = 1
         *     }
         * }
         *
         * Some.x // <--- no superQualifiedSymbol
         */
        if (classSymbol.isCompanion) return null

        val irClassSymbol = classifierStorage.getIrClassSymbol(classSymbol)

        /**
         * enum class Some {
         *     A, B;
         *
         *     val x: Int = 1
         *
         *     fun foo() {
         *         this.x // <--- no superQualifiedSymbol
         *     }
         * }
         */
        if (classSymbol.classKind == ClassKind.ENUM_CLASS && conversionScope.parentStack.any { (it as? IrClass)?.symbol == irClassSymbol }) {
            return null
        }


        /**
         * // FILE: Base.java
         * public class Base {
         *     int fromJava = 0;
         * }
         *
         * // FILE: Derived.kt
         * class Derived : Base() {
         *     val fromKotlin = 1
         *
         *     init {
         *         this.fromJava // <--- no superQualifiedSymbol
         *         this.fromKotlin // <--- superQualifiedSymbol is set
         *     }
         *  }
         */
        if (
            conversionScope.initBlocksStack.any { it.parentAsClass.symbol == irClassSymbol } &&
            !(this is FirThisReceiverExpression && firResolvedSymbol?.fir is FirJavaField)
        ) {
            return null
        }
        return irClassSymbol
    }

    private val Name.dynamicOperator
        get() = when (this) {
            OperatorNameConventions.UNARY_PLUS -> IrDynamicOperator.UNARY_PLUS
            OperatorNameConventions.UNARY_MINUS -> IrDynamicOperator.UNARY_MINUS",OperatorNameConventions.NOT -> IrDynamicOperator.EXCL
"// FILE: logIntrinsic.kt

import kotlin.experimental.*

const val thisFileInfo = <!EVALUATED: `logIntrinsic.kt:5`!>sourceLocation()<!>
const val otherFileInfo = <!EVALUATED: `other.kt:29`!>getSomeInfo()<!>

@CompileTimeCalculation
fun sumWithLog(a: Int, b: Int): String {
    val firstWord = <!EVALUATED: `logIntrinsic.kt:10`!>log(""Function start"")<!>
    val before = <!EVALUATED: `logIntrinsic.kt:11`!>log(""Start summation of $a and $b"")<!>
    val after = <!EVALUATED: `logIntrinsic.kt:12`!>log(""Result of summation is ${a + b}"")<!>
    val finalWord = log(""Function end"", ""<WITHOUT FILE>"")

    return ""\n"" + firstWord + ""\n"" + before + ""\n"" + after + ""\n"" + finalWord
}

const val sum = <!EVALUATED: `
Function start at logIntrinsic.kt:10
Start summation of 2 and 5 at logIntrinsic.kt:11
Result of summation is 7 at logIntrinsic.kt:12","Function end at <WITHOUT FILE>`!>sumWithLog(2, 5)<!>"
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.backend.common.serialization

import org.jetbrains.kotlin.backend.common.serialization.encodings.BinarySymbolData
import org.jetbrains.kotlin.descriptors.CallableMemberDescriptor
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.descriptors.DeserializedDescriptor
import org.jetbrains.kotlin.descriptors.PropertyAccessorDescriptor
import org.jetbrains.kotlin.ir.IrBuiltIns
import org.jetbrains.kotlin.ir.declarations.IrModuleFragment
import org.jetbrains.kotlin.ir.declarations.IrSymbolOwner
import org.jetbrains.kotlin.ir.symbols.IrSymbol
import org.jetbrains.kotlin.ir.symbols.isPublicApi
import org.jetbrains.kotlin.ir.util.DelicateSymbolTableApi
import org.jetbrains.kotlin.ir.util.IdSignature
import org.jetbrains.kotlin.ir.util.SymbolTable
import org.jetbrains.kotlin.library.IrLibrary
import org.jetbrains.kotlin.library.KotlinAbiVersion
import org.jetbrains.kotlin.library.SerializedIrFile
import org.jetbrains.kotlin.library.impl.*

class ICData(val icData: List<SerializedIrFile>, val containsErrorCode: Boolean)

class ICKotlinLibrary(private val icData: List<SerializedIrFile>) : IrLibrary {
    override val hasIr get() = true
    override val dataFlowGraph: ByteArray? = null

    private inline fun <K, R : IrTableReader<K>> Array<R?>.itemBytes(fileIndex: Int, key: K, factory: () -> R): ByteArray {
        val reader = this[fileIndex] ?: factory().also { this[fileIndex] = it }

        return reader.tableItemBytes(key)
    }

    private inline fun <R : IrArrayReader> Array<R?>.itemBytes(fileIndex: Int, index: Int, factory: () -> R): ByteArray {
        val reader = this[fileIndex] ?: factory().also { this[fileIndex] = it }

        return reader.tableItemBytes(index)
    }

    private inline fun <R : IrArrayReader?> Array<R?>.itemNullableBytes(fileIndex: Int, index: Int, factory: () -> R): ByteArray? {
        val reader = this[fileIndex] ?: factory().also { this[fileIndex] = it }

        return reader?.tableItemBytes(index)
    }

    private val indexedDeclarations = arrayOfNulls<DeclarationIrTableMemoryReader>(icData.size)
    private val indexedTypes = arrayOfNulls<IrArrayMemoryReader>(icData.size)
    private val indexedSignatures = arrayOfNulls<IrArrayMemoryReader>(icData.size)
    private val indexedStrings = arrayOfNulls<IrArrayMemoryReader>(icData.size)
    private val indexedDebugInfos = arrayOfNulls<IrArrayMemoryReader?>(icData.size)
    private val indexedBodies = arrayOfNulls<IrArrayMemoryReader>(icData.size)

    override fun irDeclaration(index: Int, fileIndex: Int): ByteArray =
        indexedDeclarations.itemBytes(fileIndex, DeclarationId(index)) {
            DeclarationIrTableMemoryReader(icData[fileIndex].declarations)
        }

    override fun type(index: Int, fileIndex: Int): ByteArray =
        indexedTypes.itemBytes(fileIndex, index) {",IrArrayMemoryReader(icData[fileIndex].types)
"val nullableValues = listOf(null to ""null"", null to ""undefined"")

fun values(type: String, nullable: Boolean) = values(type) + (if (nullable) nullableValues else listOf())

fun main(args: Array<String>) {
	val types = listOf(""Byte"", ""Boolean"", ""Short"", ""Char"", ""Int"", ""Float"", ""Double"", ""Long"")

    val invocations = mutableListOf<String>()

    for (firstType in types) {
        for (secondType in types) {
            for ((firstTypeSuffix, firstNameSuffix) in listOf("""" to """", ""?"" to ""Q"")) {
                for ((secondTypeSuffix, secondNameSuffix) in listOf("""" to """", ""?"" to ""Q"")) {
                    val fnName = ""eq$firstType$firstNameSuffix$secondType$secondNameSuffix""
                    println(""fun <A: $firstType$firstTypeSuffix, B: $secondType$secondTypeSuffix> $fnName(a: A, b: B) = a == b"")

                    val firstValues = values(firstType, firstTypeSuffix == ""?"")
                    val secondValues = values(secondType, secondTypeSuffix == ""?"")

                    for ((v1, s1) in firstValues) {
                        for ((v2, s2) in secondValues) {
                            val expectedResult = if (v1 == v2) ""True"" else ""False""

                            invocations += ""assert$expectedResult($fnName($s1, $s2))""
                        }
                    }
                }
            }
        }
    }

    println()
    println(""fun box(): String {"")
    invocations.forEach { println(""    $it"") }
    println(""    return \""OK\"""")
    println(""}"")
}

*/


fun <A: Byte, B: Byte> eqByteByte(a: A, b: B) = a == b
fun <A: Byte, B: Byte?> eqByteByteQ(a: A, b: B) = a == b
fun <A: Byte?, B: Byte> eqByteQByte(a: A, b: B) = a == b
fun <A: Byte?, B: Byte?> eqByteQByteQ(a: A, b: B) = a == b
fun <A: Byte, B: Boolean> eqByteBoolean(a: A, b: B) = a == b
fun <A: Byte, B: Boolean?> eqByteBooleanQ(a: A, b: B) = a == b
fun <A: Byte?, B: Boolean> eqByteQBoolean(a: A, b: B) = a == b
fun <A: Byte?, B: Boolean?> eqByteQBooleanQ(a: A, b: B) = a == b
fun <A: Byte, B: Short> eqByteShort(a: A, b: B) = a == b
fun <A: Byte, B: Short?> eqByteShortQ(a: A, b: B) = a == b
fun <A: Byte?, B: Short> eqByteQShort(a: A, b: B) = a == b
fun <A: Byte?, B: Short?> eqByteQShortQ(a: A, b: B) = a == b
fun <A: Byte, B: Char> eqByteChar(a: A, b: B) = a == b
fun <A: Byte, B: Char?> eqByteCharQ(a: A, b: B) = a == b
fun <A: Byte?, B: Char> eqByteQChar(a: A, b: B) = a == b
fun <A: Byte?, B: Char?> eqByteQCharQ(a: A, b: B) = a == b
fun <A: Byte, B: Int> eqByteInt(a: A, b: B) = a == b
fun <A: Byte, B: Int?> eqByteIntQ(a: A, b: B) = a == b
fun <A: Byte?, B: Int> eqByteQInt(a: A, b: B) = a == b
fun <A: Byte?, B: Int?> eqByteQIntQ(a: A, b: B) = a == b
fun <A: Byte, B: Float> eqByteFloat(a: A, b: B) = a == b
fun <A: Byte, B: Float?> eqByteFloatQ(a: A, b: B) = a == b
fun <A: Byte?, B: Float> eqByteQFloat(a: A, b: B) = a == b","fun <A: Byte?, B: Float?> eqByteQFloatQ(a: A, b: B) = a == b"
"*/
internal
fun DependencyHandler.`kotlinNativeCompilerPluginClasspath`(
    dependencyNotation: String,
    dependencyConfiguration: Action<ExternalModuleDependency>
): ExternalModuleDependency = addDependencyTo(
    this, ""kotlinNativeCompilerPluginClasspath"", dependencyNotation, dependencyConfiguration
) as ExternalModuleDependency

/**
 * Adds a dependency to the 'kotlinNativeCompilerPluginClasspath' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`kotlinNativeCompilerPluginClasspath`(
    dependencyNotation: Provider<*>,
    dependencyConfiguration: Action<ExternalModuleDependency>
): Unit = addConfiguredDependencyTo(
    this, ""kotlinNativeCompilerPluginClasspath"", dependencyNotation, dependencyConfiguration
)

/**
 * Adds a dependency to the 'kotlinNativeCompilerPluginClasspath' configuration.
 *
 * @param dependencyNotation notation for the dependency to be added.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`kotlinNativeCompilerPluginClasspath`(
    dependencyNotation: ProviderConvertible<*>,
    dependencyConfiguration: Action<ExternalModuleDependency>
): Unit = addConfiguredDependencyTo(
    this, ""kotlinNativeCompilerPluginClasspath"", dependencyNotation, dependencyConfiguration
)

/**
 * Adds a dependency to the 'kotlinNativeCompilerPluginClasspath' configuration.
 *
 * @param group the group of the module to be added as a dependency.
 * @param name the name of the module to be added as a dependency.
 * @param version the optional version of the module to be added as a dependency.
 * @param configuration the optional configuration of the module to be added as a dependency.
 * @param classifier the optional classifier of the module artifact to be added as a dependency.
 * @param ext the optional extension of the module artifact to be added as a dependency.
 * @param dependencyConfiguration expression to use to configure the dependency.
 * @return The dependency.
 *
 * @see [DependencyHandler.create]
 * @see [DependencyHandler.add]
 */
internal
fun DependencyHandler.`kotlinNativeCompilerPluginClasspath`(
    group: String,
    name: String,
    version: String? = null,
    configuration: String? = null,
    classifier: String? = null,","ext: String? = null,"
"val expectOverriddenDeclarations =
                expectDeclaration.allRecursivelyOverriddenDeclarationsIncludingSelf(expectContainingClass).toSet()
            val actualOverriddenDeclarations =
                actualDeclaration.allRecursivelyOverriddenDeclarationsIncludingSelf(actualContainingClass)

            // If default params came from common supertypes of actual class and expect class then it's a valid code.
            // Here we filter out such default params.
            if ((actualOverriddenDeclarations - expectOverriddenDeclarations).flatMap { it.valueParameters }.any { it.hasDefaultValue }) {
                return ExpectActualCheckingCompatibility.ActualFunctionWithDefaultParameters
            }
        }

        if (!equalsBy(expectedValueParameters, actualValueParameters) { it.isVararg }) {
            return ExpectActualCheckingCompatibility.ValueParameterVararg
        }

        // Adding noinline/crossinline to parameters is disallowed, except if the expected declaration was not inline at all
        if (expectDeclaration is SimpleFunctionSymbolMarker && expectDeclaration.isInline) {
            if (expectedValueParameters.indices.any { i -> !expectedValueParameters[i].isNoinline && actualValueParameters[i].isNoinline }) {
                return ExpectActualCheckingCompatibility.ValueParameterNoinline
            }
            if (expectedValueParameters.indices.any { i -> !expectedValueParameters[i].isCrossinline && actualValueParameters[i].isCrossinline }) {
                return ExpectActualCheckingCompatibility.ValueParameterCrossinline
            }
        }

        when {
            expectDeclaration is FunctionSymbolMarker && actualDeclaration is FunctionSymbolMarker ->
                getFunctionsIncompatibility(expectDeclaration, actualDeclaration)?.let { return it }

            expectDeclaration is PropertySymbolMarker && actualDeclaration is PropertySymbolMarker ->
                getPropertiesIncompatibility(expectDeclaration, actualDeclaration, expectContainingClass, languageVersionSettings)?.let { return it }

            expectDeclaration is EnumEntrySymbolMarker && actualDeclaration is EnumEntrySymbolMarker -> {
                // do nothing, entries are matched only by name
            }

            else -> error(""Unsupported declarations: $expectDeclaration, $actualDeclaration"")
        }

        return ExpectActualCheckingCompatibility.Compatible
    }

    private fun ExpectActualMatchingContext<*>.areCompatibleClassKinds(
        expectClass: RegularClassSymbolMarker,
        actualClass: RegularClassSymbolMarker,
    ): Boolean {
        if (expectClass.classKind == actualClass.classKind) return true

        if (expectClass.classKind == ClassKind.CLASS && isFinal(expectClass) && isCtorless(expectClass)) {
            if (actualClass.classKind == ClassKind.OBJECT) return true
        }

        return false
    }

    private fun areCompatibleModalities(
        expectModality: Modality?,
        actualModality: Modality?,
        expectContainingClassModality: Modality? = null,
        actualContainingClassModality: Modality? = null,
    ): Boolean {
        val expectEffectiveModality = effectiveModality(expectModality, expectContainingClassModality)
        val actualEffectiveModality = effectiveModality(actualModality, actualContainingClassModality)",return actualEffectiveModality in compatibleModalityMap.getValue(expectEffectiveModality)
"optIn.add(""my.other.OptIn"")
            }
        }

        project.evaluate()

        val arguments = linuxX64Target.compilations.main.compileTaskProvider.get().createCompilerArguments(lenient)
        assertEquals(
            listOf(""my.OptIn"", ""my.other.OptIn""), arguments.optIn?.toList()
        )
    }

    @Test
    fun `test - k2 - shared native compilation - sources`() {
        val project = buildProjectWithMPP()
        val kotlin = project.multiplatformExtension
        kotlin.linuxX64()
        kotlin.linuxArm64()

        /* Enable K2 if necessary */
        if (KotlinVersion.DEFAULT < KotlinVersion.KOTLIN_2_0) {
            kotlin.sourceSets.all {
                it.languageSettings.languageVersion = ""2.0""
            }
        }

        val commonMainSourceFile = project.file(""src/commonMain/kotlin/CommonMain.kt"")
        commonMainSourceFile.parentFile.mkdirs()
        commonMainSourceFile.writeText(""object CommonMain"")

        project.evaluate()

        val sharedNativeCompilation = kotlin.metadata().compilations.getByName(""commonMain"")
        val sharedNativeCompileTask = sharedNativeCompilation.compileTaskProvider.get() as KotlinNativeCompile
        val arguments = sharedNativeCompileTask.createCompilerArguments(lenient)

        assertNull(
            arguments.fragments?.toList(),
            ""Expected 'fragments' to *not* be set: Metadata compilations shall use -Xcommon-sources and provide klib dependencies""
        )

        assertNull(
            arguments.fragmentSources?.toList(),
            ""Expected 'fragmentSources' to *not* be set: Metadata compilations shall use -Xcommon-sources and provide klib dependencies""
        )

        assertNull(
            arguments.fragmentRefines?.toList(),
            ""Expected 'fragmentRefines' to *not* be set: Metadata compilations shall use -Xcommon-sources and provide klib dependencies""
        )

        assertEquals(
            listOf(commonMainSourceFile), arguments.commonSources?.toList().orEmpty().map(::File)
        )

        assertTrue(
            commonMainSourceFile.absolutePath in arguments.freeArgs,
            ""Expected commonMain source file to be present in 'freeArgs'""
        )
    }

    @Test
    fun `test - k2 - platform native compilation - sources`() {
        val project = buildProjectWithMPP()
        val kotlin = project.multiplatformExtension",kotlin.linuxX64()
"// DONT_TARGET_EXACT_BACKEND: JS
// ES_MODULES
// MODULE: lib
// FILE: lib.kt

package lib

class A(val x: Int)

fun A.foo() = 23 + x

inline fun A.baz() = 99 + x

inline fun A.callFoo() = foo()

inline fun A.buzz(): Int {
    val o = object {
        fun f() = 111 + x
    }
    return o.f()
}

// MODULE: main(lib)
// FILE: main.kt

package main

import lib.*

fun box(): String {
    val a = A(1).foo()
    if (a != 24) return ""fail: simple function: $a""

    val c = A(1).baz()
    if (c != 100) return ""fail: inline function: $c""

    val d = A(1).buzz()
    if (d != 112) return ""fail: inline function with object expression: $d""",val e = A(2).callFoo()
"typealias D = E
                    typealias A = D
                    typealias A2 = A
                """""".trimIndent()
            )
        )

        assertEquals(setOf(""A""), resolver.resolveAssociatedIds(""A""))
        assertEquals(setOf(""A""), resolver.resolveAssociatedIds(""A1""))
        assertEquals(setOf(""A""), resolver.resolveAssociatedIds(""A2""))
        assertEquals(setOf(""A""), resolver.resolveAssociatedIds(""B""))
        assertEquals(setOf(""A""), resolver.resolveAssociatedIds(""C""))
        assertEquals(setOf(""A""), resolver.resolveAssociatedIds(""E""))
        assertEquals(setOf(""A""), resolver.resolveAssociatedIds(""D""))
    }

    /*
    Platform A:    A -> B -> C
    Platform B:    A -> D -> E
                   F -> G -> C

    Expected:  A, C
    */
    fun `test sample 9`() {
        val resolver = createCommonClassifierIdResolver(
            createCirTreeRootFromSourceCode(
                """"""
                    class C
                    typealias B = C
                    typealias A = B
                """""".trimIndent()
            ),
            createCirTreeRootFromSourceCode(
                """"""
                    class E
                    typealias D = E
                    typealias A = D
            
                    class C
                    typealias G = C
                    typealias F = G
                """""".trimIndent()
            )
        )

        assertEquals(setOf(""A"", ""C""), resolver.resolveAssociatedIds(""A""))
        assertEquals(setOf(""A"", ""C""), resolver.resolveAssociatedIds(""B""))
        assertEquals(setOf(""A"", ""C""), resolver.resolveAssociatedIds(""C""))
        assertEquals(setOf(""A"", ""C""), resolver.resolveAssociatedIds(""D""))
        assertEquals(setOf(""A"", ""C""), resolver.resolveAssociatedIds(""E""))
        assertEquals(setOf(""A"", ""C""), resolver.resolveAssociatedIds(""F""))
        assertEquals(setOf(""A"", ""C""), resolver.resolveAssociatedIds(""G""))
    }
}

private fun createCommonClassifierIdResolver(
    vararg root: CirTreeRoot,
    dependencies: CirProvidedClassifiers = CirProvidedClassifiers.EMPTY
): AssociatedClassifierIdsResolver {
    return AssociatedClassifierIdsResolver(
        TargetDependent(root.withIndex().associate { (index, root) -> LeafCommonizerTarget(index.toString()) to root })
            .mapValue(::CirClassifierIndex),
        targetDependencies = root.withIndex()
            .associate { (index, _) -> LeafCommonizerTarget(index.toString()) to CirProvidedClassifiers.EMPTY }.toTargetDependent(),
        commonDependencies = dependencies,",cache = AssociatedClassifierIdsResolverCache.None
"// TARGET_BACKEND: WASM

// FILE: wasmImport.kt
import kotlin.wasm.WasmImport

@WasmImport(""foo"")
external fun inc(x: Int): Int

@JsExport
fun myBox(): String {
    if (inc(5) != 6) return ""KFail1""
    return ""OK""
}

var initialized: Int = 0

@JsExport
fun getInitialized(): Int = initialized

fun main() {
    initialized = 100
}

// FILE: entry.mjs
import { instantiate } from ""./index.uninstantiated.mjs"";",let inc = x => x + 1;
"// TARGET_BACKEND: JVM
// WITH_REFLECT

import kotlin.test.assertEquals

// Generate:
// (1..70).map { ""    p${""%02d"".format(it)}: Int,"" }.joinToString(""\n"")

class A {
    fun foo(
            p01: Int,
            p02: Int,
            p03: Int,
            p04: Int,
            p05: Int,
            p06: Int,
            p07: Int,
            p08: Int,
            p09: Int,
            p10: Int,
            p11: Int,
            p12: Int,
            p13: Int,
            p14: Int,
            p15: Int,
            p16: Int,
            p17: Int,
            p18: Int,
            p19: Int,
            p20: Int,
            p21: Int,","p22: Int,"
"var sum: Double = 0.toDouble()
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the collection.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""sumOfInt"")
@kotlin.internal.InlineOnly
public inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {
    var sum: Int = 0.toInt()
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the collection.
 */
@SinceKotlin(""1.4"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""sumOfLong"")
@kotlin.internal.InlineOnly
public inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {
    var sum: Long = 0.toLong()
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the collection.
 */
@SinceKotlin(""1.5"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""sumOfUInt"")
@WasExperimental(ExperimentalUnsignedTypes::class)
@kotlin.internal.InlineOnly
public inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {
    var sum: UInt = 0.toUInt()
    for (element in this) {
        sum += selector(element)
    }
    return sum
}

/**
 * Returns the sum of all values produced by [selector] function applied to each element in the collection.
 */
@SinceKotlin(""1.5"")
@OptIn(kotlin.experimental.ExperimentalTypeInference::class)
@OverloadResolutionByLambdaReturnType
@kotlin.jvm.JvmName(""sumOfULong"")
@WasExperimental(ExperimentalUnsignedTypes::class)
@kotlin.internal.InlineOnly",public inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {
"/*
 * Copyright 2010-2017 JetBrains s.r.o.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.jetbrains.kotlin.js.translate.callTranslator

import org.jetbrains.kotlin.descriptors.CallableDescriptor
import org.jetbrains.kotlin.descriptors.PropertyDescriptor
import org.jetbrains.kotlin.descriptors.impl.LocalVariableDescriptor
import org.jetbrains.kotlin.js.backend.ast.*
import org.jetbrains.kotlin.js.backend.ast.metadata.SideEffectKind
import org.jetbrains.kotlin.js.backend.ast.metadata.sideEffects
import org.jetbrains.kotlin.js.translate.context.Namer
import org.jetbrains.kotlin.js.translate.context.Namer.getCapturedVarAccessor
import org.jetbrains.kotlin.js.translate.declaration.contextWithPropertyMetadataCreationIntrinsified
import org.jetbrains.kotlin.js.translate.reference.ReferenceTranslator
import org.jetbrains.kotlin.js.translate.reference.buildReifiedTypeArgs
import org.jetbrains.kotlin.js.translate.utils.JsAstUtils
import org.jetbrains.kotlin.js.translate.utils.JsAstUtils.pureFqn
import org.jetbrains.kotlin.js.translate.utils.JsDescriptorUtils",import org.jetbrains.kotlin.js.translate.utils.TranslationUtils
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */
package org.jetbrains.kotlin.js.test.handlers

import com.google.gwt.dev.js.ThrowExceptionOnErrorReporter
import com.google.gwt.dev.js.rhino.CodePosition
import com.google.gwt.dev.js.rhino.offsetOf
import kotlinx.coroutines.withTimeout
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.decodeFromJsonElement
import org.jetbrains.kotlin.ir.backend.js.transformers.irToJs.TranslationMode
import org.jetbrains.kotlin.js.backend.ast.*
import org.jetbrains.kotlin.js.parser.parseFunction
import org.jetbrains.kotlin.js.parser.sourcemaps.*
import org.jetbrains.kotlin.js.test.debugger.*
import org.jetbrains.kotlin.js.test.utils.getAllFilesForRunner
import org.jetbrains.kotlin.test.TargetBackend
import org.jetbrains.kotlin.test.directives.JsEnvironmentConfigurationDirectives
import org.jetbrains.kotlin.test.model.TestModule
import org.jetbrains.kotlin.test.services.TestServices
import org.jetbrains.kotlin.test.services.configuration.JsEnvironmentConfigurator
import org.jetbrains.kotlin.test.services.defaultDirectives
import org.jetbrains.kotlin.test.services.moduleStructure
import org.jetbrains.kotlin.test.utils.*
import java.io.File
import java.net.URI
import java.net.URISyntaxException
import java.util.logging.Level
import java.util.logging.Logger

/**
 * This class is an analogue of the [DebugRunner][org.jetbrains.kotlin.test.backend.handlers.DebugRunner] from JVM stepping tests.
 *
 * It runs a generated JavaScript file under a debugger, stops right before entering the `box` function,
 * and performs the ""step into"" action until there is nothing more to step into. On each pause it records the source file name,
 * the source line and the function name of the current call frame, and compares this data with the expectations written in the test file.
 *
 * It uses sourcemaps for mapping locations in the generated JS file to the corresponding locations in the source Kotlin file.
 * Also, it assumes that the sourcemap contains absolute paths to source files. The relative paths are replaced with
 * absolute paths earlier by [JsSourceMapPathRewriter].
 *
 * Stepping tests only work with the IR backend. The legacy backend is not supported.
 *
 * For simplicity, only the [FULL][org.jetbrains.kotlin.ir.backend.js.transformers.irToJs.TranslationMode.FULL] translation mode is
 * supported.
 *
 */
class JsDebugRunner(testServices: TestServices, private val localVariables: Boolean) : AbstractJsArtifactsCollector(testServices) {

    private val logger = Logger.getLogger(this::class.java.name)

    override fun processAfterAllModules(someAssertionWasFailed: Boolean) {",if (someAssertionWasFailed) return
"import kotlinx.cinterop.*
import kotlin.test.*
import objcTests.*

@Test fun testBlocks() {",assertTrue(Blocks.blockIsNull(null))
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.utils

import kotlin.annotation.AnnotationTarget.*

/**
 * AS 211-based, IU211 or IC211 is the same _211 key.
 *
 * Usage in 213 platform means, that there was a **released** IDEA build or plugin on plugin marketplace compatible with
 * `213.*` platform that has used this API. If you found a usage in the IDEA and removed it usage before the first official release of the
 * corresponding platform it is considered as ""not used"" in this platform. In other words, if API was used in 221 EAP's
 * or even 221 RC but not in the 221 release -- then API don't have the 221 usage.
 */
enum class IDEAPlatforms {
    _211,
    _212,
    _213,
    _221,
    _222,","_223,"
"internal val CINTEROP_SOURCE_EXTENSIONS = setOf(""c"", ""cpp"", ""m"", ""mm"")
internal val CINTEROP_DEFINITION_EXTENSIONS = setOf(""def"", ""h"")
internal val KNOWN_EXTENSIONS = setOf(""kt"") + CINTEROP_DEFINITION_EXTENSIONS + CINTEROP_SOURCE_EXTENSIONS

internal class TestCInteropArgs(cinteropArgs: List<String>) : TestCompilerArgs(emptyList(), cinteropArgs) {
    constructor(vararg cinteropArgs: String) : this(cinteropArgs.asList())
}

open class TestCompilerArgs(
    val compilerArgs: List<String>,
    val cinteropArgs: List<String> = emptyList(),
    val assertionsMode: AssertionsMode = AssertionsMode.DEFAULT,
) {
    constructor(vararg compilerArgs: String) : this(compilerArgs.asList())

    private val uniqueCompilerArgs = compilerArgs.toSet()
    private val uniqueCinteropArgs = cinteropArgs.toSet()
    override fun hashCode() = ((uniqueCompilerArgs + uniqueCinteropArgs) to assertionsMode).hashCode()
    override fun equals(other: Any?) = (other as? TestCompilerArgs)?.uniqueCompilerArgs == uniqueCompilerArgs &&
            other.uniqueCinteropArgs == uniqueCinteropArgs && other.assertionsMode == assertionsMode

    operator fun plus(otherCompilerArgs: TestCompilerArgs): TestCompilerArgs = TestCompilerArgs(
        this.compilerArgs + otherCompilerArgs.compilerArgs,
        this.cinteropArgs + otherCompilerArgs.cinteropArgs,
        if (this.assertionsMode == otherCompilerArgs.assertionsMode) this.assertionsMode
        else fail { ""Cannot add ${this.assertionsMode} and ${otherCompilerArgs.assertionsMode}"" },
    )

    companion object {
        val EMPTY = TestCompilerArgs(emptyList())

        fun findForbiddenArgs(compilerArgs: Iterable<String>): Set<String> = buildSet {
            addAll(compilerArgs)
            retainAll(EXPLICITLY_FORBIDDEN_COMPILER_ARGS)
            compilerArgs.mapNotNullTo(this) { arg ->
                if (EXPLICITLY_FORBIDDEN_COMPILER_ARG_PREFIXES.any { prefix -> arg.startsWith(prefix) }) arg else null
            }
        }

        /** The set of compiler args that are not permitted to be explicitly specified using [FREE_COMPILER_ARGS]. */
        private val EXPLICITLY_FORBIDDEN_COMPILER_ARGS = setOf(
            ""-trn"", ""-generate-no-exit-test-runner"",
            ""-tr"", ""-generate-test-runner"",
            ""-trw"", ""-generate-worker-test-runner"",
            ""-nomain"",
            ""-output"",
            ""-entry"", ""-e"",
            ""-produce"",
            ""-repo"",
            ""-target"",
            ""-Xinclude"",
            ""-g"", ""-opt"",
            ""-memory-model"",
            ""-Xcheck-state-at-external-calls""
        )

        /** The set of compiler arg prefixes that are not permitted to be explicitly specified using [FREE_COMPILER_ARGS]. */
        private val EXPLICITLY_FORBIDDEN_COMPILER_ARG_PREFIXES = setOf(
            ""-Xgc=""
        )
    }
}

internal fun parseTestKind(registeredDirectives: RegisteredDirectives, location: Location): TestKind? {
    if (KIND !in registeredDirectives)",return null // The default is determined by TEST_KIND global property
"}
            }
        }

        private fun getLibIncrementalCache(libFile: KotlinLibraryFile) =
            incrementalCaches[libFile] ?: notFoundIcError(""incremental cache"", libFile)

        private fun addFilesWithRemovedDependencies(
            modifiedFiles: KotlinSourceFileMutableMap<KotlinSourceFileMetadata>,
            removedFiles: KotlinSourceFileMap<KotlinSourceFileMetadata>
        ): KotlinSourceFileMap<KotlinSourceFileMetadata> {
            val extraModifiedLibFiles = KotlinSourceFileMutableMap<KotlinSourceFileMetadata>()

            fun addDependenciesToExtraModifiedFiles(dependencies: KotlinSourceFileMap<*>, dirtyState: DirtyFileState) {
                for ((dependentLib, dependentFiles) in dependencies) {
                    val dependentCache = incrementalCaches[dependentLib] ?: continue
                    val alreadyModifiedFiles = modifiedFiles[dependentLib] ?: emptyMap()
                    val alreadyRemovedFiles = removedFiles[dependentLib] ?: emptyMap()
                    val extraModifiedFiles by lazy(LazyThreadSafetyMode.NONE) { extraModifiedLibFiles.getOrPutFiles(dependentLib) }
                    val fileStats by lazy(LazyThreadSafetyMode.NONE) { dirtyFileStats.getOrPutFiles(dependentLib) }
                    for (dependentFile in dependentFiles.keys) {
                        when (dependentFile) {
                            in alreadyModifiedFiles -> continue
                            in alreadyRemovedFiles -> continue
                            in extraModifiedFiles -> continue
                            else -> {
                                val dependentMetadata = dependentCache.fetchSourceFileFullMetadata(dependentFile)
                                extraModifiedFiles[dependentFile] = dependentMetadata
                                fileStats.addDirtFileStat(dependentFile, dirtyState)
                            }
                        }
                    }
                }
            }

            removedFiles.forEachFile { _, _, removedFileMetadata ->
                addDependenciesToExtraModifiedFiles(removedFileMetadata.directDependencies, DirtyFileState.REMOVED_INVERSE_DEPENDS)
                addDependenciesToExtraModifiedFiles(removedFileMetadata.inverseDependencies, DirtyFileState.REMOVED_DIRECT_DEPENDS)
            }

            modifiedFiles.copyFilesFrom(extraModifiedLibFiles)
            return modifiedFiles
        }

        fun loadModifiedFiles(): KotlinSourceFileMap<KotlinSourceFileMetadata> {
            val removedFilesMetadata = hashMapOf<KotlinLibraryFile, Map<KotlinSourceFile, KotlinSourceFileMetadata>>()

            fun collectDirtyFiles(lib: KotlinLibraryFile, cache: IncrementalCache): MutableMap<KotlinSourceFile, KotlinSourceFileMetadata> {
                val (addedFiles, removedFiles, modifiedFiles, nonModifiedFiles) = cache.collectModifiedFiles()

                val fileStats by lazy(LazyThreadSafetyMode.NONE) { dirtyFileStats.getOrPutFiles(lib) }
                addedFiles.forEach { fileStats.addDirtFileStat(it, DirtyFileState.ADDED_FILE) }
                removedFiles.forEach { fileStats.addDirtFileStat(it.key, DirtyFileState.REMOVED_FILE) }
                modifiedFiles.forEach { fileStats.addDirtFileStat(it.key, DirtyFileState.MODIFIED_IR) }
                nonModifiedFiles.forEach { fileStats.addDirtFileStat(it, DirtyFileState.NON_MODIFIED_IR) }

                if (removedFiles.isNotEmpty()) {
                    removedFilesMetadata[lib] = removedFiles
                }

                return addedFiles.associateWithTo(modifiedFiles.toMutableMap()) { KotlinSourceFileMetadataNotExist }
            }

            for (cache in removedIncrementalCaches) {
                val libFile = cache.libraryFileFromHeader ?: notFoundIcError(""removed library name; cache dir: ${cache.cacheDir}"")","val dirtyFiles = collectDirtyFiles(libFile, cache)"
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.backend.js

import org.jetbrains.kotlin.backend.common.compilationException
import org.jetbrains.kotlin.backend.common.ir.Ir
import org.jetbrains.kotlin.backend.common.ir.Symbols
import org.jetbrains.kotlin.backend.common.linkage.partial.createPartialLinkageSupportForLowerings
import org.jetbrains.kotlin.backend.common.lower.InnerClassesSupport
import org.jetbrains.kotlin.backend.common.serialization.IrInterningService
import org.jetbrains.kotlin.builtins.PrimitiveType
import org.jetbrains.kotlin.builtins.isFunctionType
import org.jetbrains.kotlin.config.CompilerConfiguration
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.ModuleDescriptor
import org.jetbrains.kotlin.descriptors.PropertyDescriptor
import org.jetbrains.kotlin.descriptors.SimpleFunctionDescriptor
import org.jetbrains.kotlin.incremental.components.NoLookupLocation
import org.jetbrains.kotlin.ir.IrBuiltIns
import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.UNDEFINED_OFFSET
import org.jetbrains.kotlin.ir.backend.js.ir.JsIrBuilder
import org.jetbrains.kotlin.ir.backend.js.lower.JsInnerClassesSupport
import org.jetbrains.kotlin.ir.backend.js.transformers.irToJs.JsGenerationGranularity
import org.jetbrains.kotlin.ir.backend.js.transformers.irToJs.JsPolyfills
import org.jetbrains.kotlin.ir.backend.js.transformers.irToJs.translateJsCodeIntoStatementList
import org.jetbrains.kotlin.ir.backend.js.utils.*
import org.jetbrains.kotlin.ir.builders.declarations.addFunction
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.declarations.impl.IrExternalPackageFragmentImpl
import org.jetbrains.kotlin.ir.expressions.IrCall
import org.jetbrains.kotlin.ir.expressions.IrExpression
import org.jetbrains.kotlin.ir.linkage.partial.partialLinkageConfig
import org.jetbrains.kotlin.ir.symbols.*
import org.jetbrains.kotlin.ir.symbols.impl.DescriptorlessExternalPackageFragmentSymbol
import org.jetbrains.kotlin.ir.types.*
import org.jetbrains.kotlin.ir.types.impl.IrDynamicTypeImpl
import org.jetbrains.kotlin.ir.util.*
import org.jetbrains.kotlin.js.backend.ast.JsExpressionStatement
import org.jetbrains.kotlin.js.backend.ast.JsFunction
import org.jetbrains.kotlin.js.config.ErrorTolerancePolicy
import org.jetbrains.kotlin.js.config.JSConfigurationKeys
import org.jetbrains.kotlin.js.config.RuntimeDiagnostic
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.resolve.scopes.MemberScope
import org.jetbrains.kotlin.types.Variance
import org.jetbrains.kotlin.types.isNullable
import org.jetbrains.kotlin.utils.addToStdlib.cast
import org.jetbrains.kotlin.utils.addToStdlib.safeAs
import org.jetbrains.kotlin.utils.filterIsInstanceMapNotNull
import java.util.*

@OptIn(ObsoleteDescriptorBasedAPI::class)
class JsIrBackendContext(
    val module: ModuleDescriptor,
    override val irBuiltIns: IrBuiltIns,
    val symbolTable: SymbolTable,
    val additionalExportedDeclarationNames: Set<FqName>,
    keep: Set<String>,
    override val configuration: CompilerConfiguration, // TODO: remove configuration from backend context","val mainCallArguments: List<String>?,"
"// FIR_IDENTICAL
// !OPT_IN: kotlin.RequiresOptIn

@RequiresOptIn(level = RequiresOptIn.Level.ERROR)
@Retention(AnnotationRetention.BINARY)
annotation class ExperimentalAPI

@ExperimentalAPI
fun function(): String = """"

fun use(): String {
    @OptIn(ExperimentalAPI::class)",for (i in 1..2) {
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package kotlin.collections

public expect class LinkedHashMap<K, V> : MutableMap<K, V> {
    /**
     * Creates a new empty [LinkedHashMap].
     */
    public constructor()

    /**
     * Creates a new empty [LinkedHashMap] with the specified initial capacity.
     *
     * Capacity is the maximum number of entries the map is able to store in current internal data structure.
     * When the map gets full by a certain default load factor, its capacity is expanded,
     * which usually leads to rebuild of the internal data structure.
     *
     * @param initialCapacity the initial capacity of the created map.
     *   Note that the argument is just a hint for the implementation and can be ignored.
     *
     * @throws IllegalArgumentException if [initialCapacity] is negative.
     */
    public constructor(initialCapacity: Int)

    /**
     * Creates a new empty [LinkedHashMap] with the specified initial capacity and load factor.
     *
     * Capacity is the maximum number of entries the map is able to store in current internal data structure.
     * Load factor is the measure of how full the map is allowed to get in relation to
     * its capacity before the capacity is expanded, which usually leads to rebuild of the internal data structure.
     *
     * @param initialCapacity the initial capacity of the created map.
     *   Note that the argument is just a hint for the implementation and can be ignored.
     * @param loadFactor the load factor of the created map.
     *   Note that the argument is just a hint for the implementation and can be ignored.
     *
     * @throws IllegalArgumentException if [initialCapacity] is negative or [loadFactor] is non-positive.
     */
    public constructor(initialCapacity: Int, loadFactor: Float)

    /**
     * Creates a new [LinkedHashMap] filled with the contents of the specified [original] map.
     *
     * The iteration order of entries in the created map is the same as in the [original] map.
     */
    public constructor(original: Map<out K, V>)

    // From Map

    override val size: Int
    override fun isEmpty(): Boolean
    override fun containsKey(key: K): Boolean",override fun containsValue(value: V): Boolean
"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.assignment.plugin.diagnostics

import org.jetbrains.kotlin.assignment.plugin.diagnostics.ErrorsAssignmentPlugin.*
import org.jetbrains.kotlin.diagnostics.rendering.DefaultErrorMessages
import org.jetbrains.kotlin.diagnostics.rendering.DiagnosticFactoryToRendererMap

object DefaultErrorMessagesAssignmentPlugin : DefaultErrorMessages.Extension {

    private val MAP = DiagnosticFactoryToRendererMap(""ValueContainerAssignment"")

    override fun getMap() = MAP

    init {
        MAP.put(
            DECLARATION_ERROR_ASSIGN_METHOD_SHOULD_RETURN_UNIT,
            ""Function 'assign' used for '=' overload should return 'Unit'""
        )

        MAP.put(
            CALL_ERROR_ASSIGN_METHOD_SHOULD_RETURN_UNIT,","""Function 'assign' used for '=' overload should return 'Unit'"""
"val labelName =
                    context.getLastLabel(functionDeclaration)?.name ?: runIf(!functionName.isSpecial) { functionName.identifier }
                target = FirFunctionTarget(labelName, isLambda = false)
                FirSimpleFunctionBuilder().apply {
                    source = functionSource
                    receiverParameter = receiverType?.convertToReceiverParameter()
                    name = functionName
                    status = FirDeclarationStatusImpl(
                        if (isLocal) Visibilities.Local else calculatedModifiers.getVisibility(),
                        calculatedModifiers.getModality(isClassOrObject = false)
                    ).apply {
                        isExpect = calculatedModifiers.hasExpect() || context.containerIsExpect
                        isActual = calculatedModifiers.hasActual()
                        isOverride = calculatedModifiers.hasOverride()
                        isOperator = calculatedModifiers.hasOperator()
                        isInfix = calculatedModifiers.hasInfix()
                        isInline = calculatedModifiers.hasInline()
                        isTailRec = calculatedModifiers.hasTailrec()
                        isExternal = calculatedModifiers.hasExternal()
                        isSuspend = calculatedModifiers.hasSuspend()
                    }

                    symbol = functionSymbol as FirNamedFunctionSymbol
                    dispatchReceiverType = runIf(!isLocal) { currentDispatchReceiverType() }
                    contextReceivers.addAll(convertContextReceivers(functionDeclaration))
                }
            }

            val firTypeParameters = mutableListOf<FirTypeParameter>()
            typeParameterList?.let { firTypeParameters += convertTypeParameters(it, typeConstraints, functionSymbol) }

            val function = functionBuilder.apply {
                moduleData = baseModuleData
                origin = FirDeclarationOrigin.Source
                returnTypeRef = returnType!!

                context.firFunctionTargets += target
                annotations += functionAnnotations

                val actualTypeParameters = if (this is FirSimpleFunctionBuilder) {
                    typeParameters += firTypeParameters
                    typeParameters
                } else {
                    listOf()
                }

                withCapturedTypeParameters(true, functionSource, actualTypeParameters) {
                    valueParametersList?.let { list ->
                        valueParameters += convertValueParameters(
                            list,
                            functionSymbol,
                            if (isAnonymousFunction) ValueParameterDeclaration.LAMBDA else ValueParameterDeclaration.FUNCTION
                        ).map { it.firValueParameter }
                    }

                    val allowLegacyContractDescription = outerContractDescription == null
                    val bodyWithContractDescription = withForcedLocalContext {
                        convertFunctionBody(block, expression, allowLegacyContractDescription)
                    }
                    this.body = bodyWithContractDescription.first
                    val contractDescription = outerContractDescription ?: bodyWithContractDescription.second
                    contractDescription?.let {
                        if (this is FirSimpleFunctionBuilder) {
                            this.contractDescription = it
                        } else if (this is FirAnonymousFunctionBuilder) {",this.contractDescription = it
"// FIR_IDENTICAL
import kotlin.reflect.KProperty

@Target(AnnotationTarget.FIELD) annotation class Field

@Target(AnnotationTarget.PROPERTY) annotation class Prop

class CustomDelegate {
    operator fun getValue(thisRef: Any?, prop: KProperty<*>): String = prop.name
}

<!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Field<!>
class SomeClass {

    <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Field<!>
    constructor()

    <!INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE!>@delegate:Field<!> <!INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Prop<!>
    protected val simpleProperty: String = ""text""

    @delegate:Field <!WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Prop<!>
    protected val delegatedProperty: String by CustomDelegate()

    <!INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Field<!> <!INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE, WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET!>@delegate:Prop<!>",val propertyWithCustomGetter: Int
"// IGNORE_BACKEND_K1: JS_IR

// WITH_STDLIB

import kotlinx.serialization.*
import kotlinx.serialization.json.*

// From #1264
@Serializable
sealed class TypedSealedClass<T>(val a: T) {
    @Serializable","class Child(val y: Int) : TypedSealedClass<String>(""10"") {"
"val `OrgGradlePluginGroup`.`jdk-toolchains`: PluginDependencySpec
    get() = plugins.id(""org.gradle.jdk-toolchains"")


/**
 * The `org.gradle.jvm-ecosystem` plugin implemented by [org.gradle.api.plugins.JvmEcosystemPlugin].
 */
internal
val `OrgGradlePluginGroup`.`jvm-ecosystem`: PluginDependencySpec
    get() = plugins.id(""org.gradle.jvm-ecosystem"")


/**
 * The `org.gradle.jvm-test-suite` plugin implemented by [org.gradle.api.plugins.JvmTestSuitePlugin].
 */
internal
val `OrgGradlePluginGroup`.`jvm-test-suite`: PluginDependencySpec
    get() = plugins.id(""org.gradle.jvm-test-suite"")


/**
 * The `org.gradle.jvm-toolchain-management` plugin implemented by [org.gradle.api.plugins.JvmToolchainManagementPlugin].
 */
internal
val `OrgGradlePluginGroup`.`jvm-toolchain-management`: PluginDependencySpec
    get() = plugins.id(""org.gradle.jvm-toolchain-management"")


/**
 * The `org.gradle.jvm-toolchains` plugin implemented by [org.gradle.api.plugins.JvmToolchainsPlugin].
 */
internal
val `OrgGradlePluginGroup`.`jvm-toolchains`: PluginDependencySpec
    get() = plugins.id(""org.gradle.jvm-toolchains"")


/**
 * The `org.gradle.language-base` plugin implemented by [org.gradle.language.base.plugins.LanguageBasePlugin].
 */
internal
val `OrgGradlePluginGroup`.`language-base`: PluginDependencySpec
    get() = plugins.id(""org.gradle.language-base"")


/**
 * The `org.gradle.lifecycle-base` plugin implemented by [org.gradle.language.base.plugins.LifecycleBasePlugin].
 */
internal
val `OrgGradlePluginGroup`.`lifecycle-base`: PluginDependencySpec
    get() = plugins.id(""org.gradle.lifecycle-base"")


/**
 * The `org.gradle.maven-publish` plugin implemented by [org.gradle.api.publish.maven.plugins.MavenPublishPlugin].
 */
internal
val `OrgGradlePluginGroup`.`maven-publish`: PluginDependencySpec
    get() = plugins.id(""org.gradle.maven-publish"")


/**
 * The `org.gradle.microsoft-visual-cpp-compiler` plugin implemented by [org.gradle.nativeplatform.toolchain.plugins.MicrosoftVisualCppCompilerPlugin].
 */
internal
val `OrgGradlePluginGroup`.`microsoft-visual-cpp-compiler`: PluginDependencySpec","get() = plugins.id(""org.gradle.microsoft-visual-cpp-compiler"")"
"// WITH_STDLIB
import kotlin.test.*

fun box(): String {
    val arr = intArrayOf(1, 1, 1, 1)",var sum = 0
"class A {
    companion object {
        val s: String
            get() = ""Ok""
        var v : String
            get() = ""NOT OK""",set(value) {}
"// WITH_STDLIB
// WITH_COROUTINES
// MODULE: lib
// FILE: lib.kt
suspend inline fun foo(v: String): String = v

suspend inline fun bar(): String = foo(""O"")

// MODULE: main(lib, support)
// FILE: main.kt
import helpers.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*

fun builder(c: suspend () -> Unit) {
    c.startCoroutine(EmptyContinuation)
}

fun box(): String {
    var result = """"",builder {
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.utils.kapt

import org.jetbrains.kotlin.utils.getSafe
import java.lang.ref.WeakReference
import java.lang.reflect.Modifier
import java.util.*
import javax.annotation.processing.*
import javax.lang.model.AnnotatedConstruct
import javax.lang.model.util.Elements
import javax.lang.model.util.Types
import kotlin.ConcurrentModificationException

class MemoryLeak(val className: String, val fieldName: String, val description: String) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as MemoryLeak

        if (className != other.className) return false
        if (fieldName != other.fieldName) return false

        return true
    }

    override fun hashCode(): Int {",var result = className.hashCode()
"// ISSUE: KT-47870

// FILE: example/JavaSuper.java",package example;
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.resolve.transformers

import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.declarations.FirResolvePhase
import org.jetbrains.kotlin.fir.resolve.fullyExpandedType
import org.jetbrains.kotlin.fir.resolve.toSymbol
import org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase
import org.jetbrains.kotlin.fir.types.ConeClassLikeType
import org.jetbrains.kotlin.fir.types.ConeKotlinType
import org.jetbrains.kotlin.fir.types.FirTypeRef
import org.jetbrains.kotlin.fir.types.coneTypeSafe

fun ConeKotlinType?.ensureResolvedTypeDeclaration(
    useSiteSession: FirSession,
    requiredPhase: FirResolvePhase = FirResolvePhase.DECLARATIONS,
) {
    if (this !is ConeClassLikeType) return",lookupTag.toSymbol(useSiteSession)?.lazyResolveToPhase(requiredPhase)
"// WITH_STDLIB

// FILE: Test.java
public interface Test<K> implements I<String> {}

// FILE: Test2.java
public interface Test2<K, M>

// FILE: Test3.java
public interface Test3<K> {}

// FILE: I.java
public interface I<K> {}

// FILE: main.kt
fun main(z: I<String>) {","z <!UNCHECKED_CAST!>as Test<Test2<Int, *>><!>"
"// FIR_IDENTICAL
// JSPECIFY_STATE: strict
// WITH_STDLIB
// FIR_DUMP
// ISSUE: KT-59514

// FILE: lib/En.java

package lib;

public interface En<K extends Pr> extends Se<K> {}

// FILE: lib/Ke.java",package lib;
"<!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J?"")!>a<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J?"")!>a<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J?"")!>a<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J?"")!>a<!><!UNSAFE_CALL!>.<!>funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J?"")!>a<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""DeepObject.A.B.C.D.E.F.G.J?"")!>a<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 19
fun case_19(b: Boolean) {
    val a = if (b) {
        object {
            val B19 = if (b) {
                object {
                    val C19 = if (b) {
                        object {
                            val D19 = if (b) {
                                object {
                                    val x: Number? = 10
                                }
                            } else null
                        }
                    } else null
                }
            } else null
        }
    } else null

    if (<!EQUALITY_NOT_APPLICABLE!>a != <!USELESS_IS_CHECK!>null !is Boolean<!><!> && <!EQUALITY_NOT_APPLICABLE!>a<!UNSAFE_CALL!>.<!>B19 != <!USELESS_IS_CHECK!>null is Boolean<!><!> && <!EQUALITY_NOT_APPLICABLE!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19 != <!USELESS_IS_CHECK!>null is Boolean<!><!> && <!SENSELESS_COMPARISON!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19<!UNSAFE_CALL!>.<!>D19 != null == null<!> && <!SENSELESS_COMPARISON!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19<!UNSAFE_CALL!>.<!>D19<!UNSAFE_CALL!>.<!>x != null !== null<!>) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19<!UNSAFE_CALL!>.<!>D19<!UNSAFE_CALL!>.<!>x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19<!UNSAFE_CALL!>.<!>D19<!UNSAFE_CALL!>.<!>x<!><!UNSAFE_CALL!>.<!>equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19<!UNSAFE_CALL!>.<!>D19<!UNSAFE_CALL!>.<!>x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19<!UNSAFE_CALL!>.<!>D19<!UNSAFE_CALL!>.<!>x<!><!UNSAFE_CALL!>.<!>propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19<!UNSAFE_CALL!>.<!>D19<!UNSAFE_CALL!>.<!>x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19<!UNSAFE_CALL!>.<!>D19<!UNSAFE_CALL!>.<!>x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19<!UNSAFE_CALL!>.<!>D19<!UNSAFE_CALL!>.<!>x<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19<!UNSAFE_CALL!>.<!>D19<!UNSAFE_CALL!>.<!>x<!><!UNSAFE_CALL!>.<!>funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19<!UNSAFE_CALL!>.<!>D19<!UNSAFE_CALL!>.<!>x<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Number?"")!>a<!UNSAFE_CALL!>.<!>B19<!UNSAFE_CALL!>.<!>C19<!UNSAFE_CALL!>.<!>D19<!UNSAFE_CALL!>.<!>x<!>.funNullableAny()
    }
}

// TESTCASE NUMBER: 20
fun case_20(b: Boolean) {
    val a = object {
        val B19 = object {
            val C19 = object {
                val D19 =  if (b) {
                    object {}
                } else null
            }
        }
    }

    if (<!EQUALITY_NOT_APPLICABLE!>a.B19.C19.D19 !== <!USELESS_IS_CHECK!>null !is Boolean<!><!>) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""case_20.`<no name provided>`.B19.`<no name provided>`.C19.`<no name provided>`.D19.`<no name provided>`?"")!>a.B19.C19.D19<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""case_20.`<no name provided>`.B19.`<no name provided>`.C19.`<no name provided>`.D19.`<no name provided>`?"")!>a.B19.C19.D19<!><!UNSAFE_CALL!>.<!>equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""case_20.`<no name provided>`.B19.`<no name provided>`.C19.`<no name provided>`.D19.`<no name provided>`?"")!>a.B19.C19.D19<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""case_20.`<no name provided>`.B19.`<no name provided>`.C19.`<no name provided>`.D19.`<no name provided>`?"")!>a.B19.C19.D19<!><!UNSAFE_CALL!>.<!>propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""case_20.`<no name provided>`.B19.`<no name provided>`.C19.`<no name provided>`.D19.`<no name provided>`?"")!>a.B19.C19.D19<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""case_20.`<no name provided>`.B19.`<no name provided>`.C19.`<no name provided>`.D19.`<no name provided>`?"")!>a.B19.C19.D19<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""case_20.`<no name provided>`.B19.`<no name provided>`.C19.`<no name provided>`.D19.`<no name provided>`?"")!>a.B19.C19.D19<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""case_20.`<no name provided>`.B19.`<no name provided>`.C19.`<no name provided>`.D19.`<no name provided>`?"")!>a.B19.C19.D19<!><!UNSAFE_CALL!>.<!>funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""case_20.`<no name provided>`.B19.`<no name provided>`.C19.`<no name provided>`.D19.`<no name provided>`?"")!>a.B19.C19.D19<!>.funNullableT()","<!DEBUG_INFO_EXPRESSION_TYPE(""case_20.`<no name provided>`.B19.`<no name provided>`.C19.`<no name provided>`.D19.`<no name provided>`?"")!>a.B19.C19.D19<!>.funNullableAny()"
"/*
 * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.ir.types

import org.jetbrains.kotlin.builtins.StandardNames
import org.jetbrains.kotlin.ir.IrBuiltIns
import org.jetbrains.kotlin.ir.symbols.*
import org.jetbrains.kotlin.ir.util.fqNameWhenAvailable
import org.jetbrains.kotlin.types.AbstractTypeChecker

fun IrClassifierSymbol.superTypes(): List<IrType> = when (this) {
    is IrClassSymbol -> owner.superTypes
    is IrTypeParameterSymbol -> owner.superTypes
    is IrScriptSymbol -> emptyList()
}

fun IrClassifierSymbol.isSubtypeOfClass(superClass: IrClassSymbol): Boolean =
    FqNameEqualityChecker.areEqual(this, superClass) || isStrictSubtypeOfClass(superClass)

fun IrClassifierSymbol.isStrictSubtypeOfClass(superClass: IrClassSymbol): Boolean =
    superTypes().any { it.isSubtypeOfClass(superClass) }

fun IrType.isSubtypeOfClass(superClass: IrClassSymbol): Boolean =
    this is IrSimpleType && classifier.isSubtypeOfClass(superClass)

fun IrType.isStrictSubtypeOfClass(superClass: IrClassSymbol): Boolean =
    this is IrSimpleType && classifier.isStrictSubtypeOfClass(superClass)

fun IrType.isSubtypeOf(superType: IrType, typeSystem: IrTypeSystemContext): Boolean =
    AbstractTypeChecker.isSubtypeOf(createIrTypeCheckerState(typeSystem), this, superType)

fun IrType.isNullable(): Boolean =
    when (this) {
        is IrSimpleType -> when (val classifier = classifier) {
            is IrClassSymbol -> nullability == SimpleTypeNullability.MARKED_NULLABLE
            is IrTypeParameterSymbol -> when (nullability) {
                SimpleTypeNullability.MARKED_NULLABLE -> true
                // here is a bug, there should be .all check (not .any),
                // but fixing it is a breaking change, see KT-31545 for details
                SimpleTypeNullability.NOT_SPECIFIED -> classifier.owner.superTypes.any(IrType::isNullable)
                SimpleTypeNullability.DEFINITELY_NOT_NULL -> false
            }",is IrScriptSymbol -> nullability == SimpleTypeNullability.MARKED_NULLABLE
"// WITH_STDLIB
// MODULE: m1-common
// FILE: common.kt
expect annotation class TypealiasToKotlinPkg

internal expect annotation class TypealiasToInternalPkg

expect annotation class TypealiasToAnnotationPkg

expect annotation class TypealiasToPlatformPkg

expect enum class TypealiasNotToAnnotation

// MODULE: m1-jvm()()(m1-common)
// FILE: jvm.kt",actual typealias TypealiasToKotlinPkg = <!ACTUAL_TYPEALIAS_TO_SPECIAL_ANNOTATION!>kotlin.Deprecated<!>
"} else {
                append(containingClassSwiftName.replaceFirst(""."", """"))
                append(swiftName.capitalizeAsciiOnly())
            }
        }
    }

    return buildString {
        getObjCModuleNamePrefix()?.let(::append)
        append(swiftName)
    }
}

context(KtAnalysisSession, KtObjCExportSession)
private fun KtClassLikeSymbol.canBeInnerSwift(): Boolean {
    if (configuration.objcGenerics && this.typeParameters.isNotEmpty()) {
        // Swift compiler doesn't seem to handle this case properly.
        // See https://bugs.swift.org/browse/SR-14607.
        // This behaviour of Kotlin is reported as https://youtrack.jetbrains.com/issue/KT-46518.
        return false
    }

    if (this is KtClassOrObjectSymbol && this.classKind == KtClassKind.INTERFACE) {
        // Swift doesn't support nested protocols.
        return false
    }

    return true
}

context(KtAnalysisSession, KtObjCExportSession)
private fun KtClassLikeSymbol.canBeOuterSwift(): Boolean {
    if (configuration.objcGenerics && this.typeParameters.isNotEmpty()) {
        // Swift nested classes are static but capture outer's generics.
        return false
    }

    if (this is KtClassOrObjectSymbol && this.classKind == KtClassKind.INTERFACE) {
        // Swift doesn't support outer protocols.
        return false
    }

    return true
}

private fun mangleSwiftNestedClassName(name: String): String = when (name) {
    ""Type"" -> ""${name}_"" // See https://github.com/JetBrains/kotlin-native/issues/3167
    else -> name
}

context(KtAnalysisSession, KtObjCExportSession)
private fun KtSymbol.getObjCModuleNamePrefix(): String? {
    val module = getContainingModule()
    val moduleName = module.getObjCKotlinModuleName() ?: return null
    if (moduleName == ""stdlib"" || moduleName == ""kotlin-stdlib-common"") return ""Kotlin""
    if (isExported(module)) return null
    return abbreviateModuleName(moduleName)
}

/**
 * 'MyModuleName' -> 'MMN'
 * 'someLibraryFoo' -> 'SLF'
 */
internal fun abbreviateModuleName(name: String): String {
    val normalizedName = name",.capitalizeAsciiOnly()
"private val serializerExtensionProtocol: SerializerExtensionProtocol
) : FirSymbolProvider(session) {
    // ------------------------ Caches ------------------------

    /**
     * [packageNamesForNonClassDeclarations] might contain names of packages containing type aliases, on top of packages containing
     * callables, so it's not the same as `symbolNamesProvider.getPackageNamesWithTopLevelCallables` and cannot be replaced by it.
     */
    private val packageNamesForNonClassDeclarations: Set<String> by lazy(LazyThreadSafetyMode.PUBLICATION) {
        computePackageSetWithNonClassDeclarations()
    }

    override val symbolNamesProvider: FirSymbolNamesProvider = object : FirCachedSymbolNamesProvider(session) {
        override fun computePackageNames(): Set<String>? = null

        override val hasSpecificClassifierPackageNamesComputation: Boolean get() = false

        override fun computePackageNamesWithTopLevelClassifiers(): Set<String>? = null

        override fun computeTopLevelClassifierNames(packageFqName: FqName): Set<Name>? {
            val classesInPackage = knownTopLevelClassesInPackage(packageFqName)?.mapToSetOrEmpty { Name.identifier(it) } ?: return null

            if (packageFqName.asString() !in packageNamesForNonClassDeclarations) return classesInPackage

            val typeAliasNames = typeAliasesNamesByPackage.getValue(packageFqName)
            if (typeAliasNames.isEmpty()) return classesInPackage

            return buildSet {
                addAll(classesInPackage)
                addAll(typeAliasNames)
            }
        }

        override val hasSpecificCallablePackageNamesComputation: Boolean get() = true

        override fun getPackageNamesWithTopLevelCallables(): Set<String> = packageNamesForNonClassDeclarations

        override fun computePackageNamesWithTopLevelCallables(): Set<String> = packageNamesForNonClassDeclarations

        override fun computeTopLevelCallableNames(packageFqName: FqName): Set<Name> =
            getPackageParts(packageFqName).flatMapTo(mutableSetOf()) {
                it.topLevelFunctionNameIndex.keys + it.topLevelPropertyNameIndex.keys
            }
    }

    private val typeAliasesNamesByPackage: FirCache<FqName, Set<Name>, Nothing?> =
        session.firCachesFactory.createCache { fqName: FqName ->
            getPackageParts(fqName).flatMapTo(mutableSetOf()) { it.typeAliasNameIndex.keys }
        }

    private val packagePartsCache = session.firCachesFactory.createCache(::tryComputePackagePartInfos)

    private val typeAliasCache: FirCache<ClassId, FirTypeAliasSymbol?, FirDeserializationContext?> =
        session.firCachesFactory.createCacheWithPostCompute(
            createValue = { classId, _ -> findAndDeserializeTypeAlias(classId) },
            postCompute = { _, symbol, postProcessor ->
                if (postProcessor != null && symbol != null) {
                    postProcessor.invoke(symbol)
                }
            }
        )

    private val classCache: FirCache<ClassId, FirRegularClassSymbol?, FirDeserializationContext?> =
        session.firCachesFactory.createCacheWithPostCompute(
            createValue = { classId, context -> findAndDeserializeClass(classId, context) },","postCompute = { _, symbol, postProcessor ->"
"protected fun irConst(value: Long): IrConst<Long> = IrConstImpl(
        UNDEFINED_OFFSET,
        UNDEFINED_OFFSET,
        context.irBuiltIns.longType,
        IrConstKind.Long,
        value
    )

    protected fun irConst(value: String): IrConst<String> = IrConstImpl(
        UNDEFINED_OFFSET,
        UNDEFINED_OFFSET,
        context.irBuiltIns.stringType,
        IrConstKind.String,
        value
    )

    protected fun irConst(value: Boolean) = IrConstImpl(
        UNDEFINED_OFFSET,
        UNDEFINED_OFFSET,
        context.irBuiltIns.booleanType,
        IrConstKind.Boolean,
        value
    )

    protected fun irNull() = IrConstImpl(
        UNDEFINED_OFFSET,
        UNDEFINED_OFFSET,
        context.irBuiltIns.anyNType,
        IrConstKind.Null,
        null
    )

    protected fun irForLoop(
        elementType: IrType,
        subject: IrExpression,
        loopBody: (IrValueDeclaration) -> IrExpression
    ): IrStatement {
        val getIteratorFunction = subject.type.classOrNull!!.owner.functions
            .single { it.name.asString() == ""iterator"" }

        val iteratorSymbol = getIteratorFunction.returnType.classOrNull!!
        val iteratorType = if (iteratorSymbol.owner.typeParameters.isNotEmpty()) {
            iteratorSymbol.typeWith(elementType)
        } else {
            iteratorSymbol.defaultType
        }

        val nextSymbol = iteratorSymbol.owner.functions
            .single { it.name.asString() == ""next"" }
        val hasNextSymbol = iteratorSymbol.owner.functions
            .single { it.name.asString() == ""hasNext"" }

        val call = IrCallImpl(
            UNDEFINED_OFFSET,
            UNDEFINED_OFFSET,
            iteratorType,
            getIteratorFunction.symbol,
            getIteratorFunction.symbol.owner.typeParameters.size,
            getIteratorFunction.symbol.owner.valueParameters.size,
            IrStatementOrigin.FOR_LOOP_ITERATOR
        ).also {
            it.dispatchReceiver = subject
        }",val iteratorVar = irTemporary(
"assertFalse(eqIntQByteQ(undefined, 0.toByte()))
    assertFalse(eqIntQByteQ(undefined, 1.toByte()))
    assertTrue(eqIntQByteQ(undefined, null))
    assertTrue(eqIntQByteQ(undefined, undefined))
    assertFalse(eqIntBoolean(0.toInt(), false))
    assertFalse(eqIntBoolean(0.toInt(), true))
    assertFalse(eqIntBoolean(1.toInt(), false))
    assertFalse(eqIntBoolean(1.toInt(), true))
    assertFalse(eqIntBooleanQ(0.toInt(), false))
    assertFalse(eqIntBooleanQ(0.toInt(), true))
    assertFalse(eqIntBooleanQ(0.toInt(), null))
    assertFalse(eqIntBooleanQ(0.toInt(), undefined))
    assertFalse(eqIntBooleanQ(1.toInt(), false))
    assertFalse(eqIntBooleanQ(1.toInt(), true))
    assertFalse(eqIntBooleanQ(1.toInt(), null))
    assertFalse(eqIntBooleanQ(1.toInt(), undefined))
    assertFalse(eqIntQBoolean(0.toInt(), false))
    assertFalse(eqIntQBoolean(0.toInt(), true))
    assertFalse(eqIntQBoolean(1.toInt(), false))
    assertFalse(eqIntQBoolean(1.toInt(), true))
    assertFalse(eqIntQBoolean(null, false))
    assertFalse(eqIntQBoolean(null, true))
    assertFalse(eqIntQBoolean(undefined, false))
    assertFalse(eqIntQBoolean(undefined, true))
    assertFalse(eqIntQBooleanQ(0.toInt(), false))
    assertFalse(eqIntQBooleanQ(0.toInt(), true))
    assertFalse(eqIntQBooleanQ(0.toInt(), null))
    assertFalse(eqIntQBooleanQ(0.toInt(), undefined))
    assertFalse(eqIntQBooleanQ(1.toInt(), false))
    assertFalse(eqIntQBooleanQ(1.toInt(), true))
    assertFalse(eqIntQBooleanQ(1.toInt(), null))
    assertFalse(eqIntQBooleanQ(1.toInt(), undefined))
    assertFalse(eqIntQBooleanQ(null, false))
    assertFalse(eqIntQBooleanQ(null, true))
    assertTrue(eqIntQBooleanQ(null, null))
    assertTrue(eqIntQBooleanQ(null, undefined))
    assertFalse(eqIntQBooleanQ(undefined, false))
    assertFalse(eqIntQBooleanQ(undefined, true))
    assertTrue(eqIntQBooleanQ(undefined, null))
    assertTrue(eqIntQBooleanQ(undefined, undefined))
    assertTrue(eqIntShort(0.toInt(), 0.toShort()))
    assertFalse(eqIntShort(0.toInt(), 1.toShort()))
    assertFalse(eqIntShort(1.toInt(), 0.toShort()))
    assertTrue(eqIntShort(1.toInt(), 1.toShort()))
    assertTrue(eqIntShortQ(0.toInt(), 0.toShort()))
    assertFalse(eqIntShortQ(0.toInt(), 1.toShort()))
    assertFalse(eqIntShortQ(0.toInt(), null))
    assertFalse(eqIntShortQ(0.toInt(), undefined))
    assertFalse(eqIntShortQ(1.toInt(), 0.toShort()))
    assertTrue(eqIntShortQ(1.toInt(), 1.toShort()))
    assertFalse(eqIntShortQ(1.toInt(), null))
    assertFalse(eqIntShortQ(1.toInt(), undefined))
    assertTrue(eqIntQShort(0.toInt(), 0.toShort()))
    assertFalse(eqIntQShort(0.toInt(), 1.toShort()))
    assertFalse(eqIntQShort(1.toInt(), 0.toShort()))
    assertTrue(eqIntQShort(1.toInt(), 1.toShort()))
    assertFalse(eqIntQShort(null, 0.toShort()))
    assertFalse(eqIntQShort(null, 1.toShort()))
    assertFalse(eqIntQShort(undefined, 0.toShort()))
    assertFalse(eqIntQShort(undefined, 1.toShort()))
    assertTrue(eqIntQShortQ(0.toInt(), 0.toShort()))
    assertFalse(eqIntQShortQ(0.toInt(), 1.toShort()))
    assertFalse(eqIntQShortQ(0.toInt(), null))
    assertFalse(eqIntQShortQ(0.toInt(), undefined))
    assertFalse(eqIntQShortQ(1.toInt(), 0.toShort()))","assertTrue(eqIntQShortQ(1.toInt(), 1.toShort()))"
"// !DIAGNOSTICS: -FINAL_UPPER_BOUND -CAST_NEVER_SUCCEEDS
// !LANGUAGE: -AllowEmptyIntersectionsInResultTypeResolver

interface I

class View1
open class View2
interface View3
abstract class View4
interface View5

fun <T: View1> findViewById1(): T = null as T
fun test1(): I = <!NEW_INFERENCE_ERROR, RETURN_TYPE_MISMATCH!>findViewById1()<!>

fun <T: View2> findViewById2(): T = null as T
fun test2(): I = findViewById2()

inline fun <reified T: View1> findViewById3(): T = null as T
fun test3(): I = <!NEW_INFERENCE_ERROR, RETURN_TYPE_MISMATCH!>findViewById3()<!>

inline fun <reified T: View2> findViewById4(): T = null as T
fun test4(): I = findViewById4()

fun <T: View3> findViewById5(): T = null as T
fun test5(): I = findViewById5()

inline fun <reified T: View3> findViewById6(): T = null as T
fun test6(): I = findViewById6()

fun <T: View4> findViewById7(): T = null as T
fun test7(): I = findViewById7()

inline fun <reified T: View4> findViewById8(): T = null as T
fun test8(): I = findViewById8()

fun <T> findViewById9(): T where T: View3, T: View5 = null as T
fun test9(): I = findViewById9()

inline fun <reified T> findViewById10(): T where T: View3, T: View5 = null as T
fun test10(): I = findViewById10()

fun <T: View2> findViewById11(): T = null as T
fun test11(): View4 = <!NEW_INFERENCE_ERROR, RETURN_TYPE_MISMATCH!>findViewById11()<!>

object Obj {
    fun <T: I> findViewById1(): T = null as T
    fun test1(): View1 = <!NEW_INFERENCE_ERROR, RETURN_TYPE_MISMATCH!>findViewById1()<!>

    fun <T: I> findViewById2(): T = null as T
    fun test2(): View2 = findViewById2()

    inline fun <reified T: I> findViewById3(): T = null as T
    fun test3(): View1 = <!NEW_INFERENCE_ERROR, RETURN_TYPE_MISMATCH!>findViewById3()<!>

    inline fun <reified T: I> findViewById4(): T = null as T
    fun test4(): View2 = findViewById4()

    fun <T: I> findViewById5(): T = null as T
    fun test5(): View3 = findViewById5()

    inline fun <reified T: I> findViewById6(): T = null as T
    fun test6(): View3 = findViewById6()",fun <T: I> findViewById7(): T = null as T
"require(directEdges.size == reversedEdges.size)
                var index = 0
                val nodesStack = IntArray(nodesCount)
                val edgeIdsStack = IntArray(nodesCount)
                for (nodeId in 0 until nodesCount) {
                    if (visited[nodeId]) continue
                    visited.set(nodeId)
                    nodesStack[0] = nodeId
                    edgeIdsStack[0] = 0
                    var stackPtr = 0
                    while (stackPtr != -1) {
                        val v = nodesStack[stackPtr]
                        val eid = edgeIdsStack[stackPtr]++
                        if (eid == directEdges.edgeCount(v)) {
                            order[index++] = v
                            stackPtr--
                        } else {
                            val next = directEdges.getEdge(v, eid)
                            if (!visited[next]) {
                                ++stackPtr
                                nodesStack[stackPtr] = next
                                edgeIdsStack[stackPtr] = 0
                                visited.set(next)
                            }
                        }
                    }
                }

                require(index == nodesCount)
            }

            private fun calculateMultiNodes() : IntArray {
                visited.clear()
                var index = 0
                val multiNodesInOrder = mutableListOf<Int>()
                for (i in order.size - 1 downTo 0) {
                    val nodeIndex = order[i]
                    if (visited[nodeIndex]) continue
                    multiNodesInOrder.add(nodeIndex)
                    val start = index
                    var cur = start
                    multiNodes[index++] = nodeIndex
                    visited.set(nodeIndex)
                    while (cur < index) {
                        reversedEdges.forEachEdge(multiNodes[cur++]) {
                            if (!visited[it]) {
                                multiNodes[index++] = it
                                visited.set(it)
                            }
                        }
                    }
                    val end = index
                    for (multiNodeIndex in start until end) {
                        val node = nodes[multiNodes[multiNodeIndex]]
                        node.multiNodeStart = start
                        node.multiNodeEnd = end
                    }
                }
                require(index == nodesCount)
                return multiNodesInOrder.toIntArray()
            }


            fun build(): Condensation {
                calculateTopologicalSort()",val multiNodesInOrder = calculateMultiNodes()
"// FIR_IDENTICAL
// MODULE: m1-common
// FILE: common.kt

import kotlin.reflect.KClass

expect annotation class Primitives(
    val z: Boolean = true,
    val c: Char = 'c',
    val b: Byte = 42.toByte(),
    val s: Short = (-1).toShort(),
    val i: Int = -42,
    val f: Float = 2.72f,
    val j: Long = 123456789123456789L,
    val d: Double = 3.14159265358979
)

expect annotation class PrimitiveArrays(
    val z: BooleanArray = [true],
    val c: CharArray = ['c'],
    val b: ByteArray = [42.toByte()],
    val s: ShortArray = [(-1).toShort()],
    val i: IntArray = [-42],
    val f: FloatArray = [2.72f],
    val j: LongArray = [123456789123456789L],
    val d: DoubleArray = [3.14159265358979]
)

enum class En { A, B }

annotation class Anno(val value: String = ""Anno"")

expect annotation class Classes(
    val s: String = ""OK"",
    val e: En = En.B,
    // TODO: this does not work at the moment because AnnotationDescriptor subclasses do not implement equals correctly
    // val a: Anno = Anno(),
    val k: KClass<*> = List::class
)

expect annotation class ClassArrays(
    val s: Array<String> = [""OK""],
    val e: Array<En> = [En.B],
    // val a: Array<Anno> = [Anno()],
    val k: Array<KClass<*>> = [List::class],
    vararg val v: Int = [42]
)

// MODULE: m2-jvm()()(m1-common)
// FILE: jvm.kt

import kotlin.reflect.KClass

actual annotation class Primitives(
    actual val z: Boolean = true,
    actual val c: Char = 'c',
    actual val b: Byte = 42.toByte(),
    actual val s: Short = (-1).toShort(),
    actual val i: Int = -42,","actual val f: Float = 2.72f,"
"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.cfg

import com.intellij.psi.util.PsiTreeUtil.getParentOfType
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.ClassDescriptorWithResolutionScopes
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.psi.psiUtil.getNonStrictParentOfType
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.BindingContext.DECLARATION_TO_DESCRIPTOR

val KtElement.containingDeclarationForPseudocode: KtDeclaration?","get() = getParentOfType(this, KtDeclarationWithBody::class.java, KtClassOrObject::class.java, KtScript::class.java)"
"// !DIAGNOSTICS: -UNUSED_EXPRESSION
// SKIP_TXT
// WITH_EXTENDED_CHECKERS

/*
 * KOTLIN DIAGNOSTICS NOT LINKED SPEC TEST (POSITIVE)
 *
 * SECTIONS: dfa
 * NUMBER: 7
 * DESCRIPTION: Raw data flow analysis test
 * UNEXPECTED BEHAVIOUR
 * HELPERS: classes, enumClasses, objects, typealiases, properties, functions
 */

// FILE: other_package.kt

package orherpackage

// TESTCASE NUMBER: 13
class EmptyClass13 {}

// TESTCASE NUMBER: 14
typealias TypealiasString14 = String?

// FILE: main.kt

import orherpackage.*

// TESTCASE NUMBER: 1
fun case_1(x: Any?) {
    if (x != null || <!SENSELESS_COMPARISON!>x != null<!> || <!SENSELESS_COMPARISON!>x != null<!> || <!SENSELESS_COMPARISON!>x != null<!> || <!SENSELESS_COMPARISON!>x != null<!> || <!SENSELESS_COMPARISON!>x != null<!> || <!SENSELESS_COMPARISON!>x != null<!>) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Any"")!>x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Any"")!>x<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Any"")!>x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Any"")!>x<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Any"")!>x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Any"")!>x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Any"")!>x<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Any"")!>x<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Any"")!>x<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.Any? & kotlin.Any"")!>x<!>.funNullableAny()
    }
}

/*
 * TESTCASE NUMBER: 2
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-28159
 */",fun case_2(x: Nothing?) {
"// JVM_ABI_K1_K2_DIFF: KT-63861

// FILE: 1.kt

package test

public class Exception1(message: String) : RuntimeException(message)

public class Exception2(message: String) : RuntimeException(message)

public inline fun doCall(block: ()-> String, exception1: (e: Exception)-> Unit, finallyBlock: ()-> String,
                         exception3: (e: Exception)-> Unit, finallyBlock2: ()-> String, res: String = ""Fail"") : String {
    try {
        try {
            block()
        }
        catch (e: Exception1) {
            exception1(e)
        }
        finally {
            if (true) {
                finallyBlock()",/*External finally would be injected here*/
"override fun testDelegatedMethod() {
        doTest(
            """"""
                interface Trait {
                    fun f0()
                    fun f4()
                    fun f3()
                    fun f2()
                    fun f1()
                    fun f5()
                }

                val delegate: Trait = throw Error()

                val obj = object : Trait by delegate {
                    override fun f3() { }
                }
            """""",
            ""\$obj$1"",
            listOf(""<init>()V"", ""f0()V"", ""f4()V"", ""f2()V"", ""f1()V"", ""f5()V"", ""f3()V"")
        )
    }
}

class FirLightTreeReflectionClassLoaderTest : IrReflectionClassLoaderTest() {
    override val useFir: Boolean
        get() = true

    override val firParser: FirParser
        get() = LightTree
}

class FirLightTreeCustomBytecodeTextTest : IrCustomBytecodeTextTest() {
    override val useFir: Boolean
        get() = true

    override val firParser: FirParser
        get() = LightTree
}

class FirLightTreeCustomScriptCodegenTest : IrCustomScriptCodegenTest() {
    override val useFir: Boolean
        get() = true

    override val firParser: FirParser
        get() = LightTree
}

class FirLightTreeGenerateNotNullAssertionsTest : IrGenerateNotNullAssertionsTest() {
    override val useFir: Boolean
        get() = true

    override val firParser: FirParser
        get() = LightTree
}

class FirLightTreeSourceInfoGenTest : IrSourceInfoGenTest() {
    override val useFir: Boolean
        get() = true

    override val firParser: FirParser
        get() = LightTree
}

class FirLightTreeLinkageModeTest : JvmIrLinkageModeTest() {",override val useFir: Boolean
"KtNodeTypes.PROPERTY_ACCESSOR -> {
                    markElement(tree.accessorNamePlaceholder(node), startOffset, endOffset, tree, node)
                }
                else -> markElement(node, startOffset, endOffset, tree)
            }
        }
    }

    private class InlineFunLightTreePositioningStrategy : ModifierSetBasedLightTreePositioningStrategy(INLINE_KEYWORD) {
        override fun mark(
            node: LighterASTNode,
            startOffset: Int,
            endOffset: Int,
            tree: FlyweightCapableTreeStructure<LighterASTNode>
        ): List<TextRange> {
            if (node.tokenType == KtNodeTypes.PROPERTY) {
                return markModifier(tree.getter(node), startOffset, endOffset, tree, node)
                    ?: markModifier(tree.setter(node), startOffset, endOffset, tree, node)
                    ?: super.mark(node, startOffset, endOffset, tree)
            }
            return super.mark(node, startOffset, endOffset, tree)
        }
    }

    val VISIBILITY_MODIFIER: LightTreePositioningStrategy = ModifierSetBasedLightTreePositioningStrategy(VISIBILITY_MODIFIERS)

    val MODALITY_MODIFIER: LightTreePositioningStrategy = ModifierSetBasedLightTreePositioningStrategy(MODALITY_MODIFIERS)

    val ABSTRACT_MODIFIER: LightTreePositioningStrategy =
        ModifierSetBasedLightTreePositioningStrategy(KtTokens.ABSTRACT_KEYWORD)

    val OPEN_MODIFIER: LightTreePositioningStrategy =
        ModifierSetBasedLightTreePositioningStrategy(KtTokens.OPEN_KEYWORD)

    val OVERRIDE_MODIFIER: LightTreePositioningStrategy =
        ModifierSetBasedLightTreePositioningStrategy(KtTokens.OVERRIDE_KEYWORD)

    val PRIVATE_MODIFIER: LightTreePositioningStrategy =
        ModifierSetBasedLightTreePositioningStrategy(KtTokens.PRIVATE_KEYWORD)

    val LATEINIT_MODIFIER: LightTreePositioningStrategy =
        ModifierSetBasedLightTreePositioningStrategy(KtTokens.LATEINIT_KEYWORD)

    val VARIANCE_MODIFIER: LightTreePositioningStrategy =
        ModifierSetBasedLightTreePositioningStrategy(KtTokens.IN_KEYWORD, KtTokens.OUT_KEYWORD)

    val CONST_MODIFIER: LightTreePositioningStrategy =
        ModifierSetBasedLightTreePositioningStrategy(KtTokens.CONST_KEYWORD)

    val FUN_MODIFIER: LightTreePositioningStrategy =
        ModifierSetBasedLightTreePositioningStrategy(KtTokens.FUN_KEYWORD)

    val SUSPEND_MODIFIER: LightTreePositioningStrategy =
        ModifierSetBasedLightTreePositioningStrategy(KtTokens.SUSPEND_KEYWORD)

    private val SUSPEND_OR_FUN_MODIFIER: LightTreePositioningStrategy =
        ModifierSetBasedLightTreePositioningStrategy(KtTokens.SUSPEND_KEYWORD, KtTokens.FUN_KEYWORD)

    val INLINE_OR_VALUE_MODIFIER: LightTreePositioningStrategy =
        ModifierSetBasedLightTreePositioningStrategy(INLINE_KEYWORD, KtTokens.VALUE_KEYWORD)

    val INNER_MODIFIER: LightTreePositioningStrategy =
        ModifierSetBasedLightTreePositioningStrategy(KtTokens.INNER_KEYWORD)

    val DATA_MODIFIER: LightTreePositioningStrategy =",ModifierSetBasedLightTreePositioningStrategy(KtTokens.DATA_KEYWORD)
"// SKIP_TXT

/*
 * KOTLIN DIAGNOSTICS SPEC TEST (POSITIVE)
 *
 * SPEC VERSION: 0.1-268
 * MAIN LINK: overload-resolution, building-the-overload-candidate-set-ocs, call-with-an-explicit-receiver -> paragraph 6 -> sentence 2
 * PRIMARY LINKS: overload-resolution, c-level-partition -> paragraph 1 -> sentence 1
 * overload-resolution, building-the-overload-candidate-set-ocs, call-with-an-explicit-receiver -> paragraph 3 -> sentence 1
 * overload-resolution, building-the-overload-candidate-set-ocs, call-with-an-explicit-receiver -> paragraph 3 -> sentence 2
 * overload-resolution, building-the-overload-candidate-set-ocs, call-with-an-explicit-receiver -> paragraph 2 -> sentence 1
 * NUMBER: 2
 * DESCRIPTION: extension calls with explicit and implicit receiver
 * UNEXPECTED BEHAVIOUR
 * ISSUES: KT-36475
 */

// TESTCASE NUMBER: 1
class Case1 {
    fun bar() {
        val foo: String.() -> Unit = {} // (1)
        fun String.foo(): Unit {} // (2)
        ""1"".<!DEBUG_INFO_CALL(""fqName: Case1.bar.foo; typeCall: extension function"")!>foo()<!> // resolves to (2)
        with(""2"") {
            foo()      //resolves to (1) !!!
            this.<!DEBUG_INFO_CALL(""fqName: Case1.bar.foo; typeCall: extension function"")!>foo()<!> //resolves to (2)
        }
        """".run {
            <!DEBUG_INFO_CALL(""fqName: kotlin.Function1.invoke; typeCall: variable&invoke"")!>foo()<!>      //resolves to (1) !!!
            this.<!DEBUG_INFO_CALL(""fqName: Case1.bar.foo; typeCall: extension function"")!>foo()<!> //resolves to (2)
        }
        """".apply {
            <!DEBUG_INFO_CALL(""fqName: kotlin.Function1.invoke; typeCall: variable&invoke"")!>foo()<!>      //resolves to (1) !!!
            this.<!DEBUG_INFO_CALL(""fqName: Case1.bar.foo; typeCall: extension function"")!>foo()<!> //resolves to (2)
        }
        """".also {
            it.<!DEBUG_INFO_CALL(""fqName: Case1.bar.foo; typeCall: extension function"")!>foo()<!>   //resolves to (2)
        }
        """".let {
            it.<!DEBUG_INFO_CALL(""fqName: Case1.bar.foo; typeCall: extension function"")!>foo()<!>   //resolves to (2)
        }
    }
}

class B {
    val foo: String.() -> Unit = {} // (1)
    fun String.foo(): Unit {} // (2)
    fun bar() {
        ""1"".<!DEBUG_INFO_CALL(""fqName: B.foo; typeCall: extension function"")!>foo()<!> // resolves to (2)
        val <!UNUSED_VARIABLE!>str<!> = ""1""
        with(""2"") {
            <!DEBUG_INFO_CALL(""fqName: B.foo; typeCall: extension function"")!>foo()<!>      //resolves to (2)
            this.<!DEBUG_INFO_CALL(""fqName: B.foo; typeCall: extension function"")!>foo()<!> //resolves to (2)
        }
        """".run {
            <!DEBUG_INFO_CALL(""fqName: B.foo; typeCall: extension function"")!>foo()<!>      //resolves to (2)
            this.<!DEBUG_INFO_CALL(""fqName: B.foo; typeCall: extension function"")!>foo()<!> //resolves to (2)
        }
        """".apply {
            <!DEBUG_INFO_CALL(""fqName: B.foo; typeCall: extension function"")!>foo()<!>      //resolves to (2)
            this.<!DEBUG_INFO_CALL(""fqName: B.foo; typeCall: extension function"")!>foo()<!> //resolves to (2)
        }
        """".also {","it.<!DEBUG_INFO_CALL(""fqName: B.foo; typeCall: extension function"")!>foo()<!>   //resolves to (2)"
"class Identifier() {
    private var myNullable : Boolean = false
        set(l : Boolean) {
            //do nothing
        }

    fun getValue() : Boolean {
        return myNullable
    }

    companion object {
        fun init(isNullable : Boolean) : Identifier {
            val id = Identifier()
            id.myNullable = isNullable",return id
"// EXPECTED_REACHABLE_NODES: 1286
package foo

// CHECK_CONTAINS_NO_CALLS: testImplicitThis except=Unit_getInstance
// CHECK_CONTAINS_NO_CALLS: testExplicitThis except=Unit_getInstance

internal class A(var value: Int)

internal fun testImplicitThis(a: A, newValue: Int) {
    with (a) {
        value = newValue
    }
}

internal fun testExplicitThis(a: A, newValue: Int) {
    with (a) {
        this.value = newValue
    }
}

fun box(): String {
    val a = A(0)
    assertEquals(0, a.value)

    testImplicitThis(a, 10)","assertEquals(10, a.value)"
"/*
 * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the LICENSE file.
 */

@file:Suppress(""UNUSED"")
@file:OptIn(kotlin.native.runtime.NativeRuntimeApi::class)

package stdlib

import kotlin.test.*

fun <K, V> isEmpty(map: Map<K, V>) = map.isEmpty()

fun <K, V> getKeysAsSet(map: Map<K, V>) = map.keys
fun <K, V> getKeysAsList(map: Map<K, V>) = map.keys.toList()

fun <K, V> toMutableMap(map: HashMap<K, V>) = map.toMutableMap()

fun <E> getFirstElement(collection: Collection<E>) = collection.first()

class GenericExtensionClass<K, out V, out T : Map<K, V>> (private val holder: T?) {
    fun getFirstKey(): K? = holder?.entries?.first()?.key

    fun getFirstValue() : V? {
        holder?.entries?.forEach { e -> println(""KEY: ${e.key}  VALUE: ${e.value}"") }
        return holder?.entries?.first()?.value
    }
}

fun <K, V> createPair():
        Pair<LinkedHashMap<K, V>, GenericExtensionClass<K, V, Map<K, V>>> {
    val l = createLinkedMap<K, V>()
    val g = GenericExtensionClass(l)
    return Pair(l, g)
}

fun <K, V> createLinkedMap() = linkedMapOf<K, V>()

fun createTypedMutableMap() = linkedMapOf<Int, String>()

fun addSomeElementsToMap(map: MutableMap<String, Int>) {
    map.put(key = ""XYZ"", value = 321)
    map.put(key = ""TMP"", value = 451)
}

fun list(vararg elements: Any?): Any = listOf(*elements)
fun set(vararg elements: Any?): Any = setOf(*elements)
fun map(vararg keysAndValues: Any?): Any = mutableMapOf<Any?, Any?>().apply {
    (0 until keysAndValues.size step 2).forEach {index ->
        this[keysAndValues[index]] = keysAndValues[index + 1]
    }
}

fun emptyMutableList(): Any = mutableListOf<Any?>()
fun emptyMutableSet(): Any = mutableSetOf<Any?>()
fun emptyMutableMap(): Any = mutableMapOf<Any?, Any?>()

data class TripleVals<T>(val first: T, val second: T, val third: T)","data class TripleVars<T>(var first: T, var second: T, var third: T) {"
"// !DIAGNOSTICS: -UNUSED_VARIABLE -UNUSED_PARAMETER
// JSR305_GLOBAL_REPORT: warn

// FILE: spr/Nullable.java
package spr;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import javax.annotation.Nonnull;
import javax.annotation.meta.TypeQualifierNickname;
import javax.annotation.meta.When;

@Target({ElementType.METHOD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Nonnull(when = When.MAYBE)
@TypeQualifierNickname
public @interface Nullable {
}

// FILE: spr/NonNullApi.java
package spr;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import javax.annotation.Nonnull;
import javax.annotation.meta.TypeQualifierDefault;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Nonnull
@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})
public @interface NonNullApi {
}

// FILE: A.java
import spr.*;

@NonNullApi
public class A {
    public String field = null;

    public String foo(String x, @Nullable CharSequence y) {
        return """";
    }

    public String bar() {
        return """";
    }

    @Nullable
    public java.util.List<String> baz() {
        return null;
    }
}

// FILE: main.kt
fun main(a: A) {","a.foo("""", null)<!UNNECESSARY_SAFE_CALL!>?.<!>length"
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.resolve.dfa

import kotlinx.collections.immutable.*",import org.jetbrains.kotlin.fir.FirSession
"|            patternLayout {
    |                artifact(""v[revision]/[artifact](-v[revision]-[classifier]).[ext]"")
    |            }
    |            metadataSources { 
    |                artifact() 
    |            }
    |            content { 
    |                includeModule(""org.nodejs"", ""node"") 
    |            }
    |        }
    |        ivy {
    |            url = uri(""https://github.com/WebAssembly/binaryen/releases/download"")
    |            patternLayout {
    |                artifact(""version_[revision]/binaryen-version_[revision]-[classifier].[ext]"")
    |            }
    |            metadataSources { 
    |                artifact() 
    |            }
    |            content { 
    |                includeModule(""com.github.webassembly"", ""binaryen"") 
    |            }
    |        }
    |        ivy {
    |            url = uri(""https://storage.googleapis.com/chromium-v8/official/canary"")
    |            patternLayout {
    |                artifact(""[artifact]-[revision].[ext]"")
    |            }
    |            metadataSources { 
    |                artifact() 
    |            }
    |            content { 
    |                includeModule(""google.d8"", ""v8"") 
    |            }
    |        }
    |        maven {
    |            url ""https://packages.jetbrains.team/maven/p/ij/intellij-dependencies/""
    |        }
    |        ${additionalDependencyRepositories.map { repo -> ""maven{ url = \""$repo\"" }"" }.joinToString(""\n"")}
    |        ${localRepo?.absolutePathString()?.let { repo -> ""maven{ url = \""${repo.replace(""\\"", ""\\\\"")}\"" }"" } ?: """"}
    |    }
    """""".trimMargin()

@Language(""kts"")
internal val DEFAULT_KOTLIN_SETTINGS_FILE =
    """"""
    pluginManagement {
        repositories {
            mavenLocal()
            mavenCentral()
            google()
            gradlePluginPortal()
        }

        val kotlin_version: String by settings
        val android_tools_version: String by settings
        val test_fixes_version: String by settings
        plugins {
            id(""org.jetbrains.kotlin.jvm"") version kotlin_version
            id(""org.jetbrains.kotlin.kapt"") version kotlin_version
            id(""org.jetbrains.kotlin.android"") version kotlin_version
            id(""org.jetbrains.kotlin.js"") version kotlin_version
            id(""org.jetbrains.kotlin.native.cocoapods"") version kotlin_version
            id(""org.jetbrains.kotlin.multiplatform"") version kotlin_version
            id(""org.jetbrains.kotlin.plugin.allopen"") version kotlin_version
            id(""org.jetbrains.kotlin.plugin.spring"") version kotlin_version","id(""org.jetbrains.kotlin.plugin.jpa"") version kotlin_version"
"if (!(element19 in 1L..<3L) != !range0.contains(element19)) throw AssertionError()
    if (!(element19 !in 1L..<3L) != range0.contains(element19)) throw AssertionError()
}

fun testR0xE20() {
    // with possible local optimizations
    if (4.toByte() in 1L..<3L != range0.contains(4.toByte())) throw AssertionError()
    if (4.toByte() !in 1L..<3L != !range0.contains(4.toByte())) throw AssertionError()
    if (!(4.toByte() in 1L..<3L) != !range0.contains(4.toByte())) throw AssertionError()
    if (!(4.toByte() !in 1L..<3L) != range0.contains(4.toByte())) throw AssertionError()
    // no local optimizations
    if (element20 in 1L..<3L != range0.contains(element20)) throw AssertionError()
    if (element20 !in 1L..<3L != !range0.contains(element20)) throw AssertionError()
    if (!(element20 in 1L..<3L) != !range0.contains(element20)) throw AssertionError()
    if (!(element20 !in 1L..<3L) != range0.contains(element20)) throw AssertionError()
}

fun testR0xE21() {
    // with possible local optimizations
    if (4.toShort() in 1L..<3L != range0.contains(4.toShort())) throw AssertionError()
    if (4.toShort() !in 1L..<3L != !range0.contains(4.toShort())) throw AssertionError()
    if (!(4.toShort() in 1L..<3L) != !range0.contains(4.toShort())) throw AssertionError()
    if (!(4.toShort() !in 1L..<3L) != range0.contains(4.toShort())) throw AssertionError()
    // no local optimizations
    if (element21 in 1L..<3L != range0.contains(element21)) throw AssertionError()
    if (element21 !in 1L..<3L != !range0.contains(element21)) throw AssertionError()
    if (!(element21 in 1L..<3L) != !range0.contains(element21)) throw AssertionError()
    if (!(element21 !in 1L..<3L) != range0.contains(element21)) throw AssertionError()
}

fun testR0xE22() {
    // with possible local optimizations
    if (4 in 1L..<3L != range0.contains(4)) throw AssertionError()
    if (4 !in 1L..<3L != !range0.contains(4)) throw AssertionError()
    if (!(4 in 1L..<3L) != !range0.contains(4)) throw AssertionError()
    if (!(4 !in 1L..<3L) != range0.contains(4)) throw AssertionError()
    // no local optimizations
    if (element22 in 1L..<3L != range0.contains(element22)) throw AssertionError()
    if (element22 !in 1L..<3L != !range0.contains(element22)) throw AssertionError()
    if (!(element22 in 1L..<3L) != !range0.contains(element22)) throw AssertionError()
    if (!(element22 !in 1L..<3L) != range0.contains(element22)) throw AssertionError()
}

fun testR0xE23() {
    // with possible local optimizations
    if (4L in 1L..<3L != range0.contains(4L)) throw AssertionError()
    if (4L !in 1L..<3L != !range0.contains(4L)) throw AssertionError()
    if (!(4L in 1L..<3L) != !range0.contains(4L)) throw AssertionError()
    if (!(4L !in 1L..<3L) != range0.contains(4L)) throw AssertionError()
    // no local optimizations
    if (element23 in 1L..<3L != range0.contains(element23)) throw AssertionError()
    if (element23 !in 1L..<3L != !range0.contains(element23)) throw AssertionError()
    if (!(element23 in 1L..<3L) != !range0.contains(element23)) throw AssertionError()
    if (!(element23 !in 1L..<3L) != range0.contains(element23)) throw AssertionError()
}

fun testR1xE0() {
    // with possible local optimizations
    if ((-1).toByte() in 3L..<1L != range1.contains((-1).toByte())) throw AssertionError()
    if ((-1).toByte() !in 3L..<1L != !range1.contains((-1).toByte())) throw AssertionError()
    if (!((-1).toByte() in 3L..<1L) != !range1.contains((-1).toByte())) throw AssertionError()
    if (!((-1).toByte() !in 3L..<1L) != range1.contains((-1).toByte())) throw AssertionError()
    // no local optimizations
    if (element0 in 3L..<1L != range1.contains(element0)) throw AssertionError()
    if (element0 !in 3L..<1L != !range1.contains(element0)) throw AssertionError()",if (!(element0 in 3L..<1L) != !range1.contains(element0)) throw AssertionError()
"}

        private fun createType(classId: ClassId): ConeClassLikeType {
            return ConeClassLikeTypeImpl(classId.toLookupTag(), EMPTY_ARRAY, false)
        }

        private val INT_RANGE = Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()
        private val BYTE_RANGE = Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()
        private val SHORT_RANGE = Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()

        private val UBYTE_RANGE = UByte.MIN_VALUE.toLong()..UByte.MAX_VALUE.toLong()
        private val USHORT_RANGE = UShort.MIN_VALUE.toLong()..UShort.MAX_VALUE.toLong()
        private val UINT_RANGE = UInt.MIN_VALUE.toLong()..UInt.MAX_VALUE.toLong()
    }
}

class ConeIntegerConstantOperatorTypeImpl(
    isUnsigned: Boolean,
    nullability: ConeNullability
) : ConeIntegerConstantOperatorType(isUnsigned, nullability) {
    override val possibleTypes: Collection<ConeClassLikeType> = when (isUnsigned) {
        false -> setOf(
            createClassLikeType(StandardClassIds.Int),
            createClassLikeType(StandardClassIds.Long),
        )
        true -> setOf(
            createClassLikeType(StandardClassIds.UInt),
            createClassLikeType(StandardClassIds.ULong),
        )
    }

    override val supertypes: List<ConeClassLikeType> by lazy {
        createSupertypeList(this)
    }

    override fun getApproximatedType(expectedType: ConeKotlinType?): ConeClassLikeType {
        return getApproximatedTypeImpl(expectedType)
    }
}

/**
 * This methods detects common super type only for special rules for integer literal types
 * If it returns null then CST will be found by regular rules using real supertypes
 *   of integer literal types
 */
fun ConeIntegerLiteralType.Companion.findCommonSuperType(types: Collection<SimpleTypeMarker>): SimpleTypeMarker? {
    return ConeIntegerLiteralTypeExtensions.findCommonSuperType(types)
}

fun ConeKotlinType.approximateIntegerLiteralType(expectedType: ConeKotlinType? = null): ConeKotlinType {
    return when (this) {
        is ConeIntegerLiteralType -> getApproximatedType(expectedType)
        is ConeFlexibleType -> approximateIntegerLiteralBounds(expectedType)
        else -> this
    }
}

private object ConeIntegerLiteralTypeExtensions {
    fun createSupertypeList(type: ConeIntegerLiteralType): List<ConeClassLikeType> {
        val comparableSuperType =
            ConeClassLikeTypeImpl(StandardClassIds.Comparable.toLookupTag(), arrayOf(ConeKotlinTypeProjectionIn(type)), false)

        return if (type.possibleTypes.none { it.isUnsignedTypeOrNullableUnsignedType }) {
            listOf(
                createClassLikeType(StandardClassIds.Number),","comparableSuperType,"
"storageManager: StorageManager,
        module: ModuleDescriptor,
        configuration: DeserializationConfiguration,
        lookupTracker: LookupTracker
    ): PackageFragmentProvider {
        val scopeProto = metadata.packages.map {
            ProtoBuf.PackageFragment.parseFrom(it, JsSerializerProtocol.extensionRegistry)
        }
        val headerProto = JsProtoBuf.Header.parseFrom(CodedInputStream.newInstance(metadata.header), JsSerializerProtocol.extensionRegistry)
        return createKotlinJavascriptPackageFragmentProvider(
            storageManager, module, headerProto, scopeProto, metadata.metadataVersion, configuration, lookupTracker
        )
    }

    fun serializeMetadata(
        bindingContext: BindingContext,
        jsDescriptor: JsModuleDescriptor<ModuleDescriptor>,
        languageVersionSettings: LanguageVersionSettings,
        metadataVersion: JsMetadataVersion,
        project: Project
    ): SerializedMetadata {
        val serializedFragments =
            emptyMap<FqName, ByteArray>().missingMetadata(bindingContext, jsDescriptor.data, languageVersionSettings, metadataVersion, project)

        return SerializedMetadata(serializedFragments, jsDescriptor, languageVersionSettings, metadataVersion)
    }

    class SerializedMetadata(
        private val serializedFragments: Map<FqName, ByteArray>,
        private val jsDescriptor: JsModuleDescriptor<ModuleDescriptor>,
        private val languageVersionSettings: LanguageVersionSettings,
        private val metadataVersion: JsMetadataVersion
    ) {
        class SerializedPackage(val fqName: FqName, val bytes: ByteArray)

        fun serializedPackages(): List<SerializedPackage> {
            val packages = arrayListOf<SerializedPackage>()

            for ((fqName, part) in serializedFragments) {
                val stream = ByteArrayOutputStream()
                with(DataOutputStream(stream)) {
                    val version = metadataVersion.toArray()
                    writeInt(version.size)
                    version.forEach(this::writeInt)
                }

                serializeHeader(jsDescriptor.data, fqName, languageVersionSettings).writeDelimitedTo(stream)
                stream.write(part)

                packages.add(SerializedPackage(fqName, stream.toByteArray()))
            }

            return packages
        }

        fun asString(): String =
            KotlinJavascriptMetadataUtils.formatMetadataAsString(jsDescriptor.name, asByteArray(), metadataVersion)

        private fun asByteArray(): ByteArray =
            ByteArrayOutputStream().apply {
                GZIPOutputStream(this).use { stream ->
                    serializeHeader(
                        jsDescriptor.data,
                        packageFqName = null,
                        languageVersionSettings = languageVersionSettings",).writeDelimitedTo(stream)
"/**
     * Compares this value with the specified value for order.
     *
     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,
     * or a positive number if it's greater than other.
     */
    @kotlin.internal.IntrinsicConstEvaluation
    public override fun compareTo(other: Char): Int

    /** Adds the other Int value to this value resulting a Char. */
    @kotlin.internal.IntrinsicConstEvaluation
    public operator fun plus(other: Int): Char

    /** Subtracts the other Char value from this value resulting an Int. */
    @kotlin.internal.IntrinsicConstEvaluation
    public operator fun minus(other: Char): Int

    /** Subtracts the other Int value from this value resulting a Char. */
    @kotlin.internal.IntrinsicConstEvaluation
    public operator fun minus(other: Int): Char

    /**
     * Returns this value incremented by one.
     *
     * @sample samples.misc.Builtins.inc
     */
    public operator fun inc(): Char

    /**
     * Returns this value decremented by one.
     *
     * @sample samples.misc.Builtins.dec
     */
    public operator fun dec(): Char

    /** Creates a range from this value to the specified [other] value. */
    public operator fun rangeTo(other: Char): CharRange

    /**
     * Creates a range from this value up to but excluding the specified [other] value.
     *
     * If the [other] value is less than or equal to `this` value, then the returned range is empty.
     */
    @SinceKotlin(""1.9"")
    @WasExperimental(ExperimentalStdlibApi::class)
    public operator fun rangeUntil(other: Char): CharRange

    /** Returns the value of this character as a `Byte`. */
    @Deprecated(""Conversion of Char to Number is deprecated. Use Char.code property instead."", ReplaceWith(""this.code.toByte()""))
    @DeprecatedSinceKotlin(warningSince = ""1.5"")
    @kotlin.internal.IntrinsicConstEvaluation
    public fun toByte(): Byte

    /** Returns the value of this character as a `Char`. */
    @kotlin.internal.IntrinsicConstEvaluation
    public fun toChar(): Char

    /** Returns the value of this character as a `Short`. */
    @Deprecated(""Conversion of Char to Number is deprecated. Use Char.code property instead."", ReplaceWith(""this.code.toShort()""))
    @DeprecatedSinceKotlin(warningSince = ""1.5"")
    @kotlin.internal.IntrinsicConstEvaluation
    public fun toShort(): Short

    /** Returns the value of this character as a `Int`. */
    @Deprecated(""Conversion of Char to Number is deprecated. Use Char.code property instead."", ReplaceWith(""this.code""))","@DeprecatedSinceKotlin(warningSince = ""1.5"")"
"contract { returns(true) implies (this@case_5_1 !is String) }
    return this@case_5_1 !is String
}
fun <T> T.case_5_2(): Boolean {
    contract { returns(false) implies (this@case_5_2 !is String) }
    return !(this@case_5_2 !is String)
}
fun <T> T.case_5_3(): Boolean? {
    contract { returnsNotNull() implies (this@case_5_3 !is String) }
    return if (this@case_5_3 !is String) true else null
}
fun <T> T.case_5_4(): Boolean? {
    contract { returns(null) implies (this@case_5_4 !is String) }
    return if (this@case_5_4 !is String) null else true
}

// TESTCASE NUMBER: 6
fun <T : Number> T.case_6_1(): Boolean {
    contract { returns(true) implies (this@case_6_1 !is Int) }
    return this@case_6_1 !is Int
}
fun <T : Number> T.case_6_2(): Boolean {
    contract { returns(false) implies (this@case_6_2 !is Int) }
    return !(this@case_6_2 !is Int)
}
fun <T : Number> T.case_6_3(): Boolean? {
    contract { returnsNotNull() implies (this@case_6_3 !is Int) }
    return if (this@case_6_3 !is Int) true else null
}
fun <T : Number> T.case_6_4(): Boolean? {
    contract { returns(null) implies (this@case_6_4 !is Int) }
    return if (this@case_6_4 !is Int) null else true
}

// TESTCASE NUMBER: 7
fun <T : <!FINAL_UPPER_BOUND!>String<!>> T?.case_7_1(): Boolean {
    contract { returns(true) implies (this@case_7_1 == null) }
    return this@case_7_1 == null
}
fun <T : <!FINAL_UPPER_BOUND!>String<!>> T?.case_7_2(): Boolean {
    contract { returns(false) implies (this@case_7_2 != null) }
    return !(this@case_7_2 != null)
}
fun <T : <!FINAL_UPPER_BOUND!>String<!>> T?.case_7_3(): Boolean? {
    contract { returnsNotNull() implies (this@case_7_3 != null) }
    return if (this@case_7_3 != null) true else null
}
fun <T : <!FINAL_UPPER_BOUND!>String<!>> T?.case_7_4(): Boolean? {
    contract { returns(null) implies (this@case_7_4 != null) }
    return if (this@case_7_4 != null) null else true
}

// TESTCASE NUMBER: 8
fun <T : String?> T.case_8_1(): Boolean {
    contract { returns(true) implies (this@case_8_1 == null) }
    return this@case_8_1 == null
}
fun <T : String?> T.case_8_2(): Boolean {
    contract { returns(false) implies (this@case_8_2 != null) }
    return !(this@case_8_2 != null)
}
fun <T : String?> T.case_8_3(): Boolean? {
    contract { returnsNotNull() implies (this@case_8_3 != null) }
    return if (this@case_8_3 != null) true else null
}",fun <T : String?> T.case_8_4(): Boolean? {
"// FIR_IDENTICAL
// ISSUE: KT-51793

interface Key1
interface Key2

interface A1 {
    operator fun Key2.invoke(): String = """"
}
interface A2 {
    operator fun Key1.invoke(): Int = 1
}

val A1.k: Key1 get() = object : Key1 {}
val A2.k: Key2 get() = object : Key2 {}",fun with1(a: A1.() -> Unit) {
"""\nPlease make sure that you follow these constraints for using atomic properties:\n"" +
                    ""   * To ensure that atomic properties are not accessed out of the current Kotlin module, it is necessary to declare atomic properties as private or internal.\n"" +
                    ""     Alternatively, you can make the containing class private or internal.\n"" +
                    ""     If you need to expose the atomic property value to the public, consider using a delegated property declared within the same scope:\n"" +
                    ""       ```\n"" +
                    ""       private val _a = atomic<T>(initial) \n"" +
                    ""       public var a: T by _a \n"" +
                    ""       ```\n"" +
                    ""   * Directly invoke operations on atomic properties, like this:\n"" +
                    ""       ```\n"" +
                    ""       val top = atomic<Node?>(null)\n"" +
                    ""       top.compareAndSet(null, Node(1)) // OK\n"" +
                    ""       ```\n"" +
                    ""   * Refrain from invoking atomic operations on local variables:\n"" +
                    ""       ```\n"" +
                    ""       val top = atomic<Node?>(null)\n"" +
                    ""       val tmp = top\n"" +
                    ""       tmp.compareAndSet(null, Node(1)) // DON'T DO THIS\n"" +
                    ""       ```\n"" +
                    ""   * Avoid leaking references to atomic values in other ways, such as returning them or passing them as parameters.\n"" +
                    ""   * Be cautious with the complexity of data flow within parameters of atomic operations.\n"" +
                    ""     For instance, instead of using intricate expression directly as an argument, e.g.:\n"" +
                    ""       ```\n"" +
                    ""       top.compareAndSet(cur, <complex_expression>)\n"" +
                    ""       ```\n"" +
                    ""     create a separate variable to hold the complex expression's value and then perform the operation:\n"" +
                    ""       ```\n"" +
                    ""       val newValue = <complex_expression>\n"" +
                    ""       top.compareAndSet(cur, newValue) \n"" +
                    ""       ```\n"" +
                    ""\n""
    }

    abstract val atomicSymbols: AbstractAtomicSymbols
    protected val irBuiltIns = pluginContext.irBuiltIns

    private val ATOMICFU_INLINE_FUNCTIONS = setOf(""loop"", ""update"", ""getAndUpdate"", ""updateAndGet"")
    private val ATOMIC_VALUE_TYPES = setOf(""AtomicInt"", ""AtomicLong"", ""AtomicBoolean"", ""AtomicRef"")
    private val ATOMIC_ARRAY_TYPES = setOf(""AtomicIntArray"", ""AtomicLongArray"", ""AtomicBooleanArray"", ""AtomicArray"")

    // Maps atomicfu atomic property to the corresponding volatile property.
    protected val atomicfuPropertyToVolatile = mutableMapOf<IrProperty, IrProperty>()
    // Maps atomicfu property to the atomic handler (field updater/atomic array).
    protected val atomicfuPropertyToAtomicHandler = mutableMapOf<IrProperty, IrProperty>()

    fun transform(moduleFragment: IrModuleFragment) {
        transformAtomicProperties(moduleFragment)
        transformAtomicExtensions(moduleFragment)
        transformAtomicFunctions(moduleFragment)
        finalTransformationCheck(moduleFragment)
        for (irFile in moduleFragment.files) {
            irFile.patchDeclarationParents()
        }
    }

    protected abstract val atomicPropertiesTransformer: AtomicPropertiesTransformer
    protected abstract val atomicFunctionsTransformer: AtomicFunctionCallTransformer

    private fun transformAtomicProperties(moduleFragment: IrModuleFragment) {
        for (irFile in moduleFragment.files) {
            irFile.transform(atomicPropertiesTransformer, null)
        }
    }

    private fun transformAtomicExtensions(moduleFragment: IrModuleFragment) {",for (irFile in moduleFragment.files) {
"// DO NOT EDIT MANUALLY!
// Generated by org/jetbrains/kotlin/generators/arguments/GenerateGradleOptions.kt
// To regenerate run 'generateGradleOptions' task
@file:Suppress(""RemoveRedundantQualifierName"", ""Deprecation"", ""Deprecation_Error"", ""DuplicatedCode"")

package org.jetbrains.kotlin.gradle.dsl

/**
 * Common options for all Kotlin platforms' compilations and tools.
 */
@Deprecated(
    ""The kotlinOptions types are deprecated, please migrate to the compilerOptions types. More details are here: https://kotl.in/u1r8ln""
)
interface KotlinCommonToolOptions {
    /**
     * @suppress
     */
    val options: org.jetbrains.kotlin.gradle.dsl.KotlinCommonCompilerToolOptions

    /**
     * Report an error if there are any warnings.
     *
     * Default value: false
     */
    var allWarningsAsErrors: kotlin.Boolean
        get() = options.allWarningsAsErrors.get()
        set(value) = options.allWarningsAsErrors.set(value)

    /**
     * Don't generate any warnings.
     *
     * Default value: false
     */
    var suppressWarnings: kotlin.Boolean",get() = options.suppressWarnings.get()
"@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun <R, V> kotlin.UShortArray.zip(other: kotlin.Array<out R>, transform: (a: kotlin.UShort, b: R) -> V): kotlin.collections.List<V>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
public infix fun kotlin.UShortArray.zip(other: kotlin.UShortArray): kotlin.collections.List<kotlin.Pair<kotlin.UShort, kotlin.UShort>>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun <V> kotlin.UShortArray.zip(other: kotlin.UShortArray, transform: (a: kotlin.UShort, b: kotlin.UShort) -> V): kotlin.collections.List<V>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
public infix fun <R> kotlin.UShortArray.zip(other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<kotlin.UShort, R>>

@kotlin.SinceKotlin(version = ""1.3"")
@kotlin.ExperimentalUnsignedTypes
@kotlin.internal.InlineOnly
public inline fun <R, V> kotlin.UShortArray.zip(other: kotlin.collections.Iterable<R>, transform: (a: kotlin.UShort, b: R) -> V): kotlin.collections.List<V>

public infix fun <T, R> kotlin.collections.Iterable<T>.zip(other: kotlin.Array<out R>): kotlin.collections.List<kotlin.Pair<T, R>>

public inline fun <T, R, V> kotlin.collections.Iterable<T>.zip(other: kotlin.Array<out R>, transform: (a: T, b: R) -> V): kotlin.collections.List<V>

public infix fun <T, R> kotlin.collections.Iterable<T>.zip(other: kotlin.collections.Iterable<R>): kotlin.collections.List<kotlin.Pair<T, R>>

public inline fun <T, R, V> kotlin.collections.Iterable<T>.zip(other: kotlin.collections.Iterable<R>, transform: (a: T, b: R) -> V): kotlin.collections.List<V>

@kotlin.SinceKotlin(version = ""1.2"")
public fun <T> kotlin.collections.Iterable<T>.zipWithNext(): kotlin.collections.List<kotlin.Pair<T, T>>

@kotlin.SinceKotlin(version = ""1.2"")
public inline fun <T, R> kotlin.collections.Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): kotlin.collections.List<R>

@kotlin.SinceKotlin(version = ""1.1"")
public abstract class AbstractCollection<out E> : kotlin.collections.Collection<E> {
    protected constructor AbstractCollection<out E>()

    public abstract override val size: kotlin.Int { get; }

    public open override operator fun contains(element: E): kotlin.Boolean

    public open override fun containsAll(elements: kotlin.collections.Collection<E>): kotlin.Boolean

    public open override fun isEmpty(): kotlin.Boolean

    public abstract override operator fun iterator(): kotlin.collections.Iterator<E>

    @kotlin.js.JsName(name = ""toArray"")
    protected open fun toArray(): kotlin.Array<kotlin.Any?>

    protected open fun <T> toArray(array: kotlin.Array<T>): kotlin.Array<T>

    public open override fun toString(): kotlin.String
}

public abstract class AbstractIterator<T> : kotlin.collections.Iterator<T> {
    public constructor AbstractIterator<T>()

    protected abstract fun computeNext(): kotlin.Unit

    protected final fun done(): kotlin.Unit",public open override operator fun hasNext(): kotlin.Boolean
"open abstract class B {
    fun foo(arg: Int = 239 + 1) : Int = arg
}",class C() : B() {
"}
                    }
                }

                stackArrayCandidates.sortBy { it.size }
                var remainedToAlloc = allowedToAlloc
                for ((ptgNode, irClass, size) in stackArrayCandidates) {
                    if (lifetimeOf(ptgNode) != Lifetime.STACK) continue
                    if (size <= remainedToAlloc)
                        remainedToAlloc -= size
                    else {
                        remainedToAlloc = 0
                        // Do not exile primitive arrays - they ain't reference no object.
                        if (irClass.symbol == symbols.array && propagateExiledToHeapObjects) {
                            context.log { ""Forcing node ${nodeToString(ptgNode.node!!)} to escape"" }
                            escapeOrigins += ptgNode
                            propagateEscapeOrigin(ptgNode)
                        } else {
                            ptgNode.forcedLifetime = Lifetime.GLOBAL // TODO: Change to LOCAL when supported.
                        }
                    }
                }
            }

            private fun findReachableDrains(drain: PointsToGraphNode, visitedDrains: MutableSet<PointsToGraphNode>) {
                visitedDrains += drain
                for (edge in drain.edges) {
                    if (edge is PointsToGraphEdge.Assignment)
                        error(""A drain cannot have outgoing assignment edges"")
                    val nextDrain = edge.node.drain
                    if (nextDrain !in visitedDrains)
                        findReachableDrains(nextDrain, visitedDrains)
                }
            }

            private fun paintNodes(
                    parameters: Array<PointsToGraphNode>,
                    interestingDrains: Set<PointsToGraphNode>,
                    drainFactory: () -> CompressedPointsToGraph.Node
            ): MutableMap<PointsToGraphNode, CompressedPointsToGraph.Node> {
                val nodeIds = mutableMapOf<PointsToGraphNode, CompressedPointsToGraph.Node>()

                for (index in parameters.indices)
                    nodeIds[parameters[index]] = CompressedPointsToGraph.Node.parameter(index, parameters.size)

                val standAloneDrains = interestingDrains.toMutableSet()
                for (drain in interestingDrains)
                    for (edge in drain.edges) {
                        val node = edge.node
                        if (node.isDrain && node != drain /* Skip loops */)
                            standAloneDrains.remove(node)
                    }
                for (drain in standAloneDrains) {
                    if (nodeIds[drain] == null
                            // A little optimization - skip leaf drains.
                            && drain.edges.any { it.node.drain in interestingDrains })
                        nodeIds[drain] = drainFactory()
                }

                var front = nodeIds.keys.toMutableList()
                do {
                    while (front.isNotEmpty()) {
                        val nextFront = mutableListOf<PointsToGraphNode>()
                        for (node in front) {
                            val nodeId = nodeIds[node]!!",node.edges.filterIsInstance<PointsToGraphEdge.Field>().forEach { edge ->
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

@file:Suppress(""UNUSED_PARAMETER"")

package org.jetbrains.kotlin.incremental

import org.jetbrains.kotlin.library.metadata.KlibMetadataProtoBuf
import org.jetbrains.kotlin.metadata.ProtoBuf
import org.jetbrains.kotlin.metadata.builtins.BuiltInsProtoBuf
import org.jetbrains.kotlin.metadata.deserialization.NameResolver
import org.jetbrains.kotlin.metadata.java.JavaClassProtoBuf
import org.jetbrains.kotlin.metadata.js.JsProtoBuf
import org.jetbrains.kotlin.metadata.jvm.JvmProtoBuf
import org.jetbrains.kotlin.metadata.serialization.Interner
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.serialization.deserialization.getClassId
import java.util.*

/** This file is generated by org.jetbrains.kotlin.generators.protobuf.GenerateProtoBufCompare. DO NOT MODIFY MANUALLY */

open class ProtoCompareGenerated(
    val oldNameResolver: NameResolver,
    val newNameResolver: NameResolver,
    oldTypeTable: ProtoBuf.TypeTable?,
    newTypeTable: ProtoBuf.TypeTable?
) {
    private val strings = Interner<String>()
    val oldStringIndexesMap: MutableMap<Int, Int> = hashMapOf()
    val newStringIndexesMap: MutableMap<Int, Int> = hashMapOf()
    val oldClassIdIndexesMap: MutableMap<Int, Int> = hashMapOf()
    val newClassIdIndexesMap: MutableMap<Int, Int> = hashMapOf()
    val oldTypeTable: ProtoBuf.TypeTable = oldTypeTable ?: ProtoBuf.TypeTable.getDefaultInstance()
    val newTypeTable: ProtoBuf.TypeTable = newTypeTable ?: ProtoBuf.TypeTable.getDefaultInstance()

    private val classIds = Interner<ClassId>()

    open fun checkEquals(old: ProtoBuf.Package, new: ProtoBuf.Package): Boolean {
        if (!checkEqualsPackageFunction(old, new)) return false

        if (!checkEqualsPackageProperty(old, new)) return false

        if (!checkEqualsPackageTypeAlias(old, new)) return false

        if (old.hasVersionRequirementTable() != new.hasVersionRequirementTable()) return false
        if (old.hasVersionRequirementTable()) {
            if (!checkEquals(old.versionRequirementTable, new.versionRequirementTable)) return false
        }

        if (old.hasExtension(JvmProtoBuf.packageModuleName) != new.hasExtension(JvmProtoBuf.packageModuleName)) return false
        if (old.hasExtension(JvmProtoBuf.packageModuleName)) {
            if (!checkStringEquals(old.getExtension(JvmProtoBuf.packageModuleName), new.getExtension(JvmProtoBuf.packageModuleName))) return false
        }

        if (old.getExtensionCount(JvmProtoBuf.packageLocalVariable) != new.getExtensionCount(JvmProtoBuf.packageLocalVariable)) {
            return false
        }
        else {
            for(i in 0..old.getExtensionCount(JvmProtoBuf.packageLocalVariable) - 1) {","if (!checkEquals(old.getExtension(JvmProtoBuf.packageLocalVariable, i), new.getExtension(JvmProtoBuf.packageLocalVariable, i))) return false"
"<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<out T, T>"")!>it<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<out T, T>"")!>it<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<out T, T>"")!>it<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<out T, T>"")!>it<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<out T, T>"")!>it<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<out T, T>"")!>it<!>.funAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<out T, T>"")!>it<!>.funNullableT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<out T, T>"")!>it<!>.funNullableAny()
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<out T, T>"")!>it<!>.isEmpty()
        }
    }
}

// TESTCASE NUMBER: 42
fun <T> case_42(x: Map<T, <!REDUNDANT_PROJECTION!>out<!> T>?) {
    if (x != null) {
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, out T> & kotlin.collections.Map<T, out T>?"")!>x<!>
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, out T> & kotlin.collections.Map<T, out T>?"")!>x<!>.equals(null)
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, out T> & kotlin.collections.Map<T, out T>?"")!>x<!>.propT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, out T> & kotlin.collections.Map<T, out T>?"")!>x<!>.propAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, out T> & kotlin.collections.Map<T, out T>?"")!>x<!>.propNullableT
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, out T> & kotlin.collections.Map<T, out T>?"")!>x<!>.propNullableAny
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, out T> & kotlin.collections.Map<T, out T>?"")!>x<!>.funT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, out T> & kotlin.collections.Map<T, out T>?"")!>x<!>.funAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, out T> & kotlin.collections.Map<T, out T>?"")!>x<!>.funNullableT()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, out T> & kotlin.collections.Map<T, out T>?"")!>x<!>.funNullableAny()
        <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, out T> & kotlin.collections.Map<T, out T>?"")!>x<!>.isEmpty()

        x.equals(null)

        x.propT

        x.propAny

        x.propNullableT

        x.propNullableAny

        x.funT()

        x.funAny()

        x.funNullableT()

        x.funNullableAny()
        x.isEmpty()
        x.apply {
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>""), DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>"")!>this<!>
            equals(null)
            propT
            propAny
            propNullableT
            propNullableAny
            funT()
            funAny()
            funNullableT()
            funNullableAny()
            isEmpty()
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>""), DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>"")!>this<!>.equals(null)
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>""), DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>"")!>this<!>.propT
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>""), DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>"")!>this<!>.propAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>""), DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>"")!>this<!>.propNullableT
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>""), DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>"")!>this<!>.propNullableAny
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>""), DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>"")!>this<!>.funT()
            <!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>""), DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>"")!>this<!>.funAny()","<!DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>""), DEBUG_INFO_EXPRESSION_TYPE(""kotlin.collections.Map<T, T>"")!>this<!>.funNullableT()"
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.resolve.checkers

import com.intellij.psi.PsiElement
import org.jetbrains.kotlin.config.LanguageFeature
import org.jetbrains.kotlin.descriptors.ClassDescriptor
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.diagnostics.DiagnosticSink
import org.jetbrains.kotlin.diagnostics.Errors
import org.jetbrains.kotlin.psi.*
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.calls.util.getResolvedCall",import org.jetbrains.kotlin.resolve.scopes.receivers.ClassValueReceiver
"open class A<T : Number> {
    open fun foo(t: T) = ""A""
}

class Z : A<Int>() {
    override fun foo(t: Int) = ""Z""
}


fun box(): String {
    val z = Z()",val a: A<Int> = z
"// !DIAGNOSTICS: -DEBUG_INFO_SMARTCAST
// MODULE: m1-common
// FILE: common.kt

expect val foo: Any

expect class Bar() {
    val bus: Any
}

fun common() {
    if (foo is String) <!SMARTCAST_IMPOSSIBLE!>foo<!>.length

    val bar = Bar()",if (bar.bus is String) <!SMARTCAST_IMPOSSIBLE!>bar.bus<!>.length
"}

    private fun getUpperBounds(type: KotlinType): List<KotlinType> {
        when (type) {
            is FlexibleType -> return getUpperBounds(type.upperBound)
            is DefinitelyNotNullType -> return getUpperBounds(type.original)
            is ErrorType -> return emptyList()
            is CapturedType -> return type.constructor.supertypes.flatMap { getUpperBounds(it) }
            is NewCapturedType -> return type.constructor.supertypes.flatMap { getUpperBounds(it) }
            is SimpleType -> {
                val typeParameterDescriptor = TypeUtils.getTypeParameterDescriptorOrNull(type)
                if (typeParameterDescriptor != null) {
                    return typeParameterDescriptor.upperBounds.flatMap { getUpperBounds(it) }
                }

                val typeConstructor = type.constructor
                if (typeConstructor is NewTypeVariableConstructor) {
                    return typeConstructor.originalTypeParameter?.upperBounds.orEmpty().flatMap { getUpperBounds(it) }
                }
                if (typeConstructor is IntersectionTypeConstructor) {
                    return typeConstructor.supertypes.flatMap { getUpperBounds(it) }
                }

                return listOf(type)
            }
            else -> return emptyList()
        }
    }

    private fun areBoundsCompatible(
        upperBounds: Set<KotlinType>,
        lowerBounds: Set<KotlinType>,
        checkedTypeParameters: MutableSet<TypeParameterDescriptor> = mutableSetOf()
    ): Boolean {
        val upperBoundClasses = upperBounds.mapNotNull { getBoundClass(it) }.toSet()

        val leafClassesOrInterfaces = computeLeafClassesOrInterfaces(upperBoundClasses)
        if (areClassesOrInterfacesIncompatible(leafClassesOrInterfaces)) {
            return false
        }

        if (!lowerBounds.all { lowerBoundType ->
                val classesSatisfyingLowerBounds = collectSuperClasses(lowerBoundType)
                leafClassesOrInterfaces.all { it in classesSatisfyingLowerBounds }
            }
        ) {
            return false
        }

        if (upperBounds.size < 2) {
            return true
        }

        val typeArgumentMapping = collectTypeArgumentMapping(upperBounds)
        for ((typeParameter, boundTypeArguments) in typeArgumentMapping) {
            if (!boundTypeArguments.isCompatible) {
                return false
            }

            checkedTypeParameters.add(typeParameter)
            if (!areBoundsCompatible(boundTypeArguments.upper, boundTypeArguments.lower, checkedTypeParameters)) {
                return false
            }
        }",return true
"import org.jetbrains.kotlin.gradle.plugin.KotlinCompilerArgumentsProducer.ContributeCompilerArgumentsContext
import kotlin.reflect.KClass
import kotlin.reflect.cast

@InternalKotlinGradlePluginApi
interface KotlinCompilerArgumentsProducer {

    enum class ArgumentType {
        Primitive,
        PluginClasspath,
        DependencyClasspath,
        Sources;

        companion object {
            val all = values().toSet()
        }
    }

    interface CreateCompilerArgumentsContext {
        fun <T : CommonToolArguments> create(type: KClass<T>, action: ContributeCompilerArgumentsContext<T>.() -> Unit): T

        companion object {
            val default: CreateCompilerArgumentsContext = CreateCompilerArgumentsContext()
            val lenient: CreateCompilerArgumentsContext = CreateCompilerArgumentsContext(isLenient = true)

            inline fun <reified T : CommonToolArguments> CreateCompilerArgumentsContext.create(
                noinline action: ContributeCompilerArgumentsContext<T>.() -> Unit
            ) = create(T::class, action)
        }
    }

    interface ContributeCompilerArgumentsContext<T : CommonToolArguments> {
        /**
         * This method shall be used for any [action] used to build arguments, that could potentially throw an exception
         * (like resolving dependencies). There are some scenarios (like IDE import), where we want to be lenient
         * and provide arguments on a 'best effort bases'.
         */
        fun <T> runSafe(action: () -> T): T?
        fun primitive(contribution: (args: T) -> Unit)
        fun pluginClasspath(contribution: (args: T) -> Unit)
        fun dependencyClasspath(contribution: (args: T) -> Unit)
        fun sources(contribution: (args: T) -> Unit)
    }

    fun createCompilerArguments(
        context: CreateCompilerArgumentsContext = CreateCompilerArgumentsContext.default
    ): CommonToolArguments
}

internal fun CreateCompilerArgumentsContext(
    includeArgumentTypes: Set<KotlinCompilerArgumentsProducer.ArgumentType> = KotlinCompilerArgumentsProducer.ArgumentType.all,
    isLenient: Boolean = false
): KotlinCompilerArgumentsProducer.CreateCompilerArgumentsContext {
    return CreateCompilerArgumentsContextImpl(includeArgumentTypes, isLenient)
}

private class CreateCompilerArgumentsContextImpl(
    private val includeArgumentTypes: Set<KotlinCompilerArgumentsProducer.ArgumentType>,
    private val isLenient: Boolean
) : KotlinCompilerArgumentsProducer.CreateCompilerArgumentsContext {

    override fun <T : CommonToolArguments> create(
        type: KClass<T>, action: ContributeCompilerArgumentsContext<T>.() -> Unit
    ): T {
        val constructor = type.java.constructors.firstOrNull { it.parameters.isEmpty() }","?: throw IllegalArgumentException(""'${type.qualifiedName}' does not have an empty constructor"")"
"// Auto-generated by GenerateSteppedRangesCodegenTestData. Do not edit!
// WITH_STDLIB
import kotlin.test.*

fun box(): String {
    val intList = mutableListOf<Int>()
    val intProgression = 10 downTo 1
    for (i in intProgression step 2 step 3) {
        intList += i
    }
    assertEquals(listOf(10, 7, 4), intList)

    val longList = mutableListOf<Long>()
    val longProgression = 10L downTo 1L
    for (i in longProgression step 2L step 3L) {
        longList += i
    }
    assertEquals(listOf(10L, 7L, 4L), longList)

    val charList = mutableListOf<Char>()
    val charProgression = 'j' downTo 'a'
    for (i in charProgression step 2 step 3) {",charList += i
"/*
 * Copyright 2010-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the LICENSE file.
 */
@file:OptIn(ExperimentalTime::class)

package org.jetbrains.network

import kotlin.js.Promise            // TODO - migrate to multiplatform.
import kotlin.time.*

// Response saved in cache.
data class CachedResponse(val cachedResult: Any, val time: TimeMark)

// Dispatcher for work with cachable responses.
object CachableResponseDispatcher {
    // Storage of cached responses.
    private val cachedResponses = mutableMapOf<String, CachedResponse>()

    private val cacheMaxSize = 200

    // Get response. If response isn't cached, use provided action to get response.
    fun getResponse(request: dynamic, response: dynamic,
                    action: (success: (result: Any) -> Unit, reject: () -> Unit) -> Unit) {",cachedResponses[request.url]?.let {
"fun addAllContextReceivers(receivers: List<ContextReceiverValue<*>>): PersistentImplicitReceiverStack {
        return receivers.fold(this) { acc, value -> acc.addContextReceiver(value) }
    }

    fun add(name: Name?, value: ImplicitReceiverValue<*>, aliasLabel: Name? = null): PersistentImplicitReceiverStack {
        val stack = stack.add(value)
        val originalTypes = originalTypes.add(value.originalType)
        val index = stack.size - 1
        val receiversPerLabel = receiversPerLabel.putIfNameIsNotNull(name, value).putIfNameIsNotNull(aliasLabel, value)
        val indexesPerSymbol = indexesPerSymbol.put(value.boundSymbol, index)

        return PersistentImplicitReceiverStack(
            stack,
            receiversPerLabel,
            indexesPerSymbol,
            originalTypes
        )
    }

    private fun PersistentSetMultimap<Name, ImplicitReceiverValue<*>>.putIfNameIsNotNull(name: Name?, value: ImplicitReceiverValue<*>) =
        if (name != null)
            put(name, value)
        else
            this

    fun addContextReceiver(value: ContextReceiverValue<*>): PersistentImplicitReceiverStack {
        val labelName = value.labelName ?: return this

        val receiversPerLabel = receiversPerLabel.put(labelName, value)
        return PersistentImplicitReceiverStack(
            stack,
            receiversPerLabel,
            indexesPerSymbol,
            originalTypes
        )
    }

    override operator fun get(name: String?): ImplicitReceiverValue<*>? {
        if (name == null) return stack.lastOrNull()
        return receiversPerLabel[Name.identifier(name)].lastOrNull()
    }

    override fun lastDispatchReceiver(): ImplicitDispatchReceiverValue? {
        return stack.filterIsInstance<ImplicitDispatchReceiverValue>().lastOrNull()
    }

    override fun lastDispatchReceiver(lookupCondition: (ImplicitReceiverValue<*>) -> Boolean): ImplicitDispatchReceiverValue? {
        return stack.filterIsInstance<ImplicitDispatchReceiverValue>().lastOrNull(lookupCondition)
    }

    override fun receiversAsReversed(): List<ImplicitReceiverValue<*>> = stack.asReversed()

    override operator fun iterator(): Iterator<ImplicitReceiverValue<*>> {
        return stack.iterator()
    }

    // These methods are only used at org.jetbrains.kotlin.fir.resolve.dfa.FirDataFlowAnalyzer.Companion.createFirDataFlowAnalyzer
    // No need to be extracted to an interface
    fun getReceiverIndex(symbol: FirBasedSymbol<*>): Int? = indexesPerSymbol[symbol]

    fun getOriginalType(index: Int): ConeKotlinType {
        return originalTypes[index]
    }",fun getType(index: Int): ConeKotlinType {
"assertTrue(eqDouble(doubleArrayOf(1.0, 2.0), doubleArrayOf(1.0) + 2.0))
    assertTrue(eqDouble(doubleArrayOf(1.0, 2.0, 3.0), doubleArrayOf(1.0) + listOf(2.0, 3.0)))
    assertTrue(eqDouble(doubleArrayOf(2.0, 3.0), doubleArrayOf(1.0, 2.0, 3.0, 4.0).copyOfRange(1, 3)))
    assertTrue(eqDouble(doubleArrayOf(1.0, 2.0, 3.0, 4.0), customDoubleArrayOf(1.0, *doubleArrayOf(2.0, 3.0), 4.0)))
    assertTrue(doubleArrayOf(1.0).iterator() is DoubleIterator)
    assertEquals(1.0, doubleArrayOf(1.0).iterator().nextDouble())
    assertEquals(1.0, doubleArrayOf(1.0).iterator().next())
    assertFalse(doubleArrayOf().iterator().hasNext())
    assertTrue(assertFails { doubleArrayOf().iterator().next() } is NoSuchElementException)

    assertTrue(eqLong(longArrayOf(0), LongArray(1)))
    assertTrue(eqLong(longArrayOf(1, 2, 3), LongArray(3) { it + 1L }))
    assertTrue(eqLong(longArrayOf(1), longArrayOf(1).copyOf()))
    assertTrue(eqLong(longArrayOf(1, 0), longArrayOf(1).copyOf(2)))
    assertTrue(eqLong(longArrayOf(1), longArrayOf(1, 2).copyOf(1)))
    assertTrue(eqLong(longArrayOf(1, 2), longArrayOf(1) + 2))
    assertTrue(eqLong(longArrayOf(1, 2, 3), longArrayOf(1) + listOf(2L, 3L)))
    assertTrue(eqLong(longArrayOf(2, 3), longArrayOf(1, 2, 3, 4).copyOfRange(1, 3)))
    assertTrue(eqLong(longArrayOf(1, 2, 3, 4), customLongArrayOf(1L, *longArrayOf(2, 3), 4L)))
    assertTrue(longArrayOf(1).iterator() is LongIterator)
    assertEquals(1L, longArrayOf(1).iterator().nextLong())
    assertEquals(1L, longArrayOf(1).iterator().next())
    assertFalse(longArrayOf().iterator().hasNext())
    assertTrue(assertFails { longArrayOf().iterator().next() } is NoSuchElementException)

    // If `is` checks work...
    if (intArrayOf() is IntArray) {
        assertTrue(booleanArrayOf(false) is BooleanArray)
        assertTrue(byteArrayOf(0) is ByteArray)
        assertTrue(shortArrayOf(0) is ShortArray)
        assertTrue(charArrayOf('a') is CharArray)
        assertTrue(intArrayOf(0) is IntArray)
        assertTrue(floatArrayOf(0f) is FloatArray)
        assertTrue(doubleArrayOf(0.0) is DoubleArray)
        assertTrue(longArrayOf(0) is LongArray)
    }

    // Rhino `instanceof` fails to distinguish TypedArray's
    if (intArrayOf() is IntArray && (byteArrayOf() as Any) !is IntArray) {
        assertTrue(checkExactArrayType(booleanArrayOf(false), booleanArray = true))
        assertTrue(checkExactArrayType(byteArrayOf(0), byteArray = true))
        assertTrue(checkExactArrayType(shortArrayOf(0), shortArray = true))
        assertTrue(checkExactArrayType(charArrayOf('a'), charArray = true))
        assertTrue(checkExactArrayType(intArrayOf(0), intArray = true))
        assertTrue(checkExactArrayType(floatArrayOf(0f), floatArray = true))
        assertTrue(checkExactArrayType(doubleArrayOf(0.0), doubleArray = true))
        assertTrue(checkExactArrayType(longArrayOf(0), longArray = true))
        assertTrue(checkExactArrayType(arrayOf<Any?>(), array = true))
    }

    return ""OK""
}

fun eqBoolean(expected: BooleanArray, actual: BooleanArray): Boolean = actual.size == expected.size && actual.foldIndexed(true) { i, r, v -> r && expected[i] == v }
fun eqByte(expected: ByteArray, actual: ByteArray): Boolean = actual.size == expected.size && actual.foldIndexed(true) { i, r, v -> r && expected[i] == v }
fun eqShort(expected: ShortArray, actual: ShortArray): Boolean = actual.size == expected.size && actual.foldIndexed(true) { i, r, v -> r && expected[i] == v }
fun eqChar(expected: CharArray, actual: CharArray): Boolean = actual.size == expected.size && actual.foldIndexed(true) { i, r, v -> r && expected[i] == v }
fun eqInt(expected: IntArray, actual: IntArray): Boolean = actual.size == expected.size && actual.foldIndexed(true) { i, r, v -> r && expected[i] == v }
fun eqLong(expected: LongArray, actual: LongArray): Boolean = actual.size == expected.size && actual.foldIndexed(true) { i, r, v -> r && expected[i] == v }
fun eqFloat(expected: FloatArray, actual: FloatArray): Boolean = actual.size == expected.size && actual.foldIndexed(true) { i, r, v -> r && expected[i] == v }
fun eqDouble(expected: DoubleArray, actual: DoubleArray): Boolean = actual.size == expected.size && actual.foldIndexed(true) { i, r, v -> r && expected[i] == v }

fun customBooleanArrayOf(vararg arr: Boolean): BooleanArray = arr
fun customByteArrayOf(vararg arr: Byte): ByteArray = arr
fun customShortArrayOf(vararg arr: Short): ShortArray = arr",fun customCharArrayOf(vararg arr: Char): CharArray = arr
"}

    private fun IrClass.handle() {
        val newDeclarations = declarations.map {
            when (it) {
                is IrProperty -> context.cachedDeclarations.getStaticBackingField(it)?.also { newField ->
                    it.backingField = newField
                    newField.correspondingPropertySymbol = it.symbol
                }
                else -> null
            }
        }

        val companionParent = if (isCompanion) parentAsClass else null
        // In case a companion contains no fields, move the anonymous initializers to the parent
        // anyway, as otherwise there will probably be no references to the companion class at all
        // and therefore its class initializer will never be invoked.
        val newParent = newDeclarations.firstOrNull { it != null }?.parentAsClass ?: companionParent ?: this
        if (newParent === this) {
            declarations.replaceAll {
                // Anonymous initializers must be made static to correctly initialize the new static
                // fields when the class is loaded.
                if (it is IrAnonymousInitializer) makeAnonymousInitializerStatic(it, newParent) else it
            }

            if (companionParent != null) {
                for (declaration in declarations) {
                    if (declaration is IrProperty && declaration.isConst && declaration.hasPublicVisibility) {
                        copyConstProperty(declaration, companionParent)
                    }
                }
            }
        } else {
            // Anonymous initializers must also be moved and their ordering relative to the fields
            // must be preserved, as the fields can have expression initializers themselves.
            for ((i, newField) in newDeclarations.withIndex()) {
                if (newField != null)
                    newParent.declarations += newField
                if (declarations[i] is IrAnonymousInitializer)
                    newParent.declarations += makeAnonymousInitializerStatic(declarations[i] as IrAnonymousInitializer, newParent)
            }
            declarations.removeAll { it is IrAnonymousInitializer }
        }
    }

    private val IrProperty.hasPublicVisibility: Boolean
        get() = !DescriptorVisibilities.isPrivate(visibility) && visibility != DescriptorVisibilities.PROTECTED

    private fun makeAnonymousInitializerStatic(oldInitializer: IrAnonymousInitializer, newParent: IrClass): IrAnonymousInitializer =
        with(oldInitializer) {
            val oldParent = parentAsClass
            val newSymbol = IrAnonymousInitializerSymbolImpl(newParent.symbol)
            factory.createAnonymousInitializer(startOffset, endOffset, origin, newSymbol, isStatic = true).apply {
                parent = newParent
                body = this@with.body.patchDeclarationParents(newParent)
                replaceThisByStaticReference(context.cachedDeclarations.fieldsForObjectInstances, oldParent, oldParent.thisReceiver!!)
            }
        }

    private fun copyConstProperty(oldProperty: IrProperty, newParent: IrClass): IrField {
        val oldField = oldProperty.backingField!!
        return newParent.addField {
            updateFrom(oldField)
            name = oldField.name
            isStatic = true",}.apply {
"currentDispatchReceiver: ConeClassLikeType?,
        context: Context<T>
    ): FirProperty {
        val name = this.firValueParameter.name
        var type = this.firValueParameter.returnTypeRef
        if (type is FirImplicitTypeRef) {
            type = buildErrorTypeRef { diagnostic = ConeSyntaxDiagnostic(""Incomplete code"") }
        }

        return buildProperty {
            val propertySource = firValueParameter.source?.fakeElement(KtFakeSourceElementKind.PropertyFromParameter)
            source = propertySource
            this.moduleData = moduleData
            origin = FirDeclarationOrigin.Source
            returnTypeRef = type.copyWithNewSourceKind(KtFakeSourceElementKind.PropertyFromParameter)
            this.name = name
            initializer = buildPropertyAccessExpression {
                source = propertySource
                calleeReference = buildPropertyFromParameterResolvedNamedReference {
                    source = propertySource
                    this.name = name
                    resolvedSymbol = this@ValueParameter.firValueParameter.symbol
                    source = propertySource
                }
            }

            isVar = this@ValueParameter.isVar
            val propertySymbol = FirPropertySymbol(callableId)
            val remappedAnnotations = valueParameterAnnotations.map {
                buildAnnotationCallCopy(it) {
                    containingDeclarationSymbol = propertySymbol
                }
            }

            symbol = propertySymbol
            dispatchReceiverType = currentDispatchReceiver
            isLocal = false
            status = FirDeclarationStatusImpl(modifiers.getVisibility(), modifiers.getModality(isClassOrObject = false)).apply {
                this.isExpect = isExpect
                isActual = modifiers.hasActual()
                isOverride = modifiers.hasOverride()
                isConst = modifiers.hasConst()
                isLateInit = modifiers.hasLateinit()
            }

            val defaultAccessorSource = propertySource?.fakeElement(KtFakeSourceElementKind.DefaultAccessor)
            backingField = FirDefaultPropertyBackingField(
                moduleData = moduleData,
                origin = FirDeclarationOrigin.Source,
                source = defaultAccessorSource,
                annotations = remappedAnnotations.filter {
                    it.useSiteTarget == FIELD || it.useSiteTarget == PROPERTY_DELEGATE_FIELD
                }.toMutableList(),
                returnTypeRef = returnTypeRef.copyWithNewSourceKind(KtFakeSourceElementKind.DefaultAccessor),
                isVar = isVar,
                propertySymbol = symbol,
                status = status.copy(isLateInit = false),
            )

            annotations += remappedAnnotations.filterConstructorPropertyRelevantAnnotations(this.isVar)

            getter = FirDefaultPropertyGetter(
                defaultAccessorSource,
                moduleData,
                FirDeclarationOrigin.Source,","type.copyWithNewSourceKind(KtFakeSourceElementKind.DefaultAccessor),"
"// WITH_STDLIB
// WITH_COROUTINES
import helpers.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*

fun someCondition() = true

suspend fun suspendHere() = suspendCoroutineUninterceptedOrReturn {
    it.resume(Unit)",COROUTINE_SUSPENDED
"// Get consistent build information in cases of rerunning the same build.
    suspend fun getConsistentBuildInfo(buildInfoInstance: BuildInfo, reports: List<BenchmarksReport>,
                                       rerunNumber: Int = 1): BuildInfo {
        var currentBuildInfo = buildInfoInstance
        if (buildExists(currentBuildInfo, buildInfoIndex)) {
            // Check if benchmarks aren't repeated.
            val existingBecnhmarks = benchmarksDispatcher.getBenchmarksList(currentBuildInfo.buildNumber,
                    currentBuildInfo.agentInfo).await()
            val benchmarksToRegister = reports.map { it.benchmarks.keys }.flatten()
            if (existingBecnhmarks.toTypedArray().intersect(benchmarksToRegister).isNotEmpty()) {
                // Build was rerun.
                val buildNumber = ""${currentBuildInfo.buildNumber}.$rerunNumber""
                currentBuildInfo = BuildInfo(buildNumber, currentBuildInfo.startTime, currentBuildInfo.endTime,
                        currentBuildInfo.commitsList, currentBuildInfo.branch, currentBuildInfo.agentInfo,
                        currentBuildInfo.buildType)
                return getConsistentBuildInfo(currentBuildInfo, reports, rerunNumber + 1)
            }
        }
        return currentBuildInfo
    }

    // Register build on Artifactory.
    router.post(""/register"") { request, response ->
        val register = BuildRegister.create(JSON.stringify(request.body))

        // Get information from TeamCity.
        register.getBuildInformation().then { buildInfo ->
            register.sendTeamCityRequest(register.changesListUrl, true).then { changes ->
                val commitsList = CommitsList(JsonTreeParser.parse(changes))
                // Get artifact.
                val content  = if(register.fileWithResult.contains(""/""))
                    UrlNetworkConnector(artifactoryUrl).sendRequest(RequestMethod.GET, register.fileWithResult)
                else register.sendTeamCityRequest(register.teamCityArtifactsUrl)
                content.then { resultsContent ->
                    launch {
                        val reportData = JsonTreeParser.parse(resultsContent)
                        val reports = if (reportData is JsonArray) {
                            reportData.map { BenchmarksReport.create(it as JsonObject) }
                        } else listOf(BenchmarksReport.create(reportData as JsonObject))
                        val goldenResultPromise = getGoldenResults(goldenIndex)
                        val goldenResults = goldenResultPromise.await()
                        // Register build information.
                        val target = reports[0].env.machine.os.let {
                            if (it == ""Mac OS X"" && reports[0].env.machine.cpu == ""aarch64"")
                                ""$it Arm64""
                            else it
                        }
                        var buildInfoInstance = getConsistentBuildInfo(
                                BuildInfo(buildInfo.buildNumber, buildInfo.startTime, buildInfo.finishTime,
                                        commitsList, buildInfo.branch, target, buildInfo.buildType),
                                reports
                        )
                        if (register.bundleSize != null) {
                            // Add bundle size.
                            val bundleSizeBenchmark = BenchmarkResult(""KotlinNative"",
                                    BenchmarkResult.Status.PASSED, register.bundleSize.toDouble(),
                                    BenchmarkResult.Metric.BUNDLE_SIZE, 0.0, 1, 0)
                            val bundleSizeReport = BenchmarksReport(reports[0].env,
                                    listOf(bundleSizeBenchmark), reports[0].compiler)
                            bundleSizeReport.buildNumber = buildInfoInstance.buildNumber
                            benchmarksDispatcher.insert(bundleSizeReport, target).then { _ ->
                                println(""[BUNDLE] Success insert ${buildInfoInstance.buildNumber}"")
                            }.catch { errorResponse ->
                                println(""Failed to insert data for build"")",println(errorResponse)
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// This file was generated automatically. See compiler/ir/ir.tree/tree-generator/ReadMe.md.
// DO NOT MODIFY IT MANUALLY.

@file:Suppress(""DuplicatedCode"")

package org.jetbrains.kotlin.ir.declarations.impl

import org.jetbrains.kotlin.descriptors.ClassConstructorDescriptor
import org.jetbrains.kotlin.descriptors.DescriptorVisibility
import org.jetbrains.kotlin.ir.IrImplementationDetail
import org.jetbrains.kotlin.ir.ObsoleteDescriptorBasedAPI
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.expressions.IrBody
import org.jetbrains.kotlin.ir.expressions.IrConstructorCall
import org.jetbrains.kotlin.ir.symbols.IrConstructorSymbol
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.serialization.deserialization.descriptors.DeserializedContainerSource

class IrConstructorImpl @IrImplementationDetail constructor(
    override val startOffset: Int,
    override val endOffset: Int,
    override var origin: IrDeclarationOrigin,
    override val factory: IrFactory,","override var name: Name,"
"/*
 * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.config

import org.jetbrains.kotlin.load.java.JavaTypeEnhancementState
import kotlin.reflect.KProperty

object JvmAnalysisFlags {
    @JvmStatic
    val strictMetadataVersionSemantics by AnalysisFlag.Delegates.Boolean

    @JvmStatic
    val javaTypeEnhancementState by Delegates.JavaTypeEnhancementStateWarnByDefault",@JvmStatic
"PROJECTION
    }

    // This is just IrType repacked as a data class, good to address a hash map.
    data class IrTypeKey(
        val kind: IrTypeKind,
        val classifier: IrClassifierSymbol?,
        val nullability: SimpleTypeNullability?,
        val arguments: List<IrTypeArgumentKey>?,
        val annotations: List<IrConstructorCall>,
        val abbreviation: IrTypeAbbreviation?
    )

    data class IrTypeArgumentKey(
        val kind: IrTypeArgumentKind,
        val variance: Variance?,
        val type: IrTypeKey?
    )

    private val IrType.toIrTypeKey: IrTypeKey
        get() {
            val type = this
            return IrTypeKey(
                kind = when (this) {
                    is IrSimpleType -> IrTypeKind.SIMPLE
                    is IrDynamicType -> IrTypeKind.DYNAMIC
                    is IrErrorType -> IrTypeKind.ERROR
                    else -> error(""Unexpected IrType kind: $this"")
                },
                classifier = type.classifierOrNull,
                nullability = (type as? IrSimpleType)?.nullability,
                arguments = (type as? IrSimpleType)?.arguments?.map { it.toIrTypeArgumentKey },
                annotations = type.annotations,
                abbreviation = (type as? IrSimpleType)?.abbreviation
            )
        }

    private val IrTypeArgument.toIrTypeArgumentKey: IrTypeArgumentKey
        get() = IrTypeArgumentKey(
            kind = when (this) {
                is IrStarProjection -> IrTypeArgumentKind.STAR
                is IrTypeProjection -> IrTypeArgumentKind.PROJECTION
            },
            variance = (this as? IrTypeProjection)?.variance,
            type = (this as? IrTypeProjection)?.type?.toIrTypeKey
        )

    private fun serializeIrType(type: IrType) = protoTypeMap.getOrPut(type.toIrTypeKey) {
        protoTypeArray.add(serializeIrTypeData(type))
        protoTypeArray.size - 1
    }

    /* -------------------------------------------------------------------------- */

    private fun serializeBlockBody(expression: IrBlockBody): ProtoBlockBody {
        val proto = ProtoBlockBody.newBuilder()
        expression.statements.forEach {
            proto.addStatement(serializeStatement(it))
        }
        return proto.build()
    }

    private fun serializeBranch(branch: IrBranch): ProtoBranch {
        val proto = ProtoBranch.newBuilder()",proto.condition = serializeExpression(branch.condition)
"}
                }
                // |- extension -|- real -|- locals -|               old descriptor
                // |- extension -|- real -|- captured -|- locals -|  new descriptor
                return `var` + if (`var` < realParametersSize) 0 else capturedParamsSize
            }

            override fun visitVarInsn(opcode: Int, `var`: Int) {
                super.visitVarInsn(opcode, getNewIndex(`var`))
            }

            override fun visitIincInsn(`var`: Int, increment: Int) {
                super.visitIincInsn(getNewIndex(`var`), increment)
            }

            override fun visitMaxs(maxStack: Int, maxLocals: Int) {
                super.visitMaxs(maxStack, maxLocals + capturedParamsSize)
            }

            override fun visitLineNumber(line: Int, start: Label) {
                if (isInliningLambda || GENERATE_DEBUG_INFO) {
                    super.visitLineNumber(line, start)
                }
            }

            override fun visitMethodInsn(opcode: Int, owner: String, name: String, desc: String, itf: Boolean) {
                if (DEFAULT_LAMBDA_FAKE_CALL == owner) {
                    val index = name.substringAfter(DEFAULT_LAMBDA_FAKE_CALL).toInt()
                    val lambda = getFunctionalArgumentIfExists(index) as DefaultLambda
                    for (captured in lambda.capturedVars.asReversed()) {
                        lambda.originalBoundReceiverType?.let {
                            // The receiver is the only captured value; it needs to be boxed.
                            StackValue.onStack(it).put(captured.type, InstructionAdapter(this))
                        }
                        super.visitFieldInsn(
                            Opcodes.PUTSTATIC,
                            captured.containingLambdaName,
                            CAPTURED_FIELD_FOLD_PREFIX + captured.fieldName,
                            captured.type.descriptor
                        )
                    }
                } else {
                    super.visitMethodInsn(opcode, owner, name, desc, itf)
                }
            }

            override fun visitLocalVariable(name: String, desc: String, signature: String?, start: Label, end: Label, index: Int) {
                if (!isInliningLambda && !GENERATE_DEBUG_INFO) return

                val isInlineFunctionMarker = name.startsWith(JvmAbi.LOCAL_VARIABLE_NAME_PREFIX_INLINE_FUNCTION)
                val newName = when {
                    inliningContext.isRoot && !isInlineFunctionMarker -> {
                        if (inliningContext.inlineScopesGenerator != null) {
                            calculateNewNameUsingScopeNumbers(name)
                        } else {
                            calculateNewNameUsingTheOldScheme(name)
                        }
                    }
                    else -> name
                }
                super.visitLocalVariable(newName, desc, signature, start, end, getNewIndex(index))
            }

            private fun calculateNewNameUsingScopeNumbers(name: String): String {
                if (name.startsWith(AsmUtil.THIS)) {",val scopeNumber = name.getInlineScopeInfo()?.scopeNumber ?: return AsmUtil.INLINE_DECLARATION_SITE_THIS
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package kotlin.test.tests

import kotlin.js.Promise
import kotlin.test.*

private external fun setTimeout(body: () -> Unit, timeout: Int)

class AsyncTest {

    var log = """"

    var afterLog = """"

    var expectedAfterLog = """"

    @BeforeTest
    fun before() {
        log = """"
        afterLog = """"
        expectedAfterLog = """"
    }

    @AfterTest
    fun after() {
        assertEquals(afterLog, expectedAfterLog)
    }

    fun promise(v: Int, after: String = """") = Promise { resolve, _ ->
        log += ""a""
        setTimeout({ log += ""c""; afterLog += after; resolve(v.toJsNumber()) }, 100)
        log += ""b""
    }.also {
        expectedAfterLog += after
    }

    @Test
    @Ignore //Remove after bootstrap KT-65322
    fun checkAsyncOrder(): Promise<JsNumber> {
        log += 1","val p1 = promise(10, ""after"")"
"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

// Copyright (C) 2020-2023 Brian Norman
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.",package sample;
"testRunSettings,
            freeCompilerArgs = testCase.freeCompilerArgs,
            sourceModules = testCase.modules,
            extras = testCase.extras,
            dependencies = emptyList(),
            expectedArtifact = expectedArtifact,
        )
        val compilationResult = compilation.result
        val goldenData = rootDir.resolve(
            if (testRunSettings.get<CacheMode>().useStaticCacheForDistributionLibraries) ""logging_cache_warning.txt"" else ""empty.txt""
        )

        KotlinTestUtils.assertEqualsToFile(goldenData, compilationResult.toOutput())
    }

    @Test
    fun testLoggingInvalid() {
        Assumptions.assumeFalse(testRunSettings.get<CacheMode>().useStaticCacheForDistributionLibraries)
        val rootDir = File(""native/native.tests/testData/compilerOutput/runtimeLogging"")
        val testCase = generateTestCaseWithSingleFile(
            rootDir.resolve(""main.kt""),
            freeCompilerArgs = TestCompilerArgs(""-Xruntime-logs=invalid=unknown,logging=debug""),
            extras = TestCase.NoTestRunnerExtras(""main""),
            testKind = TestKind.STANDALONE_NO_TR,
        )
        val expectedArtifact = TestCompilationArtifact.Executable(buildDir.resolve(""logging_invalid""))
        val compilation = ExecutableCompilation(
            testRunSettings,
            freeCompilerArgs = testCase.freeCompilerArgs,
            sourceModules = testCase.modules,
            extras = testCase.extras,
            dependencies = emptyList(),
            expectedArtifact = expectedArtifact,
        )
        val compilationResult = compilation.result
        val goldenData = rootDir.resolve(""logging_invalid_error.txt"")

        KotlinTestUtils.assertEqualsToFile(goldenData, compilationResult.toOutput())
    }

    private fun doBuildObjCFrameworkWithNameCollisions(rootDir: File, additionalOptions: List<String>): TestCompilationResult<out TestCompilationArtifact.ObjCFramework> {
        Assumptions.assumeTrue(targets.hostTarget.family.isAppleFamily)

        val settings = testRunSettings
        val lib1 = compileLibrary(settings, rootDir.resolve(""lib1.kt"")).assertSuccess().resultingArtifact
        val lib2 = compileLibrary(settings, rootDir.resolve(""lib2.kt"")).assertSuccess().resultingArtifact

        val freeCompilerArgs = TestCompilerArgs(
            listOf(
                ""-Xinclude=${lib1.path}"",
                ""-Xinclude=${lib2.path}""
            ) + additionalOptions
        )
        val expectedArtifact = TestCompilationArtifact.ObjCFramework(buildDir, ""testObjCExportDiagnostics"")

        return ObjCFrameworkCompilation(
            settings,
            freeCompilerArgs,
            sourceModules = emptyList(),
            dependencies = emptyList(),
            expectedArtifact
        ).result
    }
}","@Suppress(""JUnitTestCaseWithNoTests"")"
"/*
 * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.commonizer.cir

import org.jetbrains.kotlin.commonizer.cir.ArtificialSupertypes.artificialSupertypes
import org.jetbrains.kotlin.commonizer.utils.CNAMES_STRUCTS_PACKAGE
import org.jetbrains.kotlin.commonizer.utils.OBJCNAMES_CLASSES_PACKAGE
import org.jetbrains.kotlin.commonizer.utils.OBJCNAMES_PROTOCOLS_PACKAGE
import org.jetbrains.kotlin.commonizer.utils.isUnderKotlinNativeSyntheticPackages
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.descriptors.Visibilities
import org.jetbrains.kotlin.descriptors.Visibility
import org.jetbrains.kotlin.types.Variance

object CirProvided {
    /* Classifiers */
    sealed interface Classifier: AnyClassifier {
        val typeParameters: List<TypeParameter>
    }

    sealed interface Class : Classifier, AnyClass {
        override val visibility: Visibility
        val supertypes: List<Type>
    }

    data class RegularClass(
        override val typeParameters: List<TypeParameter>,
        override val supertypes: List<Type>,
        override val visibility: Visibility,
        val kind: ClassKind
    ) : Class

    data class ExportedForwardDeclarationClass(val syntheticClassId: CirEntityId) : Class {
        init {
            check(syntheticClassId.packageName.isUnderKotlinNativeSyntheticPackages)
        }

        override val typeParameters: List<TypeParameter> get() = emptyList()
        override val visibility: Visibility get() = Visibilities.Public
        override val supertypes: List<Type> = syntheticClassId.artificialSupertypes()
    }

    data class TypeAlias(
        override val typeParameters: List<TypeParameter>,
        override val underlyingType: ClassOrTypeAliasType
    ) : Classifier, AnyTypeAlias

    /* Type parameter */
    data class TypeParameter(val index: Int, val variance: Variance)

    /* Types */
    sealed interface Type: AnyType {
        override val isMarkedNullable: Boolean
    }

    sealed interface ClassOrTypeAliasType : Type, AnyClassOrTypeAliasType {
        override val classifierId: CirEntityId",val arguments: List<TypeProjection>
"// WITH_COROUTINES
// WITH_REFLECT
// TARGET_BACKEND: JVM

import helpers.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.reflect.full.callSuspendBy

fun builder(c: suspend () -> Unit) {
    c.startCoroutine(EmptyContinuation)
}

class A {
    suspend fun noArgs() = ""OK""

    suspend fun twoArgs(a: String, b: String) = ""$a$b""
}

suspend fun twoArgs(a: String, b: String) = ""$a$b""

fun ordinary() = ""OK""

suspend fun withDefault(s: String = ""OK"") = s

suspend fun withManyDefault(
    s0: String = ""NOT OK 0"",
    s1: String = ""NOT OK 1"",","s2: String = ""NOT OK 2"","
